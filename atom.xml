<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ccw&#39;s Blogs</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-09-21T23:13:11.175Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ccw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>渲染原理</title>
    <link href="http://example.com/2024/08/21/%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2024/08/21/%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</id>
    <published>2024-08-21T00:27:00.000Z</published>
    <updated>2024-09-21T23:13:11.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h3><p>着色器类似于一个计算器，用于根据给定的参数，制作特效；</p><h3 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h3><p>这个中文名称有点怪，英文名称是 Normal Map，即普通贴图；它主要用于展现凹凸效果；理论上凹凸效果也可以使用建模来实现，但是当细节很多时，工作量过大，因此不现实。更高效的做法是使用带凹凸参数的贴图；物体只由数量有限的多边形来表示，表现的纹理则基于贴图参数来计算；</p><blockquote><p>所谓的贴图参数，即是一种细节模拟，这些参数可用来计算光线效果，让相应的部位看起来像是有真实的模型存在一样。但实际上没有，完成是基于参数计算出来的效果；</p></blockquote><p>法线：垂直于某个平面的线，这条线可用来计算物体和光线之间的夹角。 有了夹角后，就可以计算物体表面接收到多少光线；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408201628616.png"></p><p>物体呈现出体积形状，其实是由物体表面所反向的光线决定的。对于一个多边形圆柱体，如果我们将法线的角度变化，调整成圆柱形的，那么计算出来的着色也将是平滑过渡的，最后在我们肉眼看来，多边形变成了圆形。但实际上，底层的参数存储的是多边形；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408201628272.png"></p><p>将表面的法线角度与真实角度的偏差，单独抽离出来存储，那么这个偏差值的集合，就是所谓的法线贴图；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408201628894.png"></p><h3 id="CPU-渲染逻辑"><a href="#CPU-渲染逻辑" class="headerlink" title="CPU 渲染逻辑"></a>CPU 渲染逻辑</h3><p>主要有四个工作：</p><ul><li>剔除工作：<ul><li>视锥体剔除；</li><li>图层剔除；</li><li>遮挡剔除；</li></ul></li><li>设置渲染顺序：<ul><li>不透明队列：根据距离摄像头的距离，由近到远依次渲染；</li><li>半透明队列：从远到近渲染；</li></ul></li><li>打包数据：将数据打包发送给 GPU 渲染；<ul><li>模型信息：顶点坐标、法线、UV、切线、顶点颜色、索引列表等；</li><li>变换矩阵：世界变换矩阵、VP 矩阵（基于相机位置和 FOV 参数）；</li><li>灯光、材质参数：着色器和材质参数，灯光信息等；</li></ul></li><li>调用渲染函数<ul><li>SetPassCall<ul><li>shader 脚本中的一个 Pass 语义块就是一个完整的渲染过程；一个着色器可包含多个 Pass 语义块；</li></ul></li><li>DrawCall：CPU 调用图像编程接口，命令 GPU 渲染的操作，即渲染命令；渲染命令的参数为图元列表，其计算结果为显示在屏幕上的像素；</li></ul></li></ul><p>CPU 渲染阶段的一个重要输出是渲染图元，图元中包括 GPU 渲染需要用到的各种参数信息，例如点、线、面等几何信息；</p><h3 id="GPU-渲染管线"><a href="#GPU-渲染管线" class="headerlink" title="GPU 渲染管线"></a>GPU 渲染管线</h3><p>GPU 渲染管线包含以下多个步骤：</p><ul><li>顶点处理<ul><li>顶点着色器：主要执行坐标转换，将顶点的坐标转换到齐次裁剪 </li><li>曲面细分着色器（可选）</li><li>几何着色器（可选）</li></ul></li><li>图元装配</li><li>光栅化</li><li>片元着色器</li><li>输出合并</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408210825758.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;着色器&quot;&gt;&lt;a href=&quot;#着色器&quot; class=&quot;headerlink&quot; title=&quot;着色器&quot;&gt;&lt;/a&gt;着色器&lt;/h3&gt;&lt;p&gt;着色器类似于一个计算器，用于根据给定的参数，制作特效；&lt;/p&gt;
&lt;h3 id=&quot;法线贴图&quot;&gt;&lt;a href=&quot;#法线贴图&quot; clas</summary>
      
    
    
    
    <category term="文章" scheme="http://example.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="渲染" scheme="http://example.com/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>VirtualDOM 简易实现</title>
    <link href="http://example.com/2024/06/22/VirtualDom%20%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2024/06/22/VirtualDom%20%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-06-22T04:12:00.000Z</published>
    <updated>2024-09-21T23:18:59.804Z</updated>
    
    <content type="html"><![CDATA[<p>Vuejs 和 Reactjs 都用到了虚拟DOM，来实现数据绑定和 DOM 的自动更新，此处做了一个简单的实现，方便学习基本的工作原理；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> exampleButton = &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;button&quot;</span>,<br>    <span class="hljs-attr">properties</span>: &#123;<br>        <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;primary&quot;</span>,<br>        <span class="hljs-attr">disabled</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">onClick</span>: doSomething,<br>    &#125;,<br>    <span class="hljs-attr">children</span>: [] <span class="hljs-comment">// 虚拟节点列表</span><br>&#125;<br><br><span class="hljs-keyword">const</span> exampleText = &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Hello&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">tag, properties, children</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; tag, properties, children &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">text</span>(<span class="hljs-params">content</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">text</span>: content &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">diffOne</span>(<span class="hljs-params">l, r</span>) &#123;<br>    <span class="hljs-keyword">const</span> isText = l.<span class="hljs-property">text</span> !== <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-comment">// 若是文本，直接替换</span><br>    <span class="hljs-keyword">if</span> (isText) &#123;<br>        <span class="hljs-keyword">return</span> l.<span class="hljs-property">text</span> !== r.<span class="hljs-property">text</span><br>        ? &#123; <span class="hljs-attr">replace</span>: r &#125;<br>        : &#123; <span class="hljs-attr">noop</span>: <span class="hljs-literal">true</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 若 tag 不同，直接替代</span><br>    <span class="hljs-keyword">if</span> (l.<span class="hljs-property">tag</span> !== r.<span class="hljs-property">tag</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">replace</span>: r &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 检查需要删除的属性</span><br>    <span class="hljs-keyword">const</span> remove = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> l.<span class="hljs-property">properties</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r.<span class="hljs-property">properties</span>[prop] === <span class="hljs-literal">undefined</span>) &#123;<br>            remove.<span class="hljs-title function_">push</span>(prop);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查新增的属性</span><br>    <span class="hljs-keyword">const</span> set = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> r.<span class="hljs-property">properties</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r.<span class="hljs-property">properties</span>[prop] !== l.<span class="hljs-property">properties</span>[prop]) &#123;<br>            set[prop] = r.<span class="hljs-property">properties</span>[prop];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> children = <span class="hljs-title function_">diffList</span>(l.<span class="hljs-property">chilren</span>, r.<span class="hljs-property">children</span>);<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">modify</span>: &#123; remove, set, children &#125; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">diffList</span>(<span class="hljs-params">ls, rs</span>) &#123;<br>    <span class="hljs-keyword">const</span> length = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(ls.<span class="hljs-property">length</span>, rs.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(&#123; length &#125;).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (ls[i] === <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">create</span>: rs[i] &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (rs[i] === <span class="hljs-literal">undefined</span>) &#123;<br>                <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">remove</span>: <span class="hljs-literal">true</span> &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">diffOne</span>(ls[i], rs[i])<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">apply</span>(<span class="hljs-params">el, enqueue, childrenDiff</span>) &#123;<br>    <span class="hljs-keyword">const</span> children = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(el.<span class="hljs-property">childNodes</span>);<br>    childrenDiff.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">diff, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(diff)[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">switch</span>(action) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;remove&quot;</span>: &#123;<br>                  children[i].<span class="hljs-title function_">remove</span>();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;modify&quot;</span>: &#123;<br>                <span class="hljs-title function_">modify</span>(children[i], enqueue, diff.<span class="hljs-property">modify</span>);<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;create&quot;</span>: &#123;<br>                <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">create</span>(enqueue, diff.<span class="hljs-property">create</span>);<br>                el.<span class="hljs-title function_">appendChild</span>(child);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;replace&quot;</span>: &#123;<br>                <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">create</span>(diff.<span class="hljs-property">replace</span>);<br>                children[i].<span class="hljs-title function_">replacewith</span>(child);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;noop&quot;</span>: &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element[<span class="hljs-string">&quot;_ui&quot;</span>] = &#123; <span class="hljs-attr">listeners</span>: &#123; <span class="hljs-attr">click</span>: doSomething &#125;&#125;<br><br><span class="hljs-comment">// 事件监听函数, 所有事件都归集到同一个函数进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">listener</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">const</span> el = event.<span class="hljs-property">currentTarget</span>;<br>    <span class="hljs-keyword">const</span> handler = el.<span class="hljs-property">_ui</span>.<span class="hljs-property">listeners</span>[event.<span class="hljs-property">type</span>];<br>    <span class="hljs-keyword">const</span> enqueue = el.<span class="hljs-property">_ui</span>.<span class="hljs-property">enqueue</span>;<br>    <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">handler</span>(event);<br>    <span class="hljs-keyword">if</span> (msg !== <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-title function_">enqueue</span>(msg)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 给 el 添加事件监听函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setListener</span>(<span class="hljs-params">el, event, handle</span>) &#123;<br>    <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_ui</span>.<span class="hljs-property">listeners</span>[event] === <span class="hljs-literal">undefined</span>) &#123;<br>        el.<span class="hljs-title function_">addEventListener</span>(event, listener);<br>    &#125;<br>    el.<span class="hljs-property">_ui</span>.<span class="hljs-property">listeners</span>[event] = handle;<br>&#125;<br><br><span class="hljs-comment">// 获得监听的事件名称</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">eventName</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;on&quot;</span>) === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([ <span class="hljs-string">&quot;autoplay&quot;</span>, <span class="hljs-string">&quot;checked&quot;</span>, <span class="hljs-string">&quot;checked&quot;</span>, <span class="hljs-string">&quot;contentEditable&quot;</span>, <span class="hljs-string">&quot;controls&quot;</span>,<br>  <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;hidden&quot;</span>, <span class="hljs-string">&quot;loop&quot;</span>, <span class="hljs-string">&quot;selected&quot;</span>, <span class="hljs-string">&quot;spellcheck&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>,<br>  <span class="hljs-string">&quot;accessKey&quot;</span>, <span class="hljs-string">&quot;dir&quot;</span>, <span class="hljs-string">&quot;dropzone&quot;</span>, <span class="hljs-string">&quot;lang&quot;</span>, <span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;alt&quot;</span>, <span class="hljs-string">&quot;preload&quot;</span>, <span class="hljs-string">&quot;poster&quot;</span>,<br>  <span class="hljs-string">&quot;kind&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;srclang&quot;</span>, <span class="hljs-string">&quot;sandbox&quot;</span>, <span class="hljs-string">&quot;srcdoc&quot;</span>, <span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;accept&quot;</span>,<br>  <span class="hljs-string">&quot;placeholder&quot;</span>, <span class="hljs-string">&quot;acceptCharset&quot;</span>, <span class="hljs-string">&quot;action&quot;</span>, <span class="hljs-string">&quot;autocomplete&quot;</span>, <span class="hljs-string">&quot;enctype&quot;</span>, <span class="hljs-string">&quot;method&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;pattern&quot;</span>, <span class="hljs-string">&quot;htmlFor&quot;</span>, <span class="hljs-string">&quot;max&quot;</span>, <span class="hljs-string">&quot;min&quot;</span>, <span class="hljs-string">&quot;step&quot;</span>, <span class="hljs-string">&quot;wrap&quot;</span>, <span class="hljs-string">&quot;useMap&quot;</span>, <span class="hljs-string">&quot;shape&quot;</span>,<br>  <span class="hljs-string">&quot;coords&quot;</span>, <span class="hljs-string">&quot;align&quot;</span>, <span class="hljs-string">&quot;cite&quot;</span>, <span class="hljs-string">&quot;href&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>, <span class="hljs-string">&quot;download&quot;</span>, <span class="hljs-string">&quot;download&quot;</span>,<br>  <span class="hljs-string">&quot;hreflang&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;headers&quot;</span>, <span class="hljs-string">&quot;scope&quot;</span>, <span class="hljs-string">&quot;span&quot;</span> ]);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setProperty</span>(<span class="hljs-params">prop, value, el</span>) &#123;<br>    <span class="hljs-keyword">if</span> (props.<span class="hljs-title function_">has</span>(prop)) &#123;<br>        el[prop] = value;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        el.<span class="hljs-title function_">setAttribute</span>(prop, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">enqueue, vnode</span>) &#123;<br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">text</span> !== <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(vnode.<span class="hljs-property">text</span>);<br>        <span class="hljs-keyword">return</span> el;<br>    &#125;<br>    <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>);<br>    el.<span class="hljs-property">_ui</span> = &#123; <span class="hljs-attr">listeners</span>: &#123;&#125;, enqueue &#125;;<br>    <span class="hljs-comment">// 有些 properties 是真的 prop, 有些则是事件监听函数，所以需要区别对待</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">properties</span>) &#123;<br>        <span class="hljs-keyword">const</span> event = <span class="hljs-title function_">eventName</span>(prop);<br>        <span class="hljs-keyword">const</span> value = vnode.<span class="hljs-property">properties</span>[prop];<br>        <span class="hljs-keyword">if</span> (event !== <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-title function_">setListener</span>(el, event, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">setProperty</span>(prop, value, el);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> childNode <span class="hljs-keyword">of</span> vnode.<span class="hljs-property">children</span>) &#123;<br>        <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">create</span>(enqueue, childNode);<br>        el.<span class="hljs-title function_">appendChild</span>(child);<br>    &#125;<br>    <span class="hljs-keyword">return</span> el;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">modify</span>(<span class="hljs-params">el, enqueue, diff</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">of</span> diff.<span class="hljs-property">remove</span>) &#123;<br>        <span class="hljs-keyword">const</span> event = <span class="hljs-title function_">eventName</span>(prop);<br>        <span class="hljs-keyword">if</span> (event === <span class="hljs-literal">null</span>) &#123;<br>            el.<span class="hljs-title function_">removeAttribute</span>(prop);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            el.<span class="hljs-property">_ui</span>.<span class="hljs-property">listeners</span>[event] = <span class="hljs-literal">undefined</span>;<br>            el.<span class="hljs-title function_">removeEventListener</span>(event, listener);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> diff.<span class="hljs-property">set</span>) &#123;<br>        <span class="hljs-keyword">const</span> value = diff.<span class="hljs-property">set</span>[prop];<br>        <span class="hljs-keyword">const</span> event = eventName[prop];<br>        <span class="hljs-keyword">if</span> (event !== <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-title function_">setListener</span>(el, event, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">setProperty</span>(prop, value, el);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-title function_">apply</span>(el, enqueue, diff.<span class="hljs-property">children</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 应用示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">view</span>(<span class="hljs-params">state</span>) &#123;<br>    <span class="hljs-keyword">return</span> [<br>        <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;p&quot;</span>, &#123;&#125;, [ <span class="hljs-title function_">text</span>(<span class="hljs-string">`counter: <span class="hljs-subst">$&#123;state.counter&#125;</span>`</span>)])<br>    ];<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">state, msg</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + msg &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> initialState = &#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.my-application&quot;</span>);<br><br><span class="hljs-keyword">const</span> &#123; enqueue &#125; = <span class="hljs-title function_">init</span>(root, initialState, update, view);<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">enqueue</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">root, initialState, update, view</span>) &#123;<br>    <span class="hljs-keyword">let</span> state = initialState;<br>    <span class="hljs-keyword">let</span> nodes = [];<br>    <span class="hljs-keyword">let</span> queue = [];<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">msg</span>) &#123;<br>        queue.<span class="hljs-title function_">push</span>(msg);<br>    &#125;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> newNodes = <span class="hljs-title function_">view</span>(state);<br>        <span class="hljs-title function_">apply</span>(root, enqueue, <span class="hljs-title function_">diffList</span>(nodes, newNodes));<br>        nodes = newNodes;<br>    &#125;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateState</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">let</span> msgs = queue;<br>            queue = [];<br>            <span class="hljs-keyword">for</span> (msg <span class="hljs-keyword">of</span> msgs) &#123;<br>                state = <span class="hljs-title function_">update</span>(state, msg, enqueue);<br>            &#125;<br>            <span class="hljs-title function_">draw</span>();<br>        &#125;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(updateState);<br>    &#125;<br>    <span class="hljs-title function_">draw</span>();<br>    <span class="hljs-title function_">updateState</span>();<br>    <span class="hljs-keyword">return</span> &#123; enqueue &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> button = <span class="hljs-title function_">h</span>(<br><span class="hljs-string">&quot;button&quot;</span>,<br>    &#123; <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-number">1</span> &#125;,<br>    [ <span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;increase counter&quot;</span>)],<br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vuejs 和 Reactjs 都用到了虚拟DOM，来实现数据绑定和 DOM 的自动更新，此处做了一个简单的实现，方便学习基本的工作原理；&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="文章" scheme="http://example.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue3</title>
    <link href="http://example.com/2023/08/19/Vue3/"/>
    <id>http://example.com/2023/08/19/Vue3/</id>
    <published>2023-08-19T02:33:00.000Z</published>
    <updated>2024-09-21T23:19:17.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>app.use()</p><p>注册插件，有点像 Express 中的 use；所谓的插件，即具备某些功能的一段代码，这段代码用于添加全局功能；</p><p>插件可以是一个对象，也可以是一个函数；</p><p>如果是一个对象，需要有一个 install 方法，以便调用；该 install 函数的第一个参数是 app，第二个参数是 options</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;)<br><br>app.<span class="hljs-title function_">use</span>(myPlugin, &#123;<br>    <span class="hljs-attr">greetings</span>: &#123;<br>        <span class="hljs-attr">hello</span>: <span class="hljs-string">&quot;Bonjour!&quot;</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// plugins/i18n.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">install</span>: <span class="hljs-function">(<span class="hljs-params">app, options</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 注入一个全局可用的 $translate() 方法</span><br>    app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$translate</span> = <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 获取 `options` 对象的深层属性</span><br>      <span class="hljs-comment">// 使用 `key` 作为索引</span><br>      <span class="hljs-keyword">return</span> key.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">o, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (o) <span class="hljs-keyword">return</span> o[i]<br>      &#125;, options)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; $translate(&#x27;greetings.hello&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插件的几种使用场景：</p><ul><li>添加一些全局属性和方法；</li><li>添加一个全局资源；</li><li>添加一个全局组件</li><li>添加自定义指令；</li></ul><p>app.config.isCustomElement</p><p>有些元素是从外部引入的，并没有在 vue 中编写，此时需要备注一下哪些元素是自定义的，以免在编译时报错找不到；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-property">config</span>.<span class="hljs-property">isCustomElement</span> = <span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> <span class="hljs-regexp">/^x-/</span>.<span class="hljs-title function_">test</span>(tag);<br></code></pre></td></tr></table></figure><p>app.mount</p><p>将 app 关联到 HTML 文件中的 Tag</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>TodoMVC built with Vue Composition Api and Vuex<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">app-root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-root</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive 可用来创建一个对象，这个对象可以被多个组件引入，共享使用；</p><p>对象可以有自己的方法，通过调用该方法，改变对象的状态；这个改变会在所有的组件上同时更新；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;store.increment()&quot;</span>&gt;</span><br>        &#123;&#123; store.count &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了用 reactive 来创建全局对象外，其实 ref 或者函数也可以实现该功能；</p><blockquote><p>函数之所以可以，主要是利用了闭包的特性；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> &#123; ref &#125; from <span class="hljs-string">&quot;vue&quot;</span><br>    <br><span class="hljs-comment">// 保存状态的全局对象</span><br><span class="hljs-type">const</span> <span class="hljs-variable">globalCount</span> <span class="hljs-operator">=</span> ref(<span class="hljs-number">1</span>);<br><br><br>export function <span class="hljs-title function_">useCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 保存状态的局部变量</span><br>    <span class="hljs-type">const</span> <span class="hljs-variable">localCount</span> <span class="hljs-operator">=</span> ref(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">return</span> &#123;<br>        globalCount,<br>        localCount,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 问：reactive 和 ref 有什么区别？</p><p> 答：有以下一些区别：</p><ul><li>reactive 只能处理对象，不能处理原始类型；ref 的底层实现其实最终也有调用 reactive；</li><li>ref 可以通过 .value 重新赋值，reactive 不行，因此 reactive 在处理新的 array 时，不如 ref 重新赋值方便；</li><li>不过 reactive 修改对象的属性时，无须使用 .value，写起来会简单一些；</li></ul> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// reactive 很适合管理一个拥有多个原始类型属性的对象；</span><br><br><span class="hljs-keyword">const</span> person = <span class="hljs-title function_">reactive</span>(&#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">37</span>,<br>   <span class="hljs-attr">isTall</span>: <span class="hljs-literal">true</span>,<br>&#125;); <br><br><span class="hljs-comment">// 以上写法比使用多个 ref 来得方便</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;Albert&quot;</span>);<br><span class="hljs-keyword">const</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">37</span>);<br><span class="hljs-keyword">const</span> isTall = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 但 ref 其实也可以写成下面这样</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-title function_">ref</span>(&#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">37</span>,<br>   <span class="hljs-attr">isTall</span>: <span class="hljs-literal">true</span>,<br>&#125;); <br></code></pre></td></tr></table></figure></blockquote><p>computed() 其实也是返回一个 ref</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>当值 B 依赖于值 A 时，通过 computed 可以实现当 A 变动时，B 实现实时更新；</p><p>computed 接收一个函数做为参数，返回的是一个 ref</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reacitve, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript"><span class="hljs-keyword">const</span> author = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;john&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">books</span>: [</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue1&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue2&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue3&quot;</span>,</span><br><span class="language-javascript">    ]</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// computed 接收一个函数做为参数，返回的是一个 ref</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> message = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> author.<span class="hljs-property">books</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>  ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>;</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Has Published books:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>computed 的好处是有缓存，也就是说，如果所依赖的值没变的话，它是不会重新计算的；</p><p>实际上 message 也可以定义成一个函数，结果一样，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> author = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;john&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">books</span>: [</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue1&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue2&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue3&quot;</span>,</span><br><span class="language-javascript">    ]</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">message</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> author.<span class="hljs-property">books</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>  ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Has Published books:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; message() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="状态管理器"><a href="#状态管理器" class="headerlink" title="状态管理器"></a>状态管理器</h3><p>vue2 的状态管理器，在 vue3 中使用 Pinia</p><h3 id="类与样式绑定"><a href="#类与样式绑定" class="headerlink" title="类与样式绑定"></a>类与样式绑定</h3><p>有多种写法可用来绑定样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">// 方式一: 使用单个 ref<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> isAcitve = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; acitve: isActive &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">// 方式二：使用多个 ref<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> isAcitve = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> hasError = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">       <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;static&quot;</span> </span><br><span class="hljs-tag">       <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">// 方式三：使用对象<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> classObject = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">// 方法四：使用数组<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> activeClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;active&#x27;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> errorClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;text-danger&#x27;</span>);</span><br><span class="language-javascript">    </span><br><span class="language-javascript"><span class="hljs-keyword">const</span> isActive = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>// 或者<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#123;[activeClass]: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>自定义组件上的 class 值，会传递到组件内部的 Tag 上面，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">// 组件 myComponent 内部的内容<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;foo bar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">// 在调用 myComponent 组件时<br><span class="hljs-tag">&lt;<span class="hljs-name">myComponent</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;baz boo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">myComponent</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">// 渲染结果为<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;foo bar baz boo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果 myComponent 内部有多上根Tag，那么需要指定哪个根 Tag 接收外部传进来的 class 值，示例如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">// 内部有两个根元素 p 和 span，此处指定 p 接收 myComponent 的 class 值<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;$attrs.class&quot;</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>message<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>适用于 class 的绑定规则，同样也适用于 style 的绑定，示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> styleObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;30px&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>当我们想阻止某个事件的冒泡时，可以在绑定的方法中调用 event.stopPropagation()，但 vue 还提供了一种更简便的方法，示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 旧方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">warn</span>(<span class="hljs-params">message, event</span>) &#123;<br>  <span class="hljs-comment">// 这里可以访问原生事件</span><br>  <span class="hljs-keyword">if</span> (event) &#123;<br>    event.<span class="hljs-title function_">preventDefault</span>()<br>  &#125;<br>  <span class="hljs-title function_">alert</span>(message)<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是使用事件修饰符进行绑定的方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--新方法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warn</span>(<span class="hljs-params">message, event</span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">alert</span>(message)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">    </span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;warn&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><p>按键修饰符可用于监听键盘上某个特定的键被按下的事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--此处监听 enter 键--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br><br><br><span class="hljs-comment">&lt;!--此处监听 pageDown 键--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.page-down</span>=<span class="hljs-string">&quot;onPageDown&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="鼠标修饰符"><a href="#鼠标修饰符" class="headerlink" title="鼠标修饰符"></a>鼠标修饰符</h3><p>用来监听鼠标事件</p><ul><li>.left  左键</li><li>.right 右键</li><li>.middle  中键</li></ul><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><p>在处理表单输入时，是需要双向绑定的，即改动 data，会更新 html；而改动 input 时，也会更新 data</p><p>vue 使用 v-model 关键字来实现这种双向绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>多个复选框可以绑定到一个数组或集合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> checkedNames = <span class="hljs-title function_">ref</span>([]);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>checked names: &#123;&#123; checkedNames &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbot&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbot&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbot&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mike&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mike&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mike&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>v-bind 可用于标签的属性绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; id: &#x27;blue&#x27;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--等同于如下--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--简写如下--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> id = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;abc&quot;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-model-修饰符"><a href="#v-model-修饰符" class="headerlink" title="v-model 修饰符"></a>v-model 修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h4><p>默认情况下，v-model 的更新是实时的，但可使用 .lazy 修饰符，让更新不再实时，而是触发 change 事件后再更新</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h4><p>将输入的字符串自动转成数字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h4><p>自动去除字符串首尾的空格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-mdoel.trim</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>最常用的几个生命周期</p><ul><li>onMounted</li><li>onUpdated</li><li>onUnmounted</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408161623575.png"></p><h3 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h3><p>当某个对象的值出现变化时，就执行回调函数；监听的对象可以是如下几种类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 监听单个 ref 对象</span><br><span class="hljs-title function_">watch</span>(x, <span class="hljs-function">(<span class="hljs-params">new_x</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;);<br><br><br><span class="hljs-comment">// 监听 getter 函数</span><br><span class="hljs-title function_">watch</span>(<br><span class="hljs-function">() =&gt;</span> x.<span class="hljs-property">value</span> + y.<span class="hljs-property">value</span>,<br>    <span class="hljs-function">(<span class="hljs-params">sum</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sum of x and y is: &quot;</span>, sum);<br>    &#125;<br>);<br><br><br><span class="hljs-comment">// 监听数组</span><br><span class="hljs-title function_">watch</span>(<br>[x, <span class="hljs-function">() =&gt;</span> y.<span class="hljs-property">value</span>],<br>    <span class="hljs-function">(<span class="hljs-params">[new_x, new_y]</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`new x is <span class="hljs-subst">$&#123;new_x&#125;</span> and new y is <span class="hljs-subst">$&#123;new_y&#125;</span>`</span>);<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><p>watch 并非马上执行，而是当监听对象的值出现变化时，才会执行。因此，如果想让它立即执行，那么需要加个 { immediate: true } 参数；</p><p>默认情况下，如果在回调函数中访问监听对象，此时监听对象的值，是原始状态；如果未被回调函数改变前的状态；如果需要访问改变后的状态，则需要给 watch 传递 { flush: “post” } 选项；</p><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>watchEffect 有点像是 watch 的语法糖，在使用 watch 时，需要显示的指定某个监听对象；watchEffect 则不用，它可以自动从回调函数中判断需要监听的对象；而且是加载后，马上执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> todoId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://example.com/<span class="hljs-subst">$&#123;todoId.value&#125;</span>`</span>)<br>    data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="访问-DOM"><a href="#访问-DOM" class="headerlink" title="访问 DOM"></a>访问 DOM</h3><p>如果想直接访问 DOM，则可以给标签的 ref 属性设置名称，之后就可以在代码中引用它，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> myInput = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);  <span class="hljs-comment">// 此处用同名变量，实现对 input 标签的引用</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    myInput.<span class="hljs-property">value</span>.<span class="hljs-title function_">focus</span>();</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myInput&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当 ref 被用在子组件上时，此时引用的不再是标签，而是子组件实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Child.vue&quot;</span>;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 此处引用的是 Child 实例</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>默认情况下，子组件内部的属性和方法是私有的，父组件无法直接访问，除非子组件使用 defineExpose 进行暴露；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> b = <span class="hljs-title function_">ref</span>(<span class="hljs-number">2</span>);</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-title function_">defineExpose</span>(&#123;</span><br><span class="language-javascript">        a,</span><br><span class="language-javascript">        b,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时父组件可通过 ref 引用来访问子组件中的 a 和 b 变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 此时 ref 的值为 &#123; a: number, b: number &#125;</span><br></code></pre></td></tr></table></figure><h3 id="组件API"><a href="#组件API" class="headerlink" title="组件API"></a>组件API</h3><p>以下两种形式的 API 是等价的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 组合式 API --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;count++&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- 选项式 <span class="hljs-variable constant_">API</span> --&gt;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">setup</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> &#123; count &#125;;<br>    &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;button @click=&quot;count++&quot;&gt;&lt;/button&gt;`</span><br>    <span class="hljs-comment">// template 也可以引用一个模板</span><br>    <span class="hljs-comment">// template: &#x27;#my-template-element&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>父组件可通过 props 向子组件传递数据；子组件可 emit 事件，父组件通过监听事件来获得子组件传递的数据；</p><h3 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h3><p>slot 的作用类似于占位符，可接收由父组件传进来的 HTML 内容，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--AlertBox.vue--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>This is an Error box<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--此处父组合的内容 Something bad happen 会出现中子组件的 slot 位置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AlertBox</span>&gt;</span>Something bad happen<span class="hljs-tag">&lt;/<span class="hljs-name">AlertBox</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="深入组件"><a href="#深入组件" class="headerlink" title="深入组件"></a>深入组件</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>组件需要注册后才能使用，通过 app.component 方法，可将某个组件注册为全局的组件，之后可以在任意文件中使用该全局组件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;);<br><br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyComponent&#x27;</span>, <span class="hljs-title class_">MyComponent</span>);  <span class="hljs-comment">// 全局注册</span><br></code></pre></td></tr></table></figure><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>局部注册：仅在需要使用的位置，导入相应的组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentA.vue&#x27;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ComponentA</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>除了 attribute  外，考虑父组件还可通过 props 传递数据给子组件。因此，最好显式的声明 props，这样有利于 Vue 区分二者；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// props 使用对象，并写上属性值的类型，有助于尽早发现传错参数</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">likes</span>: <span class="hljs-title class_">Number</span><br>&#125;)<br><br><span class="hljs-comment">// 还可以添加校验规则</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>    <span class="hljs-attr">propA</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;hello&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">propB</span>: &#123;<br>        <span class="hljs-title function_">validator</span>(<span class="hljs-params">value, props</span>) &#123;<br>            <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].<span class="hljs-title function_">includes</span>(value);<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">propC</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-comment">// 可以是函数类型</span><br>        <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Default Function&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>Vue 倾向在写 HTML atribute 时，使用传统的 kecal-case 枨，然后它还会自动映射 kebab-case 和 camelCase 格式，以便和传统的 javascript camelCase 保持一致； </p><blockquote><p>个人感觉这种两边讨好的做法不是很好；缺少一致性，容易让人感到困惑；</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">greeting-message</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 当使用 v-bind 时，引号中的内容，实际上是一个表达式，而不是字符串</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 因为使用 v-bind，所以此处的 42 其实是一个 Number 类型，  --&gt;</span><br><span class="hljs-comment">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">:likes</span>=<span class="hljs-string">&quot;42&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">:likes</span>=<span class="hljs-string">&quot;post.likes&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 同理，false 是一个布尔值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">:is-published</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 表达式自然是支持数组的 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">:commend-ids</span>=<span class="hljs-string">&quot;[234, 245, 273]&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!--表达式也支持对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">:author</span>=<span class="hljs-string">&quot;&#123; name: &#x27;John&#x27;, age: 47 &#125;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>可通过 v-bind&#x3D;对象，批量绑定多个 prop</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> post = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My Journey&quot;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--同时绑定了 id 和 title 两个 prop --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;post&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>注意：prop 是单向绑定，即数据由父组件传递给子组件，这意味着它是只读的，我们不能在子组件的代码中，修改 prop 的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;foo&#x27;</span>]);<br><br><span class="hljs-comment">// 以下尝试修改 foo 的值是错误的</span><br>props.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;<br></code></pre></td></tr></table></figure><p>由于在 Javascript 中，对象类型的参数，实际上是一个引用，因此，虽然无法直接更改对象绑定的变量，但可以改变对象内部的属性。但这是一种不良做法，应该在实践中避免；如有需要修改，应使用 emit 事件的方式；由监听事件的父组件对 prop 进行修改；</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>在组件的 template 模板中，可使用内置的 $emit 函数来触发事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;someEvent&#x27;)&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>事件支持携带参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;someEvent&#x27;, param)&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>通过使用 defineEmit() 宏显式的声明可触发的事件后，会返回一个 emit 函数，能够在代码中直接调用，它的效果跟 template 中的 $emit 是一样的； </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;inFocus&#x27;</span>, <span class="hljs-string">&#x27;submit&#x27;</span>]);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">buttonClick</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;submit&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="组件-v-model"><a href="#组件-v-model" class="headerlink" title="组件 v-model"></a>组件 v-model</h3><p>通过在子组件上使用 v-model，可以实现父子组件之间数据的双向绑定；父子组件传统的通信方式是使用 prop 和 emit，事实上在组件上使用 v-model 只是一个语法糖，它的底层仍然还是 prop 和 emit，只是它由解释器完成补全；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--父组件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> myRef = <span class="hljs-title function_">ref</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;myRef&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--子组件 Child.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> myRefVar = <span class="hljs-title function_">defineModel</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&#x27;myRefVar&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以绑定多个 v-model</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">UserName</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model:firstName</span>=<span class="hljs-string">&quot;first&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model:lastName</span>=<span class="hljs-string">&quot;last&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> firstName = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">&quot;firstName&quot;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> lastName = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">&quot;lastName&quot;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>组件 v-model 同样支持修饰符，例如 v-model.capitalize，之后在 defineModel 中，可以基于传入的修饰符的值，自定义 set 函数，实现想要的处理；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">v-model.capitalize</span>=<span class="hljs-string">&#x27;myText&#x27;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> [model, modifiers] = <span class="hljs-title function_">defineModel</span>();</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;modifiers&quot;</span>) <span class="hljs-comment">// &#123; capitalize: true &#125;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;model&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!-- 或者可以针对 modifiers 自定义处理方法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> [model, modifiers] = <span class="hljs-title function_">defineModel</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (modifiers.<span class="hljs-property">capitalize</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUppercase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> value;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="透传-Attributes"><a href="#透传-Attributes" class="headerlink" title="透传 Attributes"></a>透传 Attributes</h3><p>最常见的透传包括 class, style, id 等几个 HTML 标签的属性；但其实 v-on 监听器也会实现透传</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyButton</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onChildClick&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>当 button 触发点击事件时，onChildClick 和 onClick 两个函数都会被执行，事实上 button 标签绑定了来自父子组件的两个点击事件；</p><h4 id="深层组件继承"><a href="#深层组件继承" class="headerlink" title="深层组件继承"></a>深层组件继承</h4><p>如果子组件的根元素也是一个组件，那么父组件的 attributes 会持续向下一级透传；</p><p>如果不想要继承透传，可在组件选项中设置 inheritAttrs: false</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">defineOptions</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>透传的 attributes 可在 template 中使用 $attris 进行访问</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; $attrs &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>@click 在透传后，子组件可使用 $attrus.onClick 进行访问；</p><p>如果子组件有多个根节点，那么需要显式指定由哪个根节点继承父组件透传的 attris，否则编译器会抛出警告；</p><p>如果想要在 js 代码中访问 attrus，则可以使用 useAttrs</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; useAttrs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> attrs = <span class="hljs-title function_">useAttrs</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>父组件可通过插横向子组件传递内容；插槽从某种意义上来说，有点像是一个形式参数。子组件本身只提供样式，内容则由参数来决定，这样可以提高子组件的通用性和灵活性；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">FancyButton</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">AwesomeIcon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;plus&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">FancyButton</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 FancyButton.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fancy-btn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 插入的位置 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 最终渲染结果 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fancy-btn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">AwesomeIcon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;plus&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408171512456.png"></p><p>作用域：插槽内容可以访问父组件中定义的变量，但无法访问子组件中的数据；</p><p>默认内容：插槽允许指定默认内容，这样当父组件没有传入内容时，可显示默认内容；就像默认参数值一样；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><br>    Submit  <span class="hljs-comment">&lt;!-- 此处的 Submit 为默认内容 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>组件支持多个插槽，为了避免混淆，需要为每个插槽指定名称，这样传入内容的时候，才能够匹配；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 BaseLayout.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 没有名称，默认名称为 default --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BaseLayout</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 此处的内容将匹配到名称为 header 的插槽上 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span>  <span class="hljs-comment">&lt;!-- v-slot 支持简写为 # --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 此处的内容将匹配到名称为 footer 的插槽上 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">BaseLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>父组件的插槽名称必须和子组件中的插槽名称完全一样，如果不一样，会无法匹配，因此也无法渲染</p><p>插槽的名称可以是动态的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">dynamicSlotName</span>]&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="反向传递"><a href="#反向传递" class="headerlink" title="反向传递"></a>反向传递</h4><p>子组件可以将自己的数据，通过插槽，反向传递给父组件</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408171631960.png"></p><h4 id="无渲染组件"><a href="#无渲染组件" class="headerlink" title="无渲染组件"></a>无渲染组件</h4><p>利用插槽机制，再加上 v-slot 让子组件能够向父组件传递数据，那么接下来便出现了一种有趣的用法，即子组件只封装了逻辑，但没有封装要渲染的内容。它在通过逻辑获得数据后，可以将数据传递给父组件，由父组件自行决定如何渲染；</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>当需要向深层次的组件时，使用 props 会导致逐级透传的问题</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408171658227.png"></p><p>Vue 使用 provide&#x2F;inject 机制来解决逐级透传的问题</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408171731829.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;   </span><br><span class="language-javascript">    <span class="hljs-title function_">provide</span>(&#123; <span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>&#125;) <span class="hljs-comment">// 此处 message 是键，hello 是值；</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span><br><span class="language-javascript">    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;count&#x27;</span>, count); <span class="hljs-comment">// provide 支持多次调用，以便传入多个值</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>app 可以提供全局依赖&#x2F;注入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;);<br><br>app.<span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>); <br></code></pre></td></tr></table></figure><p>在子组件中，使用 inject 来获得想要的数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;message&quot;</span>); <span class="hljs-comment">// 使用 inject 获得想要的数据</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-string">&quot;defaultValue&quot;</span>) <span class="hljs-comment">// inject 支持设置一个默认值</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 默认值也可以使用工厂函数来生成, 第三个参数 true 用来声明默认值是由一个函数生成</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefautlValue</span>(), <span class="hljs-literal">true</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果需要在子组件中更改注入的数据，那么 provide 最好提供一个方法，供子组件调用，而不是直接修改。这样有利于未来的维护；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;North Pole&quot;</span>);</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateLocation</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        location.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;South Pole&#x27;</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   </span><br><span class="language-javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;location&quot;</span>, &#123;</span><br><span class="language-javascript">        location,</span><br><span class="language-javascript">        updateLocation,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> &#123; location, updateLocation &#125; = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;location&quot;</span>); <span class="hljs-comment">// 可以解包</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateLocation&quot;</span>&gt;</span><br>        &#123;&#123; location &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果提供方想保护自己的数据不能被修改，可以使用 readonly 将其装饰为只读的状态</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, provide, readonly &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;readOnlyCount&#x27;</span>, <span class="hljs-title function_">readonly</span>(count)) <span class="hljs-comment">// 使用 readonly 装饰</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="使用-Symbol-避免命名冲突"><a href="#使用-Symbol-避免命名冲突" class="headerlink" title="使用 Symbol 避免命名冲突"></a>使用 Symbol 避免命名冲突</h4><p>如果构建的应用很大，或者所编写的组件会被很多人调用，那么有可能产生命名冲突。解决办法就是将名称放在一个单独的文件中统一管理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// key.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myInjectKey = <span class="hljs-title class_">Symbol</span>(); <span class="hljs-comment">// Symbol 会生成一个唯一值，以便作为标识符，避免重名</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 provide 组件中</span><br><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myIndectKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./key.js&quot;</span><br><br><span class="hljs-title function_">provide</span>(myInjectKey, &#123;<span class="hljs-comment">/* something */</span>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 inject 组件中</span><br><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./key.js&quot;</span><br><br><span class="hljs-keyword">const</span> injected = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;myInjectKey&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>当应用变得很大时，每次打开便加载所有组件将耗费很长的等待时间，更好的做法是懒加载，即等用到某个组件时，再去加载它；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 普通加截组件的方法</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponet</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/MyComponent.vue&quot;</span><br><br><span class="hljs-comment">// 异步加载组件的方法</span><br><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./components/MyComponent.vue&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="加载错误"><a href="#加载错误" class="headerlink" title="加载错误"></a>加载错误</h4><p>异步加载因为是使用时再加载的，那么有可能因为网络信号不好，导致加载失败，此时可提供一个组件，来应对出错的情况，defineAsyncComponent 支持多个配置选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;<br>    <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;../components/Foo.vue&quot;</span>),<br>    <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span>,  <span class="hljs-comment">// 例如可显示加载动画</span><br>    <span class="hljs-attr">errComponent</span>: <span class="hljs-title class_">ErrorComponent</span>, <span class="hljs-comment">// 例如在出错时，显示错误提示信息</span><br>    <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,  <span class="hljs-comment">// 设置延迟，有助于让画面过渡更加顺滑，以免加载太快，切换太快，像是页面闪烁</span><br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>, <span class="hljs-comment">// 超时后报错</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><h3 id="组合式函数"><a href="#组合式函数" class="headerlink" title="组合式函数"></a>组合式函数</h3><p>当某个行为逻辑被很多个组件复用时，可以把它抽象到一个公式的函数中，然后由各组件引入使用；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 该函数实时读取鼠标的位置，现抽象到单独的 mouse.js 文件中</span><br><span class="hljs-keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 按照惯例，组合式函数名以“use”开头</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useMouse</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 被组合式函数封装和管理的状态</span><br>  <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-comment">// 组合式函数可以随时更改其状态。</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">event</span>) &#123;<br>    x.<span class="hljs-property">value</span> = event.<span class="hljs-property">pageX</span><br>    y.<span class="hljs-property">value</span> = event.<span class="hljs-property">pageY</span><br>  &#125;<br><br>  <span class="hljs-comment">// 一个组合式函数也可以挂靠在所属组件的生命周期上</span><br>  <span class="hljs-comment">// 来启动和卸载副作用</span><br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, update))<br>  <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, update))<br><br>  <span class="hljs-comment">// 通过返回值暴露所管理的状态</span><br>  <span class="hljs-keyword">return</span> &#123; x, y &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在组件中使用 mouse.js --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Script</span> <span class="hljs-attr">setup</span>&gt;</span><br>import &#123; useMouse &#125; from &quot;./mouse.js<br>    const &#123; x, y &#125; = useMouse(); // useMouse 会创建单独的实例，因此各个组件间的状态不会相互影响<br><span class="hljs-tag">&lt;/<span class="hljs-name">Script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以将动作拆分成更小的函数，然后不同的函数可以相互组合，这样可以尽可能实现复用；</p><p>例如从后端获取数据是一个很常见的动作，获取的过程涉及三个动作，显示正在获取中；如果成功，显示数据；如果失败，显示失败提示；由于该动作很常见，因此我们可以将它封装成一个单独的函数，以便各个组件可以复用该逻辑；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 传统的方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;...&#x27;</span>)</span><br><span class="language-javascript">  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())</span><br><span class="language-javascript">  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> (data.<span class="hljs-property">value</span> = json))</span><br><span class="language-javascript">  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> (error.<span class="hljs-property">value</span> = err))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span>Oops! Error encountered: &#123;&#123; error.message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span><br>    Data loaded:<br>    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>&#123;&#123; data &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 抽象成单独的函数</span><br><span class="hljs-comment">// fetch.js</span><br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useFetch</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><br>  <span class="hljs-title function_">fetch</span>(url)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> (data.<span class="hljs-property">value</span> = json))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> (error.<span class="hljs-property">value</span> = err))<br><br>  <span class="hljs-keyword">return</span> &#123; data, error &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用封装后的函数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; useFetch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./fetch.js&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> &#123; data, error &#125; = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">&#x27;...&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>理论上也可以直接使用普通的函数，没有必要将函数封装组装，这种做的好处其实在于让它变成响应式的。因为普通的函数每次执行，都需要手动主动调用。而如果封装成了组件，同时参数为 ref 或者 getter 函数等动态类型，那么每当参数值发生变化时，组件就会自动运行。这是相对普通函数的好处；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> url = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;/initial-url&#x27;</span>)<br><br><span class="hljs-keyword">const</span> &#123; data, error &#125; = <span class="hljs-title function_">useFetch</span>(url)<br><br><span class="hljs-comment">// 这将会重新触发 fetch</span><br>url.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;/new-url&#x27;</span><br></code></pre></td></tr></table></figure><p>另外，也可以在函数式组件中使用 watchEffect 来监听参数变化；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// fetch.js</span><br><span class="hljs-keyword">import</span> &#123; ref, watchEffect, toValue &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useFetch</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 每次运行前重置</span><br>    data.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span><br>    error.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span><br><br>    <span class="hljs-title function_">fetch</span>(<span class="hljs-title function_">toValue</span>(url)) <span class="hljs-comment">// toValue 的好处是让参数可以支持多种类型，更加灵活</span><br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> (data.<span class="hljs-property">value</span> = json))<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> (error.<span class="hljs-property">value</span> = err))<br>  &#125;<br>  <br>  <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 使用 watchEffect 来监听变化</span><br>    <span class="hljs-title function_">fetchData</span>()<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> &#123; data, error &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解构重命名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> &#123;a : a1, b : b2, <span class="hljs-attr">c</span>: c3, d4 = <span class="hljs-string">&#x27;default&#x27;</span>&#125; = obj;<br></code></pre></td></tr></table></figure><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>Vue 有一些内置的指令，例如 v-model、v-show 等，这些指令从本质上来，其实是为了操作和控制 DOM；除了内置指令，Vue 也支持编写自定义的指令，这些指令可以在不同的组件上实现复用；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vFocus = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">mounted</span>: <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el.<span class="hljs-title function_">focus</span>(), <span class="hljs-comment">// 加载后，可自动对焦</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>vFocus 是一种强制的命名规范，以小写字母 v 开头；</p><p>指令支持多种钩子函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myDirective = &#123;<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;,<br>    <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;,<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;,<br>    <span class="hljs-title function_">beforeUpdated</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;,<br>    <span class="hljs-title function_">updated</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;,<br>    <span class="hljs-title function_">beforeUnmounted</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;<br>    <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;<br>&#125;<br><span class="hljs-comment">// el 参数指要操作的元素</span><br><span class="hljs-comment">// binding 是一个对象，主要用来存放要传给指令的值；以便 el 可以读取这些值，进行相应的操作；</span><br><span class="hljs-comment">// vnode 代表绑定元素的底层 VNode</span><br><span class="hljs-comment">// prevVnode 代表之前绑定的底层 VNode</span><br></code></pre></td></tr></table></figure><blockquote><p>注：应避免有组件上面使用自定义指令，而是只在原生的 HTML 元素上使用，以避免冲突，产生预期外的效果；</p></blockquote><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件可用来给 Vue 添加全局功能；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>();<br><br>app.<span class="hljs-title function_">use</span>(myPlugin), &#123;...&#125;;  <span class="hljs-comment">// 全局使用插件</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义插件示例</span><br><br><span class="hljs-keyword">const</span> myPlugin = &#123;<br>    <span class="hljs-attr">install</span>: (app, options) &#123;...&#125;,<br>&#125;<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">myPlugin</span> = (<span class="hljs-params">app, options</span>) =&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="编写插件示例"><a href="#编写插件示例" class="headerlink" title="编写插件示例"></a>编写插件示例</h4><p>该插件给在 app 上注册一个全局可用的 $translate 函数，用来翻译指定字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// plugins/i18n.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">install</span>: <span class="hljs-function">(<span class="hljs-params">app, options</span>) =&gt;</span> &#123;<br>        app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$translate</span> = <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> key.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-number">0</span>, i</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (o) &#123;<br>                    <span class="hljs-keyword">return</span> o[i];<br>                &#125;<br>            &#125;, options);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入插件</span><br><span class="hljs-keyword">import</span> i18nPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./plugins/i18n&quot;</span>;<br><br>app.<span class="hljs-title function_">use</span>(i18nPlugin, &#123;<br>    <span class="hljs-attr">greetings</span>: &#123;<br>        <span class="hljs-attr">hello</span>: <span class="hljs-string">&quot;Bonjour!&quot;</span>,<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用插件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; $translate(&quot;greetings.hello&quot;)&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插件中也可以引入 provide &#x2F; inject，这样各个组件就可以直接读取插件提供的值了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">install</span>: <span class="hljs-function">(<span class="hljs-params">app, options</span>) =&gt;</span> &#123;<br>        app.<span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;i18n&#x27;</span>, options),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在组件中通过 inject 读取 options --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> i18n = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;i18n&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i18n.<span class="hljs-property">greetings</span>.<span class="hljs-property">hello</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>内置的 Transition 组件，可用来给组件加载或卸载时提供动画效果；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;show =!show&quot;</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Transition</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Transition</span>&gt;</span><br></code></pre></td></tr></table></figure><p>动画效果可以自定义，并且可以命名，以方便管理多种不同的动画效果；</p><p>TransitionGroup 可用来设置列表的动画，当列表添加或删除元素时，呈现动画效果；</p><h3 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h3><p>KeepAlive 可用来缓存实例</p><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p>Teleport 有点像是一个传送门，用来将组件中的部分模板，传送到外部组件上面；之所以这么做，是为了能够更好的展示传送的内容，避免受到深层嵌套过程中的其他组件的布局影响；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;open = true&quot;</span>&gt;</span>Open Modal<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;open&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;model&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello from the modal<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;open = false&quot;</span>&gt;</span>Close<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Teleport</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Teleport 会改变 DOM 的层级关系，但不会改组件之间的层级关系；</p><h3 id="Suspence"><a href="#Suspence" class="headerlink" title="Suspence"></a>Suspence</h3><p>在某个组件内部存在多个异步组件时，有可能这些异步组件都有自己的异步处理机制，例如显示加载图标。当这些子组件同时加载时，会导致页面上出现多个异步图标。Suspence 的目标是对这些异步状态统一管理，展示统一的加载状态；</p><h2 id="应用规模化"><a href="#应用规模化" class="headerlink" title="应用规模化"></a>应用规模化</h2><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><p>一个 Vue 文件同时包含 js、html 和  css 三部分内容，即同时包含逻辑、模板和样式数据；</p><p>单文件组件是一种代码的组织方式，如果需要实现的功能非常小，例如只是给静态文件添加一些简单的交互，则可以考虑使用 petite-vue，只有 6k 大小；</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>非常简单的页面，可用 computed 配合监听浏览器的 haschange 来切面页面；它的原理很简单，即 js 代码调用浏览器的接口，更新了 url，触发了 haschange 事件，从而调用监听函数，完成组件的更新，实现页面的切换；</p><p>正式的路由器则使用  Vue Router</p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>如果多个组件依赖同一份数据，那么使用 props 逐级透传的方式，会让代码变得臃肿。解决办法是将数据封装成一个全局的单例，供各个组件使用；</p><p>其中一个方案是使用 reactive、ref、computed 或者组合式函数，创建一个响应式对象，放在单独的文件中，供各个组件引用；</p><p>如果应用使用服务器渲染，则以上方案变得不太可行；此时需要使用单独的状态管理器，例如 Pinia 或者 Vuex；</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>需要测试的东西：</p><ul><li>单元测试：确保函数正常</li><li>组件测试：确保 component 的功能正常</li><li>端到端测试：类似于集合测试，确保整个应用正常运行；常用框架：Cypress，Playwright，Nightwatch 等；</li></ul><p>其中端到端是最重要的，因为它确保了应用程序的运行正常；</p><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>有两种场景需要用到服务端渲染 SSR：</p><ul><li>SEO 非常重要；</li><li>首页加载速度非常重要；</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="生产部署"><a href="#生产部署" class="headerlink" title="生产部署"></a>生产部署</h3><p>在生产服务器部署，那些提高开发效率的工具就不需要了，因此记得在打包代码是地，排除它们，以缩小文件的体积；</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>Vue 本身包含了优化功能，在绝大部分场景下，vue 的性能都是够用的，除非遇到一些极端的场景，才需要手动优化；</p><p>两个常见的优化指标：</p><ul><li>页面加载速度</li><li>页面更新速度</li></ul><h4 id="页面加载优化"><a href="#页面加载优化" class="headerlink" title="页面加载优化"></a>页面加载优化</h4><p>常用的手段包括：</p><ul><li>服务端渲染</li><li>减小包体积：例如构建工具使用 Tree Shaking，预编译等，避免引入太大的依赖；</li><li>代码分割：实现懒加载；</li></ul><h4 id="页面更新优化"><a href="#页面更新优化" class="headerlink" title="页面更新优化"></a>页面更新优化</h4><p>当 props 变更时，会触发组件的更新，因此，在设计组件时，应该确保它的 props 值尽量稳定，以减少不必要的更新触发；</p><p>v-once 指令可用来标识无需更新的组件，这样进行更新计算时，会跳过该组件；</p><p>v-memo 指令可用来设置更新的条件；</p><p>computed 的计算结果如果发生变化，也会触发更新。 如果是值还好说，可直接比较；如果比较的是对象，那么即使值没有变化，也会触发更新；此时可考虑引入自定义的比较函数；</p><h4 id="通用优化"><a href="#通用优化" class="headerlink" title="通用优化"></a>通用优化</h4><ul><li>大型列表的虚拟化；</li><li>绕开深层级对象的深度检查；</li><li>在大型列表中，减少不必要的组件抽象；</li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="使用-Vue-的多种方式"><a href="#使用-Vue-的多种方式" class="headerlink" title="使用 Vue 的多种方式"></a>使用 Vue 的多种方式</h3><ul><li>独立脚本，像引入 jQuery 一样轻量化使用；</li><li>作为 Web Component 嵌入原有的旧应用；</li><li>单页面应用：主流用法；</li><li>全栈 &#x2F; SSR：适用于 SEO 很重要的场景；</li><li>静态 SSG：静态站点生成 JAMStack，作用静态文件部署；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;app.use()&lt;/p&gt;
&lt;p&gt;注册插件，有点像 Express 中的 use；所谓的插件，即具备某些功能的一段代码，这段代码用于添加全局</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue Router 基本用法</title>
    <link href="http://example.com/2023/08/18/Vue%20Router%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2023/08/18/Vue%20Router%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</id>
    <published>2023-08-18T12:26:00.000Z</published>
    <updated>2024-09-21T23:19:05.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>路由的目的是建立 url 和组件之间的映射关系；当 url 发生变化时，组件也随之更新；</p><h3 id="创建路由器实例"><a href="#创建路由器实例" class="headerlink" title="创建路由器实例"></a>创建路由器实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createMemoryHistory, createRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">HomeView</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./HomeView.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AboutView</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AboutView.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> routes = [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Homeview</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">AboutView</span> &#125;,<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createMemoryHistory</span>(),<br>    routes,<br>&#125;)<br></code></pre></td></tr></table></figure><p>history 用来记录 url 和路由的双向映射，这里用的是 createMemoryHistory，它会抛开浏览器的 url，完全自我管理；</p><p>如果想要跟浏览器的 url 保持关系，则可使用 createWebHistory 或者 createWebhashHistory；</p><h3 id="注册路由器插件"><a href="#注册路由器插件" class="headerlink" title="注册路由器插件"></a>注册路由器插件</h3><p>创建好路由器实例化，可以用 app.use(router) 将其注册为插件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>();<br>app.<span class="hljs-title function_">use</span>(router);<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br></code></pre></td></tr></table></figure><p>注册该插件后，会完成以下几项工作：</p><ul><li>注册需要的组件，如 RouterLink 和 RouterView</li><li>添加全局属性，如 $router 和 $route</li><li>添加全局组合式函数 useRouter 和 useRoute</li><li>解析初始路由</li></ul><h3 id="访问路由器和当前路由"><a href="#访问路由器和当前路由" class="headerlink" title="访问路由器和当前路由"></a>访问路由器和当前路由</h3><p>在组合式 API 中，可使用 useRouter 和 useRoute 来访问路由器和当前路由；</p><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>动态匹配：用于将多个路径匹配到同一个组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./User.vue&quot;</span><br><br><span class="hljs-keyword">const</span> routers = &#123;<br>    <span class="hljs-comment">// 动态参数使用冒号 : 来标识</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/users/:id&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span> &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>可在模板中使用 $route 或者 useRoute 来访问当前路径的参数，例如 $route.params.id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>        User &#123;&#123; $route.params.id &#125;&#125;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>路由支持多个参数，例如 &#x2F;users&#x2F;:name&#x2F;posts&#x2F;:postId</p><h3 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h3><p>当路由参数出现变化时，为提高性能，避免重新渲染，会直接复用原先的组件。这意味着组件不会重新创建，因此跟创建有关的 hook 函数例如 onMount 也不会重新执行；</p><p>可使用 watch 或者 onBeforeRouteUpdated 来监听变化，并执行相关的操作；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; watch &#125; from &#x27;vue&#x27;<br>    import &#123; useRoute &#125; from &#x27;vue-router&#x27;<br>    <br>    const route = useRoute()<br>    <br>    watch(() =&gt; route.params.id, (newId, oldId) =&gt; &#123;...&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; onBeforeRouteUpdated &#125; from &#x27;vue-router&#x27;<br>    <br>    onBeforeRouteUpdated(async(to, from) =&gt; &#123;<br>        userData.value = await fetchUser(to.params.id);<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="捕获所有路由"><a href="#捕获所有路由" class="headerlink" title="捕获所有路由"></a>捕获所有路由</h3><p>通过路径参数的正则表达式，可以匹配任意的路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:pathMatch(.*)*&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;NotFound&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">NotFound</span>&#125;,<br>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user-:afteruser(.*)&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserGeneric</span> &#125;,<br>]<br></code></pre></td></tr></table></figure><h2 id="路由的匹配语法"><a href="#路由的匹配语法" class="headerlink" title="路由的匹配语法"></a>路由的匹配语法</h2><h3 id="在参数中自定义正则"><a href="#在参数中自定义正则" class="headerlink" title="在参数中自定义正则"></a>在参数中自定义正则</h3><p>当两个路径的前缀相同，只是参数的类型不同时，可使用正则来区分它们；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    <span class="hljs-comment">// 仅匹配数字</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:orderId(\\d+)&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:productName&#x27;</span> &#125;<br>]<br></code></pre></td></tr></table></figure><p>但我个人觉得更好的做法是修改前缀，这样更简单清晰</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/order/:orderId&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product/:name&#x27;</span> &#125;,<br>]<br></code></pre></td></tr></table></figure><h3 id="可重复的参数"><a href="#可重复的参数" class="headerlink" title="可重复的参数"></a>可重复的参数</h3><p>星号 * 表示 0 个或多个</p><p>加号 + 表示 1 个或多个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    <span class="hljs-comment">// 匹配 /one, /one/two,  /one/two/three</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:chapters+&#x27;</span> &#125;,<br>    <span class="hljs-comment">// 匹配 /, /one, /one/two 等</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:chapters*&#x27;</span>&#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="Sensitive-与-Strict-路由配置"><a href="#Sensitive-与-Strict-路由配置" class="headerlink" title="Sensitive 与 Strict 路由配置"></a>Sensitive 与 Strict 路由配置</h3><p>默认情况下，路由是不区分大小写的，如需要区分，可添加 sensitive: true 和 strict: true 选项</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>修饰符 ? 可用来标记可选参数，即 0 个或者 1 个；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    <span class="hljs-comment">// 匹配 /users 和 /users/abc</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:userId?&#x27;</span> &#125;,<br>    <span class="hljs-comment">// 匹配 /users 和 /users/123</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:userId(\\d+)&#x27;</span> &#125;<br>]<br></code></pre></td></tr></table></figure><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>组件通常是嵌套的，这种嵌套关系也可以反映在 URL 上面。此时，可在路由中配置 children 子路由来标记这种嵌套关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:userId&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>,<br>        <span class="hljs-attr">children</span>: [<br>            &#123;<br>                <span class="hljs-comment">// 匹配 /user/:id/profile</span><br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,<br>                <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserProfile</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">// 匹配 /user/:id/posts</span><br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;posts&quot;</span>,<br>                <span class="hljs-attr">component</span>: <span class="hljs-string">&quot;UserPosts&quot;</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">// 匹配 /user/:id</span><br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserHome</span><br>            &#125;<br>        ]<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>路由支持命名，只需将名称备注在 name 字段中即可；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user/:username&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>该名称可用于 router-link 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link :to=&quot;&#123; name: &#x27;profile&#x27; params: &#123; username: &#x27;erina&#x27; &#125; &#125;&quot;&gt;&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><p>建议使用命名路由，一来这样更方便维护，避免后续因为更改路径，导致很多地方需要跟着改动；二来好的名称也比路径也更容易理解；</p><blockquote><p>路由的命名需要全局唯一，不然会出现冲突；</p></blockquote><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><h3 id="导航到不同的位置"><a href="#导航到不同的位置" class="headerlink" title="导航到不同的位置"></a>导航到不同的位置</h3><p>router.push(…) 会跳转到新的页面，它同时会向页面 history 的栈中添加记录，这样当用户点击浏览器上面的按钮时，就会返回上一页；</p><p>点击 router-link 组件也会有相同的效果；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link :to=&quot;...&quot;&gt;&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><p>router.push 可以支持很多种格式，其参数可以是简单的 url，也可以是一个对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 字符串路径</span><br>router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/users/eduardo&#x27;</span>)<br><br><span class="hljs-comment">// 带有路径的对象</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/eduardo&#x27;</span> &#125;)<br><br><span class="hljs-comment">// 命名的路由，并加上参数，让路由建立 url</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;eduardo&#x27;</span> &#125; &#125;)<br><br><span class="hljs-comment">// 带查询参数，结果是 /register?plan=private</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125; &#125;)<br><br><span class="hljs-comment">// 带 hash，结果是 /about#team</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">hash</span>: <span class="hljs-string">&#x27;#team&#x27;</span> &#125;)<br></code></pre></td></tr></table></figure><h3 id="替换当前位置"><a href="#替换当前位置" class="headerlink" title="替换当前位置"></a>替换当前位置</h3><p>router.replace 会跳转新页面，作用与 router.push 相同，区别是直接替换当前路由在 history 中的位置，而不是 push；</p><h3 id="横跨历史"><a href="#横跨历史" class="headerlink" title="横跨历史"></a>横跨历史</h3><p>在 history 栈中进行跳转，类似 window.history.go(n)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">go</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 前进1页，与 router.forward 作用相同</span><br>router.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// 后退1页，与 router.back 作用相同</span><br>router.<span class="hljs-title function_">go</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 前进3页</span><br>router.<span class="hljs-title function_">go</span>(-<span class="hljs-number">3</span>) <span class="hljs-comment">// 后退3页</span><br></code></pre></td></tr></table></figure><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>给视图进行命名，可以让它们同时同级展示，而不是嵌套展示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-view name=&quot;leftSidebar&quot; /&gt;<br>&lt;router-view /&gt; &lt;!-- 没有名称，默认为 default --&gt;<br>&lt;router-view name=&quot;rightSidebar&quot; /&gt;<br></code></pre></td></tr></table></figure><p>当页面上存在多个视图时，需要给各视图映射相应的组件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = (&#123;<br>    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(),<br>    <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>            <span class="hljs-attr">components</span>: &#123;<br>                <span class="hljs-attr">default</span>: <span class="hljs-title class_">Home</span>,<br>                <span class="hljs-attr">leftSidebar</span>: <span class="hljs-title class_">LeftSidebar</span>,<br>                <span class="hljs-attr">rightSidebar</span>: <span class="hljs-title class_">RightSidebar</span>,<br>            &#125;<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>命名视图也是支持嵌套滴；</p><h2 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重写向：点击 A 路径，重定向跳转到 B 路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可以是 url</span><br><span class="hljs-keyword">const</span> routes = [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/&quot;</span> &#125;]<br><br><span class="hljs-comment">// 或者一个对象</span><br><span class="hljs-keyword">const</span> routes = [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>, <span class="hljs-attr">redirect</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;homepage&quot;</span> &#125; &#125;<br>]<br><br><span class="hljs-comment">// 或者一个函数</span><br><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/search/:searchText&#x27;</span>,<br>        <span class="hljs-attr">redirect</span>: <span class="hljs-function"><span class="hljs-params">to</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/search&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">q</span>: to.<span class="hljs-property">params</span>.<span class="hljs-property">searchText</span> &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="相对重定向"><a href="#相对重定向" class="headerlink" title="相对重定向"></a>相对重定向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:userId/posts&#x27;</span>,<br>        <span class="hljs-attr">redirect</span>: <span class="hljs-function"><span class="hljs-params">to</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;profile&#x27;</span>  <span class="hljs-comment">// 实际结果为 /users/:userId/profile</span><br>        &#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>通过别名，可将任意指定的 url 匹配到相应的组件，而不会受到嵌套结构的限制；</p><h2 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h2><p>如果在组件中读取 $route 的参数，那么意味着使用该组件，将会与 url 强绑定；组件的复用范围受到了很大的限制；解决方法就是不使用 $route，而是给组件传递参数；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 传统的写法，组件与url紧密耦合 --&gt;<br>&lt;template&gt;<br>&lt;div&gt;<br>        User &#123;&#123; $route.params.id&#125;&#125;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 新的写法, id 引用 props，由外部传入，而不是读取路由 --&gt;<br>&lt;script setup&gt;<br>defineProps(&#123;<br>    id: String, // 声明 props 参数<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>&lt;div&gt;<br>        User &#123;&#123; id &#125;&#125;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在路由配置中，通过 props:true 选项将 params 声明为 props</span><br><span class="hljs-keyword">const</span> routes = [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user/:id&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>, <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span> &#125;<br>]<br></code></pre></td></tr></table></figure><p>如果路由映射了多个命名视图，那么需要为每个视图单独备注是否启用 props</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user/:id&quot;</span>,<br>        <span class="hljs-attr">components</span>: &#123; <span class="hljs-attr">default</span>: <span class="hljs-title class_">User</span>, <span class="hljs-attr">sidebar</span>: <span class="hljs-title class_">Sidebar</span> &#125;,<br>        <span class="hljs-attr">props</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用</span><br>            <span class="hljs-attr">sidebar</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 不启用</span><br>        &#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>另外 props 还支持对象或函数类型；</p><h2 id="匹配当前路由的链接"><a href="#匹配当前路由的链接" class="headerlink" title="匹配当前路由的链接"></a>匹配当前路由的链接</h2><p>有时候多个 router-link 在页面上面会以列表的形式出现，此时经常用不同的颜色，来标识当前激活的 link；</p><p>此时需要有一个方法来判断当前处于激活状态的是哪个链接；</p><h2 id="不同的历史记录模式"><a href="#不同的历史记录模式" class="headerlink" title="不同的历史记录模式"></a>不同的历史记录模式</h2><p>有三种历史模式</p><ul><li>Hash 模式：会在 URL 上面添加 # 符号，好处是用户重新刷新页面也不要紧，能够正常处理；</li><li>HTML 模式：URL 跟普通网页的 URL 一模一样，缺点当用户刷新时，会向服务器发送页面请求，需要服务器有相应的处理，不然会出现  404</li><li>Memory 模式：URL 只保存在内存，不在浏览器的 URL 上面体现，缺点是无法使用浏览器的前进和后退，因为没有页面栈；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h2&gt;&lt;p&gt;路由的</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件权限</title>
    <link href="http://example.com/2023/08/04/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <id>http://example.com/2023/08/04/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</id>
    <published>2023-08-04T02:09:00.000Z</published>
    <updated>2024-09-21T23:16:23.254Z</updated>
    
    <content type="html"><![CDATA[<p>drwxrwxrwx</p><ul><li>d 表示目录</li><li>剩下的三组 rwx 分别表示拥有者、拥有者用户组、其他用户对当前文件夹的权限情况</li></ul><p>添加权限使用加号 +</p><p>减少权限使用减号 -</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> g+rwx,u+w,o+x  &lt;file&gt;<br><span class="hljs-comment"># 以上命令的意思是</span><br><span class="hljs-comment"># g+rwx，为用户组增加 rwx 权限</span><br><span class="hljs-comment"># u+w，为用户增加 w 权限</span><br><span class="hljs-comment"># o+x，为其他用户增加 x 权限</span><br><br><span class="hljs-built_in">chmod</span> a-rwx &lt;file&gt;<br><span class="hljs-comment"># a 表示所有三个分组（即拥有者、用户组、其他用户），都取消 rwx 权限</span><br></code></pre></td></tr></table></figure><p>rwx 除了用字母外，也可以用数字来表示，rwx 对应的数字分别是 4、2、1</p><p>rwxrwxrwx 可以用 777 来表示，因为 rwx 三个数字相加，刚好等于 7，有三组的 rwx，因此有 3 个 7</p><p>rwx—— 可以用 700 来表示</p><p>r—w—x 可以用 421 来表示</p><p>rw-rw-r-x 可以用 665 来表示</p><p>本质上来说，数字只是对字母的一种缩写，一种快捷方式，但它也增加了理解的成本；</p><p>如果要将 chmod 运用于所用子目录，可以添加 -R 参数，示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> -R 777 &lt;file&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;drwxrwxrwx&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;d 表示目录&lt;/li&gt;
&lt;li&gt;剩下的三组 rwx 分别表示拥有者、拥有者用户组、其他用户对当前文件夹的权限情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;添加权限使用加号 +&lt;/p&gt;
&lt;p&gt;减少权限使用减号 -&lt;/p&gt;
&lt;figure c</summary>
      
    
    
    
    <category term="文章" scheme="http://example.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="服务器" scheme="http://example.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Paperjs</title>
    <link href="http://example.com/2023/07/30/Paperjs/"/>
    <id>http://example.com/2023/07/30/Paperjs/</id>
    <published>2023-07-30T03:49:00.000Z</published>
    <updated>2024-09-21T23:17:55.624Z</updated>
    
    <content type="html"><![CDATA[<p>Paperjs 是一个较流行的 canvas 接口封装库，可以很方便的用来实现绘图功能，基本概念如下：</p><h1 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h1><h2 id="Point-Size-Rectangle"><a href="#Point-Size-Rectangle" class="headerlink" title="Point, Size, Rectangle"></a>Point, Size, Rectangle</h2><p>Point：点，本质上是点的属性描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myPt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)  <span class="hljs-comment">// 10,20 分别表示 x,y 坐标</span><br><span class="hljs-comment">// 除了用 X,Y 参数实例化一个点之外，还可以通过传入其他点作为参数来实例化（本质上是复制，彼此后续的改变是独立的，不会相互影响）</span><br><span class="hljs-comment">// 另外也可以调用旧点的 clone() 方法来实现复制</span><br></code></pre></td></tr></table></figure><p>Size：尺寸，用来表示宽度和高度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mySize = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 表示宽度 width 为 10, 高度 height 为 20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySize); <span class="hljs-comment">// &#123; width: 0, height: 0 &#125;</span><br></code></pre></td></tr></table></figure><p>Rectangle：矩形，有多种实例化的方法（这些方法让我发现，其背后的实现原理很可能是使用数组来存储参数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myPt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">var</span> mySz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br><span class="hljs-keyword">var</span> myRect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(myPt, mySz);<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">var</span> myRect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">var</span> myRect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();<br>myRect.<span class="hljs-property">point</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>myRect.<span class="hljs-property">size</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>矢量是一个非常好用的东西，原因：</p><ul><li>它不表示绝对坐标值，而是表示从起点到终点的相对坐标值；</li><li>相对坐标的特性，让矢量可以很方便用来做各种计算；</li></ul><p>两个矢量可以相加，也可以相减，在几何层面，它们其实仅是方向的区别；</p><p>矢量与整数的乘法或除法，也很简单，即相对坐标放大或缩小指定的整数倍数，或者也可以理解为在极坐标中，不改变角度，仅改变矢量长度；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> newVec = oldVec * <span class="hljs-number">3</span> <span class="hljs-comment">// 整数必须写在右边，因为 javascript 解释器默认取左边变量的类型作为计算结果的类型</span><br></code></pre></td></tr></table></figure><p>除了乘法外，也可以通过改变矢量的 length，实现相同的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> newVec = oldVec * <span class="hljs-number">3</span><br><br><span class="hljs-comment">// 跟下面的算法等价</span><br>newVec.<span class="hljs-property">length</span> = oldVec.<span class="hljs-property">length</span> * <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>矢量拥有角度 angle 属性，可以直接赋值，也可以对其进行计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> vec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vec.<span class="hljs-property">angle</span>); <span class="hljs-comment">// 45</span><br><br><span class="hljs-comment">// 直接赋值</span><br>vec.<span class="hljs-property">angle</span> = <span class="hljs-number">135</span>;<br><span class="hljs-comment">// 或者</span><br>vec.<span class="hljs-property">angle</span> = vec.<span class="hljs-property">angle</span> + <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><p>加减乘除、旋转等计算并不会改变旧的 vector 属性，而是会直接返回一个新的 vector；但当我们直接修改 vector 的属性时，则会改变 vector 的属性值；</p><h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br><br><span class="hljs-comment">// 顺序添加新的点</span><br>myPath.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)); <br>myPath.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>));<br><br><span class="hljs-comment">// 支持一次添加多个点，只需传入多个参数即可</span><br>myPath.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>)); <br><br><span class="hljs-comment">// 支持在现有点之间插入新点</span><br>myPath.<span class="hljs-title function_">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">30</span>, <span class="hljs-number">50</span>));<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// path 有一个 smooth 方法，可以用来将直线转成曲线</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>path.<span class="hljs-property">strokeColor</span> = <span class="hljs-string">&quot;black&quot;</span>;<br>path.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">30</span>, <span class="hljs-number">75</span>));<br>path.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">30</span>, <span class="hljs-number">25</span>));<br>path.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">80</span>, <span class="hljs-number">25</span>));<br>path.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">80</span>, <span class="hljs-number">75</span>));<br>path.<span class="hljs-property">closed</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// path 默认是 open 状态，设置为 true 实现闭合</span><br><br>path.<span class="hljs-property">fullySelected</span> = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">var</span> copy = path.<span class="hljs-title function_">clone</span>();<br>copy.<span class="hljs-property">fullySelected</span> = <span class="hljs-literal">true</span>;<br>copy.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> += <span class="hljs-number">100</span>;<br><br>copy.<span class="hljs-title function_">smooth</span>();<br>    <br><span class="hljs-comment">// 自带的 remove 方法可以用来彻底删除对象</span><br>copy.<span class="hljs-title function_">remove</span>();<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061118634.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建 path 类型的圆</span><br><span class="hljs-keyword">var</span> circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Circle</span>(center_point, radius);<br><br><span class="hljs-comment">// 创建 path 类型的矩形</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Rectangle</span>(point, size);<br><span class="hljs-comment">// 也可以传入 Rectangle 矩形作为实例化的参数</span><br><span class="hljs-keyword">var</span> rect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>));<br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Rectangle</span>(rect);<br><br><span class="hljs-comment">// 创建圆角矩形</span><br><span class="hljs-keyword">var</span> radius = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Rectangle</span>(rect, radius);<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061147756.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建正多边形，例如正三角形，正十边形等</span><br><span class="hljs-comment">// new Path.RegularPolygon(center, sides, radius)</span><br><span class="hljs-keyword">var</span> triangle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">RegularPolygon</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">80</span>, <span class="hljs-number">70</span>), <span class="hljs-number">3</span>, <span class="hljs-number">50</span>);<br><span class="hljs-keyword">var</span> decagon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">RegularPolygon</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">200</span>, <span class="hljs-number">70</span>), <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20230706115151.png"></p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个打勾符号</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(&#123;<br>    <span class="hljs-attr">segments</span>: [[<span class="hljs-number">40</span>, <span class="hljs-number">115</span>], [<span class="hljs-number">80</span>, <span class="hljs-number">180</span>], [<span class="hljs-number">200</span>, <span class="hljs-number">20</span>]],<br>    <span class="hljs-attr">selected</span>: <span class="hljs-literal">true</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20230706115415.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接赋值，改成红色</span><br>path.<span class="hljs-property">strokeColor</span> = <span class="hljs-string">&quot;#ff0000&quot;</span>;<br><span class="hljs-comment">// 或者使用 color 对象赋值</span><br>path.<span class="hljs-property">strokeColor</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061157326.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 填充颜色</span><br>path.<span class="hljs-property">fillColor</span> = <span class="hljs-string">&quot;#ff0000&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061159060.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置线段粗细</span><br>path.<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061200049.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// path 两端样式</span><br>path.<span class="hljs-property">storkeCap</span> = <span class="hljs-string">&quot;round&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061201130.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 中间点的样式设置为圆角</span><br>path.<span class="hljs-property">strokeJoin</span> = <span class="hljs-string">&quot;round&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061202130.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 虚线</span><br>path.<span class="hljs-property">dashArray</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>];<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061203136.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// path 的所有相关样式都存在 style 属性中，用该字段对其他 path 进行赋值，可实现样式的复制</span><br><span class="hljs-keyword">var</span> firstPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Circle</span>(&#123;<br><span class="hljs-attr">center</span>: [<span class="hljs-number">80</span>, <span class="hljs-number">50</span>],<br><span class="hljs-attr">radius</span>: <span class="hljs-number">35</span><br>&#125;);<br><br>firstPath.<span class="hljs-property">strokeColor</span> = <span class="hljs-string">&#x27;#ff0000&#x27;</span>;<br>firstPath.<span class="hljs-property">fillColor</span> = <span class="hljs-string">&#x27;blue&#x27;</span>;<br><br><span class="hljs-comment">// secondPath doesn&#x27;t have a strokeColor yet:</span><br><span class="hljs-keyword">var</span> secondPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Circle</span>(&#123;<br><span class="hljs-attr">center</span>: [<span class="hljs-number">160</span>, <span class="hljs-number">50</span>],<br><span class="hljs-attr">radius</span>: <span class="hljs-number">35</span><br>&#125;);<br><br><span class="hljs-comment">// Apply the style of firstPath to that of secondPath:</span><br>secondPath.<span class="hljs-property">style</span> = firstPath.<span class="hljs-property">style</span>;<br><br><span class="hljs-comment">// style 也可以单独实例化，之后再赋值</span><br><span class="hljs-keyword">var</span> newStyle = &#123;<br>    <span class="hljs-attr">strokeColor</span>: <span class="hljs-string">&quot;#ff0000&quot;</span>,<br>    <span class="hljs-attr">fillColor</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-number">10</span>,<br>&#125;<br>path.<span class="hljs-property">style</span> = newStyle;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 删除某个样式，只需将该样式的属性值设置为 null 即可</span><br>path.<span class="hljs-property">fillColor</span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 如果要删除所有新式，则只需将整个 style 属性设置为 null 即可</span><br>path.<span class="hljs-property">style</span> = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 样式可以继承</span><br>project.<span class="hljs-property">currentStyle</span> = &#123;<br>    <span class="hljs-attr">strokeColor</span>: <span class="hljs-string">&quot;#000000&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 新建的 path 会自动继承 project 的样式</span><br><span class="hljs-keyword">var</span> firstPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title function_">circle</span>(&#123;<br>    <span class="hljs-attr">center</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>],<br>    <span class="hljs-attr">radius</span>: <span class="hljs-number">50</span>,<br>&#125;);<br><br><br><span class="hljs-comment">// 当 project 的样式更新后，后续新创建的 path 会继承新样式</span><br>project.<span class="hljs-property">currentStyle</span>.<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">8</span>;<br>project.<span class="hljs-property">currentStyle</span>.<span class="hljs-property">fillColor</span> = <span class="hljs-string">&#x27;green&#x27;</span>;<br><br><span class="hljs-keyword">var</span> secondPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Circle</span>(&#123;<br>    <span class="hljs-attr">center</span>: [<span class="hljs-number">250</span>, <span class="hljs-number">100</span>],<br>    <span class="hljs-attr">radius</span>: <span class="hljs-number">50</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061305415.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// path.simplify() 方法可用来简化组成 path 的 segment 数量，以便减少内存占用，提高性能</span><br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061415995.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// path.flatten(error) 方法可用来将曲线转成多段直线</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Circle</span>(&#123;<br><span class="hljs-attr">center</span>: [<span class="hljs-number">80</span>, <span class="hljs-number">50</span>],<br><span class="hljs-attr">radius</span>: <span class="hljs-number">35</span><br>&#125;);<br><br><span class="hljs-comment">// Select the path, so we can inspect its segments:</span><br>path.<span class="hljs-property">selected</span> = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// Create a copy of the path and move it by 150 points:</span><br><span class="hljs-keyword">var</span> copy = path.<span class="hljs-title function_">clone</span>();<br>copy.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> += <span class="hljs-number">150</span>;<br><br><span class="hljs-comment">// Flatten the copied path, with a maximum error of 4 points:</span><br>copy.<span class="hljs-title function_">flatten</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061418054.png"></p><h1 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h1><p>有三个全局的鼠标事件，可以对鼠标操作进行响应，它们分别是</p><ul><li>onMouseDown</li><li>onMouseDrag</li><li>onMouse</li></ul><p>鼠标事件的属性：</p><ul><li>point：当前鼠标位置</li><li>downPoint：鼠标被按下时所在位置</li><li>lastPoint：上一次鼠标事件的位置</li><li>middlePoint：当前位置和上次位置的中点</li><li>delta：当前位置和上次位置的矢量 vector（up 事件该值为按下和松开两个位置的矢量）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 每次按下鼠标时，就给路径添加一个新的点</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>path.<span class="hljs-property">strokeColor</span> = <span class="hljs-string">&quot;black&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">onMouseDown</span>(<span class="hljs-params">e</span>) &#123;<br>    path.<span class="hljs-title function_">add</span>(e.<span class="hljs-property">point</span>);<br>&#125;<br><br><span class="hljs-comment">// 通过设置全局变量 tool，可控制鼠标的移动距离（最大、最小、固定距离等）</span><br>tool.<span class="hljs-property">minDistance</span> = <span class="hljs-number">20</span>;<br>tool.<span class="hljs-property">maxDistance</span> = <span class="hljs-number">20</span>;<br>tool.<span class="hljs-property">fixedDistance</span> = <span class="hljs-number">30</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Paperjs 是一个较流行的 canvas 接口封装库，可以很方便的用来实现绘图功能，基本概念如下：&lt;/p&gt;
&lt;h1 id=&quot;Geometry&quot;&gt;&lt;a href=&quot;#Geometry&quot; class=&quot;headerlink&quot; title=&quot;Geometry&quot;&gt;&lt;/a&gt;Geo</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes mongodb operator</title>
    <link href="http://example.com/2023/06/05/kubernetes%20mongodb%20operator/"/>
    <id>http://example.com/2023/06/05/kubernetes%20mongodb%20operator/</id>
    <published>2023-06-05T00:21:00.000Z</published>
    <updated>2024-09-21T23:16:14.422Z</updated>
    
    <content type="html"><![CDATA[<p>早先在 Kubernetes 中管理 MongoDB statefulset 集群使用 sidecar 的方式，后续官方推出了 kubernetes mongodb operator，变得更加方便了，再也不需要额外的 sidecar pod 来监控数据库的状态了；</p><h2 id="下载相关文件"><a href="#下载相关文件" class="headerlink" title="下载相关文件"></a>下载相关文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/mongodb/mongodb-kubernetes-operator.git<br></code></pre></td></tr></table></figure><h2 id="创建资源定义"><a href="#创建资源定义" class="headerlink" title="创建资源定义"></a>创建资源定义</h2><p>创建</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f config/crd/bases/mongodbcommunity.mongodb.com_mongodbcommunity.yaml<br></code></pre></td></tr></table></figure><p>检查是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get crd/mongodbcommunity.mongodbcommunity.mongodb.com<br></code></pre></td></tr></table></figure><h2 id="创建角色资源"><a href="#创建角色资源" class="headerlink" title="创建角色资源"></a>创建角色资源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -k config/rbac/ --namespace &lt;my-namespace&gt;<br></code></pre></td></tr></table></figure><p>检查是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get role mongodb-kubernetes-operator --namespace &lt;my-namespace&gt;<br><br>kubectl get rolebinding mongodb-kubernetes-operator --namespace &lt;my-namespace&gt;<br><br>kubectl get serviceaccount mongodb-kubernetes-operator --namespace &lt;my-namespace&gt;<br></code></pre></td></tr></table></figure><h2 id="创建-operator"><a href="#创建-operator" class="headerlink" title="创建 operator"></a>创建 operator</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl create -f config/manager/manager.yaml --namespace &lt;my-namespace&gt;<br></code></pre></td></tr></table></figure><p>检查是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get pods --namespace &lt;my-namespace&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;早先在 Kubernetes 中管理 MongoDB statefulset 集群使用 sidecar 的方式，后续官方推出了 kubernetes mongodb operator，变得更加方便了，再也不需要额外的 sidecar pod 来监控数据库的状态了；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="kubernetes" scheme="http://example.com/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Python import 用法</title>
    <link href="http://example.com/2022/03/13/Python%20import%20%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2022/03/13/Python%20import%20%E7%94%A8%E6%B3%95/</id>
    <published>2022-03-13T07:05:00.000Z</published>
    <updated>2024-09-21T23:18:26.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常规导入"><a href="#常规导入" class="headerlink" title="常规导入"></a>常规导入</h1><h2 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块 Modules"></a>模块 Modules</h2><p>一个 py 文件即相当于一个模块 Module；它可以被其他 py 导入，以便复用其中的代码；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br>math.pi()<br></code></pre></td></tr></table></figure><p>被导入的 py 文件，同时充当了一个命名空间（Namespace），可通过该命名空间访问其内部的变量和函数；</p><p>当使用 from  A import B 时，就把 B 导入到全局命名空间中了，这个时候并没有导入 A；而且导入时 B 还可以重命名 B，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> pi <span class="hljs-keyword">as</span> PI<br></code></pre></td></tr></table></figure><h2 id="包-Packages"><a href="#包-Packages" class="headerlink" title="包 Packages"></a>包 Packages</h2><p>Pacage 也是一个模块，它跟普通模块的区别在于它内部包含了其他模块或者其他 Package</p><blockquote><p>Python 官方文档对 Package 的解释为，当一个模块的内置 path 属性有值时，即是一个 Package；个人感觉包和模块很像目录和文件的关系；</p></blockquote><p>实际使用中，Package 通常是一个包含 py 文件和子目录的文件夹；当给某个文件夹中添加一个 init 文件时，它就变成了一个 pakcage；init 文件中可以放置内容，它表示当 package 被作为模块导入时，该模块包含的内容；它可以为空；</p><blockquote><p>当一个文件夹没有 init 文件时，它仍然会被 Python 解释器视作一个 Package，只是它不是普通的 Package，而是一个特殊的 package，称为命名空间 Package；</p></blockquote><p>通常在导入一个包时，并不导入它里面的子模块和子包。</p><blockquote><p>发现一个有意思的点，当使用 from A import B 时，虽然 A 没有导入进来，但是 B 和 A 的上下级关系是存在的。因此如果有另外一行代表导入了 A，那么即使 A 的 init 文件中没有导入 B，也仍然可以通过 A.B 来访问 B；</p><p>使用 import A.B.C 来导入时，A.B. 表示的是路径关系好像；而且一旦导入成功，B 和 C 的上下级关系就建立了；即使 B 的 init 文件中原本默认没有导入 C，也因为这种关系的建立，使得 B.C 的访问能够成功；</p></blockquote><p>当一个包中的 init 文件为空时，那么导入这个包时，只导入了一个命名空间，并未导入任何具体的模块；</p><blockquote><p>注意：当导入一个模块时，除了会导入模块中的内容外，还会同时创建一个包含该内容的命名空间；当使用不同的导入方法时，同一个模块可以隶属于不同的命名空间；即可以通过多个命名空间访问到相同的模块；</p></blockquote><p>模块本质上面是一个对象，因此可以通过对象的内置方法来访问来模块中的内容，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br>math.__dict__[<span class="hljs-string">&#x27;pi&#x27;</span>]<br></code></pre></td></tr></table></figure><p>在 init 文件中导入包中的模块，可以让包的使用者更方便的使用这些模块，而无须记住相应的路径</p><h2 id="绝对导入和相对导入"><a href="#绝对导入和相对导入" class="headerlink" title="绝对导入和相对导入"></a>绝对导入和相对导入</h2><p>如果代码只在本地使用，不需要共享给他人使用时，使用绝对路径导入是一个不错的方法。但是如果它成为一个包，需要被其他人复用时，那么使用绝对路径就会报错了，此时需要在包中使用相对路径。同时引用该包的人，可通过 pip 安装该包。安装后，包就会被存放在默认的 site_packages 文件夹中，这样在运行脚本时就可以被解释器找到；不然就得修改 PYTHONPATH 环境变量或者调用 sys.path 方法添加包的路径；</p><p>当解释器遇到 import 语句时，它会到三个地方寻找包，分别如下：</p><blockquote></blockquote><ul><li>当前脚本所在的目录；</li><li>环境变量 PYTHONPATH 指向的目录；</li><li>pip 存放依赖的目录；</li></ul><h2 id="安装本地包"><a href="#安装本地包" class="headerlink" title="安装本地包"></a>安装本地包</h2><p>添加配置文件 setup.py，在里面 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> shutil <span class="hljs-keyword">import</span> rmtree<br><br><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> find_packages, setup, Command<br><br><span class="hljs-comment"># Package meta-data.</span><br>NAME = <span class="hljs-string">&#x27;mypackage&#x27;</span><br>DESCRIPTION = <span class="hljs-string">&#x27;My short description for my project.&#x27;</span><br>URL = <span class="hljs-string">&#x27;https://github.com/me/myproject&#x27;</span><br>EMAIL = <span class="hljs-string">&#x27;me@example.com&#x27;</span><br>AUTHOR = <span class="hljs-string">&#x27;Awesome Soul&#x27;</span><br>REQUIRES_PYTHON = <span class="hljs-string">&#x27;&gt;=3.6.0&#x27;</span><br>VERSION = <span class="hljs-string">&#x27;0.1.0&#x27;</span><br><br><span class="hljs-comment"># What packages are required for this module to be executed?</span><br>REQUIRED = [<br>    <span class="hljs-comment"># &#x27;requests&#x27;, &#x27;maya&#x27;, &#x27;records&#x27;,</span><br>]<br><br><span class="hljs-comment"># What packages are optional?</span><br>EXTRAS = &#123;<br>    <span class="hljs-comment"># &#x27;fancy feature&#x27;: [&#x27;django&#x27;],</span><br>&#125;<br><br><span class="hljs-comment"># The rest you shouldn&#x27;t have to touch too much :)</span><br><span class="hljs-comment"># ------------------------------------------------</span><br><span class="hljs-comment"># Except, perhaps the License and Trove Classifiers!</span><br><span class="hljs-comment"># If you do change the License, remember to change the Trove Classifier for that!</span><br><br>here = os.path.abspath(os.path.dirname(__file__))<br><br><span class="hljs-comment"># Import the README and use it as the long-description.</span><br><span class="hljs-comment"># Note: this will only work if &#x27;README.md&#x27; is present in your MANIFEST.in file!</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> io.<span class="hljs-built_in">open</span>(os.path.join(here, <span class="hljs-string">&#x27;README.md&#x27;</span>), encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        long_description = <span class="hljs-string">&#x27;\n&#x27;</span> + f.read()<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    long_description = DESCRIPTION<br><br><span class="hljs-comment"># Load the package&#x27;s __version__.py module as a dictionary.</span><br>about = &#123;&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> VERSION:<br>    project_slug = NAME.lower().replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>).replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;_&quot;</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(here, project_slug, <span class="hljs-string">&#x27;__version__.py&#x27;</span>)) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-built_in">exec</span>(f.read(), about)<br><span class="hljs-keyword">else</span>:<br>    about[<span class="hljs-string">&#x27;__version__&#x27;</span>] = VERSION<br><br><span class="hljs-comment"># Where the magic happens:</span><br>setup(<br>    name=NAME,<br>    version=about[<span class="hljs-string">&#x27;__version__&#x27;</span>],<br>    description=DESCRIPTION,<br>    long_description=long_description,<br>    long_description_content_type=<span class="hljs-string">&#x27;text/markdown&#x27;</span>,<br>    author=AUTHOR,<br>    author_email=EMAIL,<br>    python_requires=REQUIRES_PYTHON,<br>    url=URL,<br>    packages=find_packages(exclude=[<span class="hljs-string">&quot;tests&quot;</span>, <span class="hljs-string">&quot;*.tests&quot;</span>, <span class="hljs-string">&quot;*.tests.*&quot;</span>, <span class="hljs-string">&quot;tests.*&quot;</span>]),<br>    <span class="hljs-comment"># If your package is a single module, use this instead of &#x27;packages&#x27;:</span><br>    <span class="hljs-comment"># py_modules=[&#x27;mypackage&#x27;],</span><br><br>    <span class="hljs-comment"># entry_points=&#123;</span><br>    <span class="hljs-comment">#     &#x27;console_scripts&#x27;: [&#x27;mycli=mymodule:cli&#x27;],</span><br>    <span class="hljs-comment"># &#125;,</span><br>    install_requires=REQUIRED,<br>    extras_require=EXTRAS,<br>    include_package_data=<span class="hljs-literal">True</span>,<br>    license=<span class="hljs-string">&#x27;MIT&#x27;</span>,<br>    classifiers=[<br>        <span class="hljs-comment"># Trove classifiers</span><br>        <span class="hljs-comment"># Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers</span><br>        <span class="hljs-string">&#x27;License :: OSI Approved :: MIT License&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3.6&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: Implementation :: CPython&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: Implementation :: PyPy&#x27;</span><br>    ],<br>    <span class="hljs-comment"># $ setup.py publish support.</span><br>    cmdclass=&#123;<br>        <span class="hljs-string">&#x27;upload&#x27;</span>: UploadCommand,<br>    &#125;,<br>)<br></code></pre></td></tr></table></figure><p>安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install -e .<br></code></pre></td></tr></table></figure><h1 id="Resources-导入"><a href="#Resources-导入" class="headerlink" title="Resources 导入"></a>Resources 导入</h1><p>在 3.7 版本之后，静态资源文件也支持像包一样处理，只需要在资源所有的文件中添加一个 init 文件即可；然后引入包后，只需要使用内置的 importlib.resources 模块，即可实现对资源文件的读取</p><p>假设包中有如下资源：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">books/<br>│<br>├── <span class="hljs-strong">__init__</span>.py<br>├── alice<span class="hljs-emphasis">_in_</span>wonderland.png<br>└── alice<span class="hljs-emphasis">_in_</span>wonderland.txt<br></code></pre></td></tr></table></figure><p>则可以通过如下方式读取其中的资源文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> importlib <span class="hljs-keyword">import</span> resources<br><br><span class="hljs-keyword">with</span> resources.open_text(<span class="hljs-string">&quot;books&quot;</span>, <span class="hljs-string">&quot;alice.txt&quot;</span>) <span class="hljs-keyword">as</span> fid:<br>    alice = fid.readlines()<br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">data/<br>│<br>├── <span class="hljs-strong">__init__</span>.py<br>└── WPP2019<span class="hljs-emphasis">_TotalPopulationBySex.csv</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> importlib <span class="hljs-keyword">import</span> resources<br><br><span class="hljs-keyword">with</span> resources.open_text(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;WPP2019_TotalPopulationBySex.csv&quot;</span>) <span class="hljs-keyword">as</span> fid:<br>rows = csv.DictReader(fid)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常规导入&quot;&gt;&lt;a href=&quot;#常规导入&quot; class=&quot;headerlink&quot; title=&quot;常规导入&quot;&gt;&lt;/a&gt;常规导入&lt;/h1&gt;&lt;h2 id=&quot;模块-Modules&quot;&gt;&lt;a href=&quot;#模块-Modules&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="文章" scheme="http://example.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python Package 配置</title>
    <link href="http://example.com/2022/03/13/python%20package%20%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/03/13/python%20package%20%E9%85%8D%E7%BD%AE/</id>
    <published>2022-03-13T06:43:00.000Z</published>
    <updated>2024-09-21T23:18:31.955Z</updated>
    
    <content type="html"><![CDATA[<p>步骤</p><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>给 pip 使用的名字可以长一点和详细一点，这样更容易一眼看懂这个包是干嘛的，例如 realpython-reader；而用于导入时的包名称可以短一点，例如 import reader；这两点可以在 setup 文件中配置实现；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install realpython-reader<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> reader<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">help</span>(reader)<br></code></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>有三种配置方法，分别是：</p><ul><li>setup.py：最传统的一种</li><li>setup.cfg：用静态文件来替代 setup 脚本</li><li>pyproject.toml：用新格式静态文件，这是最新的标准，但是这种方式的缺点是不支持可编辑模块，此时需要额外写一个简单的 setup.py 来实现可编辑模块的安装；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;步骤&lt;/p&gt;
&lt;h2 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h2&gt;&lt;p&gt;给 pip 使用的名字可以长一点和详细一点，这样更容易一眼看懂这个包是干嘛的，例如 realpython-reader；</summary>
      
    
    
    
    <category term="文章" scheme="http://example.com/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Frida</title>
    <link href="http://example.com/2022/01/07/Frida/"/>
    <id>http://example.com/2022/01/07/Frida/</id>
    <published>2022-01-07T00:48:00.000Z</published>
    <updated>2024-09-21T23:14:28.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Frida 是一个用来向目标进程动态注入指令的工具，它使用 python 编写，因此可在多种操作系统中使用，例如 Windows, MacOS, Linux, Android, iOS 等等；</p><p>当要在 Android 上面使用时，需要先使用 root 权限运行 frida-server 进程，然后将手机通过 USB 线连接到电脑上，开启调试模式，之后就可以通过在 PC 端运行脚本实现预期效果（原理：PC 端脚本会发送指令给 frida-server 执行）；</p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="函数注入"><a href="#函数注入" class="headerlink" title="函数注入"></a>函数注入</h2><p>先用 c 语言快速定义一个程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hello.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 函数 func 接受一个参数，并打印出该参数值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span> <span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Number: %d\n&quot;</span>, n);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span> &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 函数在编译成可执行文件后，都会有一个虚拟内存地址，此处将该地址打印出来，以方便进行 hook</span><br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;func() is at %p\n&quot;</span>, func);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        func (i++);<br>        sleep (<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后调用编译踌躇，编译成可运行的程序，用来测试：</p><blockquote><p>gcc -Wall hello.c -o hello</p></blockquote><h3 id="读取函数参数"><a href="#读取函数参数" class="headerlink" title="读取函数参数"></a>读取函数参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># hook.py</span><br><br><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> frida<br><span class="hljs-keyword">import</span> sys<br><br>session = frida.attach(<span class="hljs-string">&quot;hello&quot;</span>)   <span class="hljs-comment"># 绑定名称为 hello 的进程</span><br><span class="hljs-comment"># 通过 ptr 指针值绑定内存中指定的位置</span><br>script = session.create_script(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Interceptor.attach(ptr(&quot;%s&quot;), &#123;  </span><br><span class="hljs-string">        onEnter: function(args) &#123;</span><br><span class="hljs-string">            send(args[0].toInt32());</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;);</span><br><span class="hljs-string">&quot;&quot;&quot;</span> % <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">1</span>], <span class="hljs-number">16</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_message</span>(<span class="hljs-params">message, data</span>):<br>    <span class="hljs-built_in">print</span>(message)<br><br>script.on(<span class="hljs-string">&#x27;message&#x27;</span>, on_message)<br>script.load()<br>sys.stdin.read()<br></code></pre></td></tr></table></figure><h3 id="修改函数参数"><a href="#修改函数参数" class="headerlink" title="修改函数参数"></a>修改函数参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># modify.py</span><br><br><span class="hljs-keyword">import</span> frida<br><span class="hljs-keyword">import</span> sys<br><br>session = frida.attach(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment"># 此处脚本通过绑定指定内存地址中的函数，当进入该函数时，就将参数列表中的第一个参数的值修改为 1337</span><br>script = session.create_script(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Interceptor.attach(ptr(&quot;%s&quot;), &#123;</span><br><span class="hljs-string">    onEnter: function(args) &#123;</span><br><span class="hljs-string">        args[0] = ptr(&quot;1337&quot;);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;);</span><br><span class="hljs-string">&quot;&quot;&quot;</span> % <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">1</span>], <span class="hljs-number">16</span>))<br><br>script.load()<br>sys.stdin.read()<br><br></code></pre></td></tr></table></figure><h3 id="替换函数"><a href="#替换函数" class="headerlink" title="替换函数"></a>替换函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># call.py</span><br><br><span class="hljs-keyword">import</span> frida<br><span class="hljs-keyword">import</span> sys<br><br>session = frida.attach(<span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment"># 调用 NativeFunction 在指定位置自定义了一个新函数，当该位置的函数被调用时，就会触发自定义的函数</span><br><span class="hljs-comment"># NativeFunction 函数的第二个参数用来指定返回值的类型，此处为 void，表示没有返回值</span><br>script = session.create_script(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    var func = new NativeFunction(ptr(&quot;%s&quot;), &#x27;void&#x27;, [&#x27;int&#x27;]);</span><br><span class="hljs-string">    func(1911);</span><br><span class="hljs-string">    func(1911);</span><br><span class="hljs-string">    func(1911);</span><br><span class="hljs-string">&quot;&quot;&quot;</span> % <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">1</span>], <span class="hljs-number">16</span>))<br><br>script.load()<br></code></pre></td></tr></table></figure><h3 id="注入字符串"><a href="#注入字符串" class="headerlink" title="注入字符串"></a>注入字符串</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hi.c 定义一个接受字符串参数的函数，并编译成可执行程序</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;String: %s\n&quot;</span>, s);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* s = <span class="hljs-string">&quot;Testing!&quot;</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;f() is at %p\n&quot;</span>, func);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;s is at %p\n&quot;</span>, s);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        func(s);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> frida<br><span class="hljs-keyword">import</span> sys<br><br>session = frida.attach(<span class="hljs-string">&quot;hi&quot;</span>)<br><span class="hljs-comment"># NativeFunction 函数的第二个参数用来指定返回值的类型，此处为 int</span><br><span class="hljs-comment"># 第三个参数是一个列表，用来存放输入类型</span><br><span class="hljs-comment"># 注意：在注入字符串时，传递给自定义函数的值是字符串的指针</span><br><span class="hljs-comment"># 注意：此处使用了 Memory.allocUtf8String 来创建自定义字符串，事实上，还有很多相关的方法可用</span><br><span class="hljs-comment"># 例如：Memory.alloc(), Memory.protect() 等</span><br>script = session.create_script(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    var st = Memory.allocUtf8String(&#x27;TESTMEPLZ!&#x27;);</span><br><span class="hljs-string">    var func = new NativeFunction(ptr(&quot;%s&quot;), &#x27;int&#x27;, [&#x27;pointer&#x27;]);</span><br><span class="hljs-string">    func(st);</span><br><span class="hljs-string">&quot;&quot;&quot;</span> % <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">1</span>], <span class="hljs-number">16</span>))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_message</span>(<span class="hljs-params">message, data</span>):<br>    <span class="hljs-built_in">print</span>(message)<br><br><br>script.on(<span class="hljs-string">&#x27;message&#x27;</span>, on_message)<br>script.load()<br><br></code></pre></td></tr></table></figure><h3 id="注入对象"><a href="#注入对象" class="headerlink" title="注入对象"></a>注入对象</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// client.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-type">int</span> sock_fd, i, n;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv_addr</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* b;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* message;<br>    <span class="hljs-type">char</span> recv_buf[<span class="hljs-number">1024</span>];<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s&lt;ip of server&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect() is at: %p\n&quot;</span>, connect);<br><br>    <span class="hljs-keyword">if</span> ((sock_fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Unable to create socket&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    bzero(&amp;serv_addr, <span class="hljs-keyword">sizeof</span>(serv_addr));<br><br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_port = htons(<span class="hljs-number">5000</span>);<br><br>    <span class="hljs-keyword">if</span> (inet_pton(AF_INET, argv[<span class="hljs-number">1</span>], &amp;serv_addr.sin_addr) &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Unable to parse IP address\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nHere&#x27;s the serv_addr buffer:\n&quot;</span>);<br>    b = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) &amp;serv_addr;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i != <span class="hljs-keyword">sizeof</span>(serv_addr); i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s%02x&quot;</span>, (i != <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot; &quot;</span> : <span class="hljs-string">&quot;&quot;</span>, b[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\nPress ENTER key to Continue\n&quot;</span>);<br>    <span class="hljs-keyword">while</span>(getchar() == EOF &amp;&amp; ferror(<span class="hljs-built_in">stdin</span>) &amp;&amp; errno == EINTR) &#123;<br>        ;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (connect(sock_fd, (<span class="hljs-keyword">struct</span> sockaddr*) &amp;serv_addr, <span class="hljs-keyword">sizeof</span>(serv_addr)) &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Unable to connnect&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    message = <span class="hljs-string">&quot;Hello there!&quot;</span>;<br>    <span class="hljs-keyword">if</span> (send(sock_fd, message, <span class="hljs-built_in">strlen</span>(message), <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Unable to send&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        n = recv(sock_fd, recv_buf, <span class="hljs-keyword">sizeof</span>(recv_buf) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">-1</span> &amp;&amp; errno == EINTR) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        recv_buf[n] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">fputs</span>(recv_buf, <span class="hljs-built_in">stdout</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Unable to read&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> frida<br><span class="hljs-keyword">import</span> sys<br><br>session = frida.attach(<span class="hljs-string">&quot;client&quot;</span>)<br>script = session.create_script(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    send(&#x27;Allocating memory and writing bytes...&#x27;);</span><br><span class="hljs-string">    var st = Memory.alloc(16);</span><br><span class="hljs-string">    st.writeByteArray([0x02, 0x00, 0x13, 0x89, 0x7F, 0x00, 0x00, 0x01, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30]);</span><br><span class="hljs-string">    Interceptor.attach(Module.getExportByName(null, &#x27;connect&#x27;), &#123;</span><br><span class="hljs-string">        onEnter: function(args) &#123;</span><br><span class="hljs-string">            send(&#x27;Injecting malicious byte array:&#x27;);</span><br><span class="hljs-string">            args[1] = st;</span><br><span class="hljs-string">        &#125;,</span><br><span class="hljs-string">        // onLeave: function(retval) &#123;</span><br><span class="hljs-string">        //     retval.replace(0);</span><br><span class="hljs-string">        // &#125;</span><br><span class="hljs-string">    &#125;);</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_message</span>(<span class="hljs-params">message, data</span>):<br>    <span class="hljs-keyword">if</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;error&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[!]&quot;</span> + message[<span class="hljs-string">&#x27;stack&#x27;</span>])<br>    <span class="hljs-keyword">elif</span> message[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;send&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[i]&quot;</span> + message[<span class="hljs-string">&#x27;payload&#x27;</span>])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(message)<br><br><br>script.on(<span class="hljs-string">&#x27;message&#x27;</span>, on_message)<br>script.load()<br>sys.stdin.read()<br><br></code></pre></td></tr></table></figure><h1 id="注入指令"><a href="#注入指令" class="headerlink" title="注入指令"></a>注入指令</h1><blockquote><p>可以直接使用 js 编写注入函数</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>运行 frida-server，以便 PC 端的指令可发送到手机端；方法：adb shell 连通手机 shell，运行 frida-server 可执行文件，按官网教程，路径为 &#x2F;data&#x2F;local&#x2F;tmp&#x2F;frida-server</li><li>运行 frida-ls-devices，列出当前连接的设备，得到 ID 号；</li><li>运行 frida-ps -Ua，列出当前运行的进程，得到进程名称；</li><li>运行 frida -D <device id> -f <process name> -l <script path> --no-pause</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220104091127.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;Frida 是一个用来向目标进程动态注入指令的工具，它使用 python 编写，因此可在多种操作系统中使用，例如 Windo</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Ghidra</title>
    <link href="http://example.com/2022/01/04/Ghidra/"/>
    <id>http://example.com/2022/01/04/Ghidra/</id>
    <published>2022-01-04T01:04:00.000Z</published>
    <updated>2024-09-21T23:14:44.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Ghidra 是一个逆向工具，它除了内置功能外，还支持通过插件实现功能扩展；</p><p>Ghidra 基于项目 project 来管理要所逆向工程的内容，因此第一步需要先创建一个项目，或者导入一个项目；</p><p>新创建的项目并没有什么数据，第二步需要导入相关文件，才有办法实现后续的操作；导入文件时，会生成 program；</p><p>Ghidra tool：插件管理器，当运行某个插件时，会新开一个窗口，可在 “Running Tools” 栏目查看当前正在运行的插件列表；</p><p>Ghidra 本体并不负责实际的功能，各功能由插件来完成，当运行某个插件时，会新打开一个插件窗口，该窗口中有该插件的各相关功能；</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul><li>新建项目：File -&gt; New project -&gt; Non-shared Project -&gt; 选择项目存放目录</li></ul><blockquote><p>如果之前已经创建过项目，则可以使用 Open Project 导入之前的项目文件；</p></blockquote><h2 id="运行插件"><a href="#运行插件" class="headerlink" title="运行插件"></a>运行插件</h2><ul><li>启动插件：Tool Chest 栏，点击 code browser 图标</li></ul><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><ul><li>导入文件：File -&gt; Import file，导入后会开始解析文件，需要较长的时间（原因：对代码进行反汇编），耐心等待解析完成；</li><li>搜索位置<ul><li>按名称搜索：Search -&gt; For Strings</li><li>按行号搜索：Search -&gt; For Scalars</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;Ghidra 是一个逆向工具，它除了内置功能外，还支持通过插件实现功能扩展；&lt;/p&gt;
&lt;p&gt;Ghidra 基于项目 proj</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="逆向" scheme="http://example.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Flutter</title>
    <link href="http://example.com/2022/01/01/Flutter/"/>
    <id>http://example.com/2022/01/01/Flutter/</id>
    <published>2022-01-01T07:07:00.000Z</published>
    <updated>2024-09-21T23:14:24.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Vue 中的组件在这里叫做 Widget，组件可以包含组件，组件可以通过继承实现快速构建；组件通过内置的 build 方法来实现渲染，有点像小程序中的 setData；组件也有一些内置的属性，用来设置组件的相关信息，例如标题，主体等；</p><p>官方的 Material 组件库里面有很多前人写好的组件，可以用来快速构建应用；这些组件自带样式，可以自适应不同的终端，非常方便；有些组件甚至可以只负责样式，然后再内置包含内容的其他组件，很灵活，实现了样式和内容的解耦；</p><p>有个 pubspec.yaml 文件很像 nodejs 里面的 package.json 文件，用来定义项目的相关信息以及依赖的库；同时还有一个 pub.dev 仓库网站，类似 nodejs 里面的 npm 仓库，可以方便的实现第三方库的集中管理和下载；另外还有一个 pubspec.lock 文件，貌似也跟 nodejs 里面的 package_json.lock 功能差不多；</p><p>flutter pub 命令很像 npm ，用来管理包，例如 flutter pub get 类似 npm install，用来安装依赖文件中指定的各种包，flutter pub add 则用来添加包（发现添加后，好像并没有自动下载，而是需要再运行一下 pub get 才行，但是看 pub.dev 网站的文档好像只需要 add 就可以了）；</p><p>StateLessWidget 表示无状态的应用，即生成后里面的数据就不可变了；如果里面的数据需要可变的，则需要使用 StatefulWidget；但是很有意思的是 StatefulWidget 的实现是在它里面再包含一个 State 类来实现的可变状态（猜测这样是为了兼容性？）；</p><blockquote><p>通过在类名添加下划线前缀，在 Dart 中表示强制私有；在创建 StatefulWidget 时，编辑器自动创建的 State 类即默认为私有的；</p></blockquote><p>创建 State 时，有一个很有意思的点，即新创建的 state 并不是直接继承某个 StateWidget 来实现的，而是给 State 传递一个 StatefulWidegt 来实现，示例如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_RandomWordsState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">RandomWords</span>&gt;  </span>&#123;&#125;<br><span class="hljs-comment">// 此处的 RandomWords 是一个 StatefulWidget</span><br></code></pre></td></tr></table></figure><p>Widget 类有一个内置的 build 方法，用来初始化对象，一般继承父类后，会通过重写 build 方法覆盖父类的方法；</p><p>StatefulWidget 类有一个内置的 createState 方法，用来初始化 State 对象，通过对其进行重写，实现自定义的 State；</p><p>在类内部定义的函数，直接就是该类的方法，如果加上下划线作为前缀，则成为该类的私有方法；</p><p>ListView 有一个内置的 itemBuilder 方法，貌似列表滚动到底后，会自动触发该方法；</p><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p>在 Flutter 里面，一切均是 Widget，它既负责展示，也负责交互，很像 Vue 里面的组件；</p><p>通常来说，内置的组件已经设定好了默认样式；如果想修改这些默认样式，例如 margin, padding, border, backgroud 等，有两种方法：</p><ul><li>通过外加一层 Container 的 Widget 来实现，自定义的样式放在 Container 当中去实现，同时将内置 Widget 放在 Container 中，而不是去修改内置 Widget，这样实现了更好的解耦，也方便将来进行统一的管理，例如当更新某些全局设置时，所有内置 Widget 都会相应更新，而不会因为自行修改导致失效；</li><li>直接修改 Widget 的相关属性来实现，例如 color, font, weight 等；</li></ul><p>有一些 widget 是专门负责布局排版的，统称为 layout widget，主要有以下三类：</p><ul><li>single-child：只包含一个子元素；</li><li>multi-child：包含多个子元素；</li><li>silver：其他一些类型；</li></ul><p>所有的 layout widget 不外乎使用以下两种方式中的一种来添加子元素</p><ul><li>child ：仅有单个子元素，例如 Center，Container 等；</li><li>children ：拥有多个子元素，例如 Row，Column，ListView 或 Stack 等；</li></ul><p>大部分 Widget 都有一个 build 方法，当该方法被调用时，将生成界面；</p><h1 id="常用-Widget"><a href="#常用-Widget" class="headerlink" title="常用 Widget"></a>常用 Widget</h1><p>Scaffold：包含顶部标题栏，标题，背景色等元素；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220101084534.png"></p><p>Row：表示一行，里面可以嵌套各种东西；</p><p>Column：表示一列，里面可以嵌套各种东西；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220101145532.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220101145552.png"></p><p>Row 或 Column 内部元素的对齐，通过其属性 mainAxisAllignment 和 crossAxisAlignment 来实现；</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">Row(<br>  mainAxisAlignment: MainAxisAlignment.spaceEvenly,<br>  children: [<br>    Image.asset(<span class="hljs-string">&#x27;images/pic1.jpg&#x27;</span>),<br>    Image.asset(<span class="hljs-string">&#x27;images/pic2.jpg&#x27;</span>),<br>    Image.asset(<span class="hljs-string">&#x27;images/pic3.jpg&#x27;</span>),<br>  ],<br>);<br></code></pre></td></tr></table></figure><p>如果图片的大小跟所设定的区域尺寸不匹配，可通过将其放到  Expanded 中，来实现自动缩放，示例如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dart">Row(<br>  crossAxisAlignment: CrossAxisAlignment.center,<br>  children: [<br>    Expanded(<br>      child: Image.asset(<span class="hljs-string">&#x27;images/pic1.jpg&#x27;</span>),<br>    ),<br>    Expanded(<br>      child: Image.asset(<span class="hljs-string">&#x27;images/pic2.jpg&#x27;</span>),<br>    ),<br>    Expanded(<br>      child: Image.asset(<span class="hljs-string">&#x27;images/pic3.jpg&#x27;</span>),<br>    ),<br>  ],<br>);<br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dart">Row(<br>  crossAxisAlignment: CrossAxisAlignment.center,<br>  children: [<br>    Expanded(<br>      child: Image.asset(<span class="hljs-string">&#x27;images/pic1.jpg&#x27;</span>),<br>    ),<br>    Expanded(<br>      flex: <span class="hljs-number">2</span>,<br>      child: Image.asset(<span class="hljs-string">&#x27;images/pic2.jpg&#x27;</span>),<br>    ),<br>    Expanded(<br>      child: Image.asset(<span class="hljs-string">&#x27;images/pic3.jpg&#x27;</span>),<br>    ),<br>  ],<br>);<br></code></pre></td></tr></table></figure><p>默认情况下，Row 或 Column 内部的元素会占据整行或整列的空间，如果需要各个元素按指定尺寸挨着显示，则可以通过设置 mainAxisSize 来实现</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220101150634.png"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">Row(<br>  mainAxisSize: MainAxisSize.min, <span class="hljs-comment">// 设置尺寸</span><br>  children: [<br>    Icon(Icons.star, color: Colors.green[<span class="hljs-number">500</span>]),<br>    Icon(Icons.star, color: Colors.green[<span class="hljs-number">500</span>]),<br>    Icon(Icons.star, color: Colors.green[<span class="hljs-number">500</span>]),<br>    <span class="hljs-keyword">const</span> Icon(Icons.star, color: Colors.black),<br>    <span class="hljs-keyword">const</span> Icon(Icons.star, color: Colors.black),<br>  ],<br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;Vue 中的组件在这里叫做 Widget，组件可以包含组件，组件可以通过继承实现快速构建；组件通过内置的 build 方法来</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Dart" scheme="http://example.com/tags/Dart/"/>
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Angularjs</title>
    <link href="http://example.com/2021/11/18/Angularjs/"/>
    <id>http://example.com/2021/11/18/Angularjs/</id>
    <published>2021-11-17T23:55:00.000Z</published>
    <updated>2024-09-21T23:13:21.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件由三部分组成：</p><ul><li>class：数据、功能（函数）；</li><li>template：HTML 模板</li><li>style：样式</li></ul><p>在 HTML 标签中，点击事件绑定用以下方法来表示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>do something<span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>HTML 模板中所需要的数据，通过使用依赖注入的方法，实现动态更新的效果，示例如下：</p><p>单向绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;&#123;hero.name | uppercase&#125;&#125; Details<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>此处的“| uppercase” 是一个管道连接符 + 一个内置格式转换函数，它可以将字符串转成大写。在 angular 中，这种方式被称为 pipe 函数，包括 DatePipe, UppercasePipe, LowercasePipe, CurrencyPipe, DecimalPipe, PercentPipe 等；</p></blockquote><p>双向绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hero-name&quot;</span> [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">&quot;hero.name&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>此处通过 [(ngModel)] 实现双向绑定，这样就不需要在 JS 中监听 input 事件，并手工更新 JS 中的数据，确实方便很多；</p></blockquote><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p>组件的数据可以依赖服务来注入，实现数据和组件之间的解耦。这样当数据的实现发生变化时，不需要变更组件，只需要更新服务内部的代码即可；数据来源可以是本地存储、硬编码、网络接口等；</p><p>通过将服务注入组件内部的 constructor 构建函数，之后在组件的 onInit hook 中调用初始化函数，来实现内部对数据的自定义处理</p><blockquote><p>此处非常有意思，首先外部引入的 HeroService 本身就是一个类（或函数），已经实现了第一层的解耦，但之后在组件中引入该服务时，只是将其添加为组件 Class 的私有属性，同时组件又定义了自己的 Service 函数，在该 Service 函数中调用 HeroSerivice，这样一样就实现了双重解耦，如果 HeroService 的实现有任何变化，都只需要更新组件自己定义的 Service 函数，而不会影响到组件内部的其他位置的代码；</p><p>理论上任何读取外部数据的场景，都最好自定义一个函数，来实现解耦，避免内部代码跟外部数据的实现之间产生耦合；</p></blockquote><p>创建服务的命令：ng generate service <service-name></p><p>@Injectable 修饰符用来定义服务的元属性，例如定义可注入的范围等（root 表示全局可注入），有点类似 @component 用来定义组件的元属性一样；</p><p>当服务的数据来源是网络接口时，数据的获得是异步的，因此服务需要支持该异步场景，对异步状态下的数据进行处理；</p><p>为了支持异常，ng 引入了一个 Observable 类，这个类有点像是 Promise，它会返回一个对象，该对象有一个 Subscribe 方法；该方法接受一个回调函数，并将最终数据做为参数，传递给回调函数；</p><p>constructor 构建函数的初始化很有意思，它有一个快捷方式，即在参数定义中，可以直接将参数赋值给相应名称的属性，这个做法跟 c++ 不太一样，示例如下：</p><blockquote><p> constructor*(private <em>messageService</em>: MessageService) { }</p></blockquote><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>理论上路由貌似应该是一个全局的东西，当用户在浏览器中，或者在页面上点击某个链接时，根据链接中的 path，从路由表中查到对应的组件，然后展示该组件（有点类似后端的路由，只是后端的路由是调用某个视图函数，而前端变成了调用某个视图组件）；</p><p><router-outlet> 貌似是一个内置的组件，用来展示路由返回的结果</p><p>RouterModule 的方法</p><ul><li>forRoot，用来添加路由表；</li><li>routerLink 属性用来在 HTML 页面上的 <a> 标签中指定路由路径；</li></ul><p>定义路径时，可以用冒号来表示变量，例如 “&#x2F;detail&#x2F;:id”，此处 id 是一个变量；</p><p>当用户点击某个包含 routerLink 属性的链接时，路由器将接受到事件对象，并跳转到对应的组件，之后组件有可能需要接受参数数据来完成初始化，此时需要用到 ActivatedRoute 对象来获得所需的参数数据；</p><ul><li>示例：ActivatedRoute.snapshot.paramMap.get(“id”)</li></ul><blockquote><p>但是有时候可能该参数很大，例如是一个对象，此时该如何传递数据呢？</p></blockquote><p>当用户从 A 组件页面跳转到 B 组件页面后，如果需要返回原来的 A 组件页面，貌似有两种方法，一种是在 B 页面上面放置 A 页面的链接。这种方法需要多一些工作量；如果此时能够记住原来的页面栈，而用一个通用返回方法，回到页面栈的上一层就会非常的方便，此时需要用到一个内置的 Location 服务，来获得该页面栈；</p><h3 id="添加路由的过程"><a href="#添加路由的过程" class="headerlink" title="添加路由的过程"></a>添加路由的过程</h3><ul><li>创建：创建 routing 路由模块；通过 CLI 创建时，它会自动在 app 根模块中引入路由模块；</li><li>映射：路由模块中定义路径和组件的映射关系，以便当用户点击或在浏览器中输入路径时，可以展示相应的组件；记得定义一个默认路径，让其重定向到指定的路径；</li><li>展示：在需要展示组件的位置，添加内置的 router-outlet 组件，它会将路由返回的组件展示出来；一般此时还会在 HTML 页面上添加导航，以便在不同的版块之间切换；</li><li>链接：给需要进行跳转的组件添加 routerLink 属性，当用户点击时，实现跳转；</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p> 通过引入内置的 HttpClient 模块，可以实现发送 HTTP 请求；由于请求返回的结果是异步的，因此 angular 使用 RxJS 库来处理异步，RxJS 将请求结果封装为 Observable 对象，有点类似 promise，可以调用该对象的 subscribe 方法，来获得异步返回的数据；</p><p>HttpClient 拥有常见的各种请求方法，例如 get&#x2F;post&#x2F;put&#x2F;delete 等，它的调用方式有点特别，需要使用类似 C++ 中的泛型来定义返回数据的类型，例如：</p><blockquote><p>HttpClient.get&lt;Hero[]&gt;(url)，此处 url 为参数，不同的请求方法，接受的参数个数不同；所有的请求方法都会返回一个 RxJS 中的 Observable 对象；</p></blockquote><p>RxJS 的 Observable 对象有一个 pipe 方法，该方法可用来将多个函数组合成一个函数。当条件满足时，该组合函数会被触发（调用），然后它会依次执行组合中的各个函数；例如：</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">http</span>.<span class="hljs-property">get</span>&lt;<span class="hljs-title class_">Hero</span>&gt;(url)<br>.<span class="hljs-title function_">pipe</span>(<br> <span class="hljs-title function_">tap</span>(<span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`fetched hero id=<span class="hljs-subst">$&#123;id&#125;</span>`</span>)),<br> <span class="hljs-title function_">catchError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleError</span>&lt;<span class="hljs-title class_">Hero</span>&gt;(<span class="hljs-string">`getHero id=<span class="hljs-subst">$&#123;id&#125;</span>`</span>))<br>);<br></code></pre></td></tr></table></figure><p>此处的 tap 和 catchError 都是内置函数，但是它们的执行场景不同，tap 一定会执行，而 catchError 仅在 HTTP Response 报错的情况下才会执行；这两个函数都接受一个回调函数做为其参数，并在得到 Response 后，调用该回调函数；</p></blockquote><p>因此，在 HttpClient 请求中结合 pipe，我们就可以对返回的结果加入一些我们想要实现的额外操作，例如 log 和错误处理等；</p><blockquote><p>RxJS 有很多内置方法（称为 operator），例如 map, tap, catchError 等，这些内置方法可以很方便的实现一些常用的功能，详细可查看官方文档：<a href="https://rxjs.dev/api">https://rxjs.dev/api</a></p></blockquote><p>RxJS 库中还有另外一个特别的东西叫 Subject，本质上它是一个特定类型的 Observable 对象，因此它同样支持 Observable 的各种方法，它的作用原理很像是一个 EventEmitter，它有一个 next 方法，当调用该方法时，给它传递一个参数，然后就会触发之前通过 pipe 传递进去的那些函数，示例如下：</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 初始化一个 Subject 对象</span><br>searchTerm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Subject</span>&lt;string&gt;();<br><br><span class="hljs-comment">// 调用 Subject 的 pipe 方法，放入回调函数</span><br>heroes$ = searchTerm.<span class="hljs-title function_">pipe</span>(<br> <span class="hljs-comment">// 在用户输入关键字后，等待 300 毫秒，如果用户没有继续输入，再触发关键字搜索</span><br> <span class="hljs-title function_">debounceTime</span>(<span class="hljs-number">300</span>),<br> <span class="hljs-comment">// 如果输入和之前的关键字相同，则不触发搜索</span><br> <span class="hljs-title function_">distinctUntilChanged</span>(),<br> <span class="hljs-comment">// 当关键字变化时，切换到新的搜索结果</span><br> <span class="hljs-title function_">switchMap</span>(<span class="hljs-function">(<span class="hljs-params">term: string</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">heroService</span>.<span class="hljs-title function_">searchHeroes</span>(term)),<br>)<br><br><span class="hljs-comment">// 定义事件处理函数，当事件发生时，调用 Subject 对象的 next 方法，传递最新的参数数据</span><br><span class="hljs-title function_">search</span>(<span class="hljs-attr">term</span>: string): <span class="hljs-keyword">void</span> &#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">searchTerm</span>.<span class="hljs-title function_">next</span>(term);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 Observable 的 pipe 方法返回的是一个 Observable  对象，因此这里加了特殊的符号 heroes$ 来表示该类型，而不是直接用 heroes 的常见变量名，这也直接导致随后在 Component 的 HTML 模板中绑定该变量时，需要使用 angular 内置的 async 来处理，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">&quot;let hero of heroes$ | async&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>组件：ng generate component <name></li><li>服务：ng generate service <name></li><li>模块：ng generate module <name> –flat –module&#x3D;app<ul><li>–flat：表示不需要为该模块创建单独的文件夹，而是放在根文件夹下面，即 src&#x2F;app 文件夹中；</li><li>–module&#x3D;app：表示将该模块注册登录在 AppModule 模块中（即在 AppModule 模块中 import）；</li></ul></li></ul><h3 id="启动调试服务器"><a href="#启动调试服务器" class="headerlink" title="启动调试服务器"></a>启动调试服务器</h3><p>ng serve –open</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;组件&quot;&gt;&lt;a href=&quot;#组件&quot; class=&quot;headerlink&quot; title=&quot;组件&quot;&gt;&lt;/a&gt;组件&lt;/h2&gt;&lt;p&gt;组件由三部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;class：数据、功能（函数）；&lt;/li&gt;
&lt;li&gt;template：HTML 模板&lt;/li&gt;</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Firebase</title>
    <link href="http://example.com/2021/11/04/Firebase/"/>
    <id>http://example.com/2021/11/04/Firebase/</id>
    <published>2021-11-04T01:28:00.000Z</published>
    <updated>2024-09-21T23:14:19.403Z</updated>
    
    <content type="html"><![CDATA[<p>Firebase 就像名字中所携带的 base 字样透露出的信息，它是一个数据库；Firebase 是 Google 提供的一个 Baas 云产品（Backend as a service 后端服务化）；Firebase 将数据库的常用操作封装成一个库，开发者可以在前端代码中直接调用，与数据库进行交互，这样一来就省去了传统后端应用的开发，由前端直接跟数据库打交道；</p><p>适用场景：在轻量化应用中，Firebase 可以大大节省开发的工作量；但它也意味着将原来的后端逻辑全部搬到前端了，而前端是运行在浏览器中的，有可能不适合运行一些密集运算，另外也将整个应用的逻辑全部暴露出来，并非所有的应用都适合该场景；</p><p>开发者通过 Firebase SDK 也 Google 服务器直接交互，因此在使用 Firebase 之前，需要先在 Google 控制台申请 API 账号，然后在 SDK 中使用该账号；这带来一个有趣的问题，显然该账号信息是不能传输到前端的，那么要如何保持私密性呢？貌似仍然不可避免需要有一个后端服务来处理这个事情；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Firebase 就像名字中所携带的 base 字样透露出的信息，它是一个数据库；Firebase 是 Google 提供的一个 Baas 云产品（Backend as a service 后端服务化）；Firebase 将数据库的常用操作封装成一个库，开发者可以在前端代码</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理</title>
    <link href="http://example.com/2021/10/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2021/10/20/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</id>
    <published>2021-10-20T02:20:00.000Z</published>
    <updated>2024-09-21T23:12:11.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数字图像基础"><a href="#数字图像基础" class="headerlink" title="数字图像基础"></a>数字图像基础</h1><h2 id="视觉感知要素"><a href="#视觉感知要素" class="headerlink" title="视觉感知要素"></a>视觉感知要素</h2><p>人的主观亮度是进入人眼的光线强度的对数函数，并且在暗光环境和亮光环境下，该函数有所不同；两个函数有交叉的部分。当人眼从一个光线环境切换到另外一个光线环境时，眼睛需要有一个适应的过程，此时人眼会调整自身的光线灵敏度，来完成这种适应；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211020143840.png"></p><p>韦伯比：光线变化量与变化前的光线强度的比值  delta I &#x2F; I；在低照明环境，韦伯比比较大（说明此时人眼较不敏感）；在高照明环境下，韦伯比降低（说明此时人眼对光线变化变得更加敏感了）；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211020144134.png"></p><p>在背景照明（即环境光线）恒定时，人眼可辨别的亮度级别是有限的（12-24级左右），但是当人眼开始移动时，背景照明会跟着变化，因此导致人眼能够辨别很大的亮度范围；</p><p>当背景照明变化时，由于人眼会重新适应和调整自己，因此这时在变化的边缘区域，会出现有趣的现象，此时人眼的感知不是线性的，而是会出现小范围的波动（上冲和下冲现象，马赫带效应）；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211020144543.png"></p><p>人眼对某个区域的亮度判断，并不完全取决于该区域的光线强度，还跟该区域所处的背景强相关；如果背景是暗的，则物体看起来更白；如果背景是亮的，则物体看起来变暗；</p><h2 id="光和电磁波谱"><a href="#光和电磁波谱" class="headerlink" title="光和电磁波谱"></a>光和电磁波谱</h2><p>光是一种电磁波，不同的电磁波有不同的波长和频率，频率越高的电磁波，其携带的能量越大，此时波长也相应的越短；人眼可感知的光的波长范围大概在 0.43 - 0.79 um 之间；</p><p>除了频率（波长）外，有三个指标可用来描述光的属性：</p><ul><li>发光强度：光源发出的能量总量，单位瓦特 W；</li><li>光通量：观察者从光源感受到的能量，单位流明数 lm；</li><li>亮度：观察者对感知到的光的主观描绘参数，个体之间存在差异，因此不可度量（大致相当于强度描述）；</li></ul><h2 id="图像感知和获取"><a href="#图像感知和获取" class="headerlink" title="图像感知和获取"></a>图像感知和获取</h2><p>基本原理：使用传感器，将光的能量转换成电压变化的波形，再解析波形成为数字信号；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211020152020.png"></p><blockquote><p>i 表示入射分量，表示环境光源；r 表示反射分量，表示目标物体的反射光，取值范围为 0-1，表示对环境光源的全反射到全吸收之间的范围；公式中的取值范围是理论上的，现实生活中不可能存在无穷大的光源，不同环境中的光源强度总是在有限的范围内；</p></blockquote><h2 id="图像取样和量化"><a href="#图像取样和量化" class="headerlink" title="图像取样和量化"></a>图像取样和量化</h2><p>由于传感器输出的是连续的电压波形，因此需要进一步做取样和量化动作，以便将这些波形数据数字化；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211020152803.png"></p><p>对比度：照片中最高和最低灰度级间的灰度差；</p><p>最大可度量灰度和最小可度量灰度构成了图片的动态范围；最小可度量灰度跟噪声有关；</p><p>分辩率：单位距离的线或点的总数量；印刷行业一般用点数，即 dpi（dot per inch）；</p><h1 id="彩色图像处理"><a href="#彩色图像处理" class="headerlink" title="彩色图像处理"></a>彩色图像处理</h1><p>传感器有很多种类型，不同类型的感光特性不同；同一感光材料，对不同波长的敏感度不同；波长越长的电磁波，进入材料越深，因此有更大的可能性被吸收，导致最终结果是光电转换率更低；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021153211.png"></p><p>不同颜色的电磁波，在感光材料上面的光电转换效率：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021153309.png"></p><p>原始的传感器数据是马赛克形式的，因此首先需要进行插值计算，去除马赛克，得到每一个像素点的三通道值；有很多种去除马赛克的算法，最简单的办法是取邻近点的平均值，缺点是物体边缘会不够锐利；更好的算法会稍微复杂一点，例如考虑变化幅度，当变化幅度超过临界点时，可以判断该点属于物体的边缘，因此只取纵向或横向的平均值（有些算法还会考虑该点所处的位置，例如是角点、边点、还是中间点等情况）；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021161753.png"></p><p>饱和度：指相对的纯净度，即一种颜色混合白光的数量；纯色是全饱和的，加了白色后变成次饱和的；饱和度和所加的白光数量成反比；</p><p>曝光：场景中某些物体表面由于反射的光线少，可能很暗，因此需要延长传感器接收光线的时间，这样才能收集到足够多的信息，得以看清该物体的细节；但是延长传感器的工作时间是一把双刃剑，因为此时画面中也有可能存在比较明亮的物体（反射光线多），如果延长传感器工作的时间，则会导致明亮物体区域接收到过多的光线值，如果该值超过了上限，则会导致该明亮物体最终呈现为白色，丢失了细节；因此，选择合适的曝光时间，尽量多的保留画面中核心区域的细节，是一个不可缺少的环节；</p><p>白平衡：环境光源是多种多样的，不同的环境光源，其不同波长的电磁波组成不同，因此在该环境中，物体会出现色差；有时这种色差正是我们所需要的，但有时候则不是我们想要的。白平衡的目标，就是换出环境光源各部分光线的构成比例，并加予干预调节，让其回归到某个标准光源环境的光线比例，从而让画面中的物体，能够展示在标准光源环境下的色彩；通常白平衡并没有直接调整传感器的模拟信号值，而是调整模拟信号转换后的数字信号值，对每个通道使用不同系数进行调整；</p><p>白天日光环境下 RGB 光波的比例坐标：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021141121.png"></p><blockquote><p>RIMM RGB: Reference Input&#x2F;Output Medium Metric RGB</p></blockquote><p>白平衡后的数字信号，到最终显示结果之间，有三个动作需要做：</p><ul><li>将数字信号转成颜色模型；</li><li>色阶调整（因为需要考虑最终结果的观看环境跟拍摄环境不同，例如图片观看多数在室内，而拍摄通常在室外）</li><li>转换成显示设备的颜色模型；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021165034.png"></p><blockquote><p>不同的数码相机，这三个步骤有不同的处理算法，并且它们之间不一定有明确的分界线；</p></blockquote><p>传感器收集到的原始数据，需要转换为颜色值，此时需要采用某种能够表示色彩的模型；理想情况下，针对不同的环境光线，相机应使用不同的计算公式，计算出对应的色值；但在实际应用中，该步骤一般直接使用白平衡补偿后的数据；虽然这种做法可以让中性色物体恢复到正常的色值，但其他颜色则无法还原准确；理论上相机系统可以根据白平衡参数，计算出光源类型，然后再调用最合适的色彩计算模型进行色值计算；</p><p>由于人眼对颜色的感知跟人眼所处的环境光线有直接关系，因此在计算色值前，需要考虑最终的图片将在何种光线环境下被查看，并基于该查看环境，来计算合适的色值；通常情况下，会假设存在一个统一的查看环境，将基于该环境进行计算；但有时对于专业摄影场景，则省去该计算步骤，保留原值，让摄像者在后期进行自定义处理；</p><p>相机所采用的颜色模型可以是设备无关的，例如 CIEXYZ 或者 CIELab，但也可以是设备相关的，例如 RIMM RGB 模型；</p><p>经过白平衡计算后的色值，需要进一步考虑曝光参数，计算出曝光校正后的色值，</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021142542.png"></p><blockquote><p>非纯性的曝光数据 -&gt; 查 LUT 表转成纯性的曝光数据 -&gt; 颜色校正Matrix，得到 XYZ 色值 -&gt; RIMM 转换Matrix，得到线性 RIMM RGB 色值 -&gt; 查 LUT 表，转成非线性的 RIMM RGB 值；在实际计算时，中间过程的两个矩阵可以合并成一个矩阵；</p></blockquote><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021142125.png"></p><p>然后再按以下公式转成非线性的 RGB；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021142348.png"></p><h3 id="色阶调整"><a href="#色阶调整" class="headerlink" title="色阶调整"></a>色阶调整</h3><p>照片的观看环境通常与拍摄环境不同，前者通常在室内（光线较暗），拍摄则通常在室外（光线较亮），因此在处理照片数据时，需要有一个色阶调整的环节，通过增加对比度，让照片通常在较暗的环境看得清楚；</p><p>大脑在观看照片时，存在一个心理学现象，即会强化某种现象，例如脑海中的草的颜色，会比现实中的更加鲜艳（纯度更高）；</p><p>照片的动态范围，通常要比实际生活中的更小一些，因此在做照片的处理时，需要丢弃一些动态范围信息（即对信息进行压缩）；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021172347.png"></p><blockquote><p>RIMM 与 ROMM 的映射图</p></blockquote><h3 id="输出模型"><a href="#输出模型" class="headerlink" title="输出模型"></a>输出模型</h3><p>照片最终要在某种显示设备上进行展示，因此最后一个环节需要将数据转成目标设备的颜色模型，目前国际标准是采用 sRGB 模型。这个模型的优点是通用性很强，几乎所有的显示设备都支持。缺点是它显示的颜色范围较小，因此可能无法满足一些高端显示设备的要求；如果已知目标设备，则此步可以将照片直接转成目标设备所使用的颜色模型，而不是通过 sRGB；</p><p>第一步：将非线性的 ROMM RGB 值转成线性的；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021173149.png"></p><p>第二步：将线性 ROMM RGB 转在 D50 XYZ 值；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021173230.png"></p><p>第三步：将 D50 XYZ 转成 D65 XYZ</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021173254.png"></p><p>第四步：将 D65 XYZ 转成线性的 RGB 值</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021173328.png"></p><p>第五步：将线性 RGB 转成非线性的 RGB </p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021173354.png"></p><p>注：其中第2步到第4步的三个矩阵运算，可以合并成一个矩阵</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211021173518.png"></p><p>因此，整个计算过程可以简化为 LUT - Matrix - LUT 三部曲；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数字图像基础&quot;&gt;&lt;a href=&quot;#数字图像基础&quot; class=&quot;headerlink&quot; title=&quot;数字图像基础&quot;&gt;&lt;/a&gt;数字图像基础&lt;/h1&gt;&lt;h2 id=&quot;视觉感知要素&quot;&gt;&lt;a href=&quot;#视觉感知要素&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="书籍" scheme="http://example.com/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="图像处理" scheme="http://example.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Vue2</title>
    <link href="http://example.com/2021/08/04/Vue2/"/>
    <id>http://example.com/2021/08/04/Vue2/</id>
    <published>2021-08-04T01:57:00.000Z</published>
    <updated>2024-09-21T23:19:12.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><ul><li>在实例化 Vue 对象时，data 属性所引用的 data 对象的属性，在实例时就固定下来了；即如果后续给 data 对象添加的新属性，并不会出现在 Vue 对象中；</li><li>在 HTML 标签上可以使用 v-bind 等指令，来将某个标签的属性值和某个 vue 对象的属性值进行绑定；</li><li>在 input 标签上使用 v-model 指令，可以实现在输入框中，对 vue 对象属性值的修改，从而实现双向绑定；</li><li>组件绑定的对象，如果使用了 Object.freeze 方法处理过，则绑定将失效，即对象属性的更新，将不再会反应到视图上面；</li></ul><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>Vue 实例由若干个阶段组成它的生命周期，它带来一些内置的方法，可以在这些阶段插入一些想要实现的函数，即所谓的钩子，包括 created、mounted、updated、destroyed 等；</p><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><h5 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h5><p>用双大括号绑定 Vue 实例的 data；如果在 HTML 标签上添加 v-once 属性，则插值只会赋值一次，之后不会动态更新；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="原始-HTML"><a href="#原始-HTML" class="headerlink" title="原始 HTML"></a>原始 HTML</h5><p>当 Vue 实例的 data 不是普通的字符串，而是原始 html 格式字符串时，如果使用常规的双大括号，这些 html 格式的字符串，将被当成普通的文本处理；此时需要改成给标签增加 v-html 属性来绑定值，它才会被当作 HTML 处理；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using v-html directive: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h5><p>双大括号的写法，无法将 data 值赋给 HTML 标签的属性，此时需要使用 v-bind 指令来达到预期效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!---或者也可以直接写成如下格式---&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="使用-javascript-表达式"><a href="#使用-javascript-表达式" class="headerlink" title="使用 javascript 表达式"></a>使用 javascript 表达式</h5><p>在双大括号的内部，除了给绑定 data 值外，也是可以使用 javascript 表达式的；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; number + 1 &#125;&#125; <br><br>&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125; <br><br>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125; <br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>“指令”指的是在 HTML 标签中使用 v- 前缀的特殊属性；除了 v-for 外，指令的值应为单个 javascript 表达式；它的作用是当表达式的值发生改变时，能够将新值作用于 DOM 元素，使其产生预期的变化；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>有些指令能够接收参数，用来将表达式与参数所代表的属性值或者事件进行绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h5><p>参数早期是一个静态的字符串，如果想让它变成动态的，则可以通过增加中括号来实现；这个时候参数实际上是一个表达式，通过表达式的求值，获得绑定目标，一般来说，这个目标应该是字符串类型的值，除了 null 外，其他非字符串的结果都会引发错误；</p><p>另外表达式存在一些约束，例如不能使用空格或者引号、不能使用大写字符来定义键名（会被强制转化小写，可能导致表达式求值失败）；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">attributeName</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>指令允许接以点号为标记的后缀，用来表达该指令需要以特殊的方式进行绑定；</p><p>例如：.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @[<span class="hljs-attr">event</span>]=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h3><p>双大括号适合用来放置一些简单的变量，虽然它也支持内置表达式，但是如果表达式很长，或者逻辑比较复杂，则看起来比较困难，此时可以使用 Vue 实例中的 computed 属性，在这个属性中，同样可以内置变量，但这些变量实际上是函数，当 HTML 标签绑定到这些变量后，它实际上是会执行函数并将最终结果赋值给标签；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#example&#x27;</span>, <br>    <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span> &#125;, <br>    <span class="hljs-attr">computed</span>: &#123;<br>        <span class="hljs-comment">// 计算属性的 getter </span><br>        <span class="hljs-attr">reversedMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br>            <span class="hljs-comment">// `this` 指向 vm 实例 </span><br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="计算属性-vs-方法"><a href="#计算属性-vs-方法" class="headerlink" title="计算属性 vs 方法"></a>计算属性 vs 方法</h4><p>事实上，前面的例子，也可以通过给 HTML 标签绑定 Vue 实例的方法来实现；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Reversed message: &quot;&#123;&#123; reversedMessage( ) &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-attr">reverseMessage</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>虽然二者的结果是相同的，但是背后却有所区别；如果是绑定 Vue 实例的方法，每次访问变量，都会执行方法计算结果；但计算属性则使用缓存来返回结果，直到所绑定的标签发生变化后，才会重新求值，因此它的性能更加好；对于简单的计算二者区别不明显，但是如果计算量很大，则可能产生明显差别；</p><h4 id="计算属性-vs-监听属性"><a href="#计算属性-vs-监听属性" class="headerlink" title="计算属性 vs 监听属性"></a>计算属性 vs 监听属性</h4><p>监听属性可以用来监听 data 中的属性值变化，当发生变化时，就会调用提前写好的监听函数；当有某个变量是由多个其他变量合成的时候，则将该变量放置在计算属性中是更加简单的做法；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 监听属性的做法</span><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#demo&#x27;</span>, <br>    <span class="hljs-attr">data</span>: &#123; <br>       <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Foo&#x27;</span>, <br>       <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Bar&#x27;</span>, <br>       <span class="hljs-attr">fullName</span>: <span class="hljs-string">&#x27;Foo Bar&#x27;</span><br>    &#125;, <br>    <span class="hljs-attr">watch</span>: &#123; <br>        <span class="hljs-attr">firstName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123; <br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = val + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span><br>        &#125;, <br>        <span class="hljs-attr">lastName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123; <br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + val <br>        &#125; <br>    &#125; <br>&#125;)；<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 计算属性的做法</span><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#demo&#x27;</span>, <br>    <span class="hljs-attr">data</span>: &#123; <br>        <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Foo&#x27;</span>, <br>        <span class="hljs-attr">lastName</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> <br>    &#125;, <br>    <span class="hljs-attr">computed</span>: &#123; <br>        <span class="hljs-attr">fullName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h4><p>计算属性默认只有 getter，但其实它也支持 setter 的做法；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">computed</span>: &#123; <br>    <span class="hljs-attr">fullName</span>: &#123; <br>        <span class="hljs-comment">// getter </span><br>        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> <br>        &#125;, <br>        <span class="hljs-comment">// setter </span><br>        <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) &#123; <br>            <span class="hljs-keyword">var</span> names = newValue.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27; &#x27;</span>) <br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = names[<span class="hljs-number">0</span>] <br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span> = names[names.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] <br>        &#125; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>可以用来监听实例 data 属性中某个变量值的变化；当监听到某个变量值变化时，相应的函数就会被触发；大多数情况下使用计算属性更合适，但偶尔有时候，使用侦听属性更方便；监听器特别适合用来执行一些异步或计算开销大的函数；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;watch-example&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> Ask a yes/no question: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;question&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> watchExampleVM = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#watch-example&#x27;</span>, <br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">question</span>: <span class="hljs-string">&#x27;&#x27;</span>, <br>        <span class="hljs-attr">answer</span>: <span class="hljs-string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span> <br>    &#125;, <br>    <span class="hljs-attr">watch</span>: &#123;  <br>        <span class="hljs-comment">// 如果 `question` 发生改变，这个函数就会运行 </span><br>        <span class="hljs-attr">question</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">newQuestion, oldQuestion</span>) &#123; <br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> = <span class="hljs-string">&#x27;Waiting for you to stop typing...&#x27;</span>;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">debouncedGetAnswer</span>();<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 初始化时，调用 lodash 的 denounce，生成一个限制频率的新函数；</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">denounceGetAnswer</span> = _.<span class="hljs-title function_">denounce</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">getAnswer</span>, <span class="hljs-number">500</span>);<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-attr">getAnswer</span>: <span class="hljs-title function_">funcion</span> () &#123;           <br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">answer</span> = <span class="hljs-string">&#x27;Thinking...&#x27;</span> <br>            <span class="hljs-keyword">var</span> vm = <span class="hljs-variable language_">this</span>;<br>            axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://yesno.wtf/api&#x27;</span>) <br>            .<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123; <br>                vm.<span class="hljs-property">answer</span> = _.<span class="hljs-title function_">capitalize</span>(response.<span class="hljs-property">data</span>.<span class="hljs-property">answer</span>) &#125;) <br>            .<span class="hljs-title function_">catch</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123; <br>                vm.<span class="hljs-property">answer</span> = <span class="hljs-string">&#x27;Error! Could not reach the API. &#x27;</span> + error <br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h3><h4 id="绑定-HTML-class"><a href="#绑定-HTML-class" class="headerlink" title="绑定 HTML class"></a>绑定 HTML class</h4><p>使用 v-bind 进行表达式与属性的绑定时，表达式的计算结果是字符串，多数情况下这是OK的，但是如果是要动态的改变 CSS 的 Class 时，拼接字符串就显得麻烦而且容易出错；此时可以通过给 v-bind:class 传递一个对象，来实现对 CSS Class 的动态增加和减少（即让 HTML 是否拥有哪几个 Class）；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 当 isActive 的值为 true 时，div 就拥有 active 类，等同如下写法，否则没有 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>另外上面的例子，还可以写成如下的样子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;classObj&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">classObj</span>: &#123;<br>            <span class="hljs-attr">active</span>: isActive<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>甚至 classObj 还可以放在计算属性中，实现更高级和复杂的场景；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;classObj&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span><br>&#125;,<br><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-attr">classObj</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">active</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">isActive</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h5><p>除了对象外，v-bind:class 还支持数组类型的值，以实现同时绑定多个 class</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">data</span>: &#123; <br>    <span class="hljs-attr">activeClass</span>: <span class="hljs-string">&#x27;active&#x27;</span>, <br>    <span class="hljs-attr">errorClass</span>: <span class="hljs-string">&#x27;text-danger&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h5><p>在定义组件时，允许在 template 上面提前写入一些 class，之后在引用组件时，还可以再定义 class，此时的定义不会覆盖前面的定义；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123; <br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&#x27;</span> <br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;baz boo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><p>最终的渲染结果如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;foo bar baz boo&quot;</span>&gt;</span>Hi<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h4><h5 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;styleObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 除了绑定 data，也可以绑定计算属性 computed</span><br><span class="hljs-attr">data</span>: &#123; <br>    <span class="hljs-attr">styleObject</span>: &#123; <br>        <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>, <br>        <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;13px&#x27;</span><br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h5><p>如果某些 CSS 样式需要根据不同的浏览器格式要求，添加相应的前缀，例如 transform，该工作会由 Vue 自动侦测并处理；</p><h5 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h5><p>支持数组提供多个备用值，Vue 会自动检查哪个值适用，如果都不适用，则使用最后那一个；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;awesome&quot;</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>Oh no 😢<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果需要对多个 HTML 元素实现条件切换，则可以使用 <template> 把这些元素包起来形成一个组；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;ok&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph 2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h5><p>如果有多个条件分支，则可以使用 v-else-if</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span> A <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span> B <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span> C <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span> Not A/B/C <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h5><p>对于在 if-else 中重复出现的部分，Vue 会对其进行复用，以提高渲染的速度；如果有些情况复用是不必要的，则可以通过给每个标签增加不同 key 来实现；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your username&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;username-input&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your email address&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;email-input&quot;</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><p>v-if 用来决定是否渲染，v-show 则一定会渲染元素，但控制它是否显示；当某个元素可能出现频繁的切换时，使用 v-show 更加合理，性能开销更小；</p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><p>v-for 可以用来基于某个数组渲染出元素的列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example-1&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.message&quot;</span>&gt;</span> &#123;&#123; item.message &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> example1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#example-1&#x27;</span>, <br>    <span class="hljs-attr">data</span>: &#123; <br>        <span class="hljs-attr">items</span>: [ <br>            &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;, <br>            &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125; <br>        ] <br>    &#125; <br>&#125;);<br></code></pre></td></tr></table></figure><p>除了 item 外，v-for 还支持增加一个 index 参数，另外可以在 v-for 中访问父作用域的属性值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example-2&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in items&quot;</span>&gt;</span> <br>        &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> example2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#example-2&#x27;</span>, <br>    <span class="hljs-attr">data</span>: &#123; <br>        <span class="hljs-attr">parentMessage</span>: <span class="hljs-string">&#x27;Parent&#x27;</span>, <br>        <span class="hljs-attr">items</span>: [ <br>            &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;, <br>            &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125; <br>        ] <br>    &#125; <br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="在-v-for-里使用对象"><a href="#在-v-for-里使用对象" class="headerlink" title="在 v-for 里使用对象"></a>在 v-for 里使用对象</h4><p>v-for 除了可以用遍历数组外，还可以用来遍历对象的属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;v-for-object&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;value in object&quot;</span>&gt;</span><br>        &#123;&#123; value &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#v-for-object&#x27;</span>, <br>    <span class="hljs-attr">data</span>: &#123; <br>        <span class="hljs-attr">object</span>: &#123; <br>            <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;How to do lists in Vue&#x27;</span>, <br>            <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Jane Doe&#x27;</span>, <br>            <span class="hljs-attr">publishedAt</span>: <span class="hljs-string">&#x27;2016-04-10&#x27;</span> <br>        &#125; <br>    &#125; <br>&#125;);<br></code></pre></td></tr></table></figure><p>类似数组支持 index 作为第二个参数，对象也支持键名作为第二个参数，index 作为第三个参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name) in object&quot;</span>&gt;</span><br>      &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(value, name, index) in object&quot;</span>&gt;</span> <br>    &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125; <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h4><p>默认情况下，当 v-for 所绑定的数组的数据发生变动时，v-for 会更新原生成的列表，但是为了提高渲染速度，它不是按照数组里面的新顺序来重新生成列表的，而是会复用原列表的顺序，然后仅仅替换其中的数据，这意味着列表的顺序仍然是旧的，只有数据是新的；</p><p>如果列表的顺序与数组的顺序保持一致，则需要给 v-for 增加一个 key 属性（应为字符串类型或数组类型的值）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- 内容 --&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一般来说，在使用 v-for 时，尽量同时使用 v-bind:key，因为这样的输出结果符合大多数情况下的预期；</p><h4 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h4><h5 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h5><p>数组有一些内置的方法，这些方法会改掉原有数组的内容；</p><ul><li>push</li><li>pop</li><li>shift</li><li>unshift</li><li>reverse</li><li>sort</li><li>slice</li></ul><h5 id="非变更方法"><a href="#非变更方法" class="headerlink" title="非变更方法"></a>非变更方法</h5><p>以下方法不会改变原有的数组，而是返回一个新的数组</p><ul><li>concat</li><li>filter</li><li>slice</li></ul><h4 id="显示过滤-排序后的结果"><a href="#显示过滤-排序后的结果" class="headerlink" title="显示过滤&#x2F;排序后的结果"></a>显示过滤&#x2F;排序后的结果</h4><p>如果想在不改变原有数组的情况下，显示一个过滤或排序后的数组，则可以考虑使用计算属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;n in evenNumbers&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">data</span>: &#123; <br>    <span class="hljs-attr">numbers</span>: [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br>&#125;, <br><span class="hljs-attr">computed</span>: &#123; <br>    <span class="hljs-attr">evenNumbers</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">numbers</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) &#123; <br>            <span class="hljs-keyword">return</span> number % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在-v-for-里面使用值范围"><a href="#在-v-for-里面使用值范围" class="headerlink" title="在 v-for 里面使用值范围"></a>在 v-for 里面使用值范围</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="在-上使用-v-for"><a href="#在-上使用-v-for" class="headerlink" title="在  上使用 v-for"></a>在 <template> 上使用 v-for</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;divider&quot;</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;presentation&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-for-与-v-if-一同使用"><a href="#v-for-与-v-if-一同使用" class="headerlink" title="v-for 与 v-if 一同使用"></a>v-for 与 v-if 一同使用</h4><p>正常情况下，v-for 与 v-if 不建议同时使用，因为它们两个有优先级的差别，因此有可能产生预期外的结果；v-for 的优先级高于 v-if，因此当它们同时作用一个元素时，会先渲染出列表，之后再判断是否该某个列表条目；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!todo.isComplete&quot;</span>&gt;</span> <br>    &#123;&#123; todo &#125;&#125; <br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="在组件上使用-v-for"><a href="#在组件上使用-v-for" class="headerlink" title="在组件上使用 v-for"></a>在组件上使用 v-for</h4><p>数据不会自动被传递到组件里，需要使用组件的 prop 属性来传递数据；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in items&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:item</span>=<span class="hljs-string">&quot;item&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:index</span>=<span class="hljs-string">&quot;index&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item.id&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p>v-on 可以用监听一些 DOM 事件，之后触发一些提前写好的操作；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example-1&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;counter += 1&quot;</span>&gt;</span>Add 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> example1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <br>    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#example-1&#x27;</span>, <br>    <span class="hljs-attr">data</span>: &#123; <br>        <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span> <br>    &#125; <br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h4><p>操作除了可以作为表达式写在元素中，也可以作一个单独的函数，写在 Vue 实例的方法中；</p><h4 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h4><p>除了给元素绑定方法外，还可以在元素中直接调用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example-3&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;say(&#x27;hi&#x27;)&quot;</span>&gt;</span>Say hi<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;say(&#x27;what&#x27;)&quot;</span>&gt;</span>Say what<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javacript">new Vue(&#123; <br>    el: &#x27;#example-3&#x27;, <br>    methods: &#123; <br>        say: function (message) &#123; <br>            alert(message) <br>        &#125; <br>    &#125; <br>&#125;);<br></code></pre></td></tr></table></figure><p>原始的 DOM 事件可以使用 $event 进行引用，并且还可以作为参数传递给实例的方法或者内置方法；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span> <br>    Submit <br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>: &#123; <br>    <span class="hljs-attr">warn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">message, event</span>) &#123; <br>        <span class="hljs-comment">// 现在我们可以访问原生事件对象 </span><br>        <span class="hljs-keyword">if</span> (event) &#123; <br>            event.<span class="hljs-title function_">preventDefault</span>() <br>        &#125; <br>        <span class="hljs-title function_">alert</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>事件修饰符使用点符号来表示，接在事件名称的后面，常见的事件修饰包括：</p><ul><li>stop：阻止事件传播</li><li>prevent：取消事件的默认行为</li><li>capture：优先捕获事件进行处理；</li><li>self：限制事件在当前元素；</li><li>once：控制事件只发生一次；</li><li>passive</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- 提交事件不再重载页面 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- 修饰符可以串联 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click.stop.prevent</span>=<span class="hljs-string">&quot;doThat&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- 只有修饰符 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span> <br><span class="hljs-comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-on:click.capture</span>=<span class="hljs-string">&quot;doThis&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>修饰符的顺序是很重要的，不同顺序意味着不一样的行为表现；</p></blockquote><h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p>按键修饰符用来监听键盘的按键，当某个按键被按下松开后，作出相应的响应；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-on:keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h4><p>系统修饰键比较特殊，它相当于要求在触发某个事件前，相应的系统键需要处于被按下的状态</p><ul><li>ctrl</li><li>alt</li><li>shift</li><li>meta</li></ul><h5 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a>.exact 修饰符</h5><p>普通的系统修饰键仅关心某个按键是否被按下，但没有限制是否有多余按键被一起按了；如果要限制仅限某个按键被单独唯一的按下，没有多余的其他键，则可以添加 .exact 修饰符；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.ctrl</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.ctrl.exact</span>=<span class="hljs-string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> <br><br><span class="hljs-comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.exact</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h5><p>用来限制仅某些鼠标按钮被按下时才会触发的事件</p><ul><li>left</li><li>right</li><li>middle</li></ul><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><p>v-model 指令可以在表单输入元素上实现数据的双向绑定；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;收获&quot;&gt;&lt;a href=&quot;#收获&quot; class=&quot;headerlink&quot; title=&quot;收获&quot;&gt;&lt;/a&gt;收获&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在实例化 Vue 对象时，data 属性所引用的 data 对象的属性，在实例时就固定下来了；即如果后续给 data 对象添加的</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="javascript" scheme="http://example.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Cert-Manager 证书申请</title>
    <link href="http://example.com/2021/07/20/Cert-Manager%20%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/"/>
    <id>http://example.com/2021/07/20/Cert-Manager%20%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7/</id>
    <published>2021-07-20T03:46:00.000Z</published>
    <updated>2024-09-21T23:13:54.217Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>目前腾讯云 EKS 安装 cert-manager 和 alidns webhook 过程中会报错，只能使用 TKE</p></blockquote><h2 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h2><ul><li>创建集群</li></ul><h2 id="1-安装-cert-manager"><a href="#1-安装-cert-manager" class="headerlink" title="1. 安装 cert-manager"></a>1. 安装 cert-manager</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v1.3.0/cert-manager.yaml<br></code></pre></td></tr></table></figure><blockquote><p>如果不能访问 github，则可以先下载文件到本地</p></blockquote><h2 id="2-安装-alidns-webhook"><a href="#2-安装-alidns-webhook" class="headerlink" title="2. 安装 alidns-webhook"></a>2. 安装 alidns-webhook</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f https://raw.githubusercontent.com/pragkent/alidns-webhook/master/deploy/bundle.yaml<br></code></pre></td></tr></table></figure><blockquote><p>如果不能访问 github，则可以先下载文件到本地，此步不能太快，需确保第1步安装 cert-manager 时，所有的 pod 都已经正常运行后，再安装 webhook，不然无法成功；当出现失败时，可删除整个  webhook deployment，再重新创建</p></blockquote><h2 id="3-创建访问-AliDNS-解析用的账号密码"><a href="#3-创建访问-AliDNS-解析用的账号密码" class="headerlink" title="3. 创建访问 AliDNS 解析用的账号密码"></a>3. 创建访问 AliDNS 解析用的账号密码</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Secret</span><br><span class="hljs-attr">metadata:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">alidns-secret</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">cert-manager</span><br><span class="hljs-attr">data:</span> <span class="hljs-comment"># 如果用 stringData，则下面两个属性就不需要编码</span><br>    <span class="hljs-attr">access-key:</span> <span class="hljs-string">YOUR_ID</span> <span class="hljs-comment"># 需 base64 转码</span><br>    <span class="hljs-attr">secret-key:</span> <span class="hljs-string">YOUR_KEY</span> <span class="hljs-comment"># 需 base64 转码</span><br></code></pre></td></tr></table></figure><blockquote><p>注：此处的 ID 和 KEY 需要先进行 base64 转码，除非将 data 字段改成 stringData</p></blockquote><h2 id="4-创建-ClusterIssuer"><a href="#4-创建-ClusterIssuer" class="headerlink" title="4. 创建 ClusterIssuer"></a>4. 创建 ClusterIssuer</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">cert-manager.io/v1alpha2</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterIssuer</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">letsencrypt</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">acme:</span><br>    <span class="hljs-attr">email:</span> <span class="hljs-string">YOUR_EMAIL</span> <span class="hljs-comment"># Change to your letsencrypt email</span><br>    <span class="hljs-attr">server:</span> <span class="hljs-string">https://acme-v02.api.letsencrypt.org/directory</span><br>    <span class="hljs-attr">privateKeySecretRef:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">letsencrypt-account-key</span><br>    <span class="hljs-attr">solvers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">dns01:</span><br>        <span class="hljs-attr">webhook:</span><br>          <span class="hljs-attr">groupName:</span> <span class="hljs-string">acme.yourcompany.com</span><br>          <span class="hljs-attr">solverName:</span> <span class="hljs-string">alidns</span><br>          <span class="hljs-attr">config:</span><br>            <span class="hljs-attr">region:</span> <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-attr">accessKeySecretRef:</span><br>              <span class="hljs-attr">name:</span> <span class="hljs-string">alidns-secret</span><br>              <span class="hljs-attr">key:</span> <span class="hljs-string">access-key</span><br>            <span class="hljs-attr">secretKeySecretRef:</span><br>              <span class="hljs-attr">name:</span> <span class="hljs-string">alidns-secret</span><br>              <span class="hljs-attr">key:</span> <span class="hljs-string">secret-key</span><br></code></pre></td></tr></table></figure><h2 id="5-创建证书"><a href="#5-创建证书" class="headerlink" title="5. 创建证书"></a>5. 创建证书</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">cert-manager.io/v1alpha2</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Certificate</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">YOUR_CERT_NAME</span> <span class="hljs-comment"># 证书名，供 pod 引用</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">secretName:</span> <span class="hljs-string">www-example-com-tls</span> <span class="hljs-comment"># 最终签发出来的证书会保存在这个 Secret 里面</span><br>  <span class="hljs-attr">dnsNames:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">www.example.com</span>  <span class="hljs-comment"># 待签发证书的域名</span><br>  <span class="hljs-attr">issuerRef:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">letsencrypt</span><br>    <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterIssuer</span><br></code></pre></td></tr></table></figure><blockquote><p>如果创建过程中出现错误，可以使用 kubectl describe &lt;资源类型&gt; &lt; 资源名称&gt; ，根据显示的消息，进行错误排查，例如：</p><p>kubectl desribe certificate example</p><p>kubectl describe ClusterIssuer example</p><p>详细排查办法查看以下链接：<a href="https://cert-manager.io/docs/faq/acme/">https://cert-manager.io/docs/faq/acme/</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;目前腾讯云 EKS 安装 cert-manager 和 alidns webhook 过程中会报错，只能使用 TKE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;0-准备工作&quot;&gt;&lt;a href=&quot;#0-准备工作&quot; class=&quot;header</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="Kubernetes" scheme="http://example.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>交换机和路由器的区别</title>
    <link href="http://example.com/2021/07/18/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/07/18/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-18T03:09:00.000Z</published>
    <updated>2024-09-21T23:09:09.094Z</updated>
    
    <content type="html"><![CDATA[<h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210718100403.png"></p><p>交换机工作在第2层，它维护着一份 Mac 地址和网线连接端口的映射表，所有连接它的设备都写在表中。当它收到一个数据包时，它读取数据包中的 Mac 地址，然后从映射表中查到对应的端口号，然后将数据包转发到对应的连接端口；</p><p>如果从映射表中找不到 Mac 地址映射，则交换机将简单粗暴的将该数据包发送给所有的端口；之后匹配该 MAC 地址的目标设备会响应交换机，然后交换机就知道拥有该 MAC 地址的设备连接着自己的哪个端口了，然后它会更新自己的映射表，这样下次再有相同的请求进来，就不需要广播，而是直接转发了；</p><blockquote><p>当交换机将数据包广播给所有端口时，其扮演的角色就有点像 Hub 集线器了；</p><p>疑问：发起请求的设备，是如何知道目标设备的 MAC 地址的呢？</p></blockquote><h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210718100335.png"></p><p>路由器工作在第3层，它有两个职责：</p><ul><li>为所有连接它的终端设备建立一个内部局域网；</li><li>与外部局域网建立通信；</li></ul><p>路由器将从第3层中读取 IP 地址信息，然后从其维护的路由表中找到对应的端口号，将数据包转发给相应的端口号。如果找不到，则直接丢弃数据包；</p><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><blockquote><p>Address Resolution Protocol，地址解析协议，其实就是一份 IP 地址和 MAC 地址的映射表</p></blockquote><p>当某个设备  A 连接到路由器上面时，它会被分配一个 IP  地址，同时会被告知网关的 IP 地址。这样，当该设备尝试与另外一台设备通信时，它会先检查自己的 ARP 表中，是否有目标 IP 的 MAC 地址</p><ul><li>如果有，它直接提取该 MAC 地址，写入数据包第2层头部，发送出去；</li><li>如果没有，它需要检查一下该目标设备的 IP 是否与自己在同一个局域网中<ul><li>如果在，它将在局域网中广播一个该 IP 地址的 ARP 请求；持有该 IP 的目标设备将响应该广播，不持有该 IP 的其他设备将忽略该广播；</li><li>如果不在，它将在局域网中广播网关 IP 地址的 ARP 请求，网关在收到该广播后，将会响应自己的 MAC 地址给设备 A；</li></ul></li></ul><p>当通过广播获得 MAC 地址后，设备 A 将该 MAC 地址缓存到自己的 ARP 映射表中，然后将其写入数据包第2层头部发送出去；</p><blockquote><p>很奇怪，为什么不直接使用路由器的 MAC 地址来打包呢，这样就不需要额外发送一次 ARP 请求了；路由器收到后，再解析到第3层中的 IP 来获知数据包的目的地，貌似这种方法也是可以的，为什么要额外引入 ARP 机制呢？</p><p>答：原来是因为两台设备不一定通过路由器连接。当它们通过路由器来连接时，上面的方式确实是可行的。但是它们也有可能是直连，或者通过交换机来连接，这个时候，在生成第2层时，就无法直接填写路由器的 IP  地址了；因此，通用的方式是广播 ARP 请求，来得知目标 IP 地址的 MAC 地址。ARP 机制可以工作在任意一种连接场景中，直连，集线器、交换机、路由器等都可以；</p></blockquote><p>关键点：当某个终端设备被连接时，该设备是不知道也无须知道自己连接的是什么类型的设备，它只需关心自己的工作，即打包好各层数据即可。当缺少目标 MAC 地址时，就广播 ARP 请求得到它，然后完成打包并发送数据即可，剩下的工作都是别人的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;交换机&quot;&gt;&lt;a href=&quot;#交换机&quot; class=&quot;headerlink&quot; title=&quot;交换机&quot;&gt;&lt;/a&gt;交换机&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202107181004</summary>
      
    
    
    
    <category term="运维" scheme="http://example.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TailsOS 注意事项</title>
    <link href="http://example.com/2021/06/30/TailsOS%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://example.com/2021/06/30/TailsOS%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2021-06-29T23:33:00.000Z</published>
    <updated>2024-09-21T23:18:51.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="保护个人身份信息"><a href="#保护个人身份信息" class="headerlink" title="保护个人身份信息"></a>保护个人身份信息</h2><p>可能泄露个人身份信息的活动：</p><ul><li>分享带有元信息的文件，常见的文件元信息包含日期、时间、定位、设备信息等；</li><li>将 Tails 同时用于多种场景；</li></ul><h2 id="Tor-的缺陷"><a href="#Tor-的缺陷" class="headerlink" title="Tor 的缺陷"></a>Tor 的缺陷</h2><ul><li>当使用 Tor 时，不管对于 ISP，还是对于目标网站，都是透明的，只要它们收集一份 Tor 的中继服务器列表，即可知道当前的访问请求来自 Tor 网络；</li><li>当所访问的目标网站没有使用 HTTPS 建立连接时，出口节点可以监听请求内容，甚至伪装成目标网站；</li><li>因为 Tor 使用三节点的固定线路，因此通过监听入口节点和出口节点，比对请求时间和数据包，有可能识别出用户身份（这种方法称为端到端关联攻击）；</li></ul><h2 id="使用事项"><a href="#使用事项" class="headerlink" title="使用事项"></a>使用事项</h2><ul><li>仅当电脑处于关机状态时，再插入并启动，避免在其他系统处于运行状态时插入 U 盘；</li><li>Tails U 盘只用于运行操作系统，避免用它跟其他操作系统拷贝文件；</li><li>尽量避免使用公共电脑运行 Tails，因为其硬件有可能被修改（例如增加键盘记录器来获取输入的各种信息，此时需要通过密码管理器来复制粘贴密码，避免使用键盘输入；或者使用屏幕键盘来点击输入密码）；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;保护个人身份信息&quot;&gt;&lt;a href=&quot;#保护个人身份信息&quot; class=&quot;headerlink&quot; title=&quot;保护个人身份信息&quot;&gt;&lt;/a&gt;保护个人身份信息&lt;/h2&gt;&lt;p&gt;可能泄露个人身份信息的活动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分享带有元信息的文件，常见的文件元信</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>SecurityOS</title>
    <link href="http://example.com/2021/06/21/SecurityOS/"/>
    <id>http://example.com/2021/06/21/SecurityOS/</id>
    <published>2021-06-21T00:46:00.000Z</published>
    <updated>2024-09-21T23:18:47.078Z</updated>
    
    <content type="html"><![CDATA[<p>主打安全的操作系统主要分成两类：</p><ul><li>以匿名为目标；</li><li>以研究为目标，一般包含渗透测试工具；</li></ul><p>常见的三个以匿名为目标的 OS：</p><ul><li>Tails：不在主机上安装保存任何文件或程序，这意味着当移动介质（如 U 盘或光盘）被拔走后，主机上找不到使用记录；</li><li>Qubes：通过创建多个虚拟机，来实现 APP 之间的隔离；这样当某个 APP 被攻击时，不会影响到其他 APP；</li><li>Whonix：通过将应用和通信分成两个模块，所有应用运行在虚拟机中，所有通信由一个单独的网关模块进行控制；网关默认连接到 Tor 网络中；</li></ul><p>三个 OS 实现不同的安全实现，使得它们适用于不同的安全场景，大致如下：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210621084544.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主打安全的操作系统主要分成两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以匿名为目标；&lt;/li&gt;
&lt;li&gt;以研究为目标，一般包含渗透测试工具；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见的三个以匿名为目标的 OS：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tails：不在主机上安装保存任何文件或程序，这意味着</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="安全" scheme="http://example.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
