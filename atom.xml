<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ccw&#39;s Blogs</title>
  
  
  <link href="https://ccw1078.github.io/atom.xml" rel="self"/>
  
  <link href="https://ccw1078.github.io/"/>
  <updated>2024-09-24T00:49:18.943Z</updated>
  <id>https://ccw1078.github.io/</id>
  
  <author>
    <name>ccw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器人建模和控制</title>
    <link href="https://ccw1078.github.io/2024/09/18/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E6%A8%A1%E5%92%8C%E6%8E%A7%E5%88%B6/"/>
    <id>https://ccw1078.github.io/2024/09/18/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BB%BA%E6%A8%A1%E5%92%8C%E6%8E%A7%E5%88%B6/</id>
    <published>2024-09-18T12:21:00.000Z</published>
    <updated>2024-09-24T00:49:18.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h3 id="机器人的数学模型"><a href="#机器人的数学模型" class="headerlink" title="机器人的数学模型"></a>机器人的数学模型</h3><h4 id="机器人的符号表示"><a href="#机器人的符号表示" class="headerlink" title="机器人的符号表示"></a>机器人的符号表示</h4><p>机械臂：由一系列关节+连杆组成的运动链</p><p>关节：</p><ul><li>回转 revolute，用 R 表示</li><li>平动 prismatic，用 P 表示</li></ul><blockquote><p>示例：RRR 机械臂，表示带有三个回转关节的机械臂；</p></blockquote><p>常用关节变量及符号：</p><ul><li>z 表示旋转轴线；</li><li>θ 表示回转关节的角度；</li><li>d 表示平动关节的距离；</li></ul><h4 id="位形空间"><a href="#位形空间" class="headerlink" title="位形空间"></a>位形空间</h4><p>位形：机械臂上各点位置的详细规范；</p><p>位形空间：所有位形的组合，称为位形空间；</p><blockquote><p>示例：如果已知关节变量 θ 和 d 的值，就可以推算出机械臂上任意一点的位置；</p></blockquote><p>因此，位形可由各关节变量值的集合来表示，例如 { q1, q2, q2, …, qn }</p><p>有多少个 q，即相当于有多少个自由度；自由度的个数，相当于位形空间的维度数量；</p><p>三维空间需要6个自由度，才能到达任意一点；但是为了规避障碍，有时需要增加一些冗余的自由度；</p><h4 id="状态空间"><a href="#状态空间" class="headerlink" title="状态空间"></a>状态空间</h4><p>位形是机械臂的一个瞬时状态，但机械臂通常处于运动的状态；因此，使用状态空间，来表示接下来一段时间内，机械臂的所有可能状态的组合；</p><p>关节的下一个时间点的状态，取决于两个变量，一个是关节的当前状态，一个是关节的移动速度；</p><p>因此，对于有 n 个自由度的机械臂来说，它的状态空间有 2n 个维度；</p><h4 id="工作空间"><a href="#工作空间" class="headerlink" title="工作空间"></a>工作空间</h4><p>工作空间表示机械臂在运动过程中，所有可能出现的位置的组合；如果站在这个工作空间内，有可能被打到；如果站在工作空间外，则一定不会被打到；</p><h3 id="作为机械装置的机器人"><a href="#作为机械装置的机器人" class="headerlink" title="作为机械装置的机器人"></a>作为机械装置的机器人</h3><p>机器臂毕竟也是一种机械装置，因此它有一些自己的物理特征；</p><h4 id="机器臂的分类"><a href="#机器臂的分类" class="headerlink" title="机器臂的分类"></a>机器臂的分类</h4><h5 id="动力源"><a href="#动力源" class="headerlink" title="动力源"></a>动力源</h5><p>电力</p><ul><li>优点：便宜、干净、安静；</li><li>缺点：扭矩小；</li></ul><p>液压</p><ul><li>优点：响应速度和扭矩性能好，因此适合提取重物</li><li>缺点：漏油、外围设备多、噪音</li></ul><p>气动</p><ul><li>优点：成本低，结构简单；</li><li>缺点：难以精确控制；</li></ul><h5 id="控制方法"><a href="#控制方法" class="headerlink" title="控制方法"></a>控制方法</h5><p>非伺服：non-servo，开环 open-loop 控制装置，运动范围取决于机械限位，主要用于物料传送；</p><p>伺服：servo，闭环 closed-loop 计算机控制；可编程，多功能；</p><p>早期伺服机器人的末端是点到点的，即通过示教器设置和存储一些离散点，之后末端执行器按顺序经过每个点的位置，最终到达目标点；</p><p>后来的机器人支持设置连续路径，以及速度和加速度，实现更精确的路径控制；</p><h5 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h5><p>装配机器人</p><ul><li>特点：体型小，电力驱动，常采用回转关节或者 SCARA 类型设计；</li></ul><p>非装配机器人</p><ul><li>场景：焊接、喷漆、搬运、装卸等；</li></ul><blockquote><p>二者最大的区别便是精度要求；因为装配件之间存在相互作用力，如果精度不高，便有一定的概率造成破坏或失败；</p></blockquote><h5 id="几何结构"><a href="#几何结构" class="headerlink" title="几何结构"></a>几何结构</h5><p>绝大多数机械臂的自由度不超过6个，有5种常见的几何结构：</p><ul><li>关节链接型 RRR</li><li>球坐标型 RRP</li><li>SCARA型 RRP</li><li>圆柱型 RPP </li><li>直角坐标型 PPP</li></ul><blockquote><p>以上五种都属于串联连杆，还有一种更复杂的并联机器人；</p></blockquote><h4 id="机器人系统"><a href="#机器人系统" class="headerlink" title="机器人系统"></a>机器人系统</h4><p>机械臂仅仅是整个机器人系统中的一个零件，所有零部件包括：</p><ul><li>传感器；</li><li>计算机控制器；</li><li>动力源；</li><li>末端工具；</li><li>输入设备（例如示教器或示教软件）；</li><li>存储设备和网络；</li><li>机械臂；</li></ul><h4 id="精度和重复精度"><a href="#精度和重复精度" class="headerlink" title="精度和重复精度"></a>精度和重复精度</h4><p>精度：预期到达坐标和实际到达坐标之间的误差；</p><p>重复精度：到达示教点的误差；</p><p>分辨率：控制器可检测到的最小运动增量；</p><p>传统的误差测试方法是计算各关节状态变量，而不是直接计算末端位置和姿态；</p><p>这种方法会受到因素的影响，包括：</p><ul><li>机械臂的加工精度；</li><li>计算误差；</li><li>机械臂的柔性变形；</li><li>齿轮间隙；</li><li>摩擦力等；</li></ul><blockquote><p>由于不是直接测量末端，因此为了减少误差，提高精度，机械臂只能做大刚性，以避免变形；</p></blockquote><p>由于两点之间，直线最短。因此线性轴的误差会比旋转轴小一些。但旋转轴的好处是可以让结构变紧凑，占用空间小；</p><h4 id="手腕和末端执行器"><a href="#手腕和末端执行器" class="headerlink" title="手腕和末端执行器"></a>手腕和末端执行器</h4><p>手腕几乎都是旋转关节，而且常用球形手腕；球形手腕有三个自由度，因此可以和机械臂的解耦；</p><p>可以根据不同的任务，开发不同的末端执行器，以便更高效的实现目标；</p><h3 id="常见的运动学配置"><a href="#常见的运动学配置" class="headerlink" title="常见的运动学配置"></a>常见的运动学配置</h3><h4 id="关节型机械臂"><a href="#关节型机械臂" class="headerlink" title="关节型机械臂"></a>关节型机械臂</h4><p>RRR，也叫回转机械臂，由三部分构成，分成叫做腰、肩、肘；其中肩肘的 z 轴一般平行，并垂直于腰的 z 轴；</p><h4 id="球坐标型机械臂"><a href="#球坐标型机械臂" class="headerlink" title="球坐标型机械臂"></a>球坐标型机械臂</h4><p>RRP，肘关节是平动的，垂直于肩关节；这样可使得末端执行器的坐标系和肩关节重合；</p><h4 id="SCARA-机械臂"><a href="#SCARA-机械臂" class="headerlink" title="SCARA 机械臂"></a>SCARA 机械臂</h4><p>也是 RRP，主要用于装配场景，z1, z2, z3 三个轴是平行的；</p><h4 id="圆柱型机械臂"><a href="#圆柱型机械臂" class="headerlink" title="圆柱型机械臂"></a>圆柱型机械臂</h4><p>RPP，腰是旋转的，肩肘是平动的；</p><h4 id="笛卡尔的机械臂"><a href="#笛卡尔的机械臂" class="headerlink" title="笛卡尔的机械臂"></a>笛卡尔的机械臂</h4><p>PPP，例如 3D打印机，或者龙门吊机器人</p><h4 id="并联机械臂"><a href="#并联机械臂" class="headerlink" title="并联机械臂"></a>并联机械臂</h4><p>并联机械臂指多个连杆连接同一个起点，这样可以极大的提高刚性，减少变形，从而提高精度；</p><h3 id="本书概要"><a href="#本书概要" class="headerlink" title="本书概要"></a>本书概要</h3><h4 id="机械臂"><a href="#机械臂" class="headerlink" title="机械臂"></a>机械臂</h4><h5 id="正运动学"><a href="#正运动学" class="headerlink" title="正运动学"></a>正运动学</h5><p>正运动学：使用关节角度，来确定末端执行器的位置；</p><p>当关节较多，使用世界坐标系来计算较为复杂；更简单的方法是在每个关节处建立坐标系，然后不同关节之间，使用固定的变换函数进行变换坐标即可；</p><blockquote><p>世界坐标系貌似也叫做惯性坐标系；</p></blockquote><p>如果需要通过关节速度计算末端的速度，则需要对角度进行求导；据说此处会用一个雅可比矩阵来表示；</p><p>逆雅可比矩阵则可根据末端速度来计算关节的速度；</p><p>当中间关节的角度为 0 或者 180 度时，此时两个连杆处于一条直线状态。在这种状态下，机械臂无法向关节的 x 轴方向移动，雅可比矩阵不可逆，此时机械臂处于奇异位形，存在某些无法实现的无穷小运动。因此，在规划路径时，应避免让机械臂进入奇异位形的状态；</p><h5 id="逆运动学"><a href="#逆运动学" class="headerlink" title="逆运动学"></a>逆运动学</h5><p>逆运动学：由目标位置的坐标，反向求解各关节角度；</p><p>逆运动学的求解，可能存在多种情况。有可能无解，因为不可达。也有可能存在两个解，即上肘位和下肘位。也可能存在无数个解；</p><h5 id="动力学"><a href="#动力学" class="headerlink" title="动力学"></a>动力学</h5><ul><li>拉格朗日动力学</li><li>牛顿欧拉递归方法</li></ul><h5 id="路径和轨迹规划"><a href="#路径和轨迹规划" class="headerlink" title="路径和轨迹规划"></a>路径和轨迹规划</h5><ul><li>路径规划：在不触碰工作内其他物体的情况下，计算一条可到达指定位置的路径；</li><li>轨迹生成：基于时间序列的运动轨迹集合；</li><li>轨迹跟踪</li></ul><h5 id="独立关节控制"><a href="#独立关节控制" class="headerlink" title="独立关节控制"></a>独立关节控制</h5><p>有了参考轨迹后，下一步是给关节控制器发送指令，让关节控制器干活；</p><p>控制器同时处理两个问题，一个是跟踪，一个是抗扰动；因为外部因素如噪音、摩擦等会带来干扰，需要在输入时，动态的计算这些偏差，并时不时调整自己，让误差尽可能的小；</p><p>因此涉及一些零部件如：补偿控制器、功率放大器、传感器等；</p><h5 id="非线性和多变量控制"><a href="#非线性和多变量控制" class="headerlink" title="非线性和多变量控制"></a>非线性和多变量控制</h5><ul><li>李亚普诺夫直接法</li><li>无源性控制；</li></ul><h5 id="力控制"><a href="#力控制" class="headerlink" title="力控制"></a>力控制</h5><p>当末端到达指定位置时，由于不可避免存在误差，有可能会给刚性的机械臂结构带来巨大的作用力，从而造成破坏；为避免悲剧发生，最好能够测量物体间的相互作用力，并作好应对措施，例如力控制或者柔顺控制；</p><h5 id="基于视觉的控制"><a href="#基于视觉的控制" class="headerlink" title="基于视觉的控制"></a>基于视觉的控制</h5><p>相机也可以视为一种传感器，因此可以基于图像进行伺服控制；</p><h5 id="反馈线性化"><a href="#反馈线性化" class="headerlink" title="反馈线性化"></a>反馈线性化</h5><p>将非线性反馈变换成线性的；适用于解决柔性关节机器人的场景；</p><h4 id="欠驱动和移动机器人"><a href="#欠驱动和移动机器人" class="headerlink" title="欠驱动和移动机器人"></a>欠驱动和移动机器人</h4><p>欠驱动：驱动数量少于自由度的数量；</p><p>移动机器人：非完整系统的一种形式，需要新方法将非完整系统转变一种可控和稳定的形式；</p><h2 id="刚体运动"><a href="#刚体运动" class="headerlink" title="刚体运动"></a>刚体运动</h2><p>建立各种坐标系，表示刚体的位置和状态，以及这些坐标系之间的转换；</p><p>齐次变换可在矩阵中同时包含旋转和平移的操作；</p><h3 id="位置的表示"><a href="#位置的表示" class="headerlink" title="位置的表示"></a>位置的表示</h3><p>实体物理空间中的一个点 p，在不同的参考坐标系中，有不同的坐标值；</p><p>对于某个坐标系的原点来说，也是如此。它在自身的坐标系中是原点，坐标为 [0, 0]，但在其他坐标系中，它就不是这个值；</p><p>向量是独立于坐标系的，它用来表示方向；仅仅看向量，并不知道它实际上指向哪里，需要同时结合坐标系的原点后，才有办法判断；</p><p>如果两个坐标系平行，那么两个向量之间是可以进行计算的；但如果不平行，则不行，需要先进行变换，之后才可以计算；</p><h3 id="旋转的表示"><a href="#旋转的表示" class="headerlink" title="旋转的表示"></a>旋转的表示</h3><h4 id="平面内的旋转"><a href="#平面内的旋转" class="headerlink" title="平面内的旋转"></a>平面内的旋转</h4><p>当知道坐标系 A 的原点，在坐标系 B 中的坐标时，就可以知道这两个坐标系之间的姿态关系了，进而还可以计算得出它们的旋转变换方程；其实也很简单，只需要将 B 坐标系的各轴，投影到 A 坐标系中，就知道如何变换了；</p><h4 id="三维空间内的旋转"><a href="#三维空间内的旋转" class="headerlink" title="三维空间内的旋转"></a>三维空间内的旋转</h4><p>同二维，也是通过投影来计算；</p><h3 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h3><p>旋转矩阵可用来表示坐标系 B 相对于另外一个坐标系 A 的姿态角，也可用来表示某个点从 B 到 A 的坐标变换；</p><h4 id="相似变换"><a href="#相似变换" class="headerlink" title="相似变换"></a>相似变换</h4><p>一个坐标系可以定义为一组基本向量，例如沿各坐标轴的单位向量；</p><h3 id="旋转的叠加"><a href="#旋转的叠加" class="headerlink" title="旋转的叠加"></a>旋转的叠加</h3><h4 id="相对于当前坐标系的旋转"><a href="#相对于当前坐标系的旋转" class="headerlink" title="相对于当前坐标系的旋转"></a>相对于当前坐标系的旋转</h4><p>当前坐标系：旋转发生时，所围绕的那个坐标系；</p><p>通过多个坐标系的链式变换，可得到最终坐标系的坐标，即”后乘“；</p><h4 id="相对于固定坐标系的旋转"><a href="#相对于固定坐标系的旋转" class="headerlink" title="相对于固定坐标系的旋转"></a>相对于固定坐标系的旋转</h4><p>相对于当前坐标系，只需以相反的顺序叠加即可，即”前乘“；</p><h4 id="旋转变换的叠加规则"><a href="#旋转变换的叠加规则" class="headerlink" title="旋转变换的叠加规则"></a>旋转变换的叠加规则</h4><p>基于当前坐标系，后乘；</p><p>基于固定坐标系，前乘；</p><h3 id="旋转的参数化"><a href="#旋转的参数化" class="headerlink" title="旋转的参数化"></a>旋转的参数化</h3><p>一个刚体最多只有三个自由度，因为最多只需要三个变量，便可定义其姿态；</p><p>以下是用来表示自由旋转的三种方式：</p><h4 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h4><p>按顺序分别绕 XYZ 三个轴旋转，用三个角度来表示旋转后的坐标系与原坐标系的姿态；每个旋转角度都是基于当前坐标系，而不是世界坐标系；</p><h4 id="滚动-俯仰-偏航"><a href="#滚动-俯仰-偏航" class="headerlink" title="滚动-俯仰-偏航"></a>滚动-俯仰-偏航</h4><p>按顺序分别绕 XYZ 三个轴旋转；三个轴的旋转角度是参照世界坐标系</p><h4 id="转轴-角度"><a href="#转轴-角度" class="headerlink" title="转轴&#x2F;角度"></a>转轴&#x2F;角度</h4><p>自定义一个旋转，让整个坐标系绕该轴旋转一定的角度即可；</p><p>该方法将涉及 4 个参数，其中前 3 个参数用来定义旋转轴，最后一个参数用来定义旋转角度；</p><p>任意一个旋转矩阵，都可以转换成转轴+角度的形式来描述；</p><p>转轴+角度的表示并不唯一，即相反方向的转轴+相反方向的角度，旋转后的结果是一样的的；</p><h4 id="指数坐标"><a href="#指数坐标" class="headerlink" title="指数坐标"></a>指数坐标</h4><p>转轴+角度的另外一种描述形式，用 k 和 θ 两个变量来表示；</p><h3 id="刚体运动的概念"><a href="#刚体运动的概念" class="headerlink" title="刚体运动的概念"></a>刚体运动的概念</h3><p>刚体运动相对旋转变换的唯一区别是增加一个平移变量；</p><p>P<sup>0</sup> &#x3D; R<sub>1</sub><sup>0</sup> P<sup>1</sup> + d<sup>0</sup></p><h4 id="齐次变换"><a href="#齐次变换" class="headerlink" title="齐次变换"></a>齐次变换</h4><p>将平移也添加到矩阵中，这样可以简化计算过程；</p><h4 id="一般刚体运动的指数坐标"><a href="#一般刚体运动的指数坐标" class="headerlink" title="一般刚体运动的指数坐标"></a>一般刚体运动的指数坐标</h4><p>跟旋转变换一样，齐次变换也可使用指数坐标来表示；</p><h2 id="正运动学-1"><a href="#正运动学-1" class="headerlink" title="正运动学"></a>正运动学</h2><p>正运动学：基于各关节的状态（如角度），计算出末端执行器的位置和姿态；</p><h3 id="运动链"><a href="#运动链" class="headerlink" title="运动链"></a>运动链</h3><p>旋转关节或平动关节只有一个自由度，但球窝关节一般有两个自由度，球形腕关节有三个自由度；但后二者可等同视为多个单自由度组合且连杆长度为 0 的情形；所以在计算上面并没有本质的区别；</p><p>根据每个关节相对上一个关节的齐次变换矩阵，通过递归计算，可求解任意一点的位置；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409190900422.png"></p><h3 id="Denavit-约定"><a href="#Denavit-约定" class="headerlink" title="Denavit 约定"></a>Denavit 约定</h3><p>为简化递归分析和计算的复杂性，引入了 Denavit-Hartenberg 约定；它将齐次变换矩阵，替换为四个基本矩阵的乘积。这四个基本矩阵，分别代表连杆长度、连杆扭曲、连杆位移、关节角度；</p><h4 id="存在和唯一性问题"><a href="#存在和唯一性问题" class="headerlink" title="存在和唯一性问题"></a>存在和唯一性问题</h4><p>齐次变换矩阵中，有 6 个参数；按 DH 约定，只剩下了 4 个参数；显然这 4 个参数没有办法表示所有场景，但可以表示满足特殊条件下的所有场景；</p><p>特殊条件包括：</p><ul><li>坐标轴 x<sub>1</sub> 垂直于坐标轴 x<sub>0</sub></li><li>坐标轴 x<sub>1</sub> 与坐标轴 z<sub>0</sub> 相交</li></ul><h4 id="坐标系的配置"><a href="#坐标系的配置" class="headerlink" title="坐标系的配置"></a>坐标系的配置</h4><p>事实上，坐标系的原点是可以任意选择的，并不一定必须设置在连杆的末端；</p><p>不管中间的坐标系如何选择，T<sup>0</sup><sub>n</sub> 都将会是一样的；并且，在一些特殊的情况下，齐次变换方程可以简化；</p><h3 id="正运动学实例"><a href="#正运动学实例" class="headerlink" title="正运动学实例"></a>正运动学实例</h3><p>此处作者举了以下几个例子来示范如何完成正运动学的计算：</p><ul><li>平面肘型机械臂</li><li>三连杆圆柱型机械臂</li><li>球型手腕</li><li>带有球型手腕的圆柱型机械臂</li><li>斯坦福机械臂</li><li>SCARA 型机械臂</li></ul><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章主要介绍如何通过关节变量 q，计算出末端的位置和姿态；</p><h2 id="速度运动学"><a href="#速度运动学" class="headerlink" title="速度运动学"></a>速度运动学</h2><p>本章主要探讨关节的速度与末端的线速度和角速度之间的关系。这种关系，可用一个雅可比矩阵来表示；</p><p>末端执行器的线速度和角速度是一个 6 维向量，对于 n 个连杆的机械臂来说，这种变化关系，也叫雅可比矩阵，便是一个  6*n 的矩阵了；</p><h3 id="角速度：固定转轴情况"><a href="#角速度：固定转轴情况" class="headerlink" title="角速度：固定转轴情况"></a>角速度：固定转轴情况</h3><p>对于围绕某个固定轴的情况，如果角速度是 w，半径是 r，那么线速度 v &#x3D;  w * r</p><p>此时刚体上任意一点的运动轨迹实际上是一个圆（平面），因此它的计算可以进行简化，该简化需要用到反对称矩阵；</p><h3 id="反对称矩阵"><a href="#反对称矩阵" class="headerlink" title="反对称矩阵"></a>反对称矩阵</h3><p>对于 n * n 的矩阵 S，如果  S<sup>T</sup> + S &#x3D; 0 时，那么 S 是一个反对称矩阵；</p><p>反对称矩阵在运算上有一些特性，这些特性会让计算变得方便；</p><h3 id="奇点"><a href="#奇点" class="headerlink" title="奇点"></a>奇点</h3><p>奇点的一些特性：</p><ul><li>在奇点处，某些方向的运动可能无法达到；</li><li>在奇点处，有限的末端速度，可能对应无限的关节速度；</li><li>在奇点处，有限的关节力矩，可能对应无限的末端处的力和力矩；</li><li>奇点通常对应工作空间的边界点；</li><li>受连杆参数微小变化的影响，奇点可能无法到达；</li></ul><h3 id="静态力-力矩的关系"><a href="#静态力-力矩的关系" class="headerlink" title="静态力&#x2F;力矩的关系"></a>静态力&#x2F;力矩的关系</h3><p>当机械臂和环境相互作用时，会受到反作用力，该反作用力会传递给关节，从而在关节处产生力矩；</p><p>理论上来说，通过雅可比矩阵的转置，可以反向计算出关节的受力情况；</p><h3 id="逆向速度和加速度"><a href="#逆向速度和加速度" class="headerlink" title="逆向速度和加速度"></a>逆向速度和加速度</h3><p>逆向速度：通过末端的速度，反向求解关节速度</p><p>加速度：对速度进行求导；</p><h3 id="可操作性"><a href="#可操作性" class="headerlink" title="可操作性"></a>可操作性</h3><p>对于特定的关节角度 q，根据雅可比矩阵，可计算出末端的速度；雅可比矩阵有点类似一个缩放系数；</p><p>在满足特定条件下，末端值的速度取值范围，构成了一个可操作性的椭球；我们可借助可操作性的取值范围，来确定执行特定任务的最佳位形。</p><p>另外，该可操作性，也可帮助我们设计满足特定条件的连杆长度组合；一般来说，当两根连杆的长度相等时，可操作性最大；</p><h2 id="逆运动学-1"><a href="#逆运动学-1" class="headerlink" title="逆运动学"></a>逆运动学</h2><p>基于末端的位置和姿态，反向求解各关节的变量值，称为逆运动学。考虑到解并不唯一，因此它会更加困难一些；</p><h3 id="一般的逆运动学问题"><a href="#一般的逆运动学问题" class="headerlink" title="一般的逆运动学问题"></a>一般的逆运动学问题</h3><p>对于一般的逆运动学问题，末端的位置和姿态变量只有4个，但是待求解的关节变量要远远多于 4 个。这意味着很可能存在无数个解；</p><p>有两种求解方法：</p><ul><li>闭式解：用解析表达式来表达的解，因此也叫做解析解；</li><li>数值方法求解：用数值来表示的解；</li></ul><h3 id="运动解耦"><a href="#运动解耦" class="headerlink" title="运动解耦"></a>运动解耦</h3><p>在特定条件下，我们可以将逆运动学问题拆解成以下两个相对简单的问题：</p><ul><li>逆位置运动学</li><li>逆姿态运动学</li></ul><h3 id="逆位置求解：一种几何方法"><a href="#逆位置求解：一种几何方法" class="headerlink" title="逆位置求解：一种几何方法"></a>逆位置求解：一种几何方法</h3><p>考虑到机械臂的物理构造的特定形式和规律，我们可以通过几何方法来简化逆位置的求解过程。</p><blockquote><p>事实上，正是因为逆运动学问题的求解太过复杂，才导致机械臂的构造形式要保持简单，以便能够求解；</p></blockquote><p>所谓的几何方法，就是将机械臂投影到前一个关节的坐标系平面中，转换成求解一个三角学的问题；简单来说，就是降维求解，将三维空间的问题，降维到二维空间来解决；</p><h3 id="逆姿态求解"><a href="#逆姿态求解" class="headerlink" title="逆姿态求解"></a>逆姿态求解</h3><p>当使用逆位置的几何方法求解后，我们就只剩下三个关节变量未知了；</p><h3 id="逆运动学的数值方法"><a href="#逆运动学的数值方法" class="headerlink" title="逆运动学的数值方法"></a>逆运动学的数值方法</h3><p>随着计算机能发的提升，数值方法变得可行了，有两种方法：</p><ul><li>逆雅可比法；</li><li>雅可比转置法，一种梯度搜索算法</li></ul><h2 id="动力学-1"><a href="#动力学-1" class="headerlink" title="动力学"></a>动力学</h2><p>动力学方程的目标，是解决力和运动之间的关系；有两种常见的解决方案，一种是欧拉-拉格朗日方程，一种是牛顿-欧拉方法；</p><p>计算的目的，估计在于知道动力源如电机，需要以什么样的功率运行，才能够驱动机械臂实现预期中的运动；</p><h3 id="欧拉-拉格朗日方程"><a href="#欧拉-拉格朗日方程" class="headerlink" title="欧拉-拉格朗日方程"></a>欧拉-拉格朗日方程</h3><p>欧拉-拉格朗日方程：一组用来描述系统如何随时间进行变化的微分方程；（前提条件：处于完整约束，且约束力满足虚功原理）；</p><blockquote><p>这个方程可由虚功原理推导出来，也可使用最小作用量原理推导出来；</p><p>完整约束：在讨论物理的运动时，除了基于物理定律，通常还需要假设一些约束条件，减少需要考虑的因素，以便让计算变得简单和纯粹；所谓的完整约束是指，在任意的时刻，粒子的位置都符合对应此刻的确定几何关系；</p><p>虚功：根据给定的虚位移，乘以施加的外力，得到的机械功，称为虚功；</p><p>虚功原理：如果一个物理系统处于平衡状态，那么所有施加在该系统的外力，乘以虚位移，得到的虚功总和，等于零；</p></blockquote><p>物体会受到两个外力影响，一个是天然存在的重力，一个是人工施加的动力，因此拉格朗日算子表示为动能和势能之差；</p><blockquote><p>达朗贝尔定理：如果给每个质点施加一个虚构的反向附加力，那么每个质点将会处于平衡状态；</p></blockquote><h3 id="动能和势能"><a href="#动能和势能" class="headerlink" title="动能和势能"></a>动能和势能</h3><p>如果能使用广义坐标来表示系统的动能和重力势能，那么就能够用欧拉-拉格朗日方程来推导动力学方程；</p><p>对于一个 n 连杆机械臂，其总动能是一个 n * n 的惯性矩阵，这个矩阵是对称且正定的；</p><blockquote><p>正定：总动能是非负的，并且仅在所有关节的速度都为零时，总动能才为零；</p></blockquote><p>机械臂的唯一势能来源是重力，对于重力来说，它仅仅是广义坐标的函数，与速度（坐标的导数）无关；</p><h3 id="运动方程"><a href="#运动方程" class="headerlink" title="运动方程"></a>运动方程</h3><h3 id="一些常见的位形"><a href="#一些常见的位形" class="headerlink" title="一些常见的位形"></a>一些常见的位形</h3><p>前述分析方法在几种机械臂位形中的应用：</p><ul><li>双连杆直角坐标机械臂</li><li>平面肘型机械臂</li><li>带有远程驱动连杆的平面肘型机械臂</li><li>五杆机构</li></ul><h3 id="机器人动力学方程的性质"><a href="#机器人动力学方程的性质" class="headerlink" title="机器人动力学方程的性质"></a>机器人动力学方程的性质</h3><p>n 连杆机器人的动力学方程，包含一些重要的结构特性，这些特性有助于开发控制算法；</p><h4 id="反对称性和无源性"><a href="#反对称性和无源性" class="headerlink" title="反对称性和无源性"></a>反对称性和无源性</h4><p>反对称性：矩阵 N 中的元素，满足 n<sub>j</sub><sub>k</sub> &#x3D; -n<sub>k</sub><sub>j</sub></p><blockquote><p>无源元件：只能接收能量的电子元件；它可以吸收能量，耗散能量，或者存储能量；它发挥这些功能的时候，不需要施加外部电源；例如电阻、电容和电感等；</p><p>有源元件：需要电源才能正常工作的元件；</p></blockquote><p>一个无源的机械系统可由阻尼、质量、弹簧等部分组成；</p><h4 id="惯性矩阵的有界性"><a href="#惯性矩阵的有界性" class="headerlink" title="惯性矩阵的有界性"></a>惯性矩阵的有界性</h4><blockquote><p>注：略</p></blockquote><h4 id="参数的线性化"><a href="#参数的线性化" class="headerlink" title="参数的线性化"></a>参数的线性化</h4><p>机器人的运动方程由连杆质量、惯性矩阵等参数构成；不同的机械人，参数值不同；</p><p>一个给定的刚体，可通过 10 个参数来描述；对于一个 n 连杆的机器人，最多有 10n 个动力学参数；但由于连杆本身存在约束，关节之间相互连接和耦合，所以实际上独立参数的数量要少于 10n</p><p>对于不同的连杆结构，所需的参数数量不同，最少可以只需要 5 个参数；</p><h3 id="牛顿-欧拉公式"><a href="#牛顿-欧拉公式" class="headerlink" title="牛顿-欧拉公式"></a>牛顿-欧拉公式</h3><p>拉格朗日方法，将机械臂当作一个整体来分析；牛顿欧拉方法则单独分析每一个连杆，最后再综合递归计算，可得出相同的结果；</p><p>有两种计算场景：</p><ul><li>广义力已知，想知道运动轨迹；（此类型的问题，拉格朗日方法有优势）</li><li>运动轨迹已知，想知道广义力；（此类型的问题，牛顿欧拉方法有优势）</li></ul><h2 id="路径和轨迹规划-1"><a href="#路径和轨迹规划-1" class="headerlink" title="路径和轨迹规划"></a>路径和轨迹规划</h2><p>机械臂的空间有时候并不是空旷的，而是很可能存在障碍物的约束，包括自体的存在约束；为了避免让机器人碰到障碍物，有必要进行路径规划；</p><p>当机械臂的自由度增加时，路径规划的计算复杂度将以指数级上升。因此完整算法仅可能在低自由度的场景中实现；对于多自由度的场景，需要将其转换成搜索问题，使用启发式算法来解决；</p><p>虽然启发式算法不能覆盖全部答案，但常常已经够用，计算时间可控，能够在绝大部分场景中解决好问题；</p><h3 id="位形空间-1"><a href="#位形空间-1" class="headerlink" title="位形空间"></a>位形空间</h3><p>对于机械臂来说，关节变量组成的向量，可很方便的用来表示位形；</p><p>所有可能与障碍物发生碰撞的位形所组成的集合，称为位形空间障碍；无碰撞位形的集合，则称为自由位形空间；</p><h3 id="平面路径规划"><a href="#平面路径规划" class="headerlink" title="平面路径规划"></a>平面路径规划</h3><p>最终可转换成图结构的搜索问题；图由顶点和边组成；每条边由两个顶点构成；</p><p>三种构造碰撞路径的算法：</p><blockquote><p>以上三种方法主要用于二维空间的场景，如在地面上移动行走的机器人；</p></blockquote><h4 id="可见性图"><a href="#可见性图" class="headerlink" title="可见性图"></a>可见性图</h4><p>可见性图：顶点可以相互看到的图，每对顶点组成一条边，该边不与障碍物内部相交，即两个顶点之间没有东西遮挡；</p><p>这些顶点集合由障碍物的所有顶点，以及机械臂的起点和终点构成；</p><p>可见性图可用来计算起点和终点之间的最短路径，但由于存在一些不确定性，这种路径有些危险，容易出现碰撞；更好的做法或许是寻找离障碍物最远的路径，而不是最近的路径；</p><h4 id="广义-Voronoi-图"><a href="#广义-Voronoi-图" class="headerlink" title="广义 Voronoi 图"></a>广义 Voronoi 图</h4><p>Voronoi 单元：假设平面上有一系列的离散点 p<sub>1</sub> 到 p<sub>n</sub> , Voronoi 单元表示某个区域，在该区域内的所有点，都离该单元的离散点更近，而离其他离散点更远；</p><p>这些单元的界限，便是一条安全的路径了。虽然理论上可以计算出最理想的路径，但简单暴力的网格算法，其实效果也不错；</p><h4 id="梯形分解"><a href="#梯形分解" class="headerlink" title="梯形分解"></a>梯形分解</h4><blockquote><p>问：什么是梯形分解？</p><p>答：使用垂直线段扫描多边形，与多边形的边和顶点构成梯形，将多边形切分解很多个梯形；</p></blockquote><p>对空间进行梯形分解，得到多个梯形后，使用连通图来表达梯形之间的邻接关系；</p><h3 id="人工势场"><a href="#人工势场" class="headerlink" title="人工势场"></a>人工势场</h3><p>将目标位置视为吸引力场，将障碍物体视为排斥力场，将路径规划问题，转换成寻找最小势场值的优化问题，使用梯度下降进行求解；</p><p>考虑到势场中通常会存在局部最小值，为避免卡在局部最小值，一般会引入随机化来逃离陷阱；</p><p>对于引力场，距离越远，引入越接近无穷大；对于斥力场，距离越近，斥力越接近无穷大；</p><h3 id="基于采样的方法"><a href="#基于采样的方法" class="headerlink" title="基于采样的方法"></a>基于采样的方法</h3><p>先使用随机策略生成一系列的位形，然后从中筛选出可行的路径；有两种规划算法：</p><h4 id="概率路线图"><a href="#概率路线图" class="headerlink" title="概率路线图"></a>概率路线图</h4><p>步骤：</p><ul><li>在位形空间中，生成一组随机样本，并只保留无碰撞的样本；</li><li>使用简单的直线路径，将每个样本与其最近的节点相连；并只保留无碰撞的路径；<ul><li>注：此时节点将分成几组，各组内部的节点相互连接，但组与组之间没有连接；</li></ul></li><li>增强阶段：生成一些额外的节点，在无碰撞的情况下，将不同组连接在一起；</li><li>将起点和终点连接到路线图中，从中找到一条从起点通往终点的路径；</li></ul><p>缺点：完全随机的情况下，有时候会出现死胡同；</p><h4 id="快速探索随机树"><a href="#快速探索随机树" class="headerlink" title="快速探索随机树"></a>快速探索随机树</h4><p>从起始点处开始构建一棵随机树，直到某些叶子节点，达到目标位形为止；</p><p>步骤：</p><ul><li>基于均匀概率分布，生成 sample；</li><li>从现有树中，找出离 sample 最近的顶点 near；</li><li>从 near 往 sample 的方向迈出一小步，得到 new；</li><li>如果 new 无碰撞，则将其添加到现有树中；</li></ul><p>优点：快速探索随机数已被证明能够有效的应对复杂的路径规划场景，例如自动驾驶、无人机、卫星、航天器等；</p><h3 id="轨迹规划"><a href="#轨迹规划" class="headerlink" title="轨迹规划"></a>轨迹规划</h3><p>得到位形后，下一步就要基于这些位形，构建运动轨迹；</p><ul><li>点到点运动的轨迹：单关节的情形；</li><li>通过中间点确定路径的轨迹；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导论&quot;&gt;&lt;a href=&quot;#导论&quot; class=&quot;headerlink&quot; title=&quot;导论&quot;&gt;&lt;/a&gt;导论&lt;/h2&gt;&lt;h3 id=&quot;机器人的数学模型&quot;&gt;&lt;a href=&quot;#机器人的数学模型&quot; class=&quot;headerlink&quot; title=&quot;机器人的数学模型&quot;</summary>
      
    
    
    
    <category term="计算机" scheme="https://ccw1078.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="机器人" scheme="https://ccw1078.github.io/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>大模型应用开发极简入门</title>
    <link href="https://ccw1078.github.io/2024/08/22/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/"/>
    <id>https://ccw1078.github.io/2024/08/22/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/</id>
    <published>2024-08-22T09:06:00.000Z</published>
    <updated>2024-09-25T10:22:47.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-初识-GPT-4"><a href="#第1章-初识-GPT-4" class="headerlink" title="第1章  初识 GPT-4"></a>第1章  初识 GPT-4</h1><h2 id="LLM-概述"><a href="#LLM-概述" class="headerlink" title="LLM 概述"></a>LLM 概述</h2><h3 id="探索语言模型和-NLP-的基础"><a href="#探索语言模型和-NLP-的基础" class="headerlink" title="探索语言模型和 NLP 的基础"></a>探索语言模型和 NLP 的基础</h3><p>GPT-4 和 ChatGPT 基于一种特定的神经网络架构 Transformer；</p><p>Transformer 通过关注句子和段落的不同部分，学习到句子中各个单词的模式和关系，从而能够理解上下文；因此，Transformer 很擅长语言翻译、问题回答和文本生成类的任务；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408221715502.png"></p><p>最早的语言模型是 n-gram，它的原理很简单，就是统计各个单词之间按顺序出现的概率。当给出 A 单词时，它根据概率预测预测下一个单词 B；</p><p>为了提高 n-gram 的性能，之后引入了循环神经网络（RNN，recurrent neural networ）和长短期记忆（LSTM，long short term memory）的方法，以便模型能够更好的理解上下文；</p><h3 id="理解-Transformer"><a href="#理解-Transformer" class="headerlink" title="理解 Transformer"></a>理解 Transformer</h3><p>在处理短文本时，RNN 效果还行，但如果是长文本，上下文很大，超过了 RNN 的处理能力，容易出现上下文遗忘的问题；</p><p>Transformer 通过使用注意力机制，解决了 RNN 面临问题；所谓的注意力机制，即模型不再将所有单词视为同等重要，而是只关注其中少数几个关键词，这样既降低了数据处理的负担，又提高了准确性；</p><p>注意力机制有两个模块，分别为：</p><ul><li>交叉注意力：输入与输出的相关性匹配；（关注重点）</li><li>自注意力：区分输入的不同部分之间的相对重要性；（分清主次）</li></ul><blockquote><p>自注意力机制给句子中的不同单词分配不同的权重后，有助于抓出核心单词，构建新的抽象概念；</p></blockquote><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408221802033.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408221804215.png"></p><h3 id="解密-GPT-模型的标记化和预测步骤"><a href="#解密-GPT-模型的标记化和预测步骤" class="headerlink" title="解密 GPT 模型的标记化和预测步骤"></a>解密 GPT 模型的标记化和预测步骤</h3><p>文本补全：接受一段输入（提示词），生成一段输出；</p><p>Transformer 架构使得模型能够识别关键信息和上下文；它在生成预测时，也用到了迭代机制，即先预测下一个最有可能出现的词，之后基于包含预测词的新句子，再次预测下一个可能出现的词。不断迭代重复这个过程，直到生成整个完整的句子；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408231018506.png"></p><h2 id="GPT-模型简史"><a href="#GPT-模型简史" class="headerlink" title="GPT 模型简史"></a>GPT 模型简史</h2><p>早期的 NLP 模型是监督式的，用于分类预测，需要使用标注数据进行训练，但标注的成本很高，难以获得大规模的训练数据；GPT 则是无监督式的，突破了这个限制，模型参数的数量也因此急剧膨胀；</p><p>基于预测的工作模式，并不能满足大部分使用场景，因此 GPT3 引入了微调和反馈，即使用提示词让模型根据反馈再次学习，从而得出更准确的结果；</p><p>所谓的微调和反馈，即人工编写一个示例打个样，然后做为训练数据，让模型学习；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408231103755.png"></p><p>微调的三个步骤：</p><ul><li>制作示例，训练模型</li><li>基于相同问题，设置不同的随机数（temperature），以便模型输出多个不同的结果，然后给结果打分；</li><li>基于打分结果，设置奖励机制，再次训练模型；</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul><li>Be My Ayes：作为盲人的虚拟助手，帮助他们获得视觉信息；</li><li>摩根士丹利：从公司报告库中，快速检索文本，以获得答案；</li><li>可汗学院：生成虚拟的教学助手，回答学生的提问，并给予鼓励；</li><li>多邻国：通过角色扮演，让学生获得沉浸式的学习氛围</li><li>Yabble：分析消费者的数据，提供见解，辅助决策；</li><li>Waymark：快速生成视频脚本，提高视频制作人员的效率；</li><li>Inworld AI：生成有趣、有独特性格特点的游戏角色，提高游戏开发效率；</li></ul><h2 id="AI-幻觉"><a href="#AI-幻觉" class="headerlink" title="AI 幻觉"></a>AI 幻觉</h2><p>模型很适合用来处理创意型的任务，因为这些任务并没有标准答案。但目前还不太适合用来生成严肃问题的答案，例如医学诊断等；因为这些任务的准确性要求很高，而且 AI 的本质上是预测，因此有时候它提供的答案并不正确，却对错误答案信誓旦旦，有可能会误导提问者；</p><h2 id="使用插件和微调优化-GPT-模型"><a href="#使用插件和微调优化-GPT-模型" class="headerlink" title="使用插件和微调优化 GPT 模型"></a>使用插件和微调优化 GPT 模型</h2><p>使用插件能够让 GPT 能够更好的处理特定任务；</p><h1 id="第2章-深入了解-API"><a href="#第2章-深入了解-API" class="headerlink" title="第2章  深入了解 API"></a>第2章  深入了解 API</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>针对不同的使用场景，OpenAI 提供了不同的模型，几种场景包括：</p><ul><li>聊天</li><li>助手</li><li>补全</li><li>文本转语音</li></ul><h2 id="OpenAI-的模型"><a href="#OpenAI-的模型" class="headerlink" title="OpenAI 的模型"></a>OpenAI 的模型</h2><ul><li>InstructGPT</li><li>ChatGPT</li><li>GPT-4</li></ul><h2 id="使用-GPT-模型"><a href="#使用-GPT-模型" class="headerlink" title="使用 GPT 模型"></a>使用 GPT 模型</h2><p>预设提示词的使用示例，每个示例提供了一些特定的自定义参数；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408231602686.png"></p><p>OpenAI 既可以使用 GUI 来调用，也可以通过 API 来调用；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openai<br>openai.api_key = os.getenv(<span class="hljs-string">&quot;OPENAI_API_KEY&quot;</span>)<br>response = openai.Completion.create(<br>    model=<span class="hljs-string">&quot;text-davinci-003&quot;</span>,<br>    prompt=<span class="hljs-string">&quot;As Descartes said, I think therefore&quot;</span>,<br>    temperature=<span class="hljs-number">0.7</span>,<br>    max_tokens=<span class="hljs-number">3</span>,<br>    top_p=<span class="hljs-number">1</span>,<br>    frequency_penalty=<span class="hljs-number">0</span>,<br>    presence_penalty=<span class="hljs-number">0</span>,<br>)<br></code></pre></td></tr></table></figure><h2 id="OpenAI-Python"><a href="#OpenAI-Python" class="headerlink" title="OpenAI Python"></a>OpenAI Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openai<br><span class="hljs-comment">#对GPT-3.5 Turbo来说，端点是ChatCompletion</span><br>openai.ChatCompletion.create(<br>    <span class="hljs-comment">#对GPT-3.5 Turbo来说，模型是gpt-3.5-turbo</span><br>    model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>,<br>    <span class="hljs-comment">#消息列表形式的对话</span><br>    messages=[<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;You are a helpful teacher.&quot;</span>&#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,<br>            <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;Are there other measures than time \</span><br><span class="hljs-string">            complexity for an algorithm?&quot;</span>,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>,<br>            <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;Yes, there are other measures besides time \</span><br><span class="hljs-string">            complexity for an algorithm, such as space complexity.&quot;</span>,<br>        &#125;,<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;What is it?&quot;</span>&#125;,<br>    ],<br>)<br></code></pre></td></tr></table></figure><p>每次调用 API 时，都需要附带整个对话记录，因为模型并不记忆上下文，所以需要在请求中携带上下文；</p><h3 id="从文本补全到函数"><a href="#从文本补全到函数" class="headerlink" title="从文本补全到函数"></a>从文本补全到函数</h3><p>以下示例通过文字描述想要查询的目标，由 GPT 转成 SQL 语句，然后调用预设好的函数，执行该 SQL 语句；得到数据库的查询结果后，再发给 GPT，转换成普遍人能够读懂的结果（用文字来描述查询结果）；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例函数（有点像 JS 里面的回调函数）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_product</span>(<span class="hljs-params">sql_query</span>):<br>    results = [<br>        &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;pen&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">1.99</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;pen&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;price&quot;</span>: <span class="hljs-number">1.78</span>&#125;,<br>    ]<br>    <span class="hljs-keyword">return</span> results<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 函数定义</span><br>functions = [<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;find_product&quot;</span>,<br>        <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Get a list of products from a sql query&quot;</span>,<br>        <span class="hljs-string">&quot;parameters&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>            <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;sql_query&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>                    <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;A SQL query&quot;</span>,<br>                &#125;<br>            &#125;,<br>            <span class="hljs-string">&quot;required&quot;</span>: [<span class="hljs-string">&quot;sql_query&quot;</span>],<br>        &#125;,<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#示例问题</span><br>user_question = <span class="hljs-string">&quot;I need the top 2 products where the price is less</span><br><span class="hljs-string">    than 2.00&quot;</span><br>messages = [&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: user_question&#125;]<br><span class="hljs-comment">#使用函数定义调用ChatCompletion端点</span><br>response = openai.ChatCompletion.create(<br>        model=<span class="hljs-string">&quot;gpt-3.5-turbo-0613&quot;</span>, messages=messages,<br>            functions=functions<br>)<br>response_message = response[<span class="hljs-string">&quot;choices&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;message&quot;</span>]<br>messages.append(response_message)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">&quot;function_call&quot;: &#123;</span><br><span class="hljs-string">        &quot;name&quot;: &quot;find_product&quot;,</span><br><span class="hljs-string">        &quot;arguments&quot;: &#x27;&#123;\n &quot;sql_query&quot;: &quot;SELECT * FROM products \</span><br><span class="hljs-string">    WHERE price &lt; 2.00 ORDER BY price ASC LIMIT 2&quot;\n&#125;&#x27;,</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#调用函数</span><br>function_args = json.loads(<br>    response_message[<span class="hljs-string">&quot;function_call&quot;</span>][<span class="hljs-string">&quot;arguments&quot;</span>]<br>)<br>products = find_product(function_args.get(<span class="hljs-string">&quot;sql_query&quot;</span>))<br><span class="hljs-comment">#将函数的响应附加到消息中</span><br>messages.append(<br>    &#123;<br>        <span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;function&quot;</span>,<br>        <span class="hljs-string">&quot;name&quot;</span>: function_name,<br>        <span class="hljs-string">&quot;content&quot;</span>: json.dumps(products),<br>    &#125;<br>)<br><span class="hljs-comment">#将函数的响应格式化为自然语言</span><br>response = openai.ChatCompletion.create(<br>    model=<span class="hljs-string">&quot;gpt-3.5-turbo-0613&quot;</span>,<br>    messages=messages,<br>)<br></code></pre></td></tr></table></figure><p>基于聊天模型的输入，必须使用对话格式；而补全模型的输入则可以是单独的提示词；</p><h2 id="其他-API-功能"><a href="#其他-API-功能" class="headerlink" title="其他 API 功能"></a>其他 API 功能</h2><h3 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h3><p>将不是数值类型的元素，转换成数值向量；嵌入有个突出的特点，即它将数据转换成数值格式后，这些数值之间仍然保持语义相似性；即含义相近的词，在数值空间的距离也更近；</p><p>嵌入在 LLM 中用得非常广泛，一般使用 512 维来表示，这使得模型能够存储复杂的关系；</p><h3 id="内容审核模型"><a href="#内容审核模型" class="headerlink" title="内容审核模型"></a>内容审核模型</h3><p>为了确保用户输入的提示词，符合法律规定，OpenAI 还部署了一个内容审核模型，以确保用户的输入合法；</p><h3 id="Whipser-和-DALL-E"><a href="#Whipser-和-DALL-E" class="headerlink" title="Whipser 和 DALL-E"></a>Whipser 和 DALL-E</h3><p>Whipser 用于语音识别、翻译等场景；</p><p>DALL-E 则能够根据自然语言的描述，生成图片；</p><h1 id="第3章-构建应用程序"><a href="#第3章-构建应用程序" class="headerlink" title="第3章  构建应用程序"></a>第3章  构建应用程序</h1><h2 id="应用程序开发概述"><a href="#应用程序开发概述" class="headerlink" title="应用程序开发概述"></a>应用程序开发概述</h2><p>从环境变量读取密钥</p><h2 id="软件架构设计原则"><a href="#软件架构设计原则" class="headerlink" title="软件架构设计原则"></a>软件架构设计原则</h2><p>OpenAPI 的接口很可能会更新，因此有必要在前端与 OpenAI 之间增加一层抽象，以便将前端和 OpenAI 之间进行解耦</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408231735305.png"></p><h2 id="LLM-驱动型应用程序的漏洞"><a href="#LLM-驱动型应用程序的漏洞" class="headerlink" title="LLM 驱动型应用程序的漏洞"></a>LLM 驱动型应用程序的漏洞</h2><p>由于用户的输入存在不可控的因素，因此有必要采取措施，对输入进行检查，否则有可能会发生注入攻击；</p><h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><h3 id="新闻稿生成器"><a href="#新闻稿生成器" class="headerlink" title="新闻稿生成器"></a>新闻稿生成器</h3><p>根据某个事实发生的事件，生成新闻稿；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openai<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ask_chatgpt</span>(<span class="hljs-params">messages</span>):<br>    response = openai.ChatCompletion.create(<br>        model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>, messages=messages<br>    )<br>    <span class="hljs-keyword">return</span> response[<span class="hljs-string">&quot;choices&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;message&quot;</span>][<span class="hljs-string">&quot;content&quot;</span>]<br><br><br>prompt_role = <span class="hljs-string">&quot;You are an assistant for journalists. \</span><br><span class="hljs-string">    Your task is to write articles, based on the FACTS that are given to you. \</span><br><span class="hljs-string">    You should respect the instructions: the TONE, the LENGTH, \</span><br><span class="hljs-string">and the STYLE&quot;</span><br><br><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Listdef assist_journalist(<br>    facts: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], tone: <span class="hljs-built_in">str</span>, length_words: <span class="hljs-built_in">int</span>, style: <span class="hljs-built_in">str</span><br>):<br>    facts = <span class="hljs-string">&quot;, &quot;</span>.join(facts)<br>    prompt = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prompt_role&#125;</span> \</span><br><span class="hljs-string">        FACTS: <span class="hljs-subst">&#123;facts&#125;</span> \</span><br><span class="hljs-string">        TONE: <span class="hljs-subst">&#123;tone&#125;</span> \</span><br><span class="hljs-string">        LENGTH: <span class="hljs-subst">&#123;length_words&#125;</span> words \</span><br><span class="hljs-string">        STYLE: <span class="hljs-subst">&#123;style&#125;</span>&quot;</span><br>    <span class="hljs-keyword">return</span> ask_chatgpt([&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: prompt&#125;])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试</span><br><span class="hljs-built_in">print</span>(<br>    assist_journalist(<br>        [<span class="hljs-string">&quot;The sky is blue&quot;</span>, <span class="hljs-string">&quot;The grass is green&quot;</span>], <span class="hljs-string">&quot;informal&quot;</span>, \<br>            <span class="hljs-number">100</span>, <span class="hljs-string">&quot;blogpost&quot;</span><br>    )<br>)<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 生成结果</span><br>&quot;Hey, everyone! Did you know that the sky is blue and the grass is green?<br>I mean, it&#x27;s something we see every day and probably take for granted,<br>but it&#x27;s still pretty amazing if you think about it! The sky appears<br>blue to us because of something called Rayleigh scattering – basically,<br>the molecules in the Earth&#x27;s atmosphere scatter sunlight in all different<br>directions. Blue light has a shorter wavelength, so it gets scattered<br>more than the other colors in the spectrum. That&#x27;s why the sky looks<br>blue most of the time! As for the grass being green... that&#x27;s due to<br>chlorophyll, the pigment that helps plants capture sunlight to make<br>their food. Chlorophyll absorbs red and blue light, but reflects<br>green light, which is why we see plants as green.<br>It&#x27;s pretty cool how science explains these things we take for granted,<br>don&#x27;t you think? Next time you&#x27;re outside, take a moment to appreciate<br>the color palette around you!&quot;<br></code></pre></td></tr></table></figure><h3 id="Youtube-视频摘要"><a href="#Youtube-视频摘要" class="headerlink" title="Youtube 视频摘要"></a>Youtube 视频摘要</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> openai<br><br><span class="hljs-comment">#从文件中读取文字记录with open(&quot;transcript.txt&quot;, &quot;r&quot;) as f:</span><br>transcript = f.read()<br><br><span class="hljs-comment">#调用ChatCompletion端点，并使用gpt-3.5-turbo模型</span><br>response = openai.ChatCompletion.create(<br>    model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>,<br>    messages=[<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;You are a helpful assistant.&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;Summarize the following text&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;Yes.&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: transcript&#125;,<br>    ],<br>)<br><br><span class="hljs-built_in">print</span>(response[<span class="hljs-string">&quot;choices&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;message&quot;</span>][<span class="hljs-string">&quot;content&quot;</span>])<br></code></pre></td></tr></table></figure><p>如果视频脚本很长，超过了 API 字数上限的话，那么可以考虑将脚本分成多个段落，每个段落生成一份小摘要，最后再汇总小摘要，生成一份大摘要；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408231751549.png"></p><h3 id="打造游戏专家"><a href="#打造游戏专家" class="headerlink" title="打造游戏专家"></a>打造游戏专家</h3><p>目标：构建一个 AI 助手，它能够根据任天堂的操作指南，回答用户关于《塞尔达传说》的相关问题；</p><p>有两种常见的微调模型的方法</p><ul><li>基于特定的数据集，对模型进行二次训练；</li><li>小样本学习；</li></ul><p>还有第三种方法：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408231756052.png"></p><p>即将整个过程拆分三个步骤：</p><ul><li>先让 GPT 解析问题的意图（将用户的问题作为提示关键词，让转成嵌入）；</li><li>基于解析后的意图，从数据库中搜索匹配的数据（数据需要提前转成嵌入）；</li><li>将数据提交给 GPT，让其整理后返回最终答案；</li></ul><blockquote><p>以上方法规避了每次将整本指南发送给 GPT 的问题。虽然效果不一定很完美，但大部分情况都OK；</p></blockquote><h3 id="语音控制"><a href="#语音控制" class="headerlink" title="语音控制"></a>语音控制</h3><p>控制流程示例如下：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408231830898.png"></p><p>可使用语音转文本工具，例如  Whisper，先将语音转成文本；之后是一个状态机，让 GPT 判断用户的意图，然后根据不同的意图，调用不同的接口，来实现意图；当然，有可能用户的意图不明确，此时可让用户提供更多的信息；有点像是一个状态机；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义discussion函数，它让系统能够在各个状态之间切换：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">discussion</span>(<span class="hljs-params">messages, last_step</span>):<br>    <span class="hljs-comment">#调用OpenAI API以获取下一个状态</span><br>    answer = generate_answer(messages)<br>    <span class="hljs-keyword">if</span> answer <span class="hljs-keyword">in</span> prompts.keys():<br>        <span class="hljs-comment">#找到一个新状态，将其添加到消息列表中</span><br>        messages.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: answer&#125;)<br>        messages.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: prompts[answer]&#125;)<br>        <span class="hljs-comment">#递归式遍历状态机return discussion(messages, answer)</span><br>    <span class="hljs-keyword">elif</span> answer <span class="hljs-keyword">in</span> actions.keys():<br>        <span class="hljs-comment">#新状态是一个动作</span><br>        do_action(answer)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment">#我们处于END状态</span><br>        <span class="hljs-comment">#如果上一步是MORE，那么保留消息的历史记录</span><br>        <span class="hljs-comment">#否则重新开始if last_step != &#x27;MORE&#x27;:</span><br>        messages=[]<br>        last_step = <span class="hljs-string">&#x27;END&#x27;</span><br>     <span class="hljs-keyword">return</span> answer<br></code></pre></td></tr></table></figure><h1 id="第4章-高级技巧"><a href="#第4章-高级技巧" class="headerlink" title="第4章 高级技巧"></a>第4章 高级技巧</h1><h2 id="提示工程"><a href="#提示工程" class="headerlink" title="提示工程"></a>提示工程</h2><p>提示词的数量会影响 OpenAI 的使用成本，稳妥起见，最好设置 max_tokens 参数，以便意义发送大量数据，导致费用大幅超支；</p><h3 id="设计有效的提示词"><a href="#设计有效的提示词" class="headerlink" title="设计有效的提示词"></a>设计有效的提示词</h3><p>提示词的三个要素：</p><ul><li>角色</li><li>上下文</li><li>任务</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409241455928.png"></p><p>如何描述上下文，以便 GPT 更好的理解我们的意图，有时候并不容易，因为我们本身对问题也不是非常了解，所以无法提供更具体的信息。遇到这种情况，我们可以询问 GPT 它想知道哪些上下文，让它提问题，我们来回答。</p><p>任务：用来告诉 GPT 需要做什么，因此应该尽量描述得具体和明确一些；</p><p>角色：用来告诉 GPT 要以什么样的身份给出回答。相同的问题，由不同的角色回答，其答案会有所不同；角色并不是必须的，但使用角色可以让结果更加符合我们的预期；</p><p>prompt 提示词的作用有点像是函数参数，用来调整 GPT 内部的概率分布，引导模型生成我们想要的结果；上下文+角色+任务只是一种提示词的常用结构，但并不是唯一的结构，完成可以根据任务需要，设计其他更合理的结构；</p><h3 id="逐步思考"><a href="#逐步思考" class="headerlink" title="逐步思考"></a>逐步思考</h3><p>有时候有些问题可能比较复杂，难以在下一句对话中得出结果。此时可以考虑在提示词中添加 ”Let’s think step by step“（让我们逐步思考），来引导 GPT 模拟中间推理，将一个大问题，拆分成多个小问题进行处理；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409241908632.png"></p><p>以下是模型的输出：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409241908073.png"></p><h3 id="实现少样本学习"><a href="#实现少样本学习" class="headerlink" title="实现少样本学习"></a>实现少样本学习</h3><p>少样本学习：在提示词中，给 GPT 提供示例，让其模仿；</p><p>以下示例的目标，是让 GPT 将部分文本转成表情；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409241911000.png"></p><p>对于简一些的任务，甚至可以使用单样本，这样有助于减少费用；</p><blockquote><p>提示词工程并没有标准答案，它更像是医学，在反复试错中，找到更好的方案和技巧；</p></blockquote><h3 id="改善提示效果"><a href="#改善提示效果" class="headerlink" title="改善提示效果"></a>改善提示效果</h3><p>一些提示词的技巧：</p><h4 id="指示模型提出更多的问题"><a href="#指示模型提出更多的问题" class="headerlink" title="指示模型提出更多的问题"></a>指示模型提出更多的问题</h4><p>在提示词的结尾，询问模型是否理解问题，并指示模型提出更多的问题，示例如下：</p><blockquote><p>你清楚地理解我的请求了吗？如果没有，请问我关于上下文的问题。这样一来，当我回答时，你就能够更高效地执行我所请求的任务</p></blockquote><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>明确指示结果应该被某种格式化工具所接受</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409241917864.png"></p><h4 id="重复指示"><a href="#重复指示" class="headerlink" title="重复指示"></a>重复指示</h4><p>在提示词中多次添加相同意图的指令，但指令的表达方式有所不同</p><h4 id="使用负面提示"><a href="#使用负面提示" class="headerlink" title="使用负面提示"></a>使用负面提示</h4><p>在提示词中举反例，告诉模型自己不想要什么样的结果。这些负面提示在本质上有点像是结果筛选器；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409241919589.png"></p><h4 id="添加长度限制"><a href="#添加长度限制" class="headerlink" title="添加长度限制"></a>添加长度限制</h4><p>在提示词明确提出答案应该满足的长度要求，示例如下：</p><blockquote><p>如果你能回答，说 YES；如果你需要更多信息，说 MORE；如果你不能回答，说 NO；回答的长度只限一个单词</p></blockquote><h2 id="微调模型"><a href="#微调模型" class="headerlink" title="微调模型"></a>微调模型</h2><p>想要获得预期结果，除了使用提示词技巧外，还有一种策略是微调模型，以便提高模型处理特定任务时的表现；</p><h3 id="开始微调"><a href="#开始微调" class="headerlink" title="开始微调"></a>开始微调</h3><p>目标：实现一个电子邮件自动回复，邮件内容保持跟之前相同的风格，即使用行业专用语汇</p><p>微调的本质是修改模型中原有参数的权重，得到一个新的模型，以更好的适应特定任务；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409250833734.png"></p><blockquote><p>注：OpenAI 上面有多个基础模型，参数数量不同；其中能够进行微调的模型数量是有限的；</p></blockquote><blockquote><p>问：什么是 InstructGPT 系列？</p><p>答：对原始模型（GPT-3）的输出，使用人工反馈进行强化学习（RLHF），微调后的新模型；</p></blockquote><p>微调步骤：</p><ul><li>选择一个大小合适的基础模型；</li><li>准备好足够的数据集，重新训练模型；</li></ul><p>对于简单的任务，通常使用少样本学习就够用了。对于特定领域的复杂任务，则需要使用微调模型的方法。但使用这个方法有一个局限性，则受限于可使用的训练数据数量。当任务较为简单，可能几百个训练数据就够了。但如果任务特别复杂，那可能将涉及以万或者百万为单位的数据集。数据集来源不足可能会是一个问题，另外训练成本也将急剧上升；</p><h3 id="使用-OpenAI-API-进行模型微调"><a href="#使用-OpenAI-API-进行模型微调" class="headerlink" title="使用 OpenAI API 进行模型微调"></a>使用 OpenAI API 进行模型微调</h3><h4 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h4><p>数据集是一个 JSONL 文件，相当于多行的 JSON 组成的文件，示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;prompt text&gt;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;completion text&gt;&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;prompt text&gt;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;completion text&gt;&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;prompt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;prompt text&gt;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;completion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;completion text&gt;&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>OpenAI 有自带一个格式转换的命令行工具，可用来协助生成数据集，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">openai tools fine_tunes.prepare_data -f &lt;LOCAL_FILE&gt;<br></code></pre></td></tr></table></figure><h4 id="上传数据"><a href="#上传数据" class="headerlink" title="上传数据"></a>上传数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">openai.File.create(<br>    file=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;out_openai_completion_prepared.jsonl&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>),<br>    purpose=<span class="hljs-string">&#x27;fine-tune&#x27;</span>  <span class="hljs-comment"># 此参数表示要微调模型</span><br>)<br></code></pre></td></tr></table></figure><p>调用 OpenAI 内置函数上传数据，该函数会返回一个对象；对象中有文件 ID，该 ID 可作为创建模型的参数，以便创建模型时，可引用该份已上传的数据；</p><h4 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h4><p>上传完训练数据后，OpenAI 服务端会开启一个训练作业。可调用函数查询该作业的排队和训练的进度状态；</p><h3 id="微调的应用场景"><a href="#微调的应用场景" class="headerlink" title="微调的应用场景"></a>微调的应用场景</h3><ul><li>法律文本分析：因为法律文件一般包含很多法律术语，所以微调模型可以显著提高性能；</li><li>自动代码审查：例如 Github 的 Copilot；</li><li>财务报表摘要</li><li>技术文档翻译：同样是包含诸多专业术语；</li></ul><p>根据以上的应用场景可以发现，微调模型特别适用于在专业领域中生成专业的内容，例如某个特定领域的客服聊天机器人；</p><h3 id="案例演示：电子邮件营销"><a href="#案例演示：电子邮件营销" class="headerlink" title="案例演示：电子邮件营销"></a>案例演示：电子邮件营销</h3><p>目的：使用电子邮件，向目标用户（线下商店）推广在线支付服务（例如微信、支付宝等）；</p><p>步骤如下：</p><h4 id="创建合成的数据集"><a href="#创建合成的数据集" class="headerlink" title="创建合成的数据集"></a>创建合成的数据集</h4><p>理论上最理想的办法是使用人工来创建训练数据，但如果需要的数据量很大，会导致成本很高，并不划算。因此我们也可以考虑让 GPT 生成一些数据；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 区别不同类型、不同城市、不同规模的商店，以便生成有针对性的内容</span><br>l_sector = [<span class="hljs-string">&#x27;Grocery Stores&#x27;</span>, <span class="hljs-string">&#x27;Restaurants&#x27;</span>, <span class="hljs-string">&#x27;Fast Food Restaurants&#x27;</span>,<br>              <span class="hljs-string">&#x27;Pharmacies&#x27;</span>, <span class="hljs-string">&#x27;Service Stations (Fuel)&#x27;</span>, <span class="hljs-string">&#x27;Electronics</span><br><span class="hljs-string">              Stores&#x27;</span>]<br>l_city = [<span class="hljs-string">&#x27;Brussels&#x27;</span>, <span class="hljs-string">&#x27;Paris&#x27;</span>, <span class="hljs-string">&#x27;Berlin&#x27;</span>]<br>l_size = [<span class="hljs-string">&#x27;small&#x27;</span>, <span class="hljs-string">&#x27;medium&#x27;</span>, <span class="hljs-string">&#x27;large&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建提示词，将类型、城市、规模设置为参数</span><br>f_prompt = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Role: You are an expert content writer with extensive direct marketing</span><br><span class="hljs-string">experience. You have strong writing skills, creativity, adaptability to</span><br><span class="hljs-string">different tones and styles, and a deep understanding of audience needs</span><br><span class="hljs-string">and preferences for effective direct campaigns.</span><br><span class="hljs-string">Context: You have to write a short message in no more than 2 sentences</span><br><span class="hljs-string">for a direct marketing campaign to sell a new e-commerce payment</span><br><span class="hljs-string">service to stores.</span><br><span class="hljs-string">The target stores have the following three characteristics:</span><br><span class="hljs-string">- The sector of activity: &#123;sector&#125;</span><br><span class="hljs-string">- The city where the stores are located: &#123;city&#125;</span><br><span class="hljs-string">- The size of the stores: &#123;size&#125;</span><br><span class="hljs-string">Task: Write a short message for the direct marketing campaign. Use the</span><br><span class="hljs-string">skills defined in your role to write this message! It is important that</span><br><span class="hljs-string">the message you create takes into account the product you are selling</span><br><span class="hljs-string">and the characteristics of the store you are writing to.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># sub_prompt 将作为键，合成的数据作为值，组成训练数据集</span><br>f_sub_prompt = <span class="hljs-string">&quot;&#123;sector&#125;, &#123;city&#125;, &#123;size&#125;&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 合成数据</span><br>df = pd.DataFrame()<br><span class="hljs-keyword">for</span> sector <span class="hljs-keyword">in</span> l_sector:<br>    <span class="hljs-keyword">for</span> city <span class="hljs-keyword">in</span> l_city:<br>        <span class="hljs-keyword">for</span> size <span class="hljs-keyword">in</span> l_size:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>): <span class="hljs-comment"># 每个重复3次</span><br>                prompt = f_prompt.<span class="hljs-built_in">format</span>(sector=sector, city=city, size=size)<br>                sub_prompt = f_sub_prompt.<span class="hljs-built_in">format</span>(sector=sector, city=city, size=size)<br>                response_txt = chat_completion(<br>                    prompt, model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>, <br>                    temperature=<span class="hljs-number">1</span><br>                )<br>                new_row = &#123;<span class="hljs-string">&quot;prompt&quot;</span>: sub_prompt, <span class="hljs-string">&quot;completion&quot;</span>: response_txt&#125;<br>                new_row = pd.DataFrame([new_row])<br>                df = pd.concat([df, new_row], axis=<span class="hljs-number">0</span>, ignore_index=<span class="hljs-literal">True</span>)<br>df.to_csv(<span class="hljs-string">&quot;out_openai_completion.csv&quot;</span>, index=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 使用命令行格式化训练数据，该工具会提示我们如何处理数据，可根据其提示进行操作，例如补全换行符</span><br>openai tools fine_tunes.prepare_data -f out_openai_completion.csv<br></code></pre></td></tr></table></figure><h4 id="使用合成的数据训练模型"><a href="#使用合成的数据训练模型" class="headerlink" title="使用合成的数据训练模型"></a>使用合成的数据训练模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 上传数据</span><br>ft_file = openai.File.create(<br>    file=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;out_openai_completion_prepared.jsonl&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>),<br>    purpose=<span class="hljs-string">&quot;fine-tune&quot;</span><br>)<br><br><span class="hljs-comment"># 训练模型</span><br>openai.FineTune.create(<br>    training_file=ft_file[<span class="hljs-string">&quot;id&quot;</span>], model=<span class="hljs-string">&quot;davinci&quot;</span>, suffix=<span class="hljs-string">&quot;direct_marketing&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>调用函数创建训练模型的作业后，会得到一个 fine_tune_id，该 id 可用来查询进度，也可用于取消或者删除作业；</p><h4 id="使用微调后的模型进行文本补全"><a href="#使用微调后的模型进行文本补全" class="headerlink" title="使用微调后的模型进行文本补全"></a>使用微调后的模型进行文本补全</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409251207662.png"></p><p>由于我们之前使用商店关键字 + 广告组成的训练集进行训练，因此，对于微调后的模型，我们现在可以直接使用关键字来获取想要的结果了，例如只需输入提示词：Hotel、New York、Small，模型便会自动生成相应的广告邮件内容了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">openai.Completion.create(<br>  model=<span class="hljs-string">&quot;davinci:ft-book:direct-marketing-2023-05-01-15-20-35&quot;</span>,  <span class="hljs-comment"># 调用微调后的模型</span><br>  prompt=<span class="hljs-string">&quot;Hotel, New York, small -&gt;&quot;</span>, <span class="hljs-comment"># 使用特定格式的提示词，与训练数据中的格式一致</span><br>  max_tokens=<span class="hljs-number">100</span>,<br>  temperature=<span class="hljs-number">0</span>,<br>  stop=<span class="hljs-string">&quot;\n&quot;</span><br>)<br></code></pre></td></tr></table></figure><h4 id="微调的成本"><a href="#微调的成本" class="headerlink" title="微调的成本"></a>微调的成本</h4><p>使用微调模型调用 API 单价会更高一些；以下价格仅供参考，因为 OpenAI 会不断调整价格；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409251212100.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409251228522.png"></p><h1 id="第5章-使用-LangChain-构架和插件增加-LLM-功能"><a href="#第5章-使用-LangChain-构架和插件增加-LLM-功能" class="headerlink" title="第5章 使用 LangChain 构架和插件增加 LLM 功能"></a>第5章 使用 LangChain 构架和插件增加 LLM 功能</h1><h2 id="LangChain-框架"><a href="#LangChain-框架" class="headerlink" title="LangChain 框架"></a>LangChain 框架</h2><p>LangChain 是一个让开发基于大模型的应用程序变得更加方便的开发框架；它有以下几个核心模块：</p><ul><li>Models：提供通用的接口，让调用多个不同厂商的大模型变得更方便；</li><li>Prompts：创建和管理提示词</li><li>Indexes：对接本地数据，目前已改名为 Retrieval</li><li>Chain：用于创建调用序列，以方便组合多个模型或提示词；</li><li>Agents：用于处理用户的输入，做出判断，并调用合适的工具完成任务；</li><li>Memory：用于存储中间状态，保持上下文；</li></ul><h3 id="动态提示词"><a href="#动态提示词" class="headerlink" title="动态提示词"></a>动态提示词</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个可动态提问的程序</span><br><span class="hljs-keyword">from</span> langchain.chat_models <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain <span class="hljs-keyword">import</span> PromptTemplate, LLMChain<br><br>template = <span class="hljs-string">&quot;&quot;&quot;Question: &#123;question&#125;</span><br><span class="hljs-string">    Let&#x27;s think step by step.</span><br><span class="hljs-string">    Answer: &quot;&quot;&quot;</span><br>prompt = PromptTemplate(<br>    template=template,<br>    input_variables=[<span class="hljs-string">&quot;question&quot;</span>]<br>)<br>llm = ChatOpenAI(model_name=<span class="hljs-string">&quot;gpt-4&quot;</span>)<br>llm_chain = LLMChain(prompt=prompt, llm=llm) <span class="hljs-comment"># LLMChain 组合了模型和提示词</span><br>question = <span class="hljs-string">&quot;&quot;&quot; What is the population of the capital of the country</span><br><span class="hljs-string">where the Olympic Games were held in 2016? &quot;&quot;&quot;</span><br>llm_chain.run(question)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 得到的输出如下</span><br>Step <span class="hljs-number">1</span>: Identify the country where the Olympic Games were held <span class="hljs-keyword">in</span> <span class="hljs-number">2016.</span><br>Answer: The <span class="hljs-number">2016</span> Olympic Games were held <span class="hljs-keyword">in</span> Brazil.<br>Step <span class="hljs-number">2</span>: Identify the capital of Brazil.<br>Answer: The capital of Brazil <span class="hljs-keyword">is</span> Brasília.<br>Step <span class="hljs-number">3</span>: Find the population of Brasília.<br>Answer: As of <span class="hljs-number">2021</span>, the estimated population of Brasília <span class="hljs-keyword">is</span> around<br><span class="hljs-number">3.1</span> million. So, the population of the capital of the country where<br>the Olympic Games were held <span class="hljs-keyword">in</span> <span class="hljs-number">2016</span> <span class="hljs-keyword">is</span> around <span class="hljs-number">3.1</span> million. Note that<br>this <span class="hljs-keyword">is</span> an estimate <span class="hljs-keyword">and</span> may vary slightly.<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="智能体及工具"><a href="#智能体及工具" class="headerlink" title="智能体及工具"></a>智能体及工具</h3><p>智能体及工具是 LangChain 框架的核心功能，它将一些常用的功能，抽象并集成成更容易调用的方式；</p><p>逐步思考是一个很强大的范式，它能够利用模型来解决一些复杂的问题；原理也不复杂，相当于将一个复杂的问题，拆解成多个简单的小问题；智能体的一个功能就是内隐了这种范式，用户没有感知；</p><p>步骤如下：</p><ol><li>智能体收到用户的输入；</li><li>智能体分析输入，决定要使用的工具，以及要输入给工具的文本；</li><li>智能体调用工具，接收工具输出的文本；</li><li>智能体将收到的文本输入，作为输入，输入到智能体的上下文中</li><li>重复步骤 2 到步骤 4，直到智能体不再需要调用工具后，将结果输出给用户；</li></ol><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409251707401.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.chat_models <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain.agents <span class="hljs-keyword">import</span> load_tools, initialize_agent, AgentType<br><br>llm = ChatOpenAI(model_name=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>, temperature=<span class="hljs-number">0</span>)<br>tools = load_tools([<span class="hljs-string">&quot;wikipedia&quot;</span>, <span class="hljs-string">&quot;llm-math&quot;</span>], llm=llm)<br>agent = initialize_agent(<br>    tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,<br>    verbose=<span class="hljs-literal">True</span><br>)<br>question = <span class="hljs-string">&quot;&quot;&quot;What is the square root of the population of the capital</span><br><span class="hljs-string">of the Country where the Olympic Games were held in 2016?&quot;&quot;&quot;</span><br>agent.run(question)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算过程如下</span><br><br>&gt; Entering new chain...<br>I need to find the country where the Olympic Games were held <span class="hljs-keyword">in</span> <span class="hljs-number">2016</span><br><span class="hljs-keyword">and</span> then find the population of its capital city. Then I can take the<br>square root of that population.<br>Action: Wikipedia<br>Action Input: <span class="hljs-string">&quot;2016 Summer Olympics&quot;</span><br>Observation: Page: <span class="hljs-number">2016</span> Summer Olympics<br>[...]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">Thought:I need to search <span class="hljs-keyword">for</span> the capital city of Brazil.<br>Action: Wikipedia<br>Action Input: <span class="hljs-string">&quot;Capital of Brazil&quot;</span><br>Observation: Page: Capitals of Brazil<br>Summary: The current capital of Brazil, since its construction <span class="hljs-keyword">in</span><br><span class="hljs-number">1960</span>, <span class="hljs-keyword">is</span> Brasilia. [...]<br>Thought: I have found the capital city of Brazil, which <span class="hljs-keyword">is</span> Brasilia.<br>Now I need to find the population of Brasilia.<br>Action: Wikipedia<br>Action Input: <span class="hljs-string">&quot;Population of Brasilia&quot;</span><br>Observation: Page: Brasilia<br>[...]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">Thought: I have found the population of Brasilia, but I need to<br>calculate the square root of that population.<br>Action: Calculator  <span class="hljs-comment"># 此处调用了计算器</span><br>Action Input: Square root of the population of Brasilia (population:<br>found <span class="hljs-keyword">in</span> previous observation)<br>Observation: Answer: <span class="hljs-number">1587.051038876822</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 得出最终的答案</span><br>Thought: I now know the final answer<br>Final Answer: The square root of the population of the capital of the<br>country where the Olympic Games were held <span class="hljs-keyword">in</span> <span class="hljs-number">2016</span> <span class="hljs-keyword">is</span> approximately <span class="hljs-number">1587.</span><br>&gt; Finished chain.<br></code></pre></td></tr></table></figure><h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p>记忆之前的状态，相当于记住上下文，这在某些场景中是必须和有用的，例如构建聊天机器人</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 有专门的 ConversationChain</span><br><span class="hljs-keyword">from</span> langchain <span class="hljs-keyword">import</span> OpenAI, ConversationChain<br><br>chatbot_llm = OpenAI(model_name=<span class="hljs-string">&#x27;text-ada-001&#x27;</span>)<br>chatbot = ConversationChain(llm=chatbot_llm , verbose=<span class="hljs-literal">True</span>)<br>chatbot.predict(<span class="hljs-built_in">input</span>=<span class="hljs-string">&#x27;Hello&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输出结果如下</span><br>&gt; Entering new ConversationChain chain...<br>Prompt after formatting: <span class="hljs-comment"># 虽然用户只输入了 Hello，但实际上 LangChain 提交给模型的提示词要多很多</span><br>The following <span class="hljs-keyword">is</span> a friendly conversation between a human <span class="hljs-keyword">and</span> an<br>AI. The AI <span class="hljs-keyword">is</span> talkative <span class="hljs-keyword">and</span> provides lots of specific details <span class="hljs-keyword">from</span><br>its context. If the AI does <span class="hljs-keyword">not</span> know the answer to a question, it<br>truthfully says it does <span class="hljs-keyword">not</span> know.<br>Current conversation:<br>Human: Hello<br>AI:<br>&gt; Finished chain.<br><span class="hljs-string">&#x27; Hello! How can I help you?&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在后续的对话中，LangChain 会将聊天记录提交给模型</span><br>&gt; Entering new ConversationChain chain...<br>Prompt after formatting:<br>The following [...] does <span class="hljs-keyword">not</span> know.<br>Current conversation:<br>Human: Hello<br>AI:  Hello! How can I <span class="hljs-built_in">help</span> you?<br>Human: Can I ask you a question? Are you an AI?<br>AI:<br>&gt; Finished chain.<br><span class="hljs-string">&#x27;\n\nYes, I am an AI.&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>有些模型如 GPT-4 有专门针对聊天场景的微调模型，有时候使用这些微调模型效果更好，不一定非要用 LangChain 的接口；</p></blockquote><h3 id="嵌入-1"><a href="#嵌入-1" class="headerlink" title="嵌入"></a>嵌入</h3><p>嵌入用于将模型与本地的数据相结合，这样模型的回答将更有针对性，例如之前讨论过的游戏说明书的案例；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.document_loaders <span class="hljs-keyword">import</span> PyPDFLoader<br>loader = PyPDFLoader(<span class="hljs-string">&quot;ExplorersGuide.pdf&quot;</span>)<br>pages = loader.load_and_split()  <span class="hljs-comment"># 加载 PDF 文件，并将其分页</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.embeddings <span class="hljs-keyword">import</span> OpenAIEmbeddings<br>embeddings = OpenAIEmbeddings() <span class="hljs-comment"># 用于转分页的 PDF 内容转换成向量，并保存到数据库中</span><br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409251740895.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 之后当用户输入问题时，就到数据库中查询相近的嵌入</span><br>q = <span class="hljs-string">&quot;What is Link&#x27;s traditional outfit color?&quot;</span><br>db.similarity_search(q)[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询结果如下，从数据库中查询到与问题最相关的页面</span><br>Document(page_content=<span class="hljs-string">&#x27;&#x27;&#x27;While Link’s traditional green tunic is certainly an iconic look,</span><br><span class="hljs-string">his wardrobe has expanded [...] Dress for Success&#x27;&#x27;&#x27;</span>,<br>     metadata=&#123;<span class="hljs-string">&#x27;source&#x27;</span>: <span class="hljs-string">&#x27;ExplorersGuide.pdf&#x27;</span>, <span class="hljs-string">&#x27;page&#x27;</span>: <span class="hljs-number">35</span>&#125;<br>)<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409251745340.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将嵌入整合到聊天机器人中，让聊天机器人可以回答用户的提问</span><br><br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> RetrievalQA<br><span class="hljs-keyword">from</span> langchain <span class="hljs-keyword">import</span> OpenAI<br><br>llm = OpenAI()<br><span class="hljs-comment"># 注意此处的 retriever 用到了向量数据库，它将提取最相近的嵌入，然后做为上下文和问题一起发给模型</span><br>chain = RetrievalQA.from_llm(llm=llm, retriever=db.as_retriever()) <br>q = <span class="hljs-string">&quot;What is Link&#x27;s traditional outfit color?&quot;</span><br>chain(q, return_only_outputs=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409251747334.png"></p><h2 id="GPT-4-插件"><a href="#GPT-4-插件" class="headerlink" title="GPT-4 插件"></a>GPT-4 插件</h2><p>插件主要用于实时获取一些必要数据，它的功能不需要模型实现，而是由开发者实现好的，供模型进行调用。调用这些插件后，它会返回必要的数据，做为上下文参数发给模型，这样模型便能够处理更加复杂的任务，例如查询实时的比赛分数、股票价格、机票价格、预定机票等；</p><h3 id="插件-API"><a href="#插件-API" class="headerlink" title="插件 API"></a>插件 API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以下代码定义了一个 Todo 待办事项程序的 web 接口</span><br><br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> quart <span class="hljs-comment"># quart 是一个 web 框架，类似 flask 那种类型</span><br><span class="hljs-keyword">import</span> quart_cors<br><span class="hljs-keyword">from</span> quart <span class="hljs-keyword">import</span> request<br><br>app = quart_cors.cors(<br>    quart.Quart(__name__), <br>    allow_origin=<span class="hljs-string">&quot;https://chat.openai.com&quot;</span><br>)<br><br>_TODOS = &#123;&#125; <span class="hljs-comment"># 跟踪待办事项，如果Python会话重新启动，则数据会丢失</span><br><br><span class="hljs-meta">@app.post(<span class="hljs-params"><span class="hljs-string">&quot;/todos/&lt;string:username&gt;&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_todo</span>(<span class="hljs-params">username</span>):<br>request = <span class="hljs-keyword">await</span> quart.request.get_json(force=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">if</span> username <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _TODOS:<br>        _TODOS[username] = []<br>    _TODOS[username].append(request[<span class="hljs-string">&quot;todo&quot;</span>])<br>    <span class="hljs-keyword">return</span> quart.Response(response=<span class="hljs-string">&quot;OK&quot;</span>, status=<span class="hljs-number">200</span>)<br><br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/todos/&lt;string:username&gt;&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_todos</span>(<span class="hljs-params">username</span>):<br>    <span class="hljs-keyword">return</span> quart.Response(<br>        response=json.dumps(_TODOS.get(username, [])), status=<span class="hljs-number">200</span><br>    )<br>    <br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/.well-known/ai-plugin.json&quot;</span></span>) </span><span class="hljs-comment"># 该接口用于提供插件信息，以便模型安装该插件</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">plugin_manifest</span>():<br>    host = request.headers[<span class="hljs-string">&quot;Host&quot;</span>]<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./.well-known/ai-plugin.json&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        text = f.read()<br>        <span class="hljs-keyword">return</span> quart.Response(text, mimetype=<span class="hljs-string">&quot;text/json&quot;</span>)<br>    <br><span class="hljs-meta">@app.get(<span class="hljs-params"><span class="hljs-string">&quot;/openapi.yaml&quot;</span></span>) </span><span class="hljs-comment"># 该接口用于提供 OpenAPI 的调用规范，方便模型了解如何使用插件</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">openapi_spec</span>():<br>    host = request.headers[<span class="hljs-string">&quot;Host&quot;</span>]<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;openapi.yaml&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        text = f.read()<br>        <span class="hljs-keyword">return</span> quart.Response(text, mimetype=<span class="hljs-string">&quot;text/yaml&quot;</span>)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>app.run(debug=<span class="hljs-literal">True</span>, host=<span class="hljs-string">&quot;0.0.0.0&quot;</span>, port=<span class="hljs-number">5003</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h3 id="插件信息"><a href="#插件信息" class="headerlink" title="插件信息"></a>插件信息</h3><p>以下是 ai-plugin.json 文件示例</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;schema_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;v1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name_for_human&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;TODO Plugin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name_for_model&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;todo&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;description_for_human&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Plugin for managing a TODO list. \</span><br><span class="hljs-string">        You can add, remove and view your TODOs.&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;description_for_model&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Plugin for managing a TODO list. \</span><br><span class="hljs-string">        You can add, remove and view your TODOs.&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;none&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;api&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;openapi&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:3333/openapi.yaml&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;is_user_authenticated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;logo_url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:3333/logo.png&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;contact_email&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;support@thecompany.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;legal_info_url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://thecompany-url/legal&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="OpenAPI-规范"><a href="#OpenAPI-规范" class="headerlink" title="OpenAPI 规范"></a>OpenAPI 规范</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 以下是 openapi.yaml 示例，详细描述接口的调用方法</span><br><span class="hljs-attr">openapi:</span> <span class="hljs-number">3.0</span><span class="hljs-number">.1</span><br><span class="hljs-attr">info:</span><br>  <span class="hljs-attr">title:</span> <span class="hljs-string">TODO</span> <span class="hljs-string">Plugin</span><br>  <span class="hljs-attr">description:</span> <span class="hljs-string">A</span> <span class="hljs-string">plugin</span> <span class="hljs-string">that</span> <span class="hljs-string">allows</span> <span class="hljs-string">the</span> <span class="hljs-string">user</span> <span class="hljs-string">to</span> <span class="hljs-string">create</span> <span class="hljs-string">and</span> <span class="hljs-string">manage</span> <span class="hljs-string">a</span><br>  <span class="hljs-string">TODO</span> <span class="hljs-string">list</span> <span class="hljs-string">using</span> <span class="hljs-string">ChatGPT.</span> <span class="hljs-string">If</span> <span class="hljs-string">you</span> <span class="hljs-string">do</span> <span class="hljs-string">not</span> <span class="hljs-string">know</span> <span class="hljs-string">the</span> <span class="hljs-string">user&#x27;s</span> <span class="hljs-string">username,</span><br>  <span class="hljs-string">ask</span> <span class="hljs-string">them</span> <span class="hljs-string">first</span> <span class="hljs-string">before</span> <span class="hljs-string">making</span> <span class="hljs-string">queries</span> <span class="hljs-string">to</span> <span class="hljs-string">the</span> <span class="hljs-string">plugin.</span> <span class="hljs-string">Otherwise,</span><br>  <span class="hljs-string">use</span> <span class="hljs-string">the</span> <span class="hljs-string">username</span> <span class="hljs-string">&quot;global&quot;</span><span class="hljs-string">.</span><br>  <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;v1&#x27;</span><br><span class="hljs-attr">servers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:5003</span><br><span class="hljs-attr">paths:</span><br>  <span class="hljs-string">/todos/&#123;username&#125;:</span><br>    <span class="hljs-attr">get:</span><br>      <span class="hljs-attr">operationId:</span> <span class="hljs-string">getTodos</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">Get</span> <span class="hljs-string">the</span> <span class="hljs-string">list</span> <span class="hljs-string">of</span> <span class="hljs-string">todos</span><br>      <span class="hljs-attr">parameters:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">in:</span> <span class="hljs-string">path</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">username</span><br>        <span class="hljs-attr">schema:</span><br>            <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br>        <span class="hljs-attr">required:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">description:</span> <span class="hljs-string">The</span> <span class="hljs-string">name</span> <span class="hljs-string">of</span> <span class="hljs-string">the</span> <span class="hljs-string">user.</span><br>      <span class="hljs-attr">responses:</span><br>        <span class="hljs-attr">&quot;200&quot;:</span><br>          <span class="hljs-attr">description:</span> <span class="hljs-string">OK</span><br>          <span class="hljs-attr">content:</span><br>            <span class="hljs-attr">application/json:</span><br>              <span class="hljs-attr">schema:</span><br>                <span class="hljs-string">$ref:</span> <span class="hljs-string">&#x27;#/components/schemas/getTodosResponse&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="插件描述"><a href="#插件描述" class="headerlink" title="插件描述"></a>插件描述</h3><p>openapi.yaml 中应该尽量描述接口的用途，这样有助于模型判断何时可调用接口获得数据，以及如何调用接口；这其中最重要的字段便是 description_for_model，这个字段是对于插件的功能描述；应该尽量写得清晰易懂，一目了然；</p><p>功能描述应该是声明式的，而不是命令式的；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第1章-初识-GPT-4&quot;&gt;&lt;a href=&quot;#第1章-初识-GPT-4&quot; class=&quot;headerlink&quot; title=&quot;第1章  初识 GPT-4&quot;&gt;&lt;/a&gt;第1章  初识 GPT-4&lt;/h1&gt;&lt;h2 id=&quot;LLM-概述&quot;&gt;&lt;a href=&quot;#LLM-概</summary>
      
    
    
    
    <category term="计算机" scheme="https://ccw1078.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="人工智能" scheme="https://ccw1078.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>渲染原理</title>
    <link href="https://ccw1078.github.io/2024/07/21/%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    <id>https://ccw1078.github.io/2024/07/21/%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</id>
    <published>2024-07-21T00:27:00.000Z</published>
    <updated>2024-09-23T01:40:59.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h3><p>着色器类似于一个计算器，用于根据给定的参数，制作特效；</p><h3 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h3><p>这个中文名称有点怪，英文名称是 Normal Map，即普通贴图；它主要用于展现凹凸效果；理论上凹凸效果也可以使用建模来实现，但是当细节很多时，工作量过大，因此不现实。更高效的做法是使用带凹凸参数的贴图；物体只由数量有限的多边形来表示，表现的纹理则基于贴图参数来计算；</p><blockquote><p>所谓的贴图参数，即是一种细节模拟，这些参数可用来计算光线效果，让相应的部位看起来像是有真实的模型存在一样。但实际上没有，完成是基于参数计算出来的效果；</p></blockquote><p>法线：垂直于某个平面的线，这条线可用来计算物体和光线之间的夹角。 有了夹角后，就可以计算物体表面接收到多少光线；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408201628616.png"></p><p>物体呈现出体积形状，其实是由物体表面所反向的光线决定的。对于一个多边形圆柱体，如果我们将法线的角度变化，调整成圆柱形的，那么计算出来的着色也将是平滑过渡的，最后在我们肉眼看来，多边形变成了圆形。但实际上，底层的参数存储的是多边形；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408201628272.png"></p><p>将表面的法线角度与真实角度的偏差，单独抽离出来存储，那么这个偏差值的集合，就是所谓的法线贴图；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408201628894.png"></p><h3 id="CPU-渲染逻辑"><a href="#CPU-渲染逻辑" class="headerlink" title="CPU 渲染逻辑"></a>CPU 渲染逻辑</h3><p>主要有四个工作：</p><ul><li>剔除工作：<ul><li>视锥体剔除；</li><li>图层剔除；</li><li>遮挡剔除；</li></ul></li><li>设置渲染顺序：<ul><li>不透明队列：根据距离摄像头的距离，由近到远依次渲染；</li><li>半透明队列：从远到近渲染；</li></ul></li><li>打包数据：将数据打包发送给 GPU 渲染；<ul><li>模型信息：顶点坐标、法线、UV、切线、顶点颜色、索引列表等；</li><li>变换矩阵：世界变换矩阵、VP 矩阵（基于相机位置和 FOV 参数）；</li><li>灯光、材质参数：着色器和材质参数，灯光信息等；</li></ul></li><li>调用渲染函数<ul><li>SetPassCall<ul><li>shader 脚本中的一个 Pass 语义块就是一个完整的渲染过程；一个着色器可包含多个 Pass 语义块；</li></ul></li><li>DrawCall：CPU 调用图像编程接口，命令 GPU 渲染的操作，即渲染命令；渲染命令的参数为图元列表，其计算结果为显示在屏幕上的像素；</li></ul></li></ul><p>CPU 渲染阶段的一个重要输出是渲染图元，图元中包括 GPU 渲染需要用到的各种参数信息，例如点、线、面等几何信息；</p><h3 id="GPU-渲染管线"><a href="#GPU-渲染管线" class="headerlink" title="GPU 渲染管线"></a>GPU 渲染管线</h3><p>GPU 渲染管线包含以下多个步骤：</p><ul><li>顶点处理<ul><li>顶点着色器：主要执行坐标转换，将顶点的坐标转换到齐次裁剪 </li><li>曲面细分着色器（可选）</li><li>几何着色器（可选）</li></ul></li><li>图元装配</li><li>光栅化</li><li>片元着色器</li><li>输出合并</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408210825758.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;着色器&quot;&gt;&lt;a href=&quot;#着色器&quot; class=&quot;headerlink&quot; title=&quot;着色器&quot;&gt;&lt;/a&gt;着色器&lt;/h3&gt;&lt;p&gt;着色器类似于一个计算器，用于根据给定的参数，制作特效；&lt;/p&gt;
&lt;h3 id=&quot;法线贴图&quot;&gt;&lt;a href=&quot;#法线贴图&quot; clas</summary>
      
    
    
    
    <category term="文章" scheme="https://ccw1078.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="渲染" scheme="https://ccw1078.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>中国的选择</title>
    <link href="https://ccw1078.github.io/2024/07/02/%E4%B8%AD%E5%9B%BD%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <id>https://ccw1078.github.io/2024/07/02/%E4%B8%AD%E5%9B%BD%E7%9A%84%E9%80%89%E6%8B%A9/</id>
    <published>2024-07-02T00:19:00.000Z</published>
    <updated>2024-09-23T01:16:13.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十个值得关注的问题"><a href="#十个值得关注的问题" class="headerlink" title="十个值得关注的问题"></a>十个值得关注的问题</h1><p>中国和美国的地缘政治竞争，将持续很多一段时间，估计会有10-20年之久；</p><ol><li>当美国不再是全球经济的主导力量时，它需要做出哪些战略改变？</li><li>美国的首要目标是吗？是改善国内民生，还是维持国际地位？</li><li>美国扩大国防预算是明智的吗？</li><li>美国选择疏远盟友是明智的吗？</li><li>美国把美元作为武器对付对手是明智的吗？</li><li>美国人民是否愿意牺牲短期利益，来换取国内的经济活力？</li><li>美国将中国视为威胁，是否犯了战略上的错误？</li><li>美国对中国崛起做出的反应，是出于情绪还是出于理智？</li><li>美国了解中国领导人真正想要的东西是什么吗？</li><li>美国社会是否做好了力量和耐力上的准备，来应对中国的长期博弈？</li></ol><p>在过去的两千年时，全国两个最大的经济体一直是中国和印度，仅最近两百年因西方的崛起，这种常态才发生了改变。但是当中国和印度从西方吸收了精华，重新崛起的时候，全球经济的重心重回亚洲，很可能只是历史常态的回归；</p><p>尽管美国正在经历衰落，但是它仍然拥有巨大的力量。因此，如果中国认定自己在这场战争一定会赢，无疑将犯下严重的战略失误。对于中国来说，最好的策略是高估美国，而不是低估它；</p><p>美国有以下几个方面的优势：</p><ol><li>美国的个人英雄主义文化，为培养出某些强大的个体提供了土壤和生态系统；反观中国的文化，枪打出头鸟，二者存在着显著的不同；</li><li>美国拥有大量优秀的人才。虽然中国有 14 亿的人口基数，美国只有 3 亿，但目前美国对人才的吸引力，是全球性的；</li><li>美国拥有一个强大的制度，这个依法治国的制度，保护着美国社会的运转，而不是让社会完全依赖于某一个个体；</li><li>美国拥有全世界最多的顶尖学府，无数优秀学者在这些顶尖学府中，做着最前沿的研究，百家争鸣，百花齐放，造就了全球最繁荣的智力生态系统，这也是为什么美国能够出现最多的诺奖得主；</li><li>美国背靠一个伟大的文明传统，即西方文明；同样基于西方文明国家，彼此间有更多的信任和认同感，这让美国不完全是单打独斗；</li></ol><h1 id="中国最大的战略失误"><a href="#中国最大的战略失误" class="headerlink" title="中国最大的战略失误"></a>中国最大的战略失误</h1><p>近年来，中国疏远了其在美国国内的几大支持群体。这种疏远的后果便是，当中美之间出现冲突时，中国失去了美国国内为其辩护的声音，这种声音曾经是存在的。</p><p>这种疏远有部分是因为傲慢的情绪造成的，但中国应该从清明的衰落中吸取教训，但我们越是封闭自己的时候，我们就开始变得落后了。所以，中国越是能够给外国的企业提供一个良好的营商环境，吸引更多的外国企业来中国经营，那么中国将从中获得越多的长期利益。这种做法更多是出于战略上的需要，因为以中国今日的体量，已然能够自给自足；但如果拥有足够多的在华营商群体，中国就能够在与美国的冲突中，获得越厚的缓冲区；</p><h1 id="美国最大的战略失误"><a href="#美国最大的战略失误" class="headerlink" title="美国最大的战略失误"></a>美国最大的战略失误</h1><p>美国最大的失误是没有制订出全面的对华战略，缺乏清晰的行动目标。美国的一些应急反应，在无须之中伤害到了其他国家的利益，也削弱了其他国家对美国的信任。之前这些国家相信美国拥有一套能够自我调整的纠错制度，能够避免糟糕情况的发生，能够顾全大局，而不是以邻为壑，这也是他们愿意使用美元做为交易货币的根本原因。但现在这种信任感正在流失，美国如果不加予挽救，那么结果将会是灾难性的。当美元不再是全球各国的储备货币时，美国的巨额债务便难以维系，进而引发经济危机。</p><p>美国之所以出现这种本不应该出现的战略失误，其根本原因在于过去两百年的成功，让很多人忘记了历史的常态是什么样子的，从而无法和难以想象当美国不再是世界第一的情况，美国要如何应对。因为在很多美国人潜意识中，已经把最近两百年的异常，当成了一种常态来对待。</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202406282012719.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202406282012494.png"></p><h1 id="中国在扩张吗"><a href="#中国在扩张吗" class="headerlink" title="中国在扩张吗"></a>中国在扩张吗</h1><p>对中国了解越多的人，越能够明白中国并无扩张的意图。不仅现在如此，而是自古以来一直如此。但如此明显的一个事实，为何无法被西方精英所相信？根本上来说，这是由于两个文明内在本质的不同造成的，因为我们总是不可避免会倾向于以已度人。西方的海上文明是一种扩张的文明，但东方的农耕文化却非如此。相比东方文明的好铁不打钉，好男不当兵，学而优则仕，军人在西方文明中，拥有更高的社会地位。在出现冲突时，西方文明如美国，更频繁的诉诸于武力。</p><p>西方文明由于受到宗教的影响，天生有一种普世观，即认为自己肩负着向全世界传播福音的责任。中国人则没有这种观念，他们认为中国的价值，只适用于中国人自己，不适用于他人。美国人的这种普世观，或许可以很好的解释在过去的一百年中，为何美国频繁的卷入世界各地的军事冲突中。 在过去的两千年中，中国绝大部分时期的战略思想，都是如何更好的防御敌人，而不是入侵他国，不同朝代都在反复修建长城。</p><h1 id="美国能做出重大转变吗"><a href="#美国能做出重大转变吗" class="headerlink" title="美国能做出重大转变吗"></a>美国能做出重大转变吗</h1><p>美国当前拥有比中国多得多的武器装备，不存在本土安全方面的威胁和顾虑，尤其是考虑到已经拥有核武器的情况下。理论上来说，这时美国完全没有必要在国防预算增加投入更多的资金，更好的做法是将资金转移到科技或民生领域。但很可惜美国的国防预算不是由某个人说了算的，而是存在着庞大的既得利益群体（国防承包商）。他们通过华盛顿的游说集团，不断让国会审批通过更高的预算申请。他们巧妙的将工厂设置一些关键的国会选区，如果某些议员提议削减预算，那么约等于政治自杀，失去选票丢掉工作；</p><p>冷战结束前，美国对世界各地冲突的介入和干预，是其对抗苏联的重要策略。但是当苏联解体后，美国原本应该停止这些干预，减少无谓的资源损耗，专心发展自己，但事实却恰恰相反。这是很令人震惊的，事实上绝大多数选民是反对对外战争，因此很多军事行动都没有在法律上被定义为对外战争，以规避国会的监督。这背后到底是为什么呢？既得利益集团的游说，应该是一个重要的原因。美国拥有全世界最丰富、资金最充足的智库。但显然这些智库并没有发挥应有的作用。原因在于这些智库接受的资助。那些通过夸大外部威胁，有利于提高国防预算的智库，显然会得到国防承包商更多的资金支持。这也导致了为什么明明介入中东地区对美国没有明显的利益，美国却不断的出手。</p><p>长期的单极霸权，让美国在不知不觉中弱化了外交的重要性。驻外大使不再是精英团队，更多是总统为竞选资金者提供的岗位；久而久之，优秀的年轻人都纷纷投身到其他更有前途的领域，导致外交官团队缺乏足够多的优秀人才。当冲突不适合使用武力解决时，外交是很好的处理手段。美国在冷战结束后的一个重大失误，便是不再重视外交；</p><p>今天的美国已经不是开国元勋创立时的模样，贫富分化严重，政治权力和经济财富牢牢的掌握在少数人手中。虽然人们可以通过选票选择自己的总统，但事实上这只是一种幻觉。因为不管选哪个总统，都无法从根本上改变背后的既得利益群体；</p><h1 id="中国的民主"><a href="#中国的民主" class="headerlink" title="中国的民主"></a>中国的民主</h1><p>在西方的价值观中，民主是一个毫无意义的好东西。但其实并非如此，民主要能够发挥出力量，是需要前提的。这个前提便是同质化且受过良好教育的社会，例如现在的北欧小国或者新加坡。事实上，这种条件是很严苛。因为绝大部分部分都或多或少存在某些历史遗留问题，导致全国人民的受教育程度参差不齐。当这个前提不满足时，实行民主很容易造成社会的分裂。因为人们的思想本来就存在着巨大的代沟和差异，而民主选举不可避免地将差异突显出来。</p><p>中国是一个庞大的国家，人口规模巨大而多样。在过去两千年的历史中，不同朝代的统治者，总结出了相同的治理方案。因为凡是不如此治理的，都很快的消失在历史长河中了。这个治理通过儒家思想和科学，来达到思想和道德上的统一，是终实现社会的稳定；</p><p>印度同样是一个庞大的国家，差不多的人口，更加丰富的多样性。印度过往的历史表明，在印度这片土地上，实现思想统一是何其的艰难。如今印度所实施的民主制度，使得社会分裂的弥合，变得更加路漫漫了。</p><p>中国目前的政治制度也并非完美的，其中一个最大的问题，是如何实现领导人的交接班。既能够平稳过渡，又能够确保接班人队伍是足够优秀的。</p><p>或许我们有必要透过现象看本质，不管是民主还是集权，从本质上来说，它们都是一种关于如何做出决策的机制，而非决策的目标。政治的目标，是为人民服务。如果一个政治制度，无法让人民生活得更好，那不管它是民主的，还是集权的，都是不合格的。反之，如果一个制度，能够让人民生活得更加幸福，那么它就是一个好的制度。不管白猫黄猫，能抓老鼠的就是好猫。如果我们执着于决策机制，而不是关注决策结果，那无异于买椟还珠。</p><h1 id="美德假设"><a href="#美德假设" class="headerlink" title="美德假设"></a>美德假设</h1><p>美国高院在 2010 年做出一项影响重大的判决，即取消了企业和个人对竞选的赞助限制，这无疑让金钱对政治的影响力变得畅通无阻。它的后果是可怕的，目前也已经显现。过去的 40 年，美国 50% 的底层民众，生活质量不但没有进步，反而是 退步了。财富分配集中到了少数人的手中，各种政策也倾向于维护少数人的利益，而不是底层老百姓的利益。金钱实现了对政治的腐蚀。</p><p>美国也是一个多元民族的国家，这些不同信仰的民族，之所以能够融合在一起，其中一个很重要的原因，是关于机会平等的美国梦。当有一天，这种梦想不再被大家所相信时，那么过往的融合很可能会瓦解。</p><p>民主会让人产生一种幻觉，即这个制度是可以由普通人通过选票来塑造和控制的，即便事实并非如此，人们也不肯放弃他们手中的选举权利，这反过来有助于让制度更加稳定从而难以改变。但是当前的美国需要的正是一种大型手术，而不是小修小补。</p><h1 id="其他国家会如何抉择"><a href="#其他国家会如何抉择" class="headerlink" title="其他国家会如何抉择"></a>其他国家会如何抉择</h1><p>不同的国家面临着自己的地缘政治压力。澳大利亚离美国很远，但离东盟很近。虽然在文化根源上，它跟美国更接近，但在经济上，它跟亚洲更加密切。如果澳大利亚坚持做美国的副警长，收益很小，代价却很大。</p><p>欧洲面临的压力来自非洲，欧洲目前人口增长缓慢，而非洲的人口则快速增长。如果非洲在未来无法在经济上取得快速发展，那么不断增加的人口，将会外溢到欧洲寻找更好的生活，届时欧洲将面临极大的移民压力和挑战。对于欧洲来说，更明智的做法是与中国一起，帮助非洲的经济快速发展，从而缓解未来可能出现的困境。</p><p>日本虽然在表面上实行了美国的民主制度，但近50年，除了少数几年，都是一党执政。它在文化内核上其实更接近中国，如果中国将来有一天也做出民主化的改革，那么它有可能更接近日本的形式，而不是美国。虽然日本西化很多年了，但西方政治官员在和日本官员打交道，仍然觉得双方存在本质性的差异，相互理解存在诸多实质上的困难。</p><p>印度最终会成为一个大国，但目前由于国内各党派难以达成共识，多次失去快速发展的机会。未来这种情况可能还会持续较长的时间。随着中国的崛起，如果美国想要在亚洲维持影响力，其中一个重要的措施是加深与印度合作，让印度成为美国在亚洲维持影响力的一个重要桥梁。但美国的政府却普通存在对印度的轻视，无法将印度视为平等的战略伙伴关系，导致双方的合作难以深入；</p><p>除了印度，东盟在亚洲的地位也变得越来越重要了。最近三十年也是东盟经济发展最快的三十年，鉴于东盟背后 6.5 亿的人口，它是目前世界上经济发展前景最好的区域之一。遗憾的是，大多数美国官员对东盟接近一无所知。东盟的精英大多有留美的经历，因此事实东盟是目前世界上最亲美的地区之一，但未来较长的一段时间内依然如此。美国原本应好好利用这一难得的背景，让东盟变成美国的有力伙伴。在多数美国人眼里，东盟十国因为地理上更接近中国，所以美国认为它们更像是中国的卫星国。但事实正好相反，东盟十国中，仅有越南深受中国影响，其他九个国家则是以印度文化为基础。</p><h1 id="一个自相矛盾的结论"><a href="#一个自相矛盾的结论" class="headerlink" title="一个自相矛盾的结论"></a>一个自相矛盾的结论</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;十个值得关注的问题&quot;&gt;&lt;a href=&quot;#十个值得关注的问题&quot; class=&quot;headerlink&quot; title=&quot;十个值得关注的问题&quot;&gt;&lt;/a&gt;十个值得关注的问题&lt;/h1&gt;&lt;p&gt;中国和美国的地缘政治竞争，将持续很多一段时间，估计会有10-20年之久；&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="社科" scheme="https://ccw1078.github.io/categories/%E7%A4%BE%E7%A7%91/"/>
    
    
    <category term="政治" scheme="https://ccw1078.github.io/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>VirtualDOM 简易实现</title>
    <link href="https://ccw1078.github.io/2024/06/22/VirtualDom%20%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/"/>
    <id>https://ccw1078.github.io/2024/06/22/VirtualDom%20%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-06-22T04:12:00.000Z</published>
    <updated>2024-09-21T23:18:59.804Z</updated>
    
    <content type="html"><![CDATA[<p>Vuejs 和 Reactjs 都用到了虚拟DOM，来实现数据绑定和 DOM 的自动更新，此处做了一个简单的实现，方便学习基本的工作原理；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> exampleButton = &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;button&quot;</span>,<br>    <span class="hljs-attr">properties</span>: &#123;<br>        <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;primary&quot;</span>,<br>        <span class="hljs-attr">disabled</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">onClick</span>: doSomething,<br>    &#125;,<br>    <span class="hljs-attr">children</span>: [] <span class="hljs-comment">// 虚拟节点列表</span><br>&#125;<br><br><span class="hljs-keyword">const</span> exampleText = &#123;<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;Hello&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">h</span>(<span class="hljs-params">tag, properties, children</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; tag, properties, children &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">text</span>(<span class="hljs-params">content</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">text</span>: content &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">diffOne</span>(<span class="hljs-params">l, r</span>) &#123;<br>    <span class="hljs-keyword">const</span> isText = l.<span class="hljs-property">text</span> !== <span class="hljs-literal">undefined</span>;<br>    <span class="hljs-comment">// 若是文本，直接替换</span><br>    <span class="hljs-keyword">if</span> (isText) &#123;<br>        <span class="hljs-keyword">return</span> l.<span class="hljs-property">text</span> !== r.<span class="hljs-property">text</span><br>        ? &#123; <span class="hljs-attr">replace</span>: r &#125;<br>        : &#123; <span class="hljs-attr">noop</span>: <span class="hljs-literal">true</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">// 若 tag 不同，直接替代</span><br>    <span class="hljs-keyword">if</span> (l.<span class="hljs-property">tag</span> !== r.<span class="hljs-property">tag</span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">replace</span>: r &#125;;<br>    &#125;<br>    <span class="hljs-comment">// 检查需要删除的属性</span><br>    <span class="hljs-keyword">const</span> remove = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> l.<span class="hljs-property">properties</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r.<span class="hljs-property">properties</span>[prop] === <span class="hljs-literal">undefined</span>) &#123;<br>            remove.<span class="hljs-title function_">push</span>(prop);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 检查新增的属性</span><br>    <span class="hljs-keyword">const</span> set = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> r.<span class="hljs-property">properties</span>) &#123;<br>        <span class="hljs-keyword">if</span> (r.<span class="hljs-property">properties</span>[prop] !== l.<span class="hljs-property">properties</span>[prop]) &#123;<br>            set[prop] = r.<span class="hljs-property">properties</span>[prop];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> children = <span class="hljs-title function_">diffList</span>(l.<span class="hljs-property">chilren</span>, r.<span class="hljs-property">children</span>);<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">modify</span>: &#123; remove, set, children &#125; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">diffList</span>(<span class="hljs-params">ls, rs</span>) &#123;<br>    <span class="hljs-keyword">const</span> length = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(ls.<span class="hljs-property">length</span>, rs.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(&#123; length &#125;).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">_, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (ls[i] === <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">create</span>: rs[i] &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (rs[i] === <span class="hljs-literal">undefined</span>) &#123;<br>                <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">remove</span>: <span class="hljs-literal">true</span> &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">diffOne</span>(ls[i], rs[i])<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">apply</span>(<span class="hljs-params">el, enqueue, childrenDiff</span>) &#123;<br>    <span class="hljs-keyword">const</span> children = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(el.<span class="hljs-property">childNodes</span>);<br>    childrenDiff.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">diff, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> action = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(diff)[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">switch</span>(action) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;remove&quot;</span>: &#123;<br>                  children[i].<span class="hljs-title function_">remove</span>();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;modify&quot;</span>: &#123;<br>                <span class="hljs-title function_">modify</span>(children[i], enqueue, diff.<span class="hljs-property">modify</span>);<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;create&quot;</span>: &#123;<br>                <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">create</span>(enqueue, diff.<span class="hljs-property">create</span>);<br>                el.<span class="hljs-title function_">appendChild</span>(child);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;replace&quot;</span>: &#123;<br>                <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">create</span>(diff.<span class="hljs-property">replace</span>);<br>                children[i].<span class="hljs-title function_">replacewith</span>(child);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;noop&quot;</span>: &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element[<span class="hljs-string">&quot;_ui&quot;</span>] = &#123; <span class="hljs-attr">listeners</span>: &#123; <span class="hljs-attr">click</span>: doSomething &#125;&#125;<br><br><span class="hljs-comment">// 事件监听函数, 所有事件都归集到同一个函数进行处理</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">listener</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">const</span> el = event.<span class="hljs-property">currentTarget</span>;<br>    <span class="hljs-keyword">const</span> handler = el.<span class="hljs-property">_ui</span>.<span class="hljs-property">listeners</span>[event.<span class="hljs-property">type</span>];<br>    <span class="hljs-keyword">const</span> enqueue = el.<span class="hljs-property">_ui</span>.<span class="hljs-property">enqueue</span>;<br>    <span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">handler</span>(event);<br>    <span class="hljs-keyword">if</span> (msg !== <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-title function_">enqueue</span>(msg)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 给 el 添加事件监听函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setListener</span>(<span class="hljs-params">el, event, handle</span>) &#123;<br>    <span class="hljs-keyword">if</span> (el.<span class="hljs-property">_ui</span>.<span class="hljs-property">listeners</span>[event] === <span class="hljs-literal">undefined</span>) &#123;<br>        el.<span class="hljs-title function_">addEventListener</span>(event, listener);<br>    &#125;<br>    el.<span class="hljs-property">_ui</span>.<span class="hljs-property">listeners</span>[event] = handle;<br>&#125;<br><br><span class="hljs-comment">// 获得监听的事件名称</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">eventName</span>(<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;on&quot;</span>) === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([ <span class="hljs-string">&quot;autoplay&quot;</span>, <span class="hljs-string">&quot;checked&quot;</span>, <span class="hljs-string">&quot;checked&quot;</span>, <span class="hljs-string">&quot;contentEditable&quot;</span>, <span class="hljs-string">&quot;controls&quot;</span>,<br>  <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;hidden&quot;</span>, <span class="hljs-string">&quot;loop&quot;</span>, <span class="hljs-string">&quot;selected&quot;</span>, <span class="hljs-string">&quot;spellcheck&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>,<br>  <span class="hljs-string">&quot;accessKey&quot;</span>, <span class="hljs-string">&quot;dir&quot;</span>, <span class="hljs-string">&quot;dropzone&quot;</span>, <span class="hljs-string">&quot;lang&quot;</span>, <span class="hljs-string">&quot;src&quot;</span>, <span class="hljs-string">&quot;alt&quot;</span>, <span class="hljs-string">&quot;preload&quot;</span>, <span class="hljs-string">&quot;poster&quot;</span>,<br>  <span class="hljs-string">&quot;kind&quot;</span>, <span class="hljs-string">&quot;label&quot;</span>, <span class="hljs-string">&quot;srclang&quot;</span>, <span class="hljs-string">&quot;sandbox&quot;</span>, <span class="hljs-string">&quot;srcdoc&quot;</span>, <span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;accept&quot;</span>,<br>  <span class="hljs-string">&quot;placeholder&quot;</span>, <span class="hljs-string">&quot;acceptCharset&quot;</span>, <span class="hljs-string">&quot;action&quot;</span>, <span class="hljs-string">&quot;autocomplete&quot;</span>, <span class="hljs-string">&quot;enctype&quot;</span>, <span class="hljs-string">&quot;method&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;pattern&quot;</span>, <span class="hljs-string">&quot;htmlFor&quot;</span>, <span class="hljs-string">&quot;max&quot;</span>, <span class="hljs-string">&quot;min&quot;</span>, <span class="hljs-string">&quot;step&quot;</span>, <span class="hljs-string">&quot;wrap&quot;</span>, <span class="hljs-string">&quot;useMap&quot;</span>, <span class="hljs-string">&quot;shape&quot;</span>,<br>  <span class="hljs-string">&quot;coords&quot;</span>, <span class="hljs-string">&quot;align&quot;</span>, <span class="hljs-string">&quot;cite&quot;</span>, <span class="hljs-string">&quot;href&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>, <span class="hljs-string">&quot;download&quot;</span>, <span class="hljs-string">&quot;download&quot;</span>,<br>  <span class="hljs-string">&quot;hreflang&quot;</span>, <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;headers&quot;</span>, <span class="hljs-string">&quot;scope&quot;</span>, <span class="hljs-string">&quot;span&quot;</span> ]);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">setProperty</span>(<span class="hljs-params">prop, value, el</span>) &#123;<br>    <span class="hljs-keyword">if</span> (props.<span class="hljs-title function_">has</span>(prop)) &#123;<br>        el[prop] = value;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        el.<span class="hljs-title function_">setAttribute</span>(prop, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">enqueue, vnode</span>) &#123;<br>    <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">text</span> !== <span class="hljs-literal">undefined</span>) &#123;<br>        <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(vnode.<span class="hljs-property">text</span>);<br>        <span class="hljs-keyword">return</span> el;<br>    &#125;<br>    <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>);<br>    el.<span class="hljs-property">_ui</span> = &#123; <span class="hljs-attr">listeners</span>: &#123;&#125;, enqueue &#125;;<br>    <span class="hljs-comment">// 有些 properties 是真的 prop, 有些则是事件监听函数，所以需要区别对待</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">properties</span>) &#123;<br>        <span class="hljs-keyword">const</span> event = <span class="hljs-title function_">eventName</span>(prop);<br>        <span class="hljs-keyword">const</span> value = vnode.<span class="hljs-property">properties</span>[prop];<br>        <span class="hljs-keyword">if</span> (event !== <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-title function_">setListener</span>(el, event, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">setProperty</span>(prop, value, el);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> childNode <span class="hljs-keyword">of</span> vnode.<span class="hljs-property">children</span>) &#123;<br>        <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">create</span>(enqueue, childNode);<br>        el.<span class="hljs-title function_">appendChild</span>(child);<br>    &#125;<br>    <span class="hljs-keyword">return</span> el;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">modify</span>(<span class="hljs-params">el, enqueue, diff</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">of</span> diff.<span class="hljs-property">remove</span>) &#123;<br>        <span class="hljs-keyword">const</span> event = <span class="hljs-title function_">eventName</span>(prop);<br>        <span class="hljs-keyword">if</span> (event === <span class="hljs-literal">null</span>) &#123;<br>            el.<span class="hljs-title function_">removeAttribute</span>(prop);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            el.<span class="hljs-property">_ui</span>.<span class="hljs-property">listeners</span>[event] = <span class="hljs-literal">undefined</span>;<br>            el.<span class="hljs-title function_">removeEventListener</span>(event, listener);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> diff.<span class="hljs-property">set</span>) &#123;<br>        <span class="hljs-keyword">const</span> value = diff.<span class="hljs-property">set</span>[prop];<br>        <span class="hljs-keyword">const</span> event = eventName[prop];<br>        <span class="hljs-keyword">if</span> (event !== <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-title function_">setListener</span>(el, event, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-title function_">setProperty</span>(prop, value, el);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-title function_">apply</span>(el, enqueue, diff.<span class="hljs-property">children</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 应用示例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">view</span>(<span class="hljs-params">state</span>) &#123;<br>    <span class="hljs-keyword">return</span> [<br>        <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;p&quot;</span>, &#123;&#125;, [ <span class="hljs-title function_">text</span>(<span class="hljs-string">`counter: <span class="hljs-subst">$&#123;state.counter&#125;</span>`</span>)])<br>    ];<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">state, msg</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">counter</span>: state.<span class="hljs-property">counter</span> + msg &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> initialState = &#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.my-application&quot;</span>);<br><br><span class="hljs-keyword">const</span> &#123; enqueue &#125; = <span class="hljs-title function_">init</span>(root, initialState, update, view);<br><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">enqueue</span>(<span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">root, initialState, update, view</span>) &#123;<br>    <span class="hljs-keyword">let</span> state = initialState;<br>    <span class="hljs-keyword">let</span> nodes = [];<br>    <span class="hljs-keyword">let</span> queue = [];<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueue</span>(<span class="hljs-params">msg</span>) &#123;<br>        queue.<span class="hljs-title function_">push</span>(msg);<br>    &#125;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">let</span> newNodes = <span class="hljs-title function_">view</span>(state);<br>        <span class="hljs-title function_">apply</span>(root, enqueue, <span class="hljs-title function_">diffList</span>(nodes, newNodes));<br>        nodes = newNodes;<br>    &#125;<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateState</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">if</span> (queue.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">let</span> msgs = queue;<br>            queue = [];<br>            <span class="hljs-keyword">for</span> (msg <span class="hljs-keyword">of</span> msgs) &#123;<br>                state = <span class="hljs-title function_">update</span>(state, msg, enqueue);<br>            &#125;<br>            <span class="hljs-title function_">draw</span>();<br>        &#125;<br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(updateState);<br>    &#125;<br>    <span class="hljs-title function_">draw</span>();<br>    <span class="hljs-title function_">updateState</span>();<br>    <span class="hljs-keyword">return</span> &#123; enqueue &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> button = <span class="hljs-title function_">h</span>(<br><span class="hljs-string">&quot;button&quot;</span>,<br>    &#123; <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-number">1</span> &#125;,<br>    [ <span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;increase counter&quot;</span>)],<br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Vuejs 和 Reactjs 都用到了虚拟DOM，来实现数据绑定和 DOM 的自动更新，此处做了一个简单的实现，方便学习基本的工作原理；&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="文章" scheme="https://ccw1078.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="javascript" scheme="https://ccw1078.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>基因组</title>
    <link href="https://ccw1078.github.io/2024/05/27/%E5%9F%BA%E5%9B%A0%E7%BB%84/"/>
    <id>https://ccw1078.github.io/2024/05/27/%E5%9F%BA%E5%9B%A0%E7%BB%84/</id>
    <published>2024-05-27T14:29:00.000Z</published>
    <updated>2024-09-23T01:14:22.283Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-导论"><a href="#0-导论" class="headerlink" title="0.导论"></a>0.导论</h1><p>如果将基因组比作一本书，那么组成如下：</p><ul><li>染色体：章</li><li>基因：写在章里面的故事，每章（每条染色体）通常包含几千个故事；</li><li>外显子：组成故事的不同段落（段落中间不时会插播一些没有任何作用的广告，这些广告称为内含子）；</li><li>密码子：组成段落的单词，每个单词固定由 3 个字母组成；</li><li>碱基：组成单词的字母，共有 4 个字母，分别是 A、C、G、T，即腺嘌呤、胞嘧啶、鸟嘌呤、胸腺嘧啶；</li></ul><p>整个基因大概由 10 亿多个单词组成，字数约为《圣经》的 800 倍，可以说这本书内容篇幅相当庞大；但接近 99.9% 的内容是垃圾（历史遗留）；实际发挥作用的单词只有 0.1% 左右，即 100 万个；</p><p>DNA：脱氧核榶核酸，即由糖和磷酸构成的长链分子，碱基作为侧梯附着在长链上面；一条染色体由两条非常长的 DNA 分子相互缠绕组成（双螺旋）；</p><p>在适当的条件下，DNA 可以用于复制，也可以用作翻译；由于 A-T、C-G 的固定搭配，因此复制的工作很简单；</p><p>DNA 的翻译则稍微复杂一些，分成两步：</p><ul><li>步骤一：需要先制作一个副本（信使 RNA），该副本的材料由略有不同的 RNA 构成（RNA 除了使用 U 代替 T 之外，其他字母与 DNA 相同）；该副本在复制过程中，会自动去除“内含子”，仅包含外显子（即将 DNA 长链上面的所有外显子拼接在一起，因此制作好的 RNA 长度会小于 DNA）；</li><li>步骤二：核糖体沿着 RNA 长链移动，依次读取每个单词（即每三个碱基作为一个单词），每个单词对应一种氨基酸，将 20 多种氨基酸按照映射关系，依次首尾相连构成一条长链，最后长链会折叠成特定的形状，变成所谓的蛋白质；</li></ul><blockquote><p>蛋白质对生命非常重要，可以视作真正干活的那些工人，不同的工人有不同的技能；人体几乎所有的东西都是蛋白质构成的，例如头发、激素等；蛋白质还可以将自己附着在基因的头部（启动子和增强子），作为开关控制基因的是否表达，例如虽然所有的细胞都包含同一套基因，但是在不同的部位，例如心脏和皮肤，只有与之相关的部分基因会得到表达，从而创建出具有不同功能的蛋白质，最终产生不同形态和功能的细胞（细胞更像一个车间，蛋白质是在车间里面干活的工人）；</p></blockquote><p>四个碱基字母，每三个构成一个单词，总共有 4 * 4 * 4 &#x3D; 64 种组合，即 64 个单词，但是氨基酸只有 20 种，因此会出现多个密码子对应同一种氨基酸的情况；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202311272017692.png"></p><p>基本在复制过程中，有时候会多复制了一个字母，有时候会漏复制一个字母，有时重复复制或者漏复制某个句子或者某个段落，有时复制后的顺序是颠倒的，这种复制异常称为“突变”；绝大多数突变不会带来任何作用，既无害也无益，因为多个密码子对应一种氨基酸，所以即使复制出错，也经常能用。但如果刚好在一些关键的地方出现错误，则可能会有致命的后果。</p><blockquote><p>人类的基因组中，大约有 100 万个密码子（有用的单词）；每个世代通常会累积 100 个左右的突变，即万分之一；</p></blockquote><p>一些特例：</p><ul><li>仅有 23 条染色体并不足以构成完整的人类，因为我们身上还有一个非常重要的共生细菌：线粒体；当复制 DNA 时，还需要同时复制线性体的 DNA，才能够生产出包含正常功能的细胞；</li><li>并非所有的生命都使用 DNA 作为基因的载体，有些病毒会使用 RNA 作为基因载体；</li><li>DNA 转录成 RNA 后，大部分 RNA 会用来生产蛋白质，但有些 RNA 则会直接做为干活的工人来用，例如作为转运 RNA 或者组成核糖体，不参与生产蛋白质；</li><li>有少数 RNA 会参与催化反应，功能类似于蛋白质的催化作用；</li><li>多数蛋白质由单个基因负责生成，但有少数蛋白质是由多个基因共同合成的；</li><li>64 个密码子中，有 3 个没有映射氨基酸，而是作为停止信号；</li><li>大部分 DNA 内容是垃圾，是一些重复或者随机的杂乱序列，没有任何作用，不会被转录（但可以用来判断遗传世代，因为世代越多，累积的突变也越多）；有用的单词（密码子）大约有 100 万个，只占全部 10 亿个密码子的 0.15% 左右，即有 99.85% 的单词是无用的；</li></ul><h1 id="1-生命"><a href="#1-生命" class="headerlink" title="1.生命"></a>1.生命</h1><p>染色体有23对，每对有2条，因此总共有 46 条染色体；每条染色体有一条长臂和一条短臂；两条臂通过着丝粒连接在一起；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202311272117538.png"></p><p>蛋白质：与化学反应、呼吸、新陈代谢等有关（表现型）；DNA：与信息、复制、繁殖、遗传等有关（基因型）；二者共同组成生命机器，缺一不可；但二者并非源头，因为二者存在显著的分工，互相依赖。源头很可能是同时具备表现和遗传两种功能的 RNA，之后才演化出分工更加明确和高效的蛋白质的 DNA 组合；RNA 的缺点是不稳定，因此能够演化出更加稳定携带信息的 DNA 便具备了繁殖优势；</p><p>细菌的结构非常简单和高效，以致于我们有一度认为生命的起源于某种类似细菌的单细胞生物。但事实很可能刚好相反，细菌的世代更新很快，因此它们的演化速度比动物要快得多，它的简单并非一开始便是如此，而是在激烈的生存环境中自然选择的结果。那些拥有更粗糙更原始的形式，反而才更接近于源头祖先的形态；</p><p>密码子和氨基酸的映射关系，例如 CGA 对应精氨酸，GCG 对应丙氨酸，在所有生物形态中都是一样的，不管它是细菌、蝙蝠、鱼还是鸟类，这意味着全球所有生命都使用同一套基因语言，同时也说明所有的生命源自于共同的祖先；</p><h1 id="2-物种"><a href="#2-物种" class="headerlink" title="2.物种"></a>2.物种</h1><p>人类是当今地球上数量最多的大型动物，能适应各种生存环境，拥有改造生存环境的能力，算是一个相当成功的物种。但事实上，人类的各种祖先，在历史上曾经遭遇过多次的竞争失败，进入几近灭绝的状态。其后代能够存活到今天，并且如此强大，有很大的偶然成分。</p><blockquote><p>不过话说出来，即使没有出现人，也不能排除其他物种在经历足够长的时间以及合适的环境条件时，也有可能进化出类似人的物种，即趋同进化；</p></blockquote><p>黑猩猩和人类的染色体差异非常小，如果从黑猩猩的基因组中随机选择一个“段落”（外显子和内含子），对比人类相同位置的“段落”，每 100 个字母中，平均只有不到 2 个字母的差异。这相当于说，人类和黑猩猩之间，相似度高达 98%；</p><blockquote><p>人类有 23 对染色体，所有其他猿类有 24 对染色体。乍一看貌似差异很大，其实是因为有两对染色体在人类身上融合成了一对染色体；这很可能是因为某种地理隔离因素造成近亲繁殖后的结果，这或许也是为什么人类基因组中累积的随机变异比黑猩猩少的原因；</p></blockquote><p>人类大脑体积的不断变大，很可能是性选择的结果，就像雄孔雀的尾巴；环境变化选择了直立行走；直立行走导致了股盆变窄和婴儿早产；婴儿早产增加了养育成本，导致了一夫一妻；一夫一妻导致两性优先考虑选择年轻健康的异性，而大脑体积变大，更接近幼态化的特征，变成了性选择的结果；</p><h1 id="3-历史"><a href="#3-历史" class="headerlink" title="3.历史"></a>3.历史</h1><p>（本章简单回顾了基因发现的历史过程，略过）</p><h1 id="4-命运"><a href="#4-命运" class="headerlink" title="4.命运"></a>4.命运</h1><p>在 4 号染色体上面，存在一个特别的基因；如果这个基因中 CAG 重复的次数超过 35 次，则一定会患亨廷顿舞蹈症；重复的次数越多，则发病的时间越早。它是一种显性遗传的疾病，但是由于发病时间较晚，一般要到中年才会出现症状，因此它未能被自然选择所淘汰；</p><p>CAG 对应谷氨酰胺，当重复次数过多时，其所生成的蛋白质就会越长；过长的蛋白质会彼此聚集，并积累成难以被降解的蛋白质块，最终导致细胞非正常死亡，进而引发神经系统方面的疾病；刚出生时，基因中重复的次数最少，随着年龄增长，在基因复制的过程中，有时会出错，导致插入重复的 CAG 单词，造成重复次数慢慢增长，直到突破临界点，造成蛋白质的聚集；</p><blockquote><p>年龄越大的男性，其遗传给后代的突变会越多，大约是女性的 5 倍；原因在于男性终其一生都在不断生产精子；基因复制的次数要比女性多得多，从而出错的概率也大得多；</p></blockquote><h1 id="5-环境"><a href="#5-环境" class="headerlink" title="5.环境"></a>5.环境</h1><p>人体有很多个基因组成，每个基因只负责制造一个或多个蛋白质，而人类的很多功能，并不仅仅由一个蛋白质来控制，而是很多蛋白质共同作用的结果。因此，整个机制是相当复杂的。大多数情况下，我们很难找到关联某种疾病或异常的单一基因，如亨廷顿舞蹈症。更多时候，我们会发现背后的因果关系是错综复杂的，有多个因素在共同起作用；</p><h1 id="6-智商"><a href="#6-智商" class="headerlink" title="6.智商"></a>6.智商</h1><p>我们在直觉上以为智商是遗传所决定的，但事实并非如此简单，由于人类大脑强大的学习能力，智商，或者说解决问题的能力，是可以后天练习和培养的；并且只要方法得当，也可以得到很好的效果；因此，环境也占了很大的比重；</p><blockquote><p>解决问题的能力是存在多个维度的，例如分析能力、实践能力、创新能力等；不同的人可能擅长不同的维度，而不同维度之间并不一定具备比较的意义；</p></blockquote><p>不管是发达国家，还是发展中国家，最近几十年来，各国人民的平均智商都在不断提高，就像平均身高不断在增长一样；</p><h1 id="7-本能"><a href="#7-本能" class="headerlink" title="7.本能"></a>7.本能</h1><p>基因赋予了我们很多本能的行为，例如语言本能；当与语言相关的基因出现异常时，也会导致患者语言功能的异常。</p><blockquote><p>作者为了论证掌握语法也是语言本能的一种，在书中举了很多语言障碍患者无法正常理解或掌握语法规则的例子。里面有些例子很牵强，因为我发现不同语系的语法规则存在不少的差别，这些差别跟作者的例子有所冲突。例如在中文语法中，并不存在动词的多种时态，名词也没有复数形式。作者举的一些语言障碍患者出错的例子，在中国人学英语时也普遍会出现，但这些中国人并不是语言障碍患者。</p></blockquote><p>语言本能对人类的演化和文明的出现起到了重大的作用，它也是我们身体内的基因被自然选择的结果；</p><h1 id="23-冲突"><a href="#23-冲突" class="headerlink" title="23.冲突"></a>23.冲突</h1><blockquote><p>人类的雌性有两条 X 染色体，雄性则只有一条 X 染色体 + 一条 Y 染色体；由于缺少备份，对于雄性来说，仅有一条 X 染色体表达相关的基因，因此，它容错率较低，导致一些疾病在男性身上发生的概率更大。</p></blockquote><p>两性的繁衍策略并不完全相同，例如雌性通过哺乳增加繁衍几率，雄性通过强壮打败其他雄性获得交配机会来增加繁衍几率；因此，对于异性繁殖的物种，促进雄性优势的基因，更容易集中于某条特定染色体上面，以便有利性状能够集中遗传给雄性后代；同时，雌性优势基因则会集中到另外一条染色体上面，以便将有利性状遗传给雌性后代。原本对称的普通染色体，因为分化和积聚的关系，逐渐变成了性染色体，能够造成两性的各种差异。原本性别可能由外部的偶然因素决定，例如温度，最终却慢慢演化成了由基因来决定性别。</p><p>Y 染色体上面积累的基因，需要抑制 X 染色体相同位点基因的表达，才能让自己的性状得以表达。也就是说，两条染色体上面的相同位点的基因，由于各自的利益不同，彼此之间是存在对抗和抑制作用的；二者能够决出胜负的个体，其优势性状才能够体现出来。</p><p>X 染色体决定雌性，那么假设 X 染色体出现突变，能够完全抑制 Y 染色体的基因表达，那么短期内，对于 X 染色体上面的基因最大化传播是有利的，因为所有的后代都将会是雌性。于是这种性状能够随着后代的不断增加而快速传播和扩散。但最终会导致种群内的雄性过少，于是很多雌性无法找到雄性实现繁殖，最终将导致该基因后代的灭绝。于是，那些有一定概率生产雄性后代的 X 染色体，将笑到最后成为赢家。</p><p>鉴于二者存在博弈竞争关系，因此那些出现重大变异的 Y 染色体，相比那些小变异的 Y 染色体，它们更不容易被 X 染色体发现。即相同位点的基因，改头换面的越夸张，X 染色体就越难以有针对性的识别并进行攻击；</p><p>一个物种的社会性和交际性越强，那么两性之间的交流也会越多，考虑到两性的利益不尽相同，这种生存环境便可以为性别基因的博弈提供自然土壤。很有可能人类智力的飞速进步，是性别基因博弈的副产品。</p><p>表面上看，每个人类个体好像是一个拥有自由意志的统一体，但事实并非如此。它在本质上是基因的产物，而且这些基因之间相互博弈，互相竞争，好比宫廷内斗。所谓的自由意志，绝大多数时候不过是一层假象。我们是体内各种基因所制造出来的蛋白质的傀儡；</p><h1 id="8-自利"><a href="#8-自利" class="headerlink" title="8.自利"></a>8.自利</h1><p>基因组中并非只有一个基因，而是有着几万甚至几十万个基因。这些基因并非第一天就有的，而是日积月累而来的。每一个基因的使命，都是让自己得到复制，从而延续下去。但资源是有限的，为了实现这个目的，不同基因存在着竞争的关系。有些基因并没有实质的作用，但为了让自己得到复制和繁衍，它甚至会生产虚假信号，让宿主误以为它很重要，甚至还占用资源让宿主多复制了几份拷贝出来。这些基因有很大一部分甚至还是外来的和尚，例如来自病毒或者细菌。它们更像是寄生在我们的基因组中。</p><p>某些寄生基因甚至还会主动复制自己，即会制造出蛋白质工人，帮助转录自己，并插入到基因中的其他位置，打入其他基因的地盘。</p><h1 id="9-疾病"><a href="#9-疾病" class="headerlink" title="9.疾病"></a>9.疾病</h1><p>大多数遗传多样性是中性的，它是自然突变的结果，而非自然选择的结果。即突变结果并没有产生明显的好处，也没有产生明显的坏处，因此在繁衍过程中被保留了下来。同时这个随机突变的过程，也会不断清除一些过往的突变（遗传漂变）。</p><p>某些基因突变让个体获得了抵抗某种疾病的能力，例如霍乱、疟疾等，但同时也可能会带来一些负作用，例如镰状细胞突变会造成贫血，但增加了个体抵抗疟疾的能力。</p><p>只要生命在不断的繁衍，那种整个物种的基因库就处于不断变化的动态中。随着时间的推移，未来子代的基因也将和他们的祖先存在很大的不同；突变是随机产生的，但是环境因素，例如微生物、同类资源竞争、捕食等，也会对突变进行不断的筛选。 </p><h1 id="10-压力"><a href="#10-压力" class="headerlink" title="10.压力"></a>10.压力</h1><p>大脑、身体和基因组三者之间相互影响，相互制约，共同决定着个体的生存状态；例如某个外部事件，如考试，会通过大脑的认知，引起个体的紧张焦虑，进而身体会进入压力应激状态，分泌更多的肾上腺素，让心跳加速。如果压力持续长期存在，就会导致身体缓慢的分泌皮质醇，而皮质醇会抑制免疫系统。因此，长期处于压力下的个体，更容易患上感染性的疾病；</p><p>基因并非无条件的表达，绝大部分基因的表达，都是有条件的，因此环境因素也很重要；由基因构造出来的个体，更像是一部能够对环境进行灵活适应的机器，而不是程序写死的机器。有很多基因的主要功能是基于环境信号，开启或关闭其他基因。</p><p>当代大多数人都处于工作状态中，但不同的个体在工作环境中的自主程度有所不同；那些自主程度低，更多受控于他人指挥的员工，更容易感受到工作压力，从而导致其有更大概率生病；</p><h1 id="11-个性"><a href="#11-个性" class="headerlink" title="11.个性"></a>11.个性</h1><p>大脑中不同神经递质的分泌水平，与个体的性格表现有关：</p><ul><li>多巴胺：太少的话会缺乏主动性和积极性，太多的话容易感到无聊倾向探索冒险；</li><li>去甲肾上腺素：多的话，能够提高代谢率，但容易害羞，易过敏；</li><li>5-羟色胺：少的话，容易冲动；高的话，容易强迫症；</li></ul><p>神经递质的分泌水平既有先天的因素，也有环境的原因；例如在不同的环境中，个体不同的社会地位会影响某些神经递质的分泌水平；</p><h1 id="12-自组装"><a href="#12-自组装" class="headerlink" title="12.自组装"></a>12.自组装</h1><p>以一个小小的受精卵细胞做为基础，之后该细胞将不断分化成一个复杂的个体。目前人类世界还没有任何一种机器，可以完成相似的过程。大自然在几十亿年积累下的杰作，确实令人叹为观止。在 12 号染色体上面，有一大段与发育相关的基因，用来控制这一复杂的过程。</p><blockquote><p>理论上所有的细胞都携带相同的基因，但当细胞位于胚胎中的不同位置时，会出现不同的表达，造成同源异形现象；</p></blockquote><p>这个过程涉及的步骤：</p><ul><li>细胞先判断自己所在的位置（大概率需要使用某些化学物质，跟周边的其他细胞沟通后，才能得出结果）；</li><li>根据位置，开启不同的基因开关，开始干不一样的事情；</li></ul><p>果蝇、小鼠、人类三者从外表上差异很大，但他们却共享同一套发育机制和基因。其中某些基因是如此相似，以至于用人类的某段发育基因，替代果蝇相同位置的基因后，果蝇仍然能够正常发育，完全看不出区别。这说明二者其实共享着同一套基因软件。</p><h1 id="13-史前"><a href="#13-史前" class="headerlink" title="13.史前"></a>13.史前</h1><p>不同的语言，可以通过比较词根，来判断二者的相似度；这个方法同样适合于基因，虽然基因远远不如语言那样稳定，但是通过计算突变频率，可以大致判断出亲缘关系的远近。</p><p>不同的生存环境，会带来不一样的演化压力。例如世代以放牧为生的群落，产生乳糖酶突变的人，能够更好更多的消化奶品，从而获得繁衍优势，有助于基因的传播。</p><h1 id="14-永生"><a href="#14-永生" class="headerlink" title="14.永生"></a>14.永生</h1><p>动物的寿命跟其生存环境有关，如果在生存环境中没有天敌（例如体型庞大），或者善于自我保护（例如乌龟），不容易意外死亡，那么能够帮助个体长寿的基因突变，就有机会在演化中得到筛选并胜出。反之，如果生存环境恶劣，容易意外死亡，那么个体需要尽量缩短繁殖周期，以便在意外死亡前，繁衍和传播自己的基因。此时，那些有助于长寿的突变，并没有机会发挥用处，因此难以在繁衍过程中被筛选出来。</p><p>人类在过去的几百万年中，一直处于食物链的顶端，没有天敌的威胁。因此，相比其他哺乳动物，人类的寿命是很长的。</p><p>人类的受精卵在早期有一段活跃和快速的分裂期，之后大部分细胞就关闭了相关的基因，停止分裂，进入了休眠状态。只保存少数细胞继续保持分裂的状态，例如生殖细胞，干细胞等。癌症从某种程度来说，相当于将细胞的分裂功能重新唤醒。</p><p>在人体中分裂越活跃的器官，例如结肠、皮肤、胃、乳房等，其细胞复制的次数也越多，因此越容易积累不良突变，进而产生癌症。而不健康的生活方式，其实是缘于对身体组织器官的损害，使得器官需要更多的分裂进行自我修复。</p><h1 id="15-性别"><a href="#15-性别" class="headerlink" title="15.性别"></a>15.性别</h1><p>在 15 号染色体上面，有少数基因携带印记，即记录着自己是来着父亲，还是来自母亲。因为在有些场合，性别之间是有对抗冲突的关系的。除了对抗，来自父亲的基因，也会和来着母亲的基因进行分工合作。对于父母自身的基因，原本也是来自两个不同性别的父母，但貌似在制造精子或卵子时，会改写原本的印记（貌似通过甲基化来实现）。</p><blockquote><p>甲基化：由甲基化转移酶实现，在胞密啶（字母 C）的某个位置，加上一个甲基基团，控制某段基因的表达。</p></blockquote><p>我们在直觉上会以为胎盘是母体的器官，但通过基因实验，后来发现胎盘其实是婴儿的器官，用来从母体身上获取营养。由于胎儿有一半的基因来自母体，这部分基因跟母体基因的利益是一致的。因此，如果由父亲的基因来控制胎盘的发育，由于不存在共同利益，其策略有可能会更加的激进，从而在演化过程中胜出。</p><p>如果某种动物的雌性在受孕时，会同时跟多个雄性交配。那些每个雄性胎儿，将面临多个同母异父的其他胎儿的竞争。在这种情况下，胎儿抢夺资源的策略越激进，则越有可能胜出。反之，如果雌性只跟固定的雄性交配，那么这种激进就会起到反作用，因为它变成了一种内斗，牺牲了同源的兄弟姐妹。</p><p>雌性有两条 X 染色体，因此她既可以将 X 染色体遗传给男性，也可以遗传给女性后代；而雄性只有一条 X 染色体，这条染色体只可能遗传给女性后代。因此一些女性独有的行为特征，主要由雄性的 X 染色体进行表达。不然这些行为就有可能通过母亲遗传给雄性后代。</p><h1 id="16-记忆"><a href="#16-记忆" class="headerlink" title="16.记忆"></a>16.记忆</h1><p>大脑有一套学习和记忆的机制，其中涉及多种神经递质的参与，例如环腺甘酸。如果基因存在缺陷，不能正常合成这些神经递质，那么就会造成学习或记忆能力的下降或缺失；</p><blockquote><p>我们不但普遍低估了人类的大脑对本能的依赖程度，同时还大大低估了其他动物的学习能力</p></blockquote><h1 id="17-凋亡"><a href="#17-凋亡" class="headerlink" title="17.凋亡"></a>17.凋亡</h1><p> 人体由数以亿计的细胞组成，这些细胞共享着一套基因，却各自承担着不同的功能。其中只有极少数的生殖细胞承担繁殖的任务，这个机制很像蜜蜂等社会性昆虫。通过高度分工，实现效率最大化。绝大多数细胞就像工蜂一样，终其一生无私的奉献，最终在没有自我繁殖的状态下死去。但繁殖的基因和本能自始至终是镌刻在细胞中的，只是被外部机器抑制了。少数被激发繁殖能力的细胞，也会被这套监管机器杀死。但凡事总有例外，总有那么少数几个细胞，通过突变，巧妙的逃过了检查，实现不受控制的自我繁殖，即癌症。</p><p>癌症肿瘤在早期的进展非常缓慢，因为此时突变位点较长，还不能完全逃脱各种外部监管措施。但由于肿瘤本身也在不断的自我复制和繁殖，后期积累的突变将会越来越多，呈指数级上升。当突变的数量最终量变引起质变时，便具备了强大的免疫逃脱的能力。此时再进行治疗，变得异常困难。</p><p>TP53 基因是抑制癌症细胞的一段基因，有 1179 个字母，用来编码 p53 蛋白。该蛋白通常会很快被降解，但如果在降解前收到了 DNA 损伤的信号，那么它就会停止降解，并活跃起来。之后它会进一步激活其他基因，以便让出现 DNA 损伤的细胞进行自杀。这便是放疗或者化疗的原理，这两种疗法都会造成一定程度的 DNA 损伤，从而激活了 p53 蛋白。如果 TP53 基因本身出现了突变，那么这一机制将不再有效，此时放疗或化疗便失去作用了。</p><p>每个细胞在诞生之初便内置了死亡时钟，当多个外部信号同时生效时（多重保险），这个死亡时钟会被暂时抑制住。但是当某一个外部信号不再存在时，时钟将被激活。</p><blockquote><p>细胞凋亡机制除了可以用来应对癌变，也可以用来应对外部感染。</p></blockquote><h1 id="18-疗法"><a href="#18-疗法" class="headerlink" title="18.疗法"></a>18.疗法</h1><p>很多疾病是因为基因缺陷造成的，因此如果能够修复相关的基因，就能够釜底抽薪的治愈疾病。虽然理论上可行，但这条路并不好走。</p><p>逆转录病毒能够侵入 DNA，将自己携带的基因混入 DNA 中。我们可以利用这一机制，将正确版本的基因放入 DNA。但是逆转录病毒的基因插入位置是没有规律的，因此这种做法的成功率很低。因为如果基因未能插入在正确的位置，便会无法表达，从而失去预期效果。</p><p>虽然基因疗法在动物身上困难重重，但在植物界却意外得到迅速发展。有两方面的原因，一个植物更容易繁殖或克隆；二是找到了更好的注入机制（借助农杆菌对植物的感染）；</p><blockquote><p>如果植物对农杆菌有抵抗能力，那么还有更简单粗暴的方法，直接用火药或者粒子加速器，将携带基因的金属颗粒射入植物细胞（或许也可想象为对植物发射霰弹）；</p></blockquote><p>很多环保组织出于对新技术的恐惧，强烈的排斥基因工程。但其实在自然界，物种间的基因交换远比人们预期的更加普遍。</p><p>通过显微注射进行基因编辑的方法是比较粗糙，结果充满了不确定性。但同源重组机制的发现，让基因编辑的精确性进了一大步。</p><blockquote><p>细胞会将同源染色体上的某条基因作为模板，用于修复其他存在问题的基因片段。同源重组除了用于修复，还可反向用于破坏。在破坏某段基因后，再观察小鼠的发育结果，从而了解该段基因的具体作用。</p></blockquote><h1 id="19-预防"><a href="#19-预防" class="headerlink" title="19.预防"></a>19.预防</h1><p>个体身上不同的基因，造成了个体对不同疾病的易感程度。如果能够提前知道个体的基因类型，就能够调整生活习惯，对易感疾病进行有效的预防；</p><p>基因检测有助于提示潜在的风险，但同时这种可能罹患某种疾病的概率，也是保险公司很早知道的信息，因为这样有助于降低赔付成本，最终导致对不同个体制定不同的保费。</p><h1 id="20-政治"><a href="#20-政治" class="headerlink" title="20.政治"></a>20.政治</h1><p>具备活性的蛋白质除了有可能是营养物质外，也有可能是一种病毒，例如朊病毒；在满足特定条件时，有可能存在传染性。</p><blockquote><p>朊病毒蛋白质原本是一种正常的蛋白质，之后由于突变，其折叠形状出现了改变。突变后会感染附近其他正常的朊病毒蛋白，让其发生同样的折叠突变，最终产生链式反应。</p></blockquote><h1 id="21-优生"><a href="#21-优生" class="headerlink" title="21.优生"></a>21.优生</h1><p>优生学在 100 年前的欧洲曾经非常流行，大部分欧洲国家都试图或已经通过法案，对部分存在智力问题的人实话强制性的绝育。虽然从基因的角度来说，这种做法确实有助于减少疾病发生的概率。但是这种概率本来就很少，为了如此渺小的收益，却以个体的权利为代价，显然是很不明智的。事实上选择更加优秀的配偶，本质上也算是一种优生学，区别在于以个体的自我选择和个体利益为基础，而非以国家集体利益为基础。</p><h1 id="22-自由意志"><a href="#22-自由意志" class="headerlink" title="22.自由意志"></a>22.自由意志</h1><blockquote><p>自由意志是人类无法分析自身的动机而产生的错觉。</p></blockquote><p>真的没想到，上面这句话是达尔文说的。没错，就是那个查尔斯达尔文；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-导论&quot;&gt;&lt;a href=&quot;#0-导论&quot; class=&quot;headerlink&quot; title=&quot;0.导论&quot;&gt;&lt;/a&gt;0.导论&lt;/h1&gt;&lt;p&gt;如果将基因组比作一本书，那么组成如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;染色体：章&lt;/li&gt;
&lt;li&gt;基因：写在章里面的故事，每章</summary>
      
    
    
    
    <category term="社科" scheme="https://ccw1078.github.io/categories/%E7%A4%BE%E7%A7%91/"/>
    
    
    <category term="医学" scheme="https://ccw1078.github.io/tags/%E5%8C%BB%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>巴菲特的信</title>
    <link href="https://ccw1078.github.io/2023/11/14/%E5%B7%B4%E8%8F%B2%E7%89%B9%E7%9A%84%E4%BF%A1/"/>
    <id>https://ccw1078.github.io/2023/11/14/%E5%B7%B4%E8%8F%B2%E7%89%B9%E7%9A%84%E4%BF%A1/</id>
    <published>2023-11-14T14:15:00.000Z</published>
    <updated>2024-09-23T00:59:48.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公司治理"><a href="#公司治理" class="headerlink" title="公司治理"></a>公司治理</h1><p>从长远来说，公司的经营情况跟公司的管理层密切相关。因此，如果不了解某家公司的管理层，那就不要轻易的去投资它；</p><p>优秀管理层的特征：坦诚、能干、勤奋；</p><p>企业的行业特征多种多样，不存在一劳永逸的标准方案实现对 CEO 的监督，因此，最核心的是找到正确的人，而不是想法设法设计汇报监督流程或制度；</p><p>股东希望 CEO 拥有长远的目光，以此同时，股东对 CEO 的考核也需要相应的匹配，以免 CEO 为了短期利益牺牲公司的长期竞争力；</p><p>期权并不如想象的那么万能，如果采用期权，那么应该将其和个人业绩挂钩，而不是和公司业绩挂钩；业绩计算需要扣除相关业务的资本费用，以及留存利润所产生的利润；如果可能的话，尽量以现金作为薪酬奖励，而不是使用期权或股票；如果管理人员想要股票，可以自己掏钱购买；</p><blockquote><p>无追索权贷款：以项目本身作为抵押进行贷款，如果盈利状况良好，则用现金偿还贷款；如果盈利状态不好，则用抵押物偿还贷款；市政基建项目，例如高速公路、铁道等项目常采用这种方式；</p></blockquote><h2 id="完整公平的信息披露"><a href="#完整公平的信息披露" class="headerlink" title="完整公平的信息披露"></a>完整公平的信息披露</h2><p>让 CEO 对公司的未来盈利做出预测是很危险的行为，因为市场存在诸多不可控的因素，很多时候我们只能是尽人事，听天命；逢山开路，遇水搭桥；而一旦 CEO 作出公开的预测，那么为了兑现自己的预测，避免出现打脸，绝大多数 CEO 会为了获得短期收益，损坏公司的长期利益，例如开展没有把握的新业务（格力造手机），甚至粉饰报表和财务造假；</p><p>小心那些粉饰报表的企业，原因有三：</p><ul><li>如果在厨房里发现了一只蟑螂，那么可以保证，绝对不止一只；</li><li>不知所云的科目，往往意昧着躲躲闪闪不诚实的管理层；</li><li>鼓吹高成长预测的 CEO，就像那些华而不实的推销员，多半另有所图；</li></ul><h2 id="董事会与公司高管"><a href="#董事会与公司高管" class="headerlink" title="董事会与公司高管"></a>董事会与公司高管</h2><p>普通职员的绩效是很容易考核的，但对于 CEO 这种职位的考核却很难，因此，市场上充斥着大量平庸的 CEO，占着茅坑不拉屎；</p><p>有三种常见的董事会类型：</p><ul><li>没有控股股东：此种类型最为常见，为了实现对 CEO 的有效监管，此种类型的董事会规模应该越小越好，同时尽可能来自公司外部，因为人少容易达成一致；如果某个正直的董事无法获得其他董事的支持，那么应该向公众发声，让未进入董事会的小股东们了解情况，取得他们的支持；</li><li>有控股股东，同时是公司高管：董事基本没法监管 CEO，除非通过辞职引起公众注意，警示公司管理存在风险；</li><li>有控股股东，但未参与企业管理：董事可以将不满传达给控股股东（通常是另外一位董事）；理论上，这种情形最有利于实现对管理层的监管；大股东可以精心挑选和管理层没有利益关系的外部独立董事，实现兼听则明；</li></ul><p>绝大多数上市公司或公募基金的董事都未能达到预期的目标，因为一名合格的董事需要具备以下三方面的特质：</p><ul><li>精通商务；</li><li>股东利益导向；</li><li>有责任心；</li></ul><p>市场上一直流行着“独立董事”的声音，但事实上这是一种违反常识的安排，当某位董事的身家并不在公司股票中的时候，如何能够寄希望于它能够尽心尽职，以股东利益为导向呢。尤其是董事年金是其重要的收入来源时，常常还会带来负面效果，即董事为了一已私利而牺牲公司的长远利益。</p><p>只与自己喜欢和尊重的经理人打交道是非常重要的，因为它不仅仅有助于获得良好的投资回报，更重要的是，它让我们的人生变得更加幸福，因为和喜欢的人一起工作，本身就是让人幸福的重要组成；</p><p>对天才经理人的要求（为其创造以长期利益为考量的工作环境，消除各种短期干扰，以最大化的发挥其管理天赋）：</p><ul><li>假设你拥有100%的股份；</li><li>将公司视为你和你的家庭在世界的唯一资产，并且一直持有；</li><li>至少在100年内，不出售公司或与其他公司合并；</li></ul><h2 id="市场变化的焦虑"><a href="#市场变化的焦虑" class="headerlink" title="市场变化的焦虑"></a>市场变化的焦虑</h2><p>时势造英雄，而不是英雄造时势。因此，想要获得良好的投资回报记录，重要是选择上什么船，而不是专注于提高划船效率；当美国的纺织行业被东亚的竞争打败，失去成本优势时，能力再强的管理人也是毫无办法的，最多只能相对同行延缓公司的亏损速度；</p><h2 id="社会契约"><a href="#社会契约" class="headerlink" title="社会契约"></a>社会契约</h2><p>伯克希尔旗下有两家公用事业公司，一家做铁路运输，一家做电力供应。公用事业行业的特点是需要巨额的投入（其资金主要来源于发行债务），同时接受政府的严格管制。管制的目的是防止垄断和涨价，优点是能够保证稳定的投资回报率。</p><blockquote><p> 相对同行，伯克希尔的这两家公司的运营效率惊人，猜测应该是拥有非常优秀的管理层。由于伯克希尔是控股股东，因此猜测很可能属于前面提到的董事会组成的第三种情况</p></blockquote><h2 id="公司高管的报酬原则"><a href="#公司高管的报酬原则" class="headerlink" title="公司高管的报酬原则"></a>公司高管的报酬原则</h2><p>公司的留存利润是可以产生收益的，因为它可以做为来年的资本投入，而且还是零成本的；另外，行业的平均增长率也很重要，能力平平的管理人，也能够因为行业处于上升期而得到市场平均业绩，但这并不值得获得赞美；</p><p>如果公司高管在剔除行业因素和留存利润因素后，仍然取得了优秀业绩，那么才能够成为其优秀管理能力的证据；</p><p>超长期（例如十年）的固定价格期权是非常不合理的，因为经常完全未考虑每年的留存利润给公司业绩带来的贡献；行权期限控制在 10 个月更加合适；</p><p>期权经常被滥用，有两点需要注意：</p><ul><li>因为股票是代表整个公司的权益，因此相应的，期权也应该仅限于授予那些为公司整体业绩负责的人员；</li><li>期权在设计时，应该考虑留存利润和资本成本两方面的因素，而不是零成本的授予；</li></ul><blockquote><p>期权并非股票，二者之前有本质的不同；</p></blockquote><p>更好的方式是尽量避免使用期权，因为很多时候股价跟业绩并不一定直接相关；好的业绩，遇到不好的市场，股价低迷，而管理人员的付出仍然值得被肯定；</p><p>子公司从母公司借钱时，应该收取利息成本；反之，如果子公司借钱给母公司，母公司也应该支付利息给子公司。资本不免费很重要，因为它可以让资金的使用效率最大化；</p><h2 id="风险、声誉和失察"><a href="#风险、声誉和失察" class="headerlink" title="风险、声誉和失察"></a>风险、声誉和失察</h2><p>名誉胜过金钱，我们可以承受巨大的金钱损失，但不能承受名誉损失。因为如果保持良好的声誉，那么金钱的损失是很容易再赚回来的。但如果失去了声誉，即使当下赚到了钱，那也很可能会是最后一笔；</p><p>大部分公司的审计师是由 CEO 或者 CFO 聘用的，因此出于生计的考虑，他们经常和 CEO&#x2F;CFO 穿同一条裤子，但这很可能会损害股东的利益。因此，由公司董事组成的审计委员会，必须让审计师明白，如果未如实披露，他们需要为此承担巨额罚金；这种作法的目的是防患于未然，避免出现假账；</p><h1 id="财务与投资"><a href="#财务与投资" class="headerlink" title="财务与投资"></a>财务与投资</h1><p>有效市场理论被证明是错误的，因为市场交易的背后，是一个一个具体的人，而人并非理性动物，更多时候是感性和情绪化的。价格与价值的差距是普遍存在的，相对于内在价值，如果能够以越低的价格购入股票，那么该项投资的安全边际越高；</p><p>对于普通人来说，评估投资风险是相当有难度的，因为其中涉及的维度很多，包括</p><ul><li>管理层的诚信和能力；</li><li>产品情况；</li><li>竞争对手的情况；</li><li>企业负债的情况；</li></ul><p>因此，对于绝大多数投资者来说，最好的投资标的是指数基金。除非投资者拥有某些特殊渠道或专业，能够收集和深入了解某个特定领域的上述各项信息，即能力圈原理（只聚焦于自己看得懂并了解的公司）；</p><h2 id="市场先生"><a href="#市场先生" class="headerlink" title="市场先生"></a>市场先生</h2><p>投资者想要获得成功，需要具备两项能力：</p><ul><li>识别优秀企业的能力；</li><li>将自己的情绪与市场情绪进行隔离的能力；</li></ul><p>长期持有好的公司，因为它值得长期持有。在市场低迷的时候，运用手头的资金，更多的投入好公司的股票。每一次的市场低迷，都是一次以小博大的好机会；</p><h2 id="套利"><a href="#套利" class="headerlink" title="套利"></a>套利</h2><p>事实上巴菲特利用旗下保险公司的资金，偶尔也会做短期投机和套利，但总体来说，更多是将套利作为账面上大量现金的一种管理工具，并坚持唯一的一条原则：只有胜券在握的时候才出手。</p><p>可供套利的领域：</p><ul><li>同一家公司，在不同交易所，以不同币种计价的股票；由于汇率波动，中间可能存在价差；</li><li>某个公司出现重大事件可能造成的股价波动，例如出售、合并、重组、改制、清算等（例如最近微软收购暴雪，伯克希尔有购入股票套利）；</li></ul><p>投机决策涉及的风险考虑点如下：</p><ul><li>基于事实而非传言；</li><li>事件发生的概率；</li><li>事件未发生的可能损失；</li><li>资金占用时间；</li><li>机会成本；</li></ul><h2 id="戳穿标准教条"><a href="#戳穿标准教条" class="headerlink" title="戳穿标准教条"></a>戳穿标准教条</h2><p>评估待投资公司的几个因素：</p><ul><li>公司长期保持竞争力的确定性（因此需要投资那些自己看得懂的行业，不然无法判断企业的竞争力）；</li><li>公司管理层的能力，例如充分实现企业潜力的能力、有效使用流金流的能力等；</li><li>公司管理层是否会以公谋私，牺牲股东利益，中饱私囊；</li><li>公司股票的价格是否高估；</li><li>可能遇到的通胀水平和税率水平；</li></ul><h2 id="价值投资"><a href="#价值投资" class="headerlink" title="价值投资"></a>价值投资</h2><p>虽然通过控股的方式，可以有权力更换管理层，但事实上这个权力执行起来难度很大。因为管理层和公司有点类似婚姻的关系，经常绑定的很深，因此拆开它们除了费时费力外，还可能隐藏着风险；</p><p>但控股有另外一项好处，即能够支配子公司的留存利润，通过更好的资产配置，让留存利润实现更大的增值；很多公司的 CEO 很擅长管理好自己的公司，但却常常不擅于资产配置，因为这是两个完全不同的专业；</p><p>如果所投资的公司是上市公司，那么相对非上市公司有一项好处，即可以利用在市场出现恐惧心态时，低价购入更多的股票；</p><p>公司的营业规模变大不一定是一件好事，因为有可能边际成本上升，即每投入1美元，其他边际收益在下降，甚至变成负数。那么这种成长可能是有毒的，因为完全可以将资金转到其他回报率更高的项目；</p><p>理论上来说，股票的合理价格应该是其未来所有现金流收入在当前的贴现；但这并不容易估算，估计是因为管理层能力是一个巨大变数；因此，在挑选投资标的时，只选择那些自己看得懂的行业是很重要的，因为这样能够最大程度的保证本金的安全；另外安全边际也很重要，如果价格与价值相当接近，则安全边际不足。仅当价格明显低于价值时，才是好的投资时机；</p><blockquote><p>事实上，相对一级市场，在二级市场购入股票的一个好处是有机会等待市场周期的出现，在人们恐慌的时候以半价入手；</p></blockquote><p>为了让优秀的管理层放心，伯克希尔做了两个非常的举措：</p><ul><li>将所持股票的投票权委托给管理层；</li><li>需得到管理层的同意，才有权出售所持股票；</li></ul><h2 id="聪明的投资"><a href="#聪明的投资" class="headerlink" title="聪明的投资"></a>聪明的投资</h2><p>虽然一些高速成长的企业，能够带来巨大的投资回报，但有时候这些企业缺少远期的确定性，因此需要特别小心。</p><p>另外有些企业在过往很长的时间内，在卓越领导人的带领下，实现了巨大的成功，以至于很多人相信它们仍将在未来保持赢者通吃的局面，但事实证明并非如此，例如 IBM、通用汽车、诺基亚、索尼、西尔斯百货公司等；</p><p>能够长久保持成功的公司是极少极少的，注意识别并牢牢抓住它们即可，例如可口可乐、吉列公司等。聪明的投资者并不是说要做出很多成功的决策，而是只需要做对少数几个重要的决策即可。 </p><p>聪明的投资决策只需要学好两个技能即可：</p><ul><li>如何评估一家公司的价值：找到那些在未来的5年、10年、20年能够实现大幅盈利增长的企业；</li><li>如何对待市场价格：以理性的价格尽量大量买入并长期持有，理想情况是在别人恐惧的时候尽量贪婪；</li></ul><blockquote><p>抵制诱惑，不要去碰那些我们能力圈和认知水平之外的事物。即使每个人的能力圈可能很小，但行行出状元，小的能力圈也仍然存在好的机会。</p></blockquote><h2 id="捡烟蒂和惯性驱使"><a href="#捡烟蒂和惯性驱使" class="headerlink" title="捡烟蒂和惯性驱使"></a>捡烟蒂和惯性驱使</h2><p>不良的企业文化（或者叫企业惯性）是一种很可怕的东西，个人的不良习惯尚且难以改变，对于由众多个体所组成的组织来说，这种惯性的改变难度可想而知。因此，即使空降一名优秀的 CEO，也是于事无补的。好的骑手只有坐在一匹良马的背上，才有可能创造好成绩。骑在一匹驽马背上，则是完全没有机会的。</p><h2 id="生命与负债"><a href="#生命与负债" class="headerlink" title="生命与负债"></a>生命与负债</h2><p>杠杆有时能够提高短期收益水平，但也可能带来成倍的损失，它是一把双刃剑，要谨慎使用。如果某个杠杆让自己睡不着，那么说明不是使用杠杆的时候。仅仅在高枕无忧的时候才去使用它。</p><h1 id="投资替代品"><a href="#投资替代品" class="headerlink" title="投资替代品"></a>投资替代品</h1><h2 id="三类投资资产"><a href="#三类投资资产" class="headerlink" title="三类投资资产"></a>三类投资资产</h2><ul><li>基于货币的资产，例如货币基金、债券、按揭、存款等；这种资产短期内看似很安全，但长期来看，最危险。购买力损失最大，因为常常无法跑赢通货膨胀；</li><li>不创造价值的资产，例如黄金、比特币、郁金香等；其价格上升依赖于不断入场的接盘侠；当无人接盘时，价格停滞或下跌；</li><li>可创造价值的资产，例如企业、农场、房地产等；</li></ul><blockquote><p>农场和房地产只是形式不同，其实本质相同，即都是有良好使用价值的土地资源；</p></blockquote><h2 id="垃圾债券"><a href="#垃圾债券" class="headerlink" title="垃圾债券"></a>垃圾债券</h2><p>垃圾堆里面通常是会有那么1-2个宝，但通常很难找，需要极大的运气。花费大量时间翻找出来的东西，绝大部分正如其名字一样，是真正的垃圾。</p><h2 id="零息债券"><a href="#零息债券" class="headerlink" title="零息债券"></a>零息债券</h2><p>零息债券并不是真的不需要支付利息，而是更类似于支付砍头息，即10元的债券，以8元发行，差额的2元即是利息。</p><p>相比传统债券定期支付利息，零息债券的好处是通过市场化的债券定价，极其方便的实现了债券复利投资；堪称是一种天才的发明。但是由于在债券到期日前，借款人无需支付利息，这也意味着借款人可能出现的违约要到最后一天才会暴发。到期日前会维持一种信用良好的假象。借款人还可以利用这种假象，借新债还旧债，推迟风险的发生。</p><p>为了能够实现借新还旧，华尔街的推销员开始搞各种创新，不断降低评估企业的还贷能力的标准，以便让其看起来具备还钱能力的样子。</p><h2 id="优先股"><a href="#优先股" class="headerlink" title="优先股"></a>优先股</h2><p>优先股有点像是混合版的普通股+债券，包括：</p><ul><li>优先股会事先约定好股息率，这点很像债券；但股息派发没有保证，仅在公司派息时，可以优先保证先派，派完后，如有剩余，再派发普通股；每个年度应派发的股息，如未派发，可以累积，等后续年度派发（也可不累积，看实际的约定）；</li><li>公司破产清算时，优先股的偿付优先级低于债券，但高于普通股；</li><li>优先股没有表决权，即不参与公司经营；但优先股可转成普通股，同时公司也有赎回权；</li></ul><blockquote><p>本质上，优先股也是一种融资手段，相比债券，它的偿付压力小一些，没有到期日，可以更灵活的偿付，避免出现违约；同时可以不稀释表决权，但代价是一般需要支付比债券多一点的利息。</p><p>目前国内的证券法规，基于同股同权，因此暂时还不支持公司发行优先股；</p></blockquote><h2 id="衍生品"><a href="#衍生品" class="headerlink" title="衍生品"></a>衍生品</h2><p>衍生品这个名词有点抽象，容易让人摸不着头脑。其实本质上是交易双方签订的一份合同；合同中约定某个指标，到了约定的时间后，根据指标，决定是甲方付给乙方钱，还是反过来乙方付钱给甲方，类似一份对赌的协议；</p><p>对赌本身问题不大，不外乎是一方赚钱一方亏钱。但是当双方将合约放入财务报表时，合约很容易带来虚假盈利。因为合约通常是远期的，存在各种不确定因素，而之所以签订合约，肯定是认为自己可以赢，于是双方都将合约记为某些形式的资产。原本的一亏一盈，现在变成了两个都是盈。</p><p>衍生品合约一般会有担保条款，该条款通常和公司的信用评级挂钩。当公司的评级下调时，对方有权要求追加保证金。因此，当偶然出现某个不可抗力的外部小风险时，合约中追加担保的条款将造成公司的现金流紧张，进而导致公司的信用评级下调。之后触发新一轮追加担保和评级下调，周而复始，陷入恶性循环，将原本的小风险放大成了一场大灾难。</p><p>由于很多保险公司为了回笼现金流，通常会将手中的合约打包出售给下家，以便最大程度通过杠杆做大营业额。但这也为连锁反应埋下了定时炸弹。一旦某个公司出现风险，由于缺少有效的隔离机制，风险将在市场上不断蔓延开来，产生多米诺骨牌效应，将一大堆原本健康的公司拖下水。</p><h2 id="外汇和国外权益"><a href="#外汇和国外权益" class="headerlink" title="外汇和国外权益"></a>外汇和国外权益</h2><p>短期的贸易逆差问题不大，但如果出现长期的贸易逆差，那意味着整个国家入不敷出，此时要么给别人打了欠条，要么是变卖了部分家产。长此以往，整个国民财富实际上是在慢慢的消耗和减少。</p><h2 id="房屋产权：实践和政策"><a href="#房屋产权：实践和政策" class="headerlink" title="房屋产权：实践和政策"></a>房屋产权：实践和政策</h2><p>在城市化的过程中，房屋产权是一种能够获得的优秀投资品。但在城市化结束后，房屋更多体现的是居住价值，拥有自己的房屋能够提高生活的幸福指数。因此它注定是人们所向往购买的商品。也正因如此，从长远来看，拥有房屋产权能够有效的抵抗通货膨胀。当然了，前提是该房屋坐落在经济发展良好的城市。如果是经济衰退的城市，由于人们不断的离开，那么房屋产权将变得越来越不值钱，就像国内的鹤岗、日本的夕张、美国的底特律等城市。</p><h1 id="普通股投资"><a href="#普通股投资" class="headerlink" title="普通股投资"></a>普通股投资</h1><p>交易的本后是人，而人不可避免会受到情绪的影响，因为股市总是周期性的出现极度乐观和极度悲观。这种波动看似危险，但其实也是机会。因为当市场极度悲观时，就能够以越低的价格购入优秀公司的股票，收获更大的安全边际。</p><h2 id="交易的祸害：交易成本"><a href="#交易的祸害：交易成本" class="headerlink" title="交易的祸害：交易成本"></a>交易的祸害：交易成本</h2><p>美股市场一年的交易成本，达到了所有上市公司盈利的20%，非常可怕，说明背后每天都有大量的交易在发生。</p><h2 id="吸引正确的投资者"><a href="#吸引正确的投资者" class="headerlink" title="吸引正确的投资者"></a>吸引正确的投资者</h2><p>没有哪个机构会希望自己的成员大量的流进流出，除非有人以此为生。</p><h2 id="分红政策与股票回购"><a href="#分红政策与股票回购" class="headerlink" title="分红政策与股票回购"></a>分红政策与股票回购</h2><p>受限定收益：必须留存的利润，用于后续的再投资，以便公司保持市场竞争力；</p><p>非限定收益：可用于分红的利润；</p><p>大部分企业的管理层倾向于保留非限定收益，即不分红；因为这样对管理层有利，但是这种做法不一定对股东有利。因为有可能公司的资金使用能力很糟糕，再投资回报率很低。因此与其留存利润，还不如将钱发给股东，让其投资到其他回报率的领域，可惜绝大多数公司并不会这么做；但非常有趣的是，很多集团公司要以该标准来管理下属子公司的留存利润，其智商在此刻，就会表现得像一个聪明的投资者一样。</p><p>对于大型公司，某个业务板块有可能非常赚钱，此时它往往会帮管理层掩盖住那些不赚钱的项目。因此，以决定是否分红时，仅仅看总的增量资本回报率是不够的，要每个业务单独拆开来看，才比较准确。</p><p>除了分红，留存利润还有一个用途是回购股份。当回购价格低于内在价值时，回购股份是一项很不错的做法；事实上，在市场陷入极度悲观时，这也是一种用来鉴别那些以股东利益为导向的管理层的有效办法。</p><h2 id="拆股与交易活动"><a href="#拆股与交易活动" class="headerlink" title="拆股与交易活动"></a>拆股与交易活动</h2><p>9张10元钞票的总价值，并没有比1张100元钞票来得更多。股票价格越低，意味着购买的门槛越低，因为不可避免会有大量的情绪交易充斥其中，造成股价的情绪化变动，这并没有什么好处。甚至还有坏处，因为换手率越高，意味着交易成本越高。</p><h2 id="股东策略"><a href="#股东策略" class="headerlink" title="股东策略"></a>股东策略</h2><p>美股貌似可以将股票以约定的价格销售给指定人员，以实现定额捐赠；另外，还可以和受赠人成立合伙企业，以股票作为注资方式，之后每年可以让渡一定的权益给受赠人。</p><h2 id="伯克希尔的资本重构"><a href="#伯克希尔的资本重构" class="headerlink" title="伯克希尔的资本重构"></a>伯克希尔的资本重构</h2><p>为了方便股东实现低金额的股票捐赠，伯克希尔新发行了 B 类股票。B 类股票的投票权只有 A 类股票的 1&#x2F;200，权益则是 1&#x2F;30；A 股可以转 B 股，但 B 股不可转 A 股；</p><h1 id="兼并与收购"><a href="#兼并与收购" class="headerlink" title="兼并与收购"></a>兼并与收购</h1><p>收购其他企业是一项容易让管理层兴奋的活动，他们有一种错觉，认为自己将给被收购公司带来根本性的改变，实现 1+1&gt;2 的效果，就像童话故事中公主亲吻的青蛙变成了王子。但事实上，他们很快就会知道，会变成王子的青蛙可遇而不可求，亲吻的对象几乎全是癞蛤蟆。</p><h2 id="错误的动机和高昂的代价"><a href="#错误的动机和高昂的代价" class="headerlink" title="错误的动机和高昂的代价"></a>错误的动机和高昂的代价</h2><p>公司的管理层总是喜欢收购活动，有两方面的原因：</p><ul><li>对自身管理能力的过度自信；</li><li>追求营业规模，因为外界对管理者的评价跟公司营业规模有关，但跟盈利无关；</li></ul><p>通常收购使用现金或者借贷，但公司的现金和借贷通常是有限的，因此还有另外一种激进的做法是通过发行新股来实现收购；如果此时公司的股价低于其内在价值，那么这种收购方式实际支付的成本变高了，并不划算；为了挽回损失，有时会附加回购条款，即收购方在一定期限后，能够以约定的价格回购股票。这样一来，就重新变回公平的现金收购了；</p><p>如果收购方公司的盈利前景好于被收购方很多，那么长远看来，发行股票进行收购的方式，是很不划算的；</p><h2 id="合理的股票回购和绿色邮件讹诈式回购"><a href="#合理的股票回购和绿色邮件讹诈式回购" class="headerlink" title="合理的股票回购和绿色邮件讹诈式回购"></a>合理的股票回购和绿色邮件讹诈式回购</h2><p>绿色邮件讹诈式回购有点像是野蛮人的一些做法，即先在市场上大量购入目标公司的股票，悄悄获得控股地位，然后私下威胁换掉管理层，逼近管理层不得不筹借资金，回购野蛮人手中的股票。对于旧的股东来说，相当于遭遇了一场敲诈；</p><h2 id="杠杆收购"><a href="#杠杆收购" class="headerlink" title="杠杆收购"></a>杠杆收购</h2><p>定义：将待收购的公司抵押给银行，获得信贷额度（例如70%），然后拿着这个钱，加上自己投入的钱（30%），支付给原公司股东换取其手中的股票，实现收购；并使用收购来的新公司的现金流，支付后续的贷款利息；</p><p>如果收购方的运营能力很强，在收购后，能够提高目标公司的利润或股价，那么几年内将很快能够还清债务，并通过股价的上涨，实现翻倍的收益；</p><p>但是这种做法也带来了隐患，一方面它让公司的现金流变得紧张和脆弱；如果市场出现下行和波动，有时会造成公司的资金链断裂。原本企业充足的现金流是抵抗市场风险的缓冲垫，但杠杆收购失去了这种缓冲能力，将公司的股东、员工、顾客和供应商都暴露在了不可知的风险之中；另一方面它也对收购方的运营能力带来巨大的挑战，因为 LBO 的暴利，导致参与者众多，抬高了收购价，导致被收购公司每年的利润通常不足以支付贷款利息；</p><h2 id="稳定的收购政策"><a href="#稳定的收购政策" class="headerlink" title="稳定的收购政策"></a>稳定的收购政策</h2><p>伯克希尔希望收购的公司标准：</p><ul><li>多年的持续盈利能力；</li><li>有成熟的管理层；</li><li>规模够大（税前盈利不少 7500 万美金）；</li><li>公司没有或极少负债；</li><li>高资金回报率；</li><li>有明确的报价，而非竞价收购；</li></ul><h2 id="出售企业"><a href="#出售企业" class="headerlink" title="出售企业"></a>出售企业</h2><p>不同于其他潜在收购方，伯克希尔收购公司有两点不同：</p><ul><li>不干预被收购公司的经营（但会决定管理层的薪酬）；</li><li>将长期持有，不会转手倒卖；</li></ul><p>同时伯克希尔要求被收购方保留20%股份（估计是为了实现利益绑定和管理激励）；</p><h2 id="有选择的买家"><a href="#有选择的买家" class="headerlink" title="有选择的买家"></a>有选择的买家</h2><p>当某家企业的创始人不关心将自己的企业卖给谁时，这通常是一个重要的信号，它往往意味着这家公司并不怎么样，因为它的主人并没有用心去经营它。真正用心经营自己企业的人，会将自己看成是自己的孩子或者作品一样，在乎它的未来。</p><p>伯克希尔的收购风格让其在两种卖家群体中占有优势：</p><ul><li>创始人用心经营的企业；</li><li>受到监管的公共事业，例如供电、水务、运输等（因为事关民生，政府对买家有很高的稳定性要求）</li></ul><h1 id="估值与会计"><a href="#估值与会计" class="headerlink" title="估值与会计"></a>估值与会计</h1><h2 id="伊索寓言和失效的灌木丛理论"><a href="#伊索寓言和失效的灌木丛理论" class="headerlink" title="伊索寓言和失效的灌木丛理论"></a>伊索寓言和失效的灌木丛理论</h2><blockquote><p>伊索： 一鸟在手，胜过二鸟在林；</p></blockquote><p>未来实际上充满着很多不确定性，很多投资者对未来有时充满着过度的乐观（相信灌木丛里面有很多鸟），导致以过高的价格购入了价值不对等的股票。</p><h2 id="内在价值、账面价值和市场价格"><a href="#内在价值、账面价值和市场价格" class="headerlink" title="内在价值、账面价值和市场价格"></a>内在价值、账面价值和市场价格</h2><p>内在价值：公司在存续期间能够产生的所有现金流在当前的折现；</p><blockquote><p>是否选择上大学（即将花钱接受教育视为一种投资），是一个说明何为内在价值的好例子；虽然计算出来的数字相对粗糙，但在大方向上是没错的；</p></blockquote><h2 id="透视盈余"><a href="#透视盈余" class="headerlink" title="透视盈余"></a>透视盈余</h2><p>会计准则有一个奇怪的地方，即当持股比例少于20%时，报表中不记录和体现被投资方的盈利情况，仅记录收到的分红（如有）；如果有大量持股比例少于20%的投资，那将意味着有很多盈利在报表上没有得到真实和准确的体现；</p><p>很多公司的报表更像是任人打扮的小姑娘，穿戴着各种装饰（会计花招），并不体现公司的真实面目，因此有些科目没有太大的参考意义；当然，不可否认，有一点很有参考意义，就是可以用来发现不诚实和有毒的管理层，尽量远离他们；</p><blockquote><p>所谓的透视盈利，就是将那么被会计准则忽略的盈利计算在内；</p></blockquote><h2 id="经济的商誉-vs-会计的商誉"><a href="#经济的商誉-vs-会计的商誉" class="headerlink" title="经济的商誉 vs 会计的商誉"></a>经济的商誉 vs 会计的商誉</h2><ul><li>经济商誉是销售溢价，即相同成本和质量的商品，能够比同行多卖的钱；</li><li>会计商誉是收购溢价，即收购该公司时，支付金额超出有形资产的部分；</li></ul><p>会计法则认为这种商誉最终会消失（最长不超过40年），因此会计规则要求将溢价部分作为成本（类似折旧），分成40年摊销（相当于每年固定一次资产价值减记，计算盈利时要扣除，类似折旧；但折旧是真实的成本，商誉并不一定是，反而有可能是会增值的资产）；</p><blockquote><p>不知会计准则为什么要这么设计，它貌似将无形资产在本质上视为某种虚无，但这显然跟社会现实不符；</p></blockquote><p>通货膨胀对需要投入有形资产的企业来说，是一把钝刀。因为企业的有形资产终归是会折旧的，因此需要定期不断追加投资。当出现通货膨胀时，这种追加的投入将随着通胀不断的水涨船高。同时售价由于同业竞争，常常要滞后于成本的上升，导致利润在无形中被消耗没了；</p><blockquote><p>有形资产越少的企业，其受到通胀的伤害相对越小；</p></blockquote><p>会计商誉每年的摊销，有时会掩盖住真正的盈利，让企业的盈利变少了。进而导致对企业的估值降低，事实上，这种低估有可能造成市场基于标准会计准则后的一种误判；</p><h2 id="股东盈利和现金流谬论"><a href="#股东盈利和现金流谬论" class="headerlink" title="股东盈利和现金流谬论"></a>股东盈利和现金流谬论</h2><p>当溢价收购一家公司后，溢价部分需要记录在财务报表中；因此，相对未收购时，同一家公司的两份报表会出现很大的差异；原因在于溢价部分需要摊销到一些会计科目中，例如无形资产、固定资产会按市场允许价值重新计价。但重新计价后，增加的固定资产意味着每年的折旧金额也会随之变大。但盈利在当期是不变的，这将导致收购后的报表的盈利水平出现巨大的下滑；但事实上，它其实是同一家公司；</p><p>事实上为了维持企业的市场竞争力，每年追加固定资产投入是必需（因为设备会老旧，需要维修或更新），因此企业需要从盈利中预留该项费用；扣除该费用后，才是真实的股东盈利，以及真正可用的现金流（很多股票经纪人为了推销股票，夸大盈利能力，常常会有意忽略该项费用）；</p><blockquote><p>或许我们需要记住，会计是用来纪录，而不是用来评估的。评估企业的是人来完成的，而不是会计来完成；</p></blockquote><h2 id="期权的估值"><a href="#期权的估值" class="headerlink" title="期权的估值"></a>期权的估值</h2><p>Black-Scholes 期权定价公式在短期内是有意义的，但在长期范围中，则意义不大。因为作为公式参数之一的市场波动率，在长期范围中，基本没有参考价值，从而导致该公式的计算结果也失去了参考意义；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202310231917144.png"></p><h1 id="会计诡计"><a href="#会计诡计" class="headerlink" title="会计诡计"></a>会计诡计</h1><h2 id="会计把戏的讽刺"><a href="#会计把戏的讽刺" class="headerlink" title="会计把戏的讽刺"></a>会计把戏的讽刺</h2><p>为了演示会计诡计能够被如何花式使用，作者在书中举了一个令人叹为观止，甚至是丧心病狂的例子。最不可思议的一点是，这个例子并非虚构，而是真实发生的，故事的主角是 1935 年的美国钢铁公司。该公司当时按旧会计准则，每股亏损2.76 美元；使用“神奇”的新会计准则后，变成了每股盈利 49.8 美元；其中使用了如下一些会计处理方法：</p><ul><li>将厂房设备等资产科目减值为负的 10 亿美元（注：这样一来，原本每年作为费用的折旧，变成了收入）；</li><li>普通股面值减少为 1 美分（注：不会影响现有股东，但可以为期权的价值创造利润空间）</li><li>用股票期权支付所有薪酬（注：原每股股价为 50 美元，行权价格为 1 美分，意味着每股行权后可获得 49.99 美元的收益，用于代替工资等薪酬收入；由于行权价格很低，会快速稀释原有股东的持股比例）；</li><li>将存货记为 1 美元（注：这样不管市场如何不景气，商品价格的下调都不会给公司带来存货亏损；然后在以市场价卖出存货的时候，又给利润科目制造了超高额的利润）；</li><li>用能够以50%折旧赎回的零息债券置换优先股（注：优先股是要按约定利率进行支付股息的，但零息债券就不需要每年支付固定的股息了，并且可以将每年利息支出推出到最后一天，到期之前公司也不会有违约风险。这样每年就可以为公司省下一笔优先股的股息支出，减少了费用，创造出了盈利；但更重要的是，50%折旧赎回，意思是假设债券面值为100元，则赎回价格为 50 美元，这样表面上看，相当于找人家100元，只需要还50元，于是从会计角度相当于产生50元的利润；但实际上是亏损，因为该面值的债券，实际销售价格肯定要低于 50 元才能卖得出去，比如说市场只愿意以 30 元购买这种 100 元的零息债券，公司借了 100 元的债务，实际只收到了 30 元，虽然因 50% 折旧最终只需要还50无，但实际上利息成本是 20 元）；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202310232041983.png"></p><blockquote><p>不知今天美国的证监会是否仍然允许上市公司使用以上的会计招术，从本质上说，这种处理方式相当于对原有股东的抢劫和欺诈；</p></blockquote><h2 id="标准的设定"><a href="#标准的设定" class="headerlink" title="标准的设定"></a>标准的设定</h2><p>很多上市公司的股东非常分散，董事会中缺少控股股东。但公司是由 CEO 们进行管理的，而 CEO 的薪酬收入跟公司的盈利有关，于是其有强烈的动机美化公司的盈利报表。当独立的会计标准委员会试图将期权列为费用时，遭到 CEO 们的强烈反对。这些 CEO 们拿着股东们的钱，到华盛顿作为游说费用和政治献金，获得了参议院的支持。而大量的中小股东则没有人为其作声，默默承担了损失的风险。</p><blockquote><p>注：此问题在 2005 年国会通过新的法案后得以纠正；</p></blockquote><h2 id="股票期权"><a href="#股票期权" class="headerlink" title="股票期权"></a>股票期权</h2><p>股票期权是有价值的，当公司将有价值的东西赋予某人时，对公司来说，必然产生了成本。通常期权的行权都附带着一系列限制条件，例如需要在公司工作服务的年限，需要实现的业绩目标等。这些限制条件为期权的估算增加了难度，导致期权的价格难以标准化和精确化。但这并不意味着期权不是一项费用，很多公司使用期权作为奖励高管的手段，因为从会计规则来说，期权可以不计入费用栏目，使得这样奖励表面看起来像是没有费用和成本似的，但事实并非如此，它只是被隐藏了起来而已，对于原股东有时候甚至代价高昂。</p><p>期权如果设计合理的话，确实能够起到有效的激励作用，设计合理的条款包括：</p><ul><li>合理的行权价格；</li><li>期权价格会根据公司的留存利润进行相应的调整；</li><li>不得在获得期权后立即抛售股票；</li></ul><blockquote><p>注：期权计入成本在 2005 年强制生效；</p></blockquote><h2 id="重组费用"><a href="#重组费用" class="headerlink" title="重组费用"></a>重组费用</h2><p>很多上市公司的 CEO 的工作重心并不在于如何提升公司的核心竞争力，而是将大部分时间用在了如何维持和公司股价上面。为了达到该目的，甚至常常依赖于使用会计把戏来实现。例如将费用或亏损集中放在某个季度，然后让其他季度的盈利数字看起来很漂亮。而事实上，总体平均下来，二者是一样的。</p><p>为了营造公司的良好业绩，有些 CEO 利用收购或合并的机会，先预提一大笔超常的损失准备金，然后在后续很长一段时间里，不断降低该笔准备金，释放的准备金变成了某种形式的“利润”，从而让公司长期保持盈利的状态。</p><h2 id="退休福利估计"><a href="#退休福利估计" class="headerlink" title="退休福利估计"></a>退休福利估计</h2><p>构成标普500指数的500家公司中，有360多家有退休金计划。这个计划有点类似国内某些公司的年金计划，即员工将一部分多余的收入放到公司成立的年金基金中，由公司代为投资，获取可观的回报，让员工在退休时，能够保证更好的生活质量。</p><p>很多拥有年金计划的公司，将基金的预计回报率设定为 8%，但巴菲特觉得这个数字不太合理，因为如果按照这个回报率，道琼斯指数将由当前的 13000 点，在 100 年后上升到 200 万点。</p><blockquote><p>此处我觉得巴菲特的说法有些不准确，有两个原因：</p><ul><li>道琼斯无法实现 8% 的回报率，不代表标普 500 不可以；</li><li>经济发展依赖于科技的进步，而人类科技的进步并不是线性的，而是指数性的；过去 100 年人类的科技突破，超过过往上千年的总和；</li></ul></blockquote><h2 id="账面盈利的实现问题"><a href="#账面盈利的实现问题" class="headerlink" title="账面盈利的实现问题"></a>账面盈利的实现问题</h2><p>很多财经媒体很关注“净利润”科目，但事实上，这个指标可能远没有想象中的那么重要。因为如果公司拥有大量未变更的盈利（例如持有股票），那么通过售出这些股票，公司能够轻易的实现想要的利润数字，但事实上，它毫无意义，因为等财报发布完，过几天或许还得把它们再买回来。相对于净利润，更有意义的指标或许应该是运营利润，它大体反映了公司的运营情况。</p><h1 id="会计政策"><a href="#会计政策" class="headerlink" title="会计政策"></a>会计政策</h1><h2 id="并购"><a href="#并购" class="headerlink" title="并购"></a>并购</h2><p>并购会涉及会计处理，目前有两种处理方式：</p><ul><li>购买法：可支付现金，也可支付股票；</li><li>权益合并法：只支持股票（有点类似相互持股）；</li></ul><p>并购通常会存在溢价，对于溢价部分，购买法要求记录在商誉科目中，并在其中很多年逐年扣减，有点类似固定资产折旧。但问题是，在现实生活中，商誉的性质并不一定会折旧，有时甚至会长值。而这种脱离现实的商誉折旧，会减少当年的利润，因此很多公司的 CEO 很不喜欢这种做法，因为会让公司的业绩看上去变差，但实际并没有。因此，很多公司的CEO 更喜欢采用权益合并法，但是它也会带来其他问题。</p><blockquote><p>不知道现在的会计准则是否更新了，说不定以上问题已经得到解决了；</p></blockquote><h2 id="分部数据和会计合并"><a href="#分部数据和会计合并" class="headerlink" title="分部数据和会计合并"></a>分部数据和会计合并</h2><p>1988 年新的会计准则要求除了合并子公司的投资权益（按投资比例的子公司净值）和年度损益合并到母公司之外，还需要合并子公司的资产与负债、营收和费用等等科目。对于投资结构较为复杂的母公司来说，这些合并会降低整个财务报表的参考价值，因为很多东西被平均了，这样会在掩盖掉优秀部分的同时，也掩盖了糟糕的部分。阅读报表的人，无法一针见血的看到问题的关键所在；</p><h2 id="递延税项"><a href="#递延税项" class="headerlink" title="递延税项"></a>递延税项</h2><p>如果企业购买了其他企业的股票，在涨价卖掉后获得了盈利，那么这些盈利是需要缴税的。但是如果企业不卖掉涨价的股票，那么理论上来说，就可以一直不需要缴税；但从理论上来说，这个税是真实存在的，只是推迟到未来卖掉的时候再交。会计规则要求将这部分未缴纳的税款，按资本利得的税率（例如 34%），记入负债科目。这样做在账面上会让企业的利润减少（因为账面上有一笔预估的未偿还债务）。</p><blockquote><p>理论上，这笔款项属于国家税务局，所以确实应记作企业的债务。不过换个角度看，或许我们也可以将这笔款项当作税务局暂时借给企业使用的无息贷款，什么时候可以由企业自己决定。当然，用途非常特殊，相当于只能购买某些指定的股票；</p></blockquote><h2 id="退休福利"><a href="#退休福利" class="headerlink" title="退休福利"></a>退休福利</h2><p>很多企业的员工购买了年金，在员工退休后，企业需要按约定的收益，返还年金给员工，有点像支付另外一笔退休工资。 对于企业来说，未来的这笔支出是一项负债，因此在 1993 新会计准则要求企业将未来待支付的年金折成现值，记入负债科目。</p><blockquote><p>有些企业给员工很高的年金收益承诺，导致企业在未来将背负沉重的退休福利债务，甚至可能会压跨企业；</p></blockquote><h1 id="税务问题"><a href="#税务问题" class="headerlink" title="税务问题"></a>税务问题</h1><p>假设有一只股票，每年价格可以翻一翻，那么以下两种做法的结果差异巨大，假设初始投入￥1元，所得税率 35%：</p><ul><li>做法1：每年年初买入，年底卖出；连续操作28年，最终盈利 ￥22370；</li><li>做法2：买入后，不再卖出；连续持有28年，最终盈利 ￥1.3 亿；</li></ul><blockquote><p>之所以这两种方式差异巨大，原因在于每一次交易产生的 35% 税费；如果长期持有，则缴纳一次；如果每年交易，则缴纳了 28 次；</p></blockquote><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;公司治理&quot;&gt;&lt;a href=&quot;#公司治理&quot; class=&quot;headerlink&quot; title=&quot;公司治理&quot;&gt;&lt;/a&gt;公司治理&lt;/h1&gt;&lt;p&gt;从长远来说，公司的经营情况跟公司的管理层密切相关。因此，如果不了解某家公司的管理层，那就不要轻易的去投资它；&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="社科" scheme="https://ccw1078.github.io/categories/%E7%A4%BE%E7%A7%91/"/>
    
    
    <category term="经济" scheme="https://ccw1078.github.io/tags/%E7%BB%8F%E6%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>社会心理学</title>
    <link href="https://ccw1078.github.io/2023/09/02/%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    <id>https://ccw1078.github.io/2023/09/02/%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/</id>
    <published>2023-09-02T13:43:00.000Z</published>
    <updated>2024-09-23T00:58:17.503Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h3 id="重要课题"><a href="#重要课题" class="headerlink" title="重要课题"></a>重要课题</h3><ul><li>人们如何看待彼此、如何影响彼此；</li><li>人们的态度与信念、从众与独立、爱与恨；</li></ul><blockquote><p>人们的行为不仅取决于客观环境，同时还取决于人们对环境进行何种主观建构；</p></blockquote><h3 id="重要观点"><a href="#重要观点" class="headerlink" title="重要观点"></a>重要观点</h3><ul><li>社会现实是每个人主观构建的；</li><li>直觉很强大，但有时很危险；</li><li>外部环境会影响我们的行为；</li><li>个人性格态度也会影响我们的行为；</li><li>社会行为同时也是生物行为；</li></ul><h3 id="社会心理学与其他学科"><a href="#社会心理学与其他学科" class="headerlink" title="社会心理学与其他学科"></a>社会心理学与其他学科</h3><h4 id="社会学"><a href="#社会学" class="headerlink" title="社会学"></a>社会学</h4><p>多数社会学家主要研究团体（由两个或以上的个体组成），而社会心理学主要研究个体；</p><blockquote><p>前者的研究方法通常面临比较大的挑战，因为对于团体来说，某个研究因素，例如各团体成员的社会经济地位，通常很难进行实验操纵；</p></blockquote><h4 id="人格心理学"><a href="#人格心理学" class="headerlink" title="人格心理学"></a>人格心理学</h4><p>人格心理学同样专注于个体，它跟社会心理学的差异在于前者更侧重研究个体间的差异；而后者更侧重研究个体间的共性，以及人们如何看待和影响彼此；</p><blockquote><p>横看成岭侧成峰，不同学科在研究相同的事物时，区别更多的在于观察的角度不同，本质上并不冲突，更多的是殊途同归；通过不同的角度，让事物呈现的更加完整；</p></blockquote><h3 id="社会心理学与人类价值观"><a href="#社会心理学与人类价值观" class="headerlink" title="社会心理学与人类价值观"></a>社会心理学与人类价值观</h3><h4 id="直接影响"><a href="#直接影响" class="headerlink" title="直接影响"></a>直接影响</h4><p>在不同的历史时期，人们的注意力会放在不同的事物上面，某些事物会因此变成研究热点；人类价值观本身也是社会心理学的研究目标，因为价值观并非人类天生自带的，而是在环境中塑造的，并且它还将影响人们的态度与行为；</p><h4 id="间接影响"><a href="#间接影响" class="headerlink" title="间接影响"></a>间接影响</h4><p>虽然客观事实真实存在，但每一个人都不可避免会带着主观信念和价值观的滤镜在观察这个世界；</p><p>价值观会在无意识中影响我们对事物的定义，何谓美好，何谓健康，其标准的设定其实已经隐含了我们个人的价值判断；兼听则明，当持有不同价值观念的人们，对相同的课题进行研究时，我们可以对不同的观点进行相互验证，从而获得了摘除主观滤镜的机会；</p><h3 id="事后偏见"><a href="#事后偏见" class="headerlink" title="事后偏见"></a>事后偏见</h3><p>正如古语所云，事后诸葛亮；当事实发生了以后，围绕在事物周围的噪音消失了，只剩下关键信息。因此我们很容易觉得这些关键信息是那么的显而易见。但事实上，在事情发生之前，正确的信息是混杂在大量的噪音之中的，我们根本无从知道，哪条信息是正确的关键信息；</p><blockquote><p>事后偏见现象，会让人们高估自己的能力，误以为如果自己身处当时的情境，能够做出比当事人更正确的选择，但事实并非如此；</p></blockquote><h3 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h3><p>社会心理学与大多数其他学科的一个区别在于，它拥有大量的业余爱好者，因为观察和研究他人本身就是人们的社会日常活动之一；专业研究者与业余爱好者的区别在于，前者会使用实验的方法，更系统的验证自己的观察和假设；</p><p>一个好的理论，除了能够对大量的观察结果进行有效的总结，同时还能够帮助我们在应用方面进行有效的预测，并为后续的研究和探索指出更清明的方向；好的理论也有其寿命，当某一天它退休时，并不意味着它是错误的，而是更像一台老旧的汽车，被更新的型号替代了；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202301281912160.png"></p><p> 影响调研结果准确性的因素：</p><ul><li>样本代表性；</li><li>问题的顺序；</li><li>提供的选项；</li><li>问题的措施；</li></ul><blockquote><p>以上四个因素如果未谨慎处理，有可能会得出与事实不符，甚至完全相反的结论；</p></blockquote><p>探寻因果关系的方法：</p><ul><li>控制变量</li><li>随机分配</li></ul><h1 id="社会思维"><a href="#社会思维" class="headerlink" title="社会思维"></a>社会思维</h1><p>我们如何看待自己和他人</p><h2 id="2、社会中的自我"><a href="#2、社会中的自我" class="headerlink" title="2、社会中的自我"></a>2、社会中的自我</h2><blockquote><p>焦点效应：我们会在直觉上把自己当作一切的中心，并高估他人对我们的关注程度；</p></blockquote><p>社会环境对个人的行为影响：</p><ul><li>自我觉知：更容易察觉到自己与他人的不同；</li><li>自我服务：高估自己的能力，低估他人的能力；</li><li>形象展示：关注自我在他人眼中的形象；</li><li>角色界定：在与他人不同的社会关系中，我们会扮演不同的角色和行为；</li></ul><h3 id="自我概念"><a href="#自我概念" class="headerlink" title="自我概念"></a>自我概念</h3><blockquote><p>我是谁？我们怎样才能更精确的认识自己？是什么决定了我们的自我概念？</p></blockquote><h4 id="自我感觉"><a href="#自我感觉" class="headerlink" title="自我感觉"></a>自我感觉</h4><p>我们的自我感觉，是个体世界的核心；这种自我感觉会影响我们对外部信息的加工和记忆；自我感觉遵循一定的图式结构，是我们内心组织外部世界的一套模板；</p><blockquote><p>自我参照效应：当某个信息与我们的自我概念相关时，我们会更容易记住它（或许本质上在于类似的信息在我们大脑中已经被加工过最多次，因此能够最快的被神经系统调用）；</p></blockquote><h4 id="自我与社会"><a href="#自我与社会" class="headerlink" title="自我与社会"></a>自我与社会</h4><p>影响自我概念的常见社会因素：</p><ul><li>社会角色：我们会在社会关系中扮演不同的角色，当我们进入该角色时，就会不自觉的让自己的行为符合他人对该角色的预期，因此我们的角色扮演也随之变成现实；</li><li>社会同一性：当我们是某个大团体中的某个小团体，我们会对自己的特殊性感觉敏感；反之则不敏感；例如少数民族生活在周围都是非少数民族的社区时，更容易对自己的身份敏感；</li><li>社会比较：绝大部分人的生活，是围绕社会比较进行的；它是基因的一种生存策略；我们通过与他人的比较，了解自己在社会中的地位；</li><li>成功经验：通过辛苦努力获得成功的体验，会让我们拥有更乐观自信的生活态度，增强我们的自尊；</li><li>他人评价：我们会将他人对自己的积极评价，融入到我们的自我概念和日常行为中（此处的关键点并非他人对我们的真实评价，而是我们自己预期他人会如何评价）；</li></ul><h4 id="自我与文化"><a href="#自我与文化" class="headerlink" title="自我与文化"></a>自我与文化</h4><p>在不同的文化，自我的重要性有所不同；在欧美文化中，个人主义多于集体主义；亚洲、南美、非洲等地区的国家则反过来；该地区的人们在定义自我时，更多的考虑自己与他人、个体与整体的相互依赖关系，因此通常也会有更强烈的归属感；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202302021945104.png"></p><p>在集体主义的文化中，自尊不仅与个体的成就相关，还与他人如何评价个体所属的群体相关；因此，当其所属群体受到威胁时，会激起人们更大的情绪反应；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202302021948172.png"></p><p>但人们的观点并非固定不变的，当个体有机会到另外一种文化中长期生活时，其观点也会慢慢的受到所处环境的影响并出现变化；</p><h4 id="自我认识"><a href="#自我认识" class="headerlink" title="自我认识"></a>自我认识</h4><p>我们常常误以为自己很了解自己，但事实上我们大脑中的意识模块只是骑象人，负责解释大象（自动化模块）的行为而已。我们并没有自己所认为的那样了解自己；</p><p>当我们预测自己未来的积极行为时，常常会过于乐观；预测未来自己的消极行为时，则相对比较准确；但如果是让我们预测他人的行为，不管是积极还是消极，我们都会表现的比较准确；因为我们会基于对方的过往进行判断；但当我们预测自己时，则会忽视自己的过往；</p><p>整体来说，我们的情绪总是围绕着一条基准线进行上下波动，不管一个事件给我们带来的情感刺激多么强烈，随着时间的推移，我们的情绪最终都会回归到基准线（久居鱼肆，不闻其臭；我们的大脑的适应能力超级强大，大多数人最终都会适应新的外部环境）；</p><p>我们对自我的认识是非常有限的，大量的决策是由我们的潜意识完成的。因此骑象人给出的结论常常是靠不住的，我们应避免轻易的使用骑象人的结论来作为证据，更好的做法或许是观察大象的行为；</p><h3 id="知觉到自我控制"><a href="#知觉到自我控制" class="headerlink" title="知觉到自我控制"></a>知觉到自我控制</h3><h4 id="自我效能"><a href="#自我效能" class="headerlink" title="自我效能"></a>自我效能</h4><p>定义：对自身能力和效率的乐观信念（或许应该简称为“自信”，即对自己有能力完成某件事情有多大的信心）；</p><p>高自我效能能够帮助我们制定一些有挑战性的目标，并在遭遇困难时，坚持得更久（即更加有韧性）；反之，低自我效能会让我们归因于自身能力不足，从而较早的放弃；</p><h4 id="控制点"><a href="#控制点" class="headerlink" title="控制点"></a>控制点</h4><p>定义：个体觉得自己的命运更多的是由自身的力量（内部控制点），还是外部的力量（外部控制点）所决定；通常，倾向内部控制点的个体，会取得更多的成就；</p><h4 id="习得性无助与自我决定"><a href="#习得性无助与自我决定" class="headerlink" title="习得性无助与自我决定"></a>习得性无助与自我决定</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202302040708180.png"></p><p>对生活失去控制，选择性减少，会让个体体验到无助的感觉。这种感觉会让人更容易产生疾病，这也是为什么集中营犯人和疗养院病人会更快速的衰老和死亡的原因；</p><p>反之，如果生活中出现的选项太多，过度自由的话，也会给大脑造成信息过载，导致人们容易对自己的选择产生不满意的感觉，因为总感觉还存在另外一个更好的选项。但整体来说，更多的自由是利大于弊的，会更加有利于身心健康；</p><p>解决习得性无助的办法，仅仅靠自我说服（例如：我很棒），或者有意吹捧（例如：你很棒）是没有用的。真正有效的根本办法，是让个体获得成功的体验。当个体通过自我努力，并最终体验到成功的感觉后，就会增强自我效能（即自信心），最终走出恶性循环；</p><h3 id="自尊"><a href="#自尊" class="headerlink" title="自尊"></a>自尊</h3><p>自尊： 个体对自我的整体评价；</p><blockquote><p>爱屋及乌，对于高自尊者，他们对自身是否具备特定能力的评估会更加乐观；</p></blockquote><h4 id="自尊动机"><a href="#自尊动机" class="headerlink" title="自尊动机"></a>自尊动机</h4><p>我们对外部世界的认知，并非客观的，而是受我们内在动机的影响；例如我们都存在维护自我价值的动机，因此当我们遭遇失败时，我们更倾向将失败原因归咎于外部环境，而不是归因内部，因为那样会降低自我价值感。</p><p>自尊动机对提升个体的繁衍几率很重要，因为个体越是能够对社会评价保持敏感，就越有可能调整自己的态度和行为，从而重新获得社会的接纳和认可，以便有利于个体的生存和发展。</p><blockquote><p>社会性动物存在维护和增加自尊的动机，但对于非社会性的独居动物（例如猫），猜测可能会有所不同；</p></blockquote><blockquote><p>社会评价和比较通常发生于相互认识的个体之间，例如亲戚朋友之间。因此，相比遥远的陌生人，周围的人获得成功，会让我们感觉受到更大的自尊威胁，从而更容易激发我们的紧张和嫉妒情绪；</p></blockquote><h4 id="自尊的阴暗面"><a href="#自尊的阴暗面" class="headerlink" title="自尊的阴暗面"></a>自尊的阴暗面</h4><p>高自尊的好处：让个体产生更多的积极、乐观、愉快的感觉；但当高自尊者受到外部威胁时，也会表现出更多的敌意，例如打压对方，甚至诉诸暴力；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202302061937121.png"></p><p>高自尊有不同的来源，有些个体的高自尊来源于外部因素，例如金钱、权力、外貌、成就等；有些则来源于内在良好的自我感觉、个人品质等。在追求幸福的道路上，前者更容易遭遇挫折和焦虑，后者则较少。因为很多时候，外部因素并非我们可以完全掌控的。</p><blockquote><p>少关注自我形象，多培养才能和良好的人际关系，最终能够给个体带来更大的幸福感；</p></blockquote><h3 id="自我服务偏见"><a href="#自我服务偏见" class="headerlink" title="自我服务偏见"></a>自我服务偏见</h3><p>个体在加工信息时，会存在自我偏见，将成功归功于自身的能力，将失败归咎于外部的不利条件；大多数人都对自己感觉不错，对自己的评分通常要高于平均水平（尤其是主观行为维度，例如品德）。这种自我美化现象能够让个体最大程度的收获高自尊所带来的积极面，只有少数情况才会遭遇阴暗面；</p><h4 id="盲目乐观"><a href="#盲目乐观" class="headerlink" title="盲目乐观"></a>盲目乐观</h4><p>在对未来进行预测时，自我服务偏见会导致我们盲目乐观。我们会高估好运发生在自己身上的概率，并低估不幸发生在我们身上的概率，进而导致我们常常没有做好事前防护措施，以至当厄运出现时，损失惨重；</p><p>适度的乐观对我们的身体是有好处的，因为有助于提高自我效能感、减少焦虑、保持身体健康；同时适度的悲观也是很有必要的，因为那样会让我们付出更多的努力，减少失败的概率，并最终帮助我们获得更大的成就；</p><h4 id="虚假普遍性和独特性"><a href="#虚假普遍性和独特性" class="headerlink" title="虚假普遍性和独特性"></a>虚假普遍性和独特性</h4><p>虚假普遍性：在观点方面，我们会觉得大部分人跟我们想的一样（原因：个体掌握的样本很少，而且物以类聚，因此决策依据的信息非常有限）；</p><p>虚假独特性：在能力方面，我们觉得自己的能力异于常人（原因：这样做有助于维护和增加自我形象，提升自尊感）；</p><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>自尊动机促进了自我服务偏见的出现；</p><p>当个体的自尊受到威胁或打击后，个体有可能会被激起自我防御机制；个体会通过自夸或贬低他人来肯定自己的价值；相比高自尊，低自尊个体更加敏感，更容易对他人的的怠慢作出过激反应。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>自我服务偏见能够提高我们的适应性，让我们更加积极主动，在面对压力时减少焦虑；</p><p>坏处包括：</p><ul><li>盲目乐观，缺少对不利情况的提前准备；</li><li>容易引发团队矛盾，每个人都觉得自己的贡献更大；</li><li>高估所属群体的能力，难以看清客观事实，容易导致傲慢；</li></ul><h3 id="自我展示"><a href="#自我展示" class="headerlink" title="自我展示"></a>自我展示</h3><p>当我们在评价自己的时候，我们会进行自我美化；当我们对外展示自己时，则较少自我美化，而是会采取能够得到外界认可和赞许的方式，例如展示谦逊；</p><h4 id="虚假谦逊"><a href="#虚假谦逊" class="headerlink" title="虚假谦逊"></a>虚假谦逊</h4><p>对外展示自己的成功会引起他人的嫉妒或怨恨，当我们觉知到这点时，我们就会通过谦逊来有意隐藏自己的成功，避免给自己带来危险；</p><blockquote><p>真正的谦卑并非个体在内心贬值自我价值，而只是不那么在意外界评价和自我形象，并愿意接纳他人也是优秀的事实；</p></blockquote><h4 id="自我妨碍"><a href="#自我妨碍" class="headerlink" title="自我妨碍"></a>自我妨碍</h4><p>当个体害怕失败时，为了在失败后仍然能够维护自我形象，个体会故意给自己制造一些障碍。这样会带来两个好处：</p><ul><li>如果事后成功了，由于是在障碍下成功了，那么个体给自己更高的自我评价；</li><li>如果事后失败了，则可以将原因归咎于障碍的存在，而不是降低自我价值感；</li></ul><h4 id="印象管理"><a href="#印象管理" class="headerlink" title="印象管理"></a>印象管理</h4><p>作为社会性动物，由于自我形象与繁衍几率息息相关，因此对自我形象的维护，已经深深的刻在我们祖先的骨子里并遗传到我们每个人身上；在不同程度上，我们总是在向周围的观众进行表演；</p><p>在我们的内心中，我们都存在一定程度的自我美化。在对外展示自我时，不同文化下人们的行为则有所不同。集体主义文化中的个体，更倾向于展示谦逊和自制，以便跟他人同步。个人主义则倾向于为自己的成功感到骄傲，并将自己的失败归咎于环境；</p><h2 id="3、社会信念与判断"><a href="#3、社会信念与判断" class="headerlink" title="3、社会信念与判断"></a>3、社会信念与判断</h2><p>我们对他人的如何判断，取决于我们如何解释他人的行为；不同的解释，会产生不同的结论；</p><h3 id="如何解释他人"><a href="#如何解释他人" class="headerlink" title="如何解释他人"></a>如何解释他人</h3><h4 id="归因于个人还是情境"><a href="#归因于个人还是情境" class="headerlink" title="归因于个人还是情境"></a>归因于个人还是情境</h4><p>我们无时不刻的在将自己所处的世界进行合理化，这是一种天性。因为它可以让我们感到可控和安全。</p><p>一般有两种主流的归因方式，一种是内因，即个体的性格特质；一种是外因，即环境所迫；使用哪种归因方式，则主要取决于哪种方式更加符合我们的利益。</p><blockquote><p>例如男性比女性有更多的传播基因的需求，因此男性更容易将女性的亲密行为理解为性挑逗或性暗示；</p><p>当我们对婚姻感到满意时，我们倾向于将伴侣的过失归因于环境；当我们对婚姻不满意时，我们倾向于将伴侣的过失归因伴侣本身的特质；</p></blockquote><p>当我们观察他人的行为时，我们会在无意识之中，推断他人的性格特质。例如我们观察到某个帮助了别人，那么我们会推断该人拥有乐于助人的性格特质；</p><p>当我们进行归因时，我们会通过三个维度来判断应推断该行为是出于内部原因，还是外部原因；这三个维度包括：</p><ul><li>一致性：相同情境，个体是否会出现相同行为；</li><li>区别性：不同情境，个体是否会出现相同行为；</li><li>普遍性：相同情境，其他人是否会出现相同行为；</li></ul><h4 id="基本归因错误"><a href="#基本归因错误" class="headerlink" title="基本归因错误"></a>基本归因错误</h4><p>定义：当我们尝试解释他人的行为时，我们通常会低估外部因素的影响，同时高估内部因素的作用；当我们解释自己的行为时，则反过来；</p><p>尤其当归因结果涉及我们的利益时，这种归因错误会表现的更加明显（典型例子如自我服务偏见）；</p><p>另外一种常见的归因错误是片面性，即我们仅凭借少量的证据，在短时间内做出了总体的判断，这也是为什么第一印象很重要的原因；</p><h4 id="我们为什么会犯归因错误"><a href="#我们为什么会犯归因错误" class="headerlink" title="我们为什么会犯归因错误"></a>我们为什么会犯归因错误</h4><h5 id="注意力"><a href="#注意力" class="headerlink" title="注意力"></a>注意力</h5><p>注意力很重要，它在我们的归因过程中扮演了重要的作用，我们总是在注意力所关注的地方寻找原因；当我们观察别人时，被观察者吸引了我们主要的注意力；当我们观察自己时，外部环境吸引了我们的注意力；从而造成了归因错误；</p><blockquote><p>当我们有机会站在外部视角观察自己的行为时（例如《再见爱人》，我们会发现很多自己以前没有注意到的细节，从而变得更加了解自己；</p></blockquote><h5 id="时长"><a href="#时长" class="headerlink" title="时长"></a>时长</h5><p>时间是另一个重要的因素：</p><ul><li>在事件发生后，在短时间内，我们更倾向归因于个体的内部因素。而当我们离事发现场的时间越远，我们就会越多的考虑环境因素在事件发生过程中的重要作用；</li><li>当事件未发生时，如果要求我们做出预测；则对于短时间内会发生的事情，我们会更多的考虑环境因素；如果是未来很远的时间会发生的事情，环境因素开始变得模糊，我们会更多考虑个体的内部因素；</li></ul><h5 id="文化差异"><a href="#文化差异" class="headerlink" title="文化差异"></a>文化差异</h5><p>欧美文化更倾向于归因个体，而东亚文化则更多的考虑环境因素；例如当某个公司雇员作出违规行为时，欧美文化会更倾向于将责任归结到该个体本身，而东亚文化则更倾向于考虑是因为组织缺乏有效监管；</p><h4 id="基本归因错误的原理是什么"><a href="#基本归因错误的原理是什么" class="headerlink" title="基本归因错误的原理是什么"></a>基本归因错误的原理是什么</h4><p>我们在潜意识中有一个假设，即个体的行为是其内在特质的外化；其原因在于，这种归因方式最高效，耗费的大脑资源最少。如果要我们的大脑对环境因素进行评估时，就会耗费大量的资源收集证据并进行思考，这很费劲，违反人性；</p><blockquote><p>在远古时代，高效率的内在归因方式，虽然并不总是正确，但大多数时候是正确的，因此更有利于生存；</p></blockquote><h4 id="研究归因错误的必要性"><a href="#研究归因错误的必要性" class="headerlink" title="研究归因错误的必要性"></a>研究归因错误的必要性</h4><ul><li>人道主义，有助于找到更高效的办法，解决一些社会问题；而不只是单纯的以为某些社会群体的遭遇是自作自受；</li><li>让人们的思维变得更加理性，更加接近现实；</li></ul><h3 id="如何感知和回忆"><a href="#如何感知和回忆" class="headerlink" title="如何感知和回忆"></a>如何感知和回忆</h3><h4 id="先入为主"><a href="#先入为主" class="headerlink" title="先入为主"></a>先入为主</h4><p>先入为主现象（预先判断和期待效应），对我们的生活影响很大。我们对某个事情的预期，会强烈影响后续我们对外部信息的感知和解释；</p><blockquote><p>当我们给某个事物打 7 分时，在喜欢该事物的人看来，我们是在贬低；在讨厌该事情的人看来，我们是在抬高；</p></blockquote><p>通常人们都是立场在先，并选择性的关注支持自身立场的证据，同时忽略不利证据；我们的大脑不是一开始先空着，而是会先装入一个立场，然后我们再去观察事物；</p><p>当我们向他人表述自己对某个事情的评价时，他人会将我们所传达的信息，跟我们的性格特质关联在一起。例如我们贬低他人时，对方也会我们也不是什么好人；当我们表扬他人时，对方则会觉得我们也同样拥有那些特质；</p><h4 id="信念固着"><a href="#信念固着" class="headerlink" title="信念固着"></a>信念固着</h4><p>一旦人们为自己的信念找到某个理由（理论基础），不管这个理由（基础）正确与否，都将产生信念固着现象，后续将很难再改变人们的观点，即使他们得到了相反的证据也是如此；</p><blockquote><p>应用：假设顾客做出了选择，那么可以尝试让顾客为自己的选择解释理由；一旦顾客做出了解释，之后将会产生信念固着现象；</p></blockquote><p>我们越是极力的想证明自己的理论或解释是正确的，那么我们对挑战自己观点的信息，将会越封闭；我们会成为自己思维方式的囚徒。打破这种僵局的办法，是尝试从相反的角度，思考可能性的存在。</p><blockquote><p>思考可能性，尝试问自己，在什么情况下，相反的观点是有可能正确的呢？</p></blockquote><h4 id="构建记忆"><a href="#构建记忆" class="headerlink" title="构建记忆"></a>构建记忆</h4><p>当我们将信息存储到大脑中时，并不像硬盘客观如实的存储资料，我们的大脑会对信息进行加工。存储的时候会加工，提取的时候也会加工。加工的结果取决于我们当时的感觉和拥有的知识。因此，我们经常会修改我们的记忆，以便让其跟我们现在的认知水平保持一致；</p><blockquote><p>也就是说，人们常常重构自己的记忆；</p></blockquote><h4 id="重构态度"><a href="#重构态度" class="headerlink" title="重构态度"></a>重构态度</h4><p>随着时间的推移，我们对过去的记忆会慢慢变得模糊。为了简便，我们会用自己当下的感觉和认知，构建过去的记忆，并认为过去自己的态度，跟现在没有什么不同；</p><blockquote><p>当毛毛虫变成蝴蝶后，会认为自己的小时候，是一只小蝴蝶，而不是一只毛毛虫；</p><p>很多父母会感慨现在的年轻人没有他们那个时候那么懂事了。事实上，他们只是忘记了自己年轻时候的样子，从而用自己当下的价值观，替代了过去真实的自己；</p></blockquote><h4 id="重构行为"><a href="#重构行为" class="headerlink" title="重构行为"></a>重构行为</h4><p>当我们对某件事情抱有预期时，我们会高估过去该事情发生的概率；例如：</p><ul><li>抽烟的人，会低估自己过去抽烟的次数；</li><li>尝试改变自己的人，会高估自己过去发生的改变；例如坚持锻炼，虽然身体只有少量改善，但当事人会觉得改变很大；</li></ul><h4 id="重构经历"><a href="#重构经历" class="headerlink" title="重构经历"></a>重构经历</h4><p>信息误导效应：我们对事件的记忆，是存储在大脑的神经网络中的。当我们提取它们的时候，可以从不同的路径进行提取。不同的路径，提取出来的结果将不尽相同，甚至相互矛盾。例如当我们带着恐惧的情绪，提取到了该事件的记忆，我们将会对事件做出不同的解释；</p><blockquote><p>例子：当我们在观看恐怖片后，我们大脑中负责恐惧情绪的神经网络和记忆会被激活。之后我们对外部信息的判断，会带着误导效应，例如此时开水壶发出的声音，会让人感觉像是有不祥事物在靠近；</p><p>应用：如果我们想要引导他人对事物做出积极评价，那么我们可以在他们接触事物之前，先激发他们的积极情绪；</p></blockquote><h3 id="大脑如何判断"><a href="#大脑如何判断" class="headerlink" title="大脑如何判断"></a>大脑如何判断</h3><h4 id="直觉判断"><a href="#直觉判断" class="headerlink" title="直觉判断"></a>直觉判断</h4><p>我们的大部分行为遵循自动导航模式，并不需要意识的参与；事实上，这种方式让我们变动更加高效，有助于我们将有限的大脑资源，分配给核心事项。</p><p>我们的大脑能够在短时间内处理很多信息，这些信息会影响我们后续的行为，但是这些信息并不全部送达意识层，因此，我们的大脑实际掌握的信息量，比我们能够意识到自己知道的数量，还要多得多。</p><blockquote><p>当我们在意识层面无法解释自己为何作为某种行为时，其实是因为这个行为是由潜意识层面来触发的。人们通常将这一现象归结于依赖于自己的直觉；</p></blockquote><h4 id="过度自信倾向"><a href="#过度自信倾向" class="headerlink" title="过度自信倾向"></a>过度自信倾向</h4><p>过度自信的倾向几乎无处不在，每个人都会有。而且，掌握信息越少的人，这种倾向更加明显，正如古人所云，无知者无畏。</p><p>验证性偏见：当我们持有某个信念时，我们更倾向于寻找支持该信念的证据，去证实它；而不是寻找反面证据，去证伪它。</p><blockquote><p>我们更喜欢和那些支持我们观点的人在一起，并且，我们也会主动去找到他们；因此，便出现了所谓的物以类聚，人以群分；</p></blockquote><p>避免过度自信的方法：</p><ul><li>获得即时反馈；</li><li>思考出错的可能性；</li></ul><h4 id="直觉陷阱"><a href="#直觉陷阱" class="headerlink" title="直觉陷阱"></a>直觉陷阱</h4><p>代表性直觉：在需要对事物进行评价时，我们会更关注是否满足该类事物的代表性特征，而不会去关注基础概率；</p><p>易得性直觉：更容易被我们想起的事情，我们在直觉上会觉得它发生的概率更高；</p><blockquote><p>越是形象生动的画面，越容易被人们想起来；因此越容易激发人们的情绪反应；例如人们常常会高估飞机失事的发生概率；</p></blockquote><p>可能性思维：对可能会发生的事情进行心理模拟；当这个事情越有可能被模拟时（即越有可能发生），它对我们的情绪影响会越大</p><blockquote><p>例如以微小的差距输掉的比赛，会给失败者带来更大的遗憾感，同时给胜利者带来更大的幸运感；</p></blockquote><h4 id="错觉思维"><a href="#错觉思维" class="headerlink" title="错觉思维"></a>错觉思维</h4><p>相关性错觉：在随机事件中寻找规律；例如彩票站点的中奖号码历史分布图；</p><blockquote><p>当我们持有某个信念时，我们会更多的关注支持该信念的证据，同时忽略反对证据；</p></blockquote><p>控制错觉：相关性错觉会带来控制性错觉，即认为随机事件可以受自己控制；</p><blockquote><p>例如：相比随机分发的彩票，人们认为自己抽的彩票中奖概率更高；当我们参与某个随机事件时（例如掷骰子），我们会产生更多的信心，认为事情受自己掌控；</p></blockquote><p>惯性错觉：均值回归是违反直觉的，人们总是倾向于认为当前的状态会长久的保持下去。但事实并非如此，物极必反，才是自然的常态；</p><blockquote><p>股市的追涨杀跌即是一个典型的例子；</p></blockquote><h4 id="情绪染色"><a href="#情绪染色" class="headerlink" title="情绪染色"></a>情绪染色</h4><p>我们对社会的判断是一种信息加工过程（高效但容易出错），这种过程很容易受到情绪的影响；</p><blockquote><p>当我们心情愉快时，我们更倾向于积极的看待世界，做出各种乐观的判断；</p><p>当我们心情抑郁时，我们更倾向于消极的看待世界，做出各种悲观的判断；</p></blockquote><p>当人们因情绪变化而产生判断变化时，人们并不会觉得变化的原因在自己的情绪，而是宁愿相信是外部世界真的变的不同了；</p><p>情绪的影响有点像是给大脑的信息加工过程进行染色；当信息加工过程越长，这种染色会越深；也就是说，如果涉及一些非常简单、直觉式的、甚至条件反射的判断（信息加工过程短），那么情绪的影响小；如果涉及一些复杂的思考，则情绪影响作用大；</p><blockquote><p>我们大脑的信息加工过程，更容易被直观生动的事物所影响，因为它们会调动起我们的情绪；而不容易受抽象事物的影响，因为它们不容易带来情绪变化；</p></blockquote><h3 id="自我实现"><a href="#自我实现" class="headerlink" title="自我实现"></a>自我实现</h3><p>自我实现预言：观念会影响我们的行动，行动会影响现实，最终导致观念与现实的匹配；</p><blockquote><p>老师对学生的积极评价，与学生的优秀表现，二者是互为因果的相互促进关系；但这种影响不是万能和无限的，它需要一定的前提条件；例如对那些原本学习成绩低的学生影响更明显，而对原本学习能力强的学生影响不明显；</p><p>另外，学生对老师能力的预期也会影响学生本身的学习态度；如果学生认为老师能力强，则上课会更专心；反之，如果学生觉得老师的教学能力差，则上课更有可能分心；</p></blockquote><p>善意收获善意，敌意收获敌意，正如古人云：种瓜得瓜，种豆得豆；伴侣间的亲密关系同样如此，如果我们给予伴侣更高的评价和期望，则伴侣更有可能变成期望中的人；</p><blockquote><p>细心观察他人某些细小的积极行为，反复给予这些行为积极的评价，那么对方会不自觉的增加这些行为次数，最终变成了期望中的人；</p></blockquote><p>但这种影响并非万能通用的，如果被评价者对自我有非常清晰的概念，同时这种概念与他人的评价相矛盾时，则被评价者不太可能改变自己的行为；</p><p>除了他人的信念会影响我们的行为，我们的自我信念也会影响我们的行为；</p><blockquote><p>我们可以通过让人们假设未来他遭遇了某种情境，让其进行判断；那么有一天当这种情境真的出现时，那么人们通常会做出跟当初自己的判断相一致的行为；</p></blockquote><p>虽然我们的大脑对复杂事物进行判断时，存在种种局限性。但事实上这是一种策略选择的结果。以高效的直觉对日常简单事物做出判断，同时以牺牲复杂事物判断的准确性作为代价；在远古时代，这种策略一直是成功的。但在未来日益复杂的社会里，这种策略是否仍然能够成功，则有待观察；</p><h2 id="4、行为和态度"><a href="#4、行为和态度" class="headerlink" title="4、行为和态度"></a>4、行为和态度</h2><p>态度：个体对事情的反应方式，涉及感觉、行为、认知三个部分；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202306122120312.png"></p><blockquote><p>我们的大脑很擅长于为自己的行为寻找理由和原因，但非常不擅长将自己的认知付诸于行动；</p></blockquote><h3 id="态度决定行为"><a href="#态度决定行为" class="headerlink" title="态度决定行为"></a>态度决定行为</h3><h4 id="道德伪善"><a href="#道德伪善" class="headerlink" title="道德伪善"></a>道德伪善</h4><p>道德伪善：人们通常会对外界宣称自己拥有高水平的道德水准，但事实上，在利益的诱惑面前，90%的人会放弃自己的道德准则；</p><p>早期人们普遍认为态度会影响人们的行为。但后来发现这个事情比想象中的复杂，因为迫于社会压力或者维护形象需要，人们会隐藏自己的真实态度。因此，人们所宣称的态度，有时并非其真正的态度。因此，这类型的实验不太好做；</p><h4 id="何时影响"><a href="#何时影响" class="headerlink" title="何时影响"></a>何时影响</h4><p>态度并非完全跟个体的行为无关，只是在某个特定的情境中，个体会表现何种行为，跟情境有很大的关系，因为人是一种社会性的动物，会根据环境调整自己的行为，即使违背了内在意愿。因此态度很难预测个体的单次行为。但是如果将时间拉长，那么态度和总体平均行为，就会存在明显的相关性；</p><p>态度能够有效预测行为的三种情况：</p><ul><li>行为是否足够具体；</li><li>外部因素是否最小化；</li><li>是否能够唤起自我觉知；</li></ul><blockquote><p>大部分情况下，我们的大脑处于自动导航的模式，因此我们的很多行为是下意识做出的，是一种习惯性的动作；如果在行动之前，我们被提醒要先思考自己的态度，那么此后的行为，更有可能受到态度的影响；</p><p>突然想到，写清单之所以有效，貌似有可能是因为它也是一种唤起自我觉知的方法；</p></blockquote><h3 id="行为决定态度"><a href="#行为决定态度" class="headerlink" title="行为决定态度"></a>行为决定态度</h3><p>相比态度对行为的影响，行为对态度的影响更为直接和广泛；我们的大脑非常擅长为自己的行动编造理由；</p><h4 id="角色扮演"><a href="#角色扮演" class="headerlink" title="角色扮演"></a>角色扮演</h4><p>当我们开始扮演并进入某种角色，体验到角色的真实情感后，我们会不自觉的减少自我意识行为，改变自己原本的态度，逐渐变成角色中的那个人，就如斯坦福监狱实验所展示的那样；</p><h4 id="语言转信念"><a href="#语言转信念" class="headerlink" title="语言转信念"></a>语言转信念</h4><p>当我们表述某些内容时，有可能一开始我们只是根据外部情境，迎合他们进行表述。此时我们内心多少没那么坚定。但是随着表述的次数变多，我们会逐渐转为相信这些话语，将它们变成自己的信念；</p><h4 id="登门槛现象"><a href="#登门槛现象" class="headerlink" title="登门槛现象"></a>登门槛现象</h4><p>当我们在自愿的情况下，为某事做出了一个小的承诺，那么我们后续就很有可能做出大的承诺；</p><h4 id="邪恶合理化"><a href="#邪恶合理化" class="headerlink" title="邪恶合理化"></a>邪恶合理化</h4><p>当我们迫于外界压力对他人施加伤害后，为了减少内心的不安，我们会在事后改变自己的态度，编造理由贬低被害人，合理化自己的行为。</p><h4 id="道德内化"><a href="#道德内化" class="headerlink" title="道德内化"></a>道德内化</h4><p>当我们有机会自愿选择遵守某种规则后，这种规则有更大的几率会内化成我们的道德准则；反之，如果我们是被迫遵守该规则，那么当外界压力消失后，我们便不再遵守该规则；</p><h4 id="种族平等"><a href="#种族平等" class="headerlink" title="种族平等"></a>种族平等</h4><p>种族平等原本是一种道德行为，它取决于人们的态度。但是通过为种族平等进行立法，能够快速的影响人们的态度。</p><blockquote><p>获得他人好感的一个有效方法，是可以让对方帮自己一个小忙；</p></blockquote><h4 id="社会运动"><a href="#社会运动" class="headerlink" title="社会运动"></a>社会运动</h4><p>态度依从行为的现象，带来了一种潜在的危险，即极权政府可以通过发动社会运动，强迫人们参加某种共同的活动（例如希特勒，中国也发生过），来影响人们的态度。人们一开始参加这类活动时，内心会充满矛盾和不适感。但是当参加的次数变多后，为了调和不适，人们会开始编造理由让自己相信这些行为存在合理性，在无意识中，接纳了极权政府想要传达的观念；</p><blockquote><p>人们天生存在将自己的行为合理化的倾向；</p></blockquote><h3 id="行为决定态度原因"><a href="#行为决定态度原因" class="headerlink" title="行为决定态度原因"></a>行为决定态度原因</h3><p>行为影响态度现象，目前存在三种理论解释：</p><h4 id="自我展示：印象管理"><a href="#自我展示：印象管理" class="headerlink" title="自我展示：印象管理"></a>自我展示：印象管理</h4><p>为了避免让别人觉得自己言行不一，自相矛盾（外部压力）</p><h4 id="自我辩解：认知不协调"><a href="#自我辩解：认知不协调" class="headerlink" title="自我辩解：认知不协调"></a>自我辩解：认知不协调</h4><p>通过转变自我的态度，保持认知的一致性（消除内部压力）；因为认知不协调会导致我们感到紧张和不舒服，从而让我们产生改变自己的压力；</p><p>当外界存在某种压力或现象，给我们带来紧张的感觉时，我们会倾向于寻找并相信那些能够消除这些紧张的看法或证据；</p><blockquote><p>例如房价很高，导致购房压力很大时，未购房的人们更愿意相信房价会崩盘；因为这样会消除内心的不安感。反之，如果相信房价会继续上涨，那么会让自己的紧张和不舒服感变得更加强烈；</p></blockquote><blockquote><p>当人们为了获得高报酬进行撒谎时，人们不会相信自己说出的谎言；但如果人们在没有太多收益的情况下撒谎，那么人们会倾向于相信自己的谎言。不然自己撒谎的理由不足，会带来认知失调；</p></blockquote><p>当人们知道需要为自己的行为负责时，人们就会让自己的态度和行为保持一致；</p><h5 id="决策后的不协调"><a href="#决策后的不协调" class="headerlink" title="决策后的不协调"></a>决策后的不协调</h5><p>当我们面临两难选择时，我们会经历紧张和不安，因为两个选项各有利弊。因此，当我们最终放弃其中一个选项后，我们会开始编造理由，贬低已经放弃的选择，以便减少内心的不安。</p><h4 id="自我知觉"><a href="#自我知觉" class="headerlink" title="自我知觉"></a>自我知觉</h4><p>当我们作出某种行为后，我们会观察到自己的行为。如果这些行为是我们自愿选择的，不存在外部压力，那么我们会调整自己的觉知，让自我形象与自己的行为相匹配；这个过程有助于态度的形成；</p><blockquote><p>当我们的初始态度是模糊的，还没有完全形成时，自我知觉理论也可以很好的解释态度依从行为现象；</p></blockquote><p>我们的肢体行为和表情行为，会不自觉的影响我们的情绪状态。例如我们调动面部肌肉，做出笑容的表情，这个行为会在无意识中让我们的情绪变得更加乐观，即内部情绪依从生理行为；</p><blockquote><p>同理，当我们和他人交谈时，我们会在无意识中模仿对方的行为。这种模拟会让我们更好的感知到对方的情绪。</p></blockquote><h5 id="外化动机和内化动机"><a href="#外化动机和内化动机" class="headerlink" title="外化动机和内化动机"></a>外化动机和内化动机</h5><p>如果外部刺激不足以证明我们自身行为的合理性，那么我们会从内部寻找原因，证明自我行为的合理性，即将动机内化；</p><blockquote><p>例如打游戏能够赚钱，那么游戏者会将自己的行为归因于报酬；如果打游戏不能赚钱，那么游戏者会归因于自己的兴趣；</p></blockquote><blockquote><p>提供大额外部刺激，往往无法形成持久的激励作用。因为当外部刺激消失时，人们就会失去动力；反之，如果我们能够给予适当的赞美，让对方觉得自己很有能力，那么更有可能激发出对方的学习兴趣和持续进步的欲望；</p></blockquote><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>让人们改变自我的最好方法，就是让他们行动起来，因为行动会改变态度；甚至，行动还会改变我们的大脑，让我们更深入的思考，从而获得更多的收获。</p><blockquote><p>例如用自己的话，讲述自己学到的东西，就比单纯听的效果要好得多；因此，想要传授知识给他人时，最好的办法是引导对方表述观点和回答问题。即用问的方式，可能要比用说的方式效果更好。</p></blockquote><h1 id="社会影响"><a href="#社会影响" class="headerlink" title="社会影响"></a>社会影响</h1><p>社会对个体的影响是非常强大的。</p><h2 id="5、基因、文化和性别"><a href="#5、基因、文化和性别" class="headerlink" title="5、基因、文化和性别"></a>5、基因、文化和性别</h2><h3 id="基因和文化的影响"><a href="#基因和文化的影响" class="headerlink" title="基因和文化的影响"></a>基因和文化的影响</h3><h4 id="基因与行为"><a href="#基因与行为" class="headerlink" title="基因与行为"></a>基因与行为</h4><p>基因构造了一个具有适应性的硬件（大脑的学习能力），能够加载外部的软件（文化）；基因不仅构造了我们的生理特征，也构建了我们的心理特征和社会能力；</p><h4 id="文化与行为"><a href="#文化与行为" class="headerlink" title="文化与行为"></a>文化与行为</h4><p>适应性的大脑能够提高个体在不同的环境中的生存能力，也因此造就了多样性的文化；</p><blockquote><p>接触另外一种文化，是了解自身文化的最有效办法，正如鱼离开水后比在水中更能感受水的存在。</p></blockquote><p>文化通过社会规范（对什么是恰当行为的解释），在不知不觉中影响我们的日常行为。文化多样性的表象下面，也隐藏着大量的文化相似性，例如社会地位高的人，往往是亲密关系发展的主导者；</p><h4 id="角色与行为"><a href="#角色与行为" class="headerlink" title="角色与行为"></a>角色与行为</h4><p>每个角色背后，都会涉及一系列的社会规范。我们经常同时扮演多个社会角色。社会角色会影响我们的行为，因为我们倾向于接纳并内化自己所扮演的角色。</p><blockquote><p>当我们首次扮演一个新角色时，会感到不自然。但随着时间推移，这种不自然会消失，我们会慢慢感觉随意自然。</p></blockquote><p>不同角色的社会地位有高低之分，因此我们所扮演角色的社会地位，会不自觉影响我们的自我效能感。例如当我们扮演管理者时，我们会变得更加自信；当我们扮演助理时，我们会变得不那么自信；</p><p>角色互换也会影响我们的行为，例如当我们扮演某个新角色，并获得他人认可后，我们就会内化该角色的相关行为；</p><blockquote><p>另外，角色互换也非常有助于我们理解对方的观点；</p></blockquote><h3 id="性别相似性和差异性"><a href="#性别相似性和差异性" class="headerlink" title="性别相似性和差异性"></a>性别相似性和差异性</h3><h4 id="亲密关系"><a href="#亲密关系" class="headerlink" title="亲密关系"></a>亲密关系</h4><p>女性比男性更重视亲密关系，更擅长共情，对情绪线索更加敏感，也投入更多的时间维护关系；</p><h4 id="控制欲"><a href="#控制欲" class="headerlink" title="控制欲"></a>控制欲</h4><p>男性在控制欲、攻击性、进取心等方面，比女性更加突出，其中文化因素或许也有关系，因为自农业时代后，男性成长于高社会地位的环境中；</p><h4 id="攻击性"><a href="#攻击性" class="headerlink" title="攻击性"></a>攻击性</h4><p>在受到挑衅时，男女都会表现出攻击性，但男性攻击造成的伤害通常比女性更大；</p><h4 id="性行为"><a href="#性行为" class="headerlink" title="性行为"></a>性行为</h4><p>男性的性态度更加开放，很少拒绝，更愿意冒险和花费更多的资源获得性爱；</p><h3 id="哪些行为是天生的"><a href="#哪些行为是天生的" class="headerlink" title="哪些行为是天生的"></a>哪些行为是天生的</h3><h4 id="性别与择偶偏好"><a href="#性别与择偶偏好" class="headerlink" title="性别与择偶偏好"></a>性别与择偶偏好</h4><p>在择偶方面，男性偏好年轻健康的女性；女性则容易被拥有资源和高社会地位的男性所吸引；</p><h4 id="性别与荷尔蒙"><a href="#性别与荷尔蒙" class="headerlink" title="性别与荷尔蒙"></a>性别与荷尔蒙</h4><p>在求爱阶段，正值两性荷尔蒙分泌的高峰，因此两性间的差异更加明显；当到了中老年阶段时，随着荷尔蒙分泌水平的下降，两性都开始变得更加中性和相似了起来；</p><h4 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h4><p>两性的差异源于我们祖先生存环境的选择，代表的是过去的历史，并不代表当下以及未来我们的理性选择；</p><h3 id="哪些行为源于文化"><a href="#哪些行为源于文化" class="headerlink" title="哪些行为源于文化"></a>哪些行为源于文化</h3><h4 id="不同文化"><a href="#不同文化" class="headerlink" title="不同文化"></a>不同文化</h4><p>不同文化环境下，女性角色有显著区别；例如同为工业化国家，日本女性经理占比仅为1&#x2F;10，但德国为1&#x2F;2；北美牙医多为男性，丹麦牙医多为女性；</p><h4 id="不同时代"><a href="#不同时代" class="headerlink" title="不同时代"></a>不同时代</h4><p>1938年，20%的美国人支持已婚女性工作赚钱；现在这个比例则反了过来；在过去的几十年，有大量的已婚女性进入劳动力市场，比例翻倍；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202306272321042.png"></p><h4 id="同伴影响"><a href="#同伴影响" class="headerlink" title="同伴影响"></a>同伴影响</h4><p>基因影响占比50%，家庭影响占比10%，剩下40%为同伴影响；父母对小孩的文化影响，并没有我们想象中的那么大。很多新变化，往往来自于年轻一代；</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>生物和文化两个因素并非相互独立的，而是相辅相成的。如果没有生物程序，文化因素也无法发挥作用；所有社会和文化因素，归根结底仍然是生物因素的一部分；基因并非是死的，它最大的特点是适应性和学习能力。它主要是为我们的行为提供了一个大致的框架，并留下了让我们自由发挥的余地；</p><p>随着女性经济收入和社会地位的提高，两性间的社会角色差异也有所减少；</p><p>个体本身也有选择环境的力量；我们既是环境的产物，同时也是环境的建造者；</p><h2 id="6、从众"><a href="#6、从众" class="headerlink" title="6、从众"></a>6、从众</h2><h3 id="什么是从众"><a href="#什么是从众" class="headerlink" title="什么是从众"></a>什么是从众</h3><p>定义：个体根据他人的反应，做出行为或信念的改变；</p><blockquote><p>从众本身是一个中性的行为，它有好的一面，也有不好的一面；但不同的文化对它的评价不同，例如欧美个人主义文化将从众当为消极的；日本的集体主义文化则将从众视为成熟的表现；</p></blockquote><p>从众的两种形式：</p><ul><li>顺从：内心不认同</li><li>接纳：内心认同；</li></ul><p>出于外部压力，我们会调整自己的观点，以便尽量跟外部规范保持一致。也就是说，人们口中表达的观点，不一定是他们内心的真正想法；</p><p>当我们待在开心愉快的人群中时，我们也会跟着变得愉快起来。这种情绪传染也是一种从众行为的结果，</p><p>很多时候，我们的从众反应都是潜意识的，我们常常没有在意识层面觉察到了自己的从众行为。相比其他年龄，青少年的从众现象更为普遍一些。</p><p>从众行为有一种较为极端的现象：人群暗示导致的集体妄想症；人们在获得某种外界的暗示后，开始无中生有的感觉到该暗示的存在，例如曾经非常流行的 UFO 现象；</p><p>即使不存在外界激励或者惩罚等因素，即外界压力最小化的情况下，仍然有三分之一的人会表现出从众行为。而当外界压力或奖励变大时，从众比例将急剧上升（详见：米尔格拉姆的电击实验）；</p><p>影响服从程度的因素</p><ul><li>与受害者的情感距离：距离越近，服从越弱；因此，将受害者尽量人格化和具象化，是很有用的；人们对抽象的数字毫无感觉；</li><li>权威的接近性与合法性：权威越合法，离现场越近，则服从程度越高；</li><li>权威的机构性：命令来自越权威的机构，服从程度越高；</li><li>释放效应：如果出现一个不服从者，则会让其他很多人释放服从压力，敢于表现出不再服从；</li></ul><p>服从的程度同样遵循登门槛效应。如果一上来就是高难度的服从，反而容易激起人们的反抗；而多次小服从，会降低人们的不适感，在无形中改变人们的态度，为之后的大服从做好铺垫；</p><p>人类天生有服从邪恶的潜能，但反过来，人们也同样拥有英雄主义的潜能。这个过程同样遵循登门槛效应。一开始的微小善意，最后演变成一种强大的责任感和承诺（例子：那些冒着生命危险，保护和救助犹太人的人们）；</p><p>我们有一种天生的直觉，认为好人做好事，坏人做坏事。那些邪恶的罪行，都是一些天性邪恶的人才会做出来的行为，但事实上不是的，情境的力量是很强大的，它会让一个普通人做出残忍的行为，就像对犹太人的屠杀，是由千万个普通平凡的德国人完成的一样；</p><h3 id="从众的因素"><a href="#从众的因素" class="headerlink" title="从众的因素"></a>从众的因素</h3><h4 id="群体规模"><a href="#群体规模" class="headerlink" title="群体规模"></a>群体规模</h4><p>人数越多，能够影响的从众者越多，但到达临界值后，会出现边际递减效应，因为能够影响的都影响了。剩下的人，即使人数再多，也仍然会保持自己独立的观点（即从众再晚是无法100%的，总是会存在少数不从众的人）；</p><p>另外，在总人数相同的情况下，多个小群体（3个2人组），比单个群体（1个6人组），能够带来更多的从众行为；</p><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>如果有人发表异议，破坏了一致性，那么之后人们从众的比例将大幅下降，即此处有明显的压力释放效应。人们不再会因自己的不同看法产生压力，因为压力由其他人分担了，因此更敢于发表自己的真实观点。</p><h4 id="凝聚力"><a href="#凝聚力" class="headerlink" title="凝聚力"></a>凝聚力</h4><p>相比圈外人，圈内人能够带来更多的从众行为。即某个群体内部凝聚力越强，那么其成员有更大的概率会从众（因为不从众的压力变得更大了）</p><h4 id="社会地位"><a href="#社会地位" class="headerlink" title="社会地位"></a>社会地位</h4><p>社会地位高会更容易影响人们，带来更多的服从；反之，人们会避免与地位低或受排斥的成员保持相同的观点，因为担心这样做会被其他成员排斥，降低自己的社会地位；</p><h4 id="公开场合"><a href="#公开场合" class="headerlink" title="公开场合"></a>公开场合</h4><p>对比私下场合，人们在公开场合更容易从众，因为面临更多的社会压力；</p><h4 id="事前承诺"><a href="#事前承诺" class="headerlink" title="事前承诺"></a>事前承诺</h4><p>个体一旦在公众面前做出承诺，那么之后改变主意的可能性就很小了，即会坚持到底；</p><h3 id="从众的原因"><a href="#从众的原因" class="headerlink" title="从众的原因"></a>从众的原因</h3><p>两个常见原因（日常生活中，这两个原因常常同时出现）</p><ul><li>规范影响：个体希望自己被群体接纳，而不是被排斥。因为作为社会性动物，被排斥会给我们带来巨大的痛苦；</li><li>信息影响：当我们因信息不足，无法做出决策时，我们通常会将其他人的行为视为一种信息参考，以确保自己作出正确的决策；</li></ul><h3 id="谁会从众"><a href="#谁会从众" class="headerlink" title="谁会从众"></a>谁会从众</h3><h4 id="个性"><a href="#个性" class="headerlink" title="个性"></a>个性</h4><p>在相同情境下，不同个性的人，确实会展现不同的从众水平。但是仅依据个性指标，却很难预测个体的行为反应，原因在于社会情境的影响很大，很多时候它会盖过个性。当我们将社会影响力降到最低时，个性间的差异才比较容易展现出来；</p><h4 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h4><p>不同文化环境下的人们，在从众比例上也有所差异。例如集体主义文化比个人主义文化，人们的从众几率更高。一个文化越是惩罚不从众者，那么其成员表现出来的从众倾向越明显。</p><p>但文化是动态的，随着时间的推移，世代的更迭，该地区人们的从众倾向也会随之产生动态的变化；</p><h3 id="如何抵制从众的压力"><a href="#如何抵制从众的压力" class="headerlink" title="如何抵制从众的压力"></a>如何抵制从众的压力</h3><h4 id="逆反"><a href="#逆反" class="headerlink" title="逆反"></a>逆反</h4><p>注重自由感和自我控制感，是我们天生的倾向。因此，当我们感受到某种外力，威胁到我们的自由感时，我们就会产生反抗，以保护自己的自由感。</p><h4 id="独特性"><a href="#独特性" class="headerlink" title="独特性"></a>独特性</h4><p>我们有展示自己独特性的需求，但是有一定的前提，即我们的独特性是被外界视为积极的，简单来说，即我们会追求好过他人。事实上，这也是我们追求社会地位的某种外在表现。我们通过展示积极的独特性，在获得更高的自我效能感或社会地位。</p><blockquote><p>当我们是某个群体中的少数派时，我们会更容易觉察到自己的独特性，反之则不会；这也是为什么少数派会变得更加敏感；或许这也是一种刻在我们基因中的本能，因为这种本能或许有助于提高繁衍的几率；</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从众并不全然是负面，因为我们终归是社会性的动物，我们有归属的需要。牺牲一点自我，与他人建立更浓厚的依恋关系，同样有助于提升个体的生活幸福感。最好的策略或许是在坚持自我和融入群体之间做出恰当的平衡；</p><h2 id="7、说服"><a href="#7、说服" class="headerlink" title="7、说服"></a>7、说服</h2><p>说服在生活中无处不在，当我们认可说服行动时，说服被称做“教育”；当我们不认可时，说服被称做“灌输”；说服本身是中性的，并无好坏之分，重点在于它被用于何种场景，包含何种内容，为了实现何种目的；</p><h3 id="说服的途径"><a href="#说服的途径" class="headerlink" title="说服的途径"></a>说服的途径</h3><h4 id="中心途径"><a href="#中心途径" class="headerlink" title="中心途径"></a>中心途径</h4><p>当人们有能力对问题进行系统性的思考时，人们会更多的使用中心路径，即关注论据；只要论据有力，人们就可能被说服；</p><h4 id="外周途径"><a href="#外周途径" class="headerlink" title="外周途径"></a>外周途径</h4><p>当人们无瑕思考时，就会更多的使用外周路径，即不关注论据，而是关注那些无需动脑的外部线索，例如视觉形象（这便是为什么品牌要请明星代言人的原因）；</p><blockquote><p>以上两个途径都有效，但是前者的作用一般更加持久。因为中心路径触发受众的思考，在大脑中留下的神经刺激更强烈，因此能够产生更加持久的作用；</p></blockquote><h3 id="说服的要素"><a href="#说服的要素" class="headerlink" title="说服的要素"></a>说服的要素</h3><h4 id="谁说的（传达者）"><a href="#谁说的（传达者）" class="headerlink" title="谁说的（传达者）"></a>谁说的（传达者）</h4><p>相同的话语由不同的人讲出来，其说服效果可能存在很大的差异；</p><p>短时间内，信息来源越可靠（即可信度越强，例如来自政府官方机构）那么说服效果越好（但随着时间推移，人们会慢慢忘记信息来源）；</p><p>增加可信度的办法：</p><ul><li>先讲一些人们普遍赞同的观点（这样听众会觉得该人很聪明，有利于建立良好的第一印象）；</li><li>介绍权威的身份（例如在某个领域的博士或教授，牙膏广告的演员穿着白大挂）；</li><li>更加自信的表达方式（例如使用直截了当的措词）；</li><li>让听众觉得传达者不是对自己说话（例如让传达者不面对镜头说话，而是偏向一侧，类似有另外一个听从存在）；</li><li>站着自身利益对立面表达观点（例如公司内部人员表达对公司不利的观点） ；</li><li>提高语速（这样听众的大脑需要花更多时间处理信息，没有时间思考）；</li></ul><p>有效说服的六个要素：</p><ul><li>权威性：人们更愿意听信专家的意见（当涉及主题侧重客观事实，而非主观偏好时）；</li><li>一致性：人们更倾向表现与承诺相一致的行为；</li><li>喜好：爱屋及乌（当我们喜欢 A，在做决策时，也会偏好选择跟 A 相关的东西；因为 A 会引发我们的积极联想）；</li><li>互惠：回报那些给自己带来过好处的人；</li><li>稀缺：物以稀为贵；</li><li>从众：追随多数人的行动（当涉及主题侧重主观偏好时尤其明显）；</li></ul><h4 id="说了啥（信息内容）"><a href="#说了啥（信息内容）" class="headerlink" title="说了啥（信息内容）"></a>说了啥（信息内容）</h4><p>内容最终需要听众接收，然后才能发生效果。因此，哪种内容能够产生效果，其实不在于说的人，而在于听的人；最好的办法是对症下药。根据听众的思维特征，有针对性的组织内容；</p><blockquote><p>例如当听众擅长逻辑思考，倾向使用中心路径时，则讲话内容应该侧重逻辑性和条理性；反之，如果听从不擅于思考，依赖于外周途径时，则内容应侧重情感维度；</p></blockquote><p><strong>好心情效应</strong>：当人们处于心情愉悦的状态时，他们会更容易被说服（猜测是因为它会引发积极联想，让我们戴着有色眼镜看世界）；</p><p><strong>恐惧唤起效应</strong>：通常情况下，当人们的恐惧程度越高，其回应就越多（所以，将吸烟造成的疾病，印刷在烟盒上面，更有助于提醒人们少抽烟）；</p><blockquote><p>但是当可怕的后果，是跟一个令人愉快的行为联系在一起时，恐惧产生的效果要打折扣。人们很可能为了短期愉悦，牺牲长期利益。并且人们会否认事实的存在，以便说服自己，那些可怕的后果并不会发生在自己身上，这样自己会感觉更好受一些（无意识状态下的自我欺骗）；</p></blockquote><p><strong>差异程度</strong>：当信息来源的可信度很高时（例如某知名专家），则专家的观点与听众自身观点差异越大，带来的改变越多；反之，如果信息来源的可信度低（例如某个在校学生），则观点差异过大，带来改变反而越小；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307072300132.png"></p><p><strong>反面观点</strong>：当人们的态度跟信息来源一致时，则不讲反面观点更好；反之，当人们对信息来源持反对意见时，则提及反面观点的说服效果更好；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307072259989.png"></p><p><strong>首因&#x2F;近因效应</strong></p><p>通常情况下，首因效应更普遍，这也为什么第一印象很重要。但是在某种情况下，近因效应更突出：</p><ul><li>当两个原因间隔的时间足够长时（人们已经淡忘）；</li><li>当人们听到第二个原因后，需要立即表达态度时</li></ul><h4 id="怎么说（沟通渠道）"><a href="#怎么说（沟通渠道）" class="headerlink" title="怎么说（沟通渠道）"></a>怎么说（沟通渠道）</h4><p>跟被动态度相比，人们基于自身经验形成的态度，更加稳定和自信；</p><p>口头传达的影响力其实非常有限，在间隔一小段时间后，留存率不足10%；高效的传达需要同时具备多重因素，包括：</p><ul><li>易于理解；</li><li>易于记忆；</li><li>令人信服；</li></ul><p>想要同时做到以上几点，是相当不容易的，因此广告商们很清楚，多次重复很重要；重复的次数越多，越容易让人们记住自己；</p><blockquote><p>简单的重复都能够产生明显的效果；例如”多姿多彩可以避免让人厌倦“这句话，比”变化可以避免让人厌倦“，更加让人信服；</p></blockquote><p>某个事项（例如选举投票）越是重要，以及当事人对事情越是熟悉，那么外界的影响力越小；反之则越大（即广告的作用越大）；</p><p>我们的想法，受身边人的直接影响最大，受传媒的直接影响较小，但传媒的间接影响很大。因为传媒会先影响一小部分意见领袖，并借助意见领袖影响很多普通人；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307082109318.png"></p><p>当信息较为复杂难于理解时，那么文字的传达效果会更好。因为人们可以调整自己的阅读速度，控制信息的输入节奏；反之，对于简单的信息，则录像的效果更好；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307082112675.png"></p><h4 id="对谁说（受众）"><a href="#对谁说（受众）" class="headerlink" title="对谁说（受众）"></a>对谁说（受众）</h4><p>我们的大脑有一定的生理周期，在15-25岁这段时间，是大脑对外界刺激反应最敏感的一段时间。因此，在这个期间的经历和情感刺激，会给我们留下最深的印象。我们会形成基本的世界观和价值观，并在此后的人生中保持相对稳定的状态；因此，人群的态度存在生活时代效应，即相同时代的人，秉持相近的价值观念；不同时代的人，经常存在代沟；</p><p>说服过程的关键，并不在于信息本身，而在于它在受众身上激起什么样的反应；如果唤起正面情绪，则我们更有可能被说服；如果唤起负面情绪，则我们很可能会固执己见；</p><p>当人们意识到自己正在或即将被他人说服时，人们会提前做好防御准备，从而导致说服的难度大大上升；</p><p>当人们的注意力被分散时，说服的效果会更好。例如电视广告在播放台词时，会快速切换各种画面，分散我们的注意力，导致我们无法对文字的正确性做出判断；</p><p>不同的受众会关注不同的线索。不喜欢思考的受众，更关注外周线索；喜欢思考的受众，更关注中心路径；</p><p>事情分优先级，当事情无关紧要时，不管受众是否喜欢思考，都更倾向于依赖外围线索进行决策；</p><p>受众越是被激起更多的思考，那么强有力的信息，越是具备说服力；因此，想要更好的说服别人，多提问句也是很重要的，而不是一直单向输出；反之，对于学习也是如此。学生提出越多的问题，那么学习的效果越好；</p><h3 id="现实中的说服"><a href="#现实中的说服" class="headerlink" title="现实中的说服"></a>现实中的说服</h3><h4 id="态度依从行为"><a href="#态度依从行为" class="headerlink" title="态度依从行为"></a>态度依从行为</h4><p>人们会内化自己那些反复、公开、自动的行为；因此，通过利用登门槛效应，有意识的控制人们的行为，会在不知不觉中改变人们的态度；</p><h4 id="有说服力的因素"><a href="#有说服力的因素" class="headerlink" title="有说服力的因素"></a>有说服力的因素</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307090924328.png"></p><h4 id="团体效应"><a href="#团体效应" class="headerlink" title="团体效应"></a>团体效应</h4><p>邪教组织控制成员的过程：</p><ul><li>切断社会联系，造成社会闭塞的现象；让成员失去外部信息来源，降低判断能力；</li><li>团体为成员提供支持感、认同感、希望感等，并为其界定事实；</li></ul><p>事实上作为社会性的动物，我们经常处在某个团队之中。例如作为国家公民、公司职员、党派成员、俱乐部成员等；每个成功团队的背后，都或多或少在运用各种说服的要素，以最大化对成员的影响力。说服的力量本身是中性的，就像刀一样，并不是一定是邪恶的；使用的结果如何，取决于运用它的人；</p><h3 id="如何抵制说服"><a href="#如何抵制说服" class="headerlink" title="如何抵制说服"></a>如何抵制说服</h3><p>抵制说服的一些办法：</p><ul><li>预先公开表态（利用承诺一致性倾向）；</li><li>温和挑战：温和的攻击对方立场（当攻击强度较为温和，不足以驳倒人们时，人们会先尝试维护自己的信念；然后随着维护次数变多，触发行为决定态度，让人们在不知不觉中，变得对自己的观点更加坚定）；</li><li>触发反驳：当人们发现他人在攻击自己的态度或信念时，人们在情绪上会变得愤怒，进而触发反驳；当人们进入反驳状态后，便很难再被说服了；</li><li>打预防针：在人们受到真正的病毒（广告）之间，再让人们经历一次小的反驳行为，那么后续人们的抵抗力会上升；</li></ul><blockquote><p>现实中的应用：抵制抽烟的同伴压力（预先让小孩练习一些反驳），例如：</p><ul><li>针对香烟广告暗示抽烟让女性得到解放：假如女性无法摆脱香烟，就不能算是真正的解放；</li><li>针对抽烟的同学取笑不吸烟的同学为“小鸡”：如果抽烟只是为了给你留下什么印象，我宁愿当一只小鸡；</li><li>很多邪教或传销组织，采取了相同的手段，预先提醒其成员他们会受到家人和朋友的攻击，让其做好反驳我的准备；</li></ul></blockquote><blockquote><p>低龄儿童由于大脑还在未完全发育的阶段，因此还不能很好的辨别广告宣传的真实性，轻信的年龄特点，让其较容易受到广告商的影响；很多国家因此立法限制播放面向儿童的广告；</p></blockquote><blockquote><p>效果不佳的说服还不如没有，因为它会引发反作用。当人们驳倒效果不佳的说服后，后续的态度会变得更加坚定。即使新的说服变得更有力量，也难以回天了；</p></blockquote><blockquote><p>作为个体，一方面要保持头脑开放，相信三人行，必有我师，做积极的倾听者；另一方面，不盲从盲信，做批判性的思考者，对接受到的信息进行仔细推敲；</p></blockquote><h2 id="8、群体影响"><a href="#8、群体影响" class="headerlink" title="8、群体影响"></a>8、群体影响</h2><h3 id="社会助长作用"><a href="#社会助长作用" class="headerlink" title="社会助长作用"></a>社会助长作用</h3><h4 id="纯粹他人在场"><a href="#纯粹他人在场" class="headerlink" title="纯粹他人在场"></a>纯粹他人在场</h4><p>唤起能够给我们直觉反应带来增强效果；在直觉反应常常是正确的场景中，我们的表现会因唤起而变好；但在直觉反应常常是错误的场景中，我们的表现会变差；</p><blockquote><p>从生理角度来说，他人在场，会导致我们的心跳变快，血液加速，激素水平上升；当我们处于这种状态时，我们的优势反应（以条件反射为主的反应）经常会变得更好；但我们的弱势反应，则会因此变得更糟；</p></blockquote><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307172059169.png"></p><h4 id="众多他人在场"><a href="#众多他人在场" class="headerlink" title="众多他人在场"></a>众多他人在场</h4><p>当在场的人数越多（越拥挤）时，我们被唤起的强度也会变得越大。</p><h4 id="唤起原因"><a href="#唤起原因" class="headerlink" title="唤起原因"></a>唤起原因</h4><p>他人在场导致唤起的原因包括：</p><ul><li>评价顾忌：当我们意识到自己可能被他人评价时</li><li>分心：当我们的注意力被分散时，给大脑带来了更大的认识负担，从而造成了唤起；</li><li>纯粹在场：即使没有评价顾虑和分心，纯粹他人在场，也有可能引起一定程度的唤起；</li></ul><h3 id="社会懈怠"><a href="#社会懈怠" class="headerlink" title="社会懈怠"></a>社会懈怠</h3><p>当我们做为团队的一员，且我们的付出无法被单独评价时，我们会无意识的出现社会懈怠现象。团队规模越大，这种懈怠的现象就会越明显；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307172123026.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307172123271.png"></p><p>不管是独立一人，还是处于团队之中，当个体的表现能够被单独评价时，个体就会付出更多的努力，从而避免社会懈怠的产生；</p><p>当目标非常有挑战性，且对成员非常有吸引力时（例如团体比赛奖牌），那么每个成员都知道即使自己付出全力，也不一定能够实现目标，那么此时的懈怠现象就会减少；</p><p>另外，如果群体成员对团队拥有高度的认同感，那么懈怠现象也会有所减少（例如几个好朋友之间的合作，相比和陌生人的合作，前者会付出更大的努力）；因此，保持团队较小的规模，让彼此更加亲密，并让成员间的实力均衡，有助于提高团队的战斗力；</p><h3 id="去个体化"><a href="#去个体化" class="headerlink" title="去个体化"></a>去个体化</h3><p>社会助长现象会导致个体的唤起，而社会懈怠会分散个体的责任，让二者结合在一起时，会让个体做出一些平时原本不会做的行为，甚至完全忘却了个体的身体，出现去个体化。</p><p>造成去个体化的原因包括：</p><ul><li>群体规模：规模越大，唤起强度越大，同时责任越分散；</li><li>匿名性：当个体将自己隐藏在集体中时，减弱了自我意识，增强了集体意识，变得更加情绪化；</li><li>唤起和分心：通过参与集体性的行为（例如一起跳舞），我们体会到和他人的联结，自我意识被减弱，集体意识被加强；</li></ul><p>对抗去个体化的一个有效办法是加强自我觉察，例如可以使用镜子、摄像机、显著的姓名标签、明亮的环境光线等；</p><h3 id="群体极化"><a href="#群体极化" class="headerlink" title="群体极化"></a>群体极化</h3><p>群体讨论的结果有可能更冒险，也有可能更谨慎，答案取决于成员初始看法是什么，群体讨论更多是起到加强最初看法的作用，即所谓的群体极化现象；</p><p>这也是极端恐怖分子之所以极端的原因，当其成员持有的想法越接近时，他们越容易强化彼此的想法，从而变得更加极端；</p><p>群体极化的原因：</p><ul><li>信息影响：行为决定态度，当人们参与讨论时，不可避免需要动用大脑，引用论据（他人观点），组织语言来表述自身的观点，这个过程本身就会引起对观点的强化；</li><li>规范影响：希望获得他人的认同</li></ul><blockquote><p>人类天生希望获得对自己的能力和观点的评价；当我们的观点得到他人（我们喜欢或认同的群体）的认同和证实时，我们会强化自己的观点。同时为了能够让他人也喜欢我们，我们还经常会表达的更加极端；</p></blockquote><blockquote><p><strong>人众无知现象</strong>：当我们不清楚其他人怎么想时，我们会先隐藏自己的想法，观察一下；当所有人都这么做时，就容易带来错觉。例如大家都没听懂，但出于担心自己是少数派，害怕出丑，因此没人提问，结果大家都误以为其他人都听懂了，只有自己不懂；</p></blockquote><blockquote><p>由于人类本身是一个复杂的动物，因此我们的很多行为通常有多个因素在发挥作用，这导致了很少存在一个简洁的答案，能够解释所有的现象；</p></blockquote><h3 id="群体思维"><a href="#群体思维" class="headerlink" title="群体思维"></a>群体思维</h3><h4 id="群体思维的症状表现"><a href="#群体思维的症状表现" class="headerlink" title="群体思维的症状表现"></a>群体思维的症状表现</h4><ul><li>成员容易变得过分自信；</li><li>容易忽略群体外的道德义务；</li><li>容易合理化自身行为；</li><li>容易将对手刻板印象化；</li><li>可能会制造从众压力，让异议者不敢发声；</li><li>可能出现自我审查压力；</li><li>容易出现一致同意错觉；</li><li>容易作出心理防御行为，让异议者不要制造干扰；</li></ul><p>以上症状会阻止群体成员对不同可能性展开探讨，最终导致出现错误的决策；</p><h4 id="预防群体思维的办法"><a href="#预防群体思维的办法" class="headerlink" title="预防群体思维的办法"></a>预防群体思维的办法</h4><ul><li>公平：不偏向任何立场；</li><li>鼓励反对意见；</li><li>先分组讨论，再交换小组意见；</li><li>引入局外人，带来新视角；</li><li>实施前二次会议，鼓励畅所欲言；</li></ul><h4 id="传统头脑风暴的改进"><a href="#传统头脑风暴的改进" class="headerlink" title="传统头脑风暴的改进"></a>传统头脑风暴的改进</h4><p>传统的头脑风暴效果并不好，因为面对面的交流，很容易带来从众压力，更好的方法是：成员之间不见面，而是通过写作来相互交流想法。交流可以多轮进行，同时利用互联网软件来提高交流速度；</p><h3 id="少数派的影响力"><a href="#少数派的影响力" class="headerlink" title="少数派的影响力"></a>少数派的影响力</h3><p>大多数情况下，个体都会屈服于从众压力，但在少数特殊情况下，持有异议的个体，会反过来影响群体，包括：</p><ul><li>一致性：个体的态度自始至终的坚定；</li><li>自信：当个体展现出足够的自信时，他的观点会有更大的影响力；</li><li>释放压力：当个体勇敢的表达异议后，它能够释放群体中的从众压力，能够吸引其他异议者也站出来表达自己；</li></ul><p>两种领导风格：</p><ul><li>任务型：设置目标，制定规范，聚焦于目标实现；</li><li>社会型：倾向想法，表达支持，调解矛盾；</li></ul><p>不同的领导风格有不同的使用场景，适用于不同类型的员工。优秀的领导经常同时具备两种风格，并能够根据场合，灵活的切换；</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>我们是社会性的动物，因此群体是我们生活环境的重要组成部分。群体本身无所谓好坏，它是一把双刃剑。当使用不当时，它会带来巨大的破坏力。当使用得当时，它也会带来极大的生产力；</p><h1 id="社会关系"><a href="#社会关系" class="headerlink" title="社会关系"></a>社会关系</h1><h2 id="9、偏见：不喜欢他人"><a href="#9、偏见：不喜欢他人" class="headerlink" title="9、偏见：不喜欢他人"></a>9、偏见：不喜欢他人</h2><h3 id="偏见的本质和作用是什么"><a href="#偏见的本质和作用是什么" class="headerlink" title="偏见的本质和作用是什么"></a>偏见的本质和作用是什么</h3><p>一些概念的区别：</p><ul><li>刻板印象：对某个群体的整体性简单概况，可能符合事实，也可能不符合，可能是正面评价，也可能是负面评价；</li><li>偏见：对某个群体或其个体成员存在负面的预判断，它是一种态度（不一定会付诸行动）；</li><li>歧视：它是一种负面行为，通常缘于偏见（即先有偏见，之后部分人会付诸行动，形成歧视）；</li></ul><p>由于偏见仅仅是一种态度，而人们的态度经常是动态变化的，因此偏见也很容易随着环境的变化而变化；即当外部环境普遍认为偏见和歧视是一种不良行为时，人们内心即使存有偏见，也会有意识的压制和隐藏；因此，当这种外部压力消失时，偏见就会不自觉的浮出水面；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307251949450.png"></p><blockquote><p>虽然态度容易转变，但当涉及非常亲密的行为时，偏见却依然存在，没有那么容易改变；例如印度的很多高种姓群体，愿意和低种姓的群体做朋友，却不愿意考虑和对方结婚；</p></blockquote><p>很多时候，我们持有的偏见是内隐和自动化的，有时候我们自己都不一定觉察得到。因此，当我们的自我觉知模块受到抑制时，我们的偏见就有可能带来歧视。</p><h3 id="偏见有哪些社会根源"><a href="#偏见有哪些社会根源" class="headerlink" title="偏见有哪些社会根源"></a>偏见有哪些社会根源</h3><h4 id="社会地位-1"><a href="#社会地位-1" class="headerlink" title="社会地位"></a>社会地位</h4><p>社会地位天然存在不平等，而偏见有助于既得利益者，将自己的利益和特权合理化；例如：奴隶主对奴隶的贬低，战争中对敌人的非人化；</p><p>由于行为决定态度，因此当某个群体在某方面的行为更加突出时，人们会自动赋予相应的特质，例如女性更善于照顾家庭（原因可能仅仅是因为很多女性花了很多时间在照顾家庭）；</p><h4 id="群体环境"><a href="#群体环境" class="headerlink" title="群体环境"></a>群体环境</h4><p>社会环境中存在诸多因素，会导致或维持人们的偏见，包括：</p><ul><li>权威主义倾向：个体越是认同权威的必要性，那么越容易抱有偏见；</li><li>社会支配倾向：个体越是追求出人头地，喜欢支配他人，则越容易抱有偏见；</li><li>融入群体倾向：个体越是想要融入某个群体，就越有可能接纳群体中存在的偏见，以便为群体所接纳；</li></ul><h4 id="社会制度"><a href="#社会制度" class="headerlink" title="社会制度"></a>社会制度</h4><p>某些社会制度出于历史原因，存在某些偏见，例如男女性在农业社会的分工。因此，该现象也为某些群体抱有的偏见提供了合理化的借口，助长了偏见的存在。</p><h3 id="偏见有哪些动机根源"><a href="#偏见有哪些动机根源" class="headerlink" title="偏见有哪些动机根源"></a>偏见有哪些动机根源</h3><h4 id="应对挫折"><a href="#应对挫折" class="headerlink" title="应对挫折"></a>应对挫折</h4><p>当人们遭遇挫折时，更倾向于寻找替罪羊。例如当经济萧条时，种族歧视更频发；当经济繁荣时，种族歧视相应变少；例如一战后德国的反犹太浪潮；特朗普时期的反拉美移民等；</p><blockquote><p>通常挫折更有可能来自于直接的竞争对手，因此偏见通常更常见于两个竞争性的群体之间；例如美国底层白人对黑人的歧视；</p></blockquote><h4 id="提升自尊"><a href="#提升自尊" class="headerlink" title="提升自尊"></a>提升自尊</h4><p>当人们的自我效能较低时，人们会倾向于将自己归类于某个特定的群体，获得自我优越感进行补偿；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307252122751.png"></p><blockquote><p>人天生有群体归属的需要，因此只要能够找到某种划分办法（可以是莫名其妙的，例如同一天生日），都将极大的促进人们之间建立更紧密的联系。</p></blockquote><p>当我们将自己归类于某个群体时，也意味着我们跟其他群体划分了界线。之后我们会不自觉的产生对自己所属群体的偏爱，以及对外部群体的疏远；</p><blockquote><p>当我们所属的群体规模越小，或者地位越低时，我们就会变得更加敏感，更容易形成内群体偏见（即认为自己所在的群体更好更优秀，类似自我服务偏见）；</p></blockquote><blockquote><p>群体归属（社会同一性）的需要，让我们愿意遵守群体的规范，以获得群体的接纳。我们甚至愿意为了团体、家庭和国家牺牲自我。</p></blockquote><blockquote><p>当面临死亡时，我们的群体归属感会得到最大程度的激发，例如我们会更多的追求公共情感，变得更加的利他主义；</p></blockquote><h4 id="避免偏见"><a href="#避免偏见" class="headerlink" title="避免偏见"></a>避免偏见</h4><p>当我们的同一性获得很好的满足后，我们贬低外部群体的需求会降低，从而对外部群体变得更加友好和宽容起来；</p><p>整体来说，偏见是一种生理性的条件反射，每个人都不可避免。重点是我们会如何应对。当我们的应对动机来源于内部时（我们认为偏见是不好的），相比于外部压力（别人会给我们负面的评价），我们能够更好的避免偏见；</p><blockquote><p>随着年龄的增长，我们的大脑机能会出现退化，因此老年人更难压抑偏见，从而在外部看来，老年人变得更加顽固了；</p></blockquote><h3 id="偏见有哪些认知根源"><a href="#偏见有哪些认知根源" class="headerlink" title="偏见有哪些认知根源"></a>偏见有哪些认知根源</h3><p>近些年的研究发现，偏见的产生跟大脑的认知工作原理有关。它是我们大脑认知加工时，为了简化世界需要，而产生的一个副产品；</p><h4 id="类别化"><a href="#类别化" class="headerlink" title="类别化"></a>类别化</h4><p>对外部世界的各种事物进行分类，是大脑认知工作的必要步骤。分类不可避免为刻板印象提供了生理基础，因为后者可以提高分类的效率；</p><p>刻板印象是认知启动的必然结果。只有当我们获得更多的信息时，我们才更有可能打破对某个群体的刻板印象；否则我们就会使用某个标签来替代该群体；</p><blockquote><p>因此，大部分人都会觉得外部群体的成员看起来都很相似，而自己所属群体的成员是非常多样化。其实这是因为信息不对称造成的；</p><p>我们的注意力资源是有限的，当我们接触某个外部群体成员时，我们宝贵的认知资源往往会放在对方那些更明显维度上面，例如种族差异，而非面部细节；</p></blockquote><h4 id="独特性-1"><a href="#独特性-1" class="headerlink" title="独特性"></a>独特性</h4><p>我们的大脑天生更善于发现环境中的独特之外（这也助于提高繁衍几率），因此当群体中出现某些特别的个体时，它会吸引我们注意力；我们的大脑会更多的记住其与众不同之处（例如是一位黑人），同时忽略其他细节。进而导致我们的大脑难以进行准确的判断（容易产生虚假相关）；</p><p>当我们觉察到自己是群体当中的独特一员时，会激发我们的防御情绪；我们对他人的行为会变得更加敏感，进而容易产生一些误解；</p><p>当某个事件比较罕见时，如果此时又恰逢当事者拥有独特的身份，两个独特的属性放在一起，同时刺激了我们的大脑，进而会导致我们的大脑产生虚假相关性。</p><blockquote><p>由于媒体天性是追求报道独特的事件，因此进一步助长了虚假相关性的产生；</p></blockquote><p>另外我们脑海中原本存在的刻板印象，也会导致我们将注意力放在不同的地方。简单来说，就是我们会倾向于为自己的刻板印象寻找相关的证据，并忽略其他不相关或相反的证据（即我们更愿意看到自己想看到的，而不是看到所有）；</p><h4 id="归因"><a href="#归因" class="headerlink" title="归因"></a>归因</h4><p>我们的注意力在哪里，我们就会在哪里寻找原因（很像那个关于路灯的寓言，只在被路灯点亮的区域寻找丢失的钥匙）；</p><p><strong>利群偏差</strong>：我们倾向从积极的角度解释内群体成员的行为，同时从消极的角度解读外群体成员的行为（很像自我服务偏差）；例如：</p><ul><li>自己团队做错了，我们会觉得他不是故意的，只是一时失误；其他团队做错了，我们会觉得对方比较笨；</li><li>自己团队做对了，我们会觉得这是团队优秀品质的体现；其他团队做对了，我们会觉得对方只是侥幸；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307252311945.png"></p><p><strong>公正世界现象</strong>：在我们大脑中，天生自带一个公正世界的假设，即默认这个世界是公正公平的。善有善报，恶有恶报，付出总会得到回报；因此，当发生了某个悲剧的事情后，我们的大脑会为该事件寻找一个符合公正世界假设的理由；比如受害者之所以遭遇悲剧，他们自身也负有责任，因此不值得同情；最典型的例子是强奸案件的女性受害者，事后人们反而经常会批评该女性行为或者衣着不检点，才导致了悲剧的发生；事实上，这种理解是十分荒谬的。因为从本质上来看，这个世界更像是随机的，很多因素是个体所不可控的，而不是我们所想象中的公正的世界；</p><h3 id="偏见的后果是什么"><a href="#偏见的后果是什么" class="headerlink" title="偏见的后果是什么"></a>偏见的后果是什么</h3><h4 id="永存的刻板印象"><a href="#永存的刻板印象" class="headerlink" title="永存的刻板印象"></a>永存的刻板印象</h4><p>先入为主，刻板印象一旦存在，便很难消除；即使有一天看到了反例，人们会也会将反例示为一种特例，调节外部事实来符合自己的认知，而不是改变自己的刻板印象本身；如果特例出现的比较多，我们甚至还会人为划分出一个子群体，将这种特例归纳进去，例如在运动员中，划分出老年运动员的群体。这样一来，我们就需要改变自己的旧认知了；</p><p>刻板印象会影响我们如何看待他人，因为它在无形中造成了我们注意力分配的不平衡，我们会因此变得对某方面更加敏感，将信号作不同的解读，进而实现某些自我预言；</p><blockquote><p>这里让我想到了医患矛盾。很多人有医生想要坑患者的刻板印象，进而导致他们在和医生的接触过程中，会对这方面的信号做过度解读，将医生一些原本正常的举动，误解为别有用心；</p></blockquote><h4 id="自我实现的预言"><a href="#自我实现的预言" class="headerlink" title="自我实现的预言"></a>自我实现的预言</h4><p>歧视会对受害者产生两大类影响：</p><ul><li>有些受害者会责怪自己：变得退缩，痛恨自己，甚至攻击自己的群体；</li><li>有些受害者会责怪外部：变得敏感多疑，容易反击，群体自豪感增加；</li></ul><p>当受害者因被歧视产生一些负面行为时，例如攻击他人，又会反过来为歧视者提供了歧视接口，导致预言的自我实现；</p><h4 id="刻板印象威胁"><a href="#刻板印象威胁" class="headerlink" title="刻板印象威胁"></a>刻板印象威胁</h4><p>当我们内心预期他人对我们存在负面的刻板印象时，会让我们产生焦虑，担心自己表现不好，证实或加剧他人的刻板印象。而过度的焦虑很容易会让我们的能力难以正常发挥，从而坐实了他人的刻板印象；</p><p>反过来，如果我们被告知正面的刻板印象时，我们会在相关的任务中，比没有刻板印象时，表现得更好；</p><blockquote><p>这一点有点像他人在场对我们的生理唤醒；</p></blockquote><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307301439433.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307301442893.png"></p><h4 id="个体判断"><a href="#个体判断" class="headerlink" title="个体判断"></a>个体判断</h4><p>虽然刻板印象会影响我们对他人的判断，但是在和他人交往的过程中，我们会接触大量生动的个人信息。这些生动琐碎的信息，会让我们忽略原本大脑中存在的宽泛刻板印象，变得具体情况具体分析；但这种变化需要时间，因为当事人需要时间收集足够多的信息。在第一时间，刻板印象仍然会强烈影响当事人对他人的认知；</p><p>当个体的表现与我们的刻板印象预期不符时，人们倾向于给个体更极端的评价；例如同样是批评他人插队，如果批评来自某个女性，我们会认为该女性比做出同样行为的男性更加强硬；</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>随着我们对偏见产生的根源研究得更加清楚，我们也更加能够对症下药，制定一些相应的措施，来减少和限制偏见。事实上，欧美最近几十年，在这方面还是取得不少的进步的。</p><h2 id="10、攻击：伤害他人"><a href="#10、攻击：伤害他人" class="headerlink" title="10、攻击：伤害他人"></a>10、攻击：伤害他人</h2><p>人类的行为可以是相当残忍的，甚至是冷漠和健忘的。大多数人都知道并记得美国的 911 事件，却不知道大约在相同时期发生的刚果种族大屠杀，后者造成了大约 350 万人死亡，是 911 事件遇害人数的 1000 倍左右；</p><h3 id="什么是攻击行为"><a href="#什么是攻击行为" class="headerlink" title="什么是攻击行为"></a>什么是攻击行为</h3><p>定义：以伤害他人为目的的行为，可以是身体上的生理伤害，也可以是精神伤害（例如通过语言）；</p><p>攻击行为分为两类：</p><ul><li>工具性攻击行为：将攻击做为实现某个目标的手段，例如恐怖袭击多数为工具性的攻击行为；</li><li>敌意性攻击行为：以伤害对方为目的，通常源于愤怒；</li></ul><h3 id="攻击行为的理论"><a href="#攻击行为的理论" class="headerlink" title="攻击行为的理论"></a>攻击行为的理论</h3><h4 id="生物学理论"><a href="#生物学理论" class="headerlink" title="生物学理论"></a>生物学理论</h4><p>人类携带着发起攻击行为的基因，同时也携带着抑制这种行为的基因。这两方面的基因都有助于我们更好的适应环境，增加繁衍的几率。我们并非天生的好战，更重要的或许是，我们会在什么情况下变得好战。</p><p>不同人的基因有所差异，由基因所构造的大脑是一部精密的机器，各个零部件需要准确配合，机器才能实现正常运转；当出于某种原因，机器内部出现不平衡的问题时，个体就会表现出异常的行为，例如攻击性增加；</p><p>攻击性仅仅是某种倾向，它更像是一个火药桶。火药并不会点燃自己，它还需要依赖于环境。当合适的环境出现时，导火索被点燃，导致最终火药桶的爆炸；</p><h4 id="挫折攻击理论"><a href="#挫折攻击理论" class="headerlink" title="挫折攻击理论"></a>挫折攻击理论</h4><p>挫折：实现目标的强烈动机 + 预期得到满意结果 + 最终却遭遇了失败；当人们遭遇挫折后，会进入愤怒的状态，为某种形式的攻击行为创造了基础；愤怒是否会转变成攻击，跟个体对挫折的解释有很大的关系；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308022254093.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308022256073.png"></p><p>挫折是否产生，其中一个非常重要的因素是人们对结果的预期，而不是结果本身；</p><blockquote><p>例如预期是获得100元，结果也是获得100元，那么人们没有挫折感；如果预期是获得1000元，结果却只获得200元，那么人们会产生强烈的挫折感；</p></blockquote><h4 id="社会学习理论"><a href="#社会学习理论" class="headerlink" title="社会学习理论"></a>社会学习理论</h4><p>除了基因内置外，攻击行为本身也是可以习得的，它有两种习得途径：</p><ul><li>亲身经历：当个体发现攻击行为能够为自己带来额外的回报时，个体就会将其变成一种习惯；</li><li>间接经历：当个体观察到他人的攻击行为能够得到额外的回报时，个体就会进行模仿；</li></ul><p>我们的成长环境（家庭和社会）会影响我们对攻击行为的结果预期；如果个体预期自身的攻击行为不会得到惩罚，就有更大概率会表现出攻击行为；</p><h3 id="攻击行为的诱发因素"><a href="#攻击行为的诱发因素" class="headerlink" title="攻击行为的诱发因素"></a>攻击行为的诱发因素</h3><h4 id="厌恶情绪"><a href="#厌恶情绪" class="headerlink" title="厌恶情绪"></a>厌恶情绪</h4><p>当个体正在经历某种令其感到厌恶的体验时，就可能会诱发个体的攻击行为，而且这种攻击行为通常并不区分目标，即会对旁边的任意事物发起攻击，包括攻击同类或者非生物物体（如网球）；</p><blockquote><p>厌恶事件可以是生理性的，例如疼痛、炎热、拥挤、被攻击等；也可以是心理上的，例如挫折；</p></blockquote><h4 id="生理唤醒"><a href="#生理唤醒" class="headerlink" title="生理唤醒"></a>生理唤醒</h4><p>当身体处于被唤醒的状态时，会强化我们的情绪，我们的行为会变得更加极端化一些；这也是为什么人们喝酒后，会变得更加情绪化；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308031957417.png"></p><h4 id="攻击线索"><a href="#攻击线索" class="headerlink" title="攻击线索"></a>攻击线索</h4><p>当人们进行攻击前的情绪状态时，环境中出现的线索，将会个体采取的行为发生影响；例如环境中出现攻击性武器（例如手枪），那么该线索将很可能诱发个体作出攻击行为（使用该武器）；</p><h4 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h4><p>人们观看媒体的目的多数是出于娱乐，因此越是能够带来生理唤醒的节目（例如色情或暴力），就越受人们的欢迎。但随着观看次数的变多，会降低人们的阈值，类似登门槛效应，人们对他人的痛苦变得冷漠和麻木，更加容易接纳暴力 。而且，由于媒体的生理唤醒作用，人们变得更加容易进入攻击状态；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308032029115.png"></p><p>为了吸引观众的注意力，影视作品需要对现实进行加工，增加戏剧冲突。这种加工不可避免会导致对现实的扭曲，而观众在观看节目时，无法感知这种扭曲，反而会让影视作品中的内容，等同于现实；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308032036013.png"></p><blockquote><p>除了影视作品外，暴力内容的电子游戏也会起到跟影视作品类似的效果；</p></blockquote><h4 id="群体影响"><a href="#群体影响" class="headerlink" title="群体影响"></a>群体影响</h4><p>由于处于群体中的个体会产生懈怠效应，即降低自身责任感（去个体化）。因此攻击行为一旦出现，很容易在群体中扩散开来，从而放大了攻击行为的范围；同时，由于群体提供了示范，个体会去除自我抑制，对他人行为进行效仿；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308060800114.png"></p><h3 id="如何减少攻击"><a href="#如何减少攻击" class="headerlink" title="如何减少攻击"></a>如何减少攻击</h3><p>长久以来，有一种理论模型将攻击视为内部累积的压力释放，认为通过宣泄有助于减少攻击行为。但事实以此相反，因为行为决定态度。人们越是通过攻击释放自己的情绪，反而更容易让攻击升级，或者让其变得合理化；</p><p>减少攻击有两种努力方向：</p><ul><li>奖励合作行为</li><li>惩罚攻击行为：作用有限，如果威慑不够强大，则效果不好，很容易引发反弹；</li></ul><blockquote><p>严厉的惩罚对工具性攻击行为效果较好，因为后者本来也是某种理性计算的结果；但对冲动性的敌意攻击效果有限；</p></blockquote><p>针对诱发攻击行业的因素，可以采取针对性的措施，包括：</p><ul><li>降低期望，减少厌恶情绪的发生；</li><li>减少攻击线索，例如严格管控枪支使用；</li><li>审查媒体：减少暴力节目，引导未成年人对节目的讨论和推理，了解媒体的局限性；</li></ul><h2 id="11、吸引和亲密：喜欢他人"><a href="#11、吸引和亲密：喜欢他人" class="headerlink" title="11、吸引和亲密：喜欢他人"></a>11、吸引和亲密：喜欢他人</h2><p>人是一种社会性的动物，所谓的社会性，意思是我们天生有依赖他人的需要，有归属的需要。因此，人际关系一直是人类生活的核心部分；当我们的归属需要无法被满足，即我们遭受社会的排斥时，我们大脑中被激活的区域，跟生理创伤激活的区域相同，这意味着被排斥对人类来说，是一种痛苦的体验。</p><h3 id="什么造就了友谊和吸引"><a href="#什么造就了友谊和吸引" class="headerlink" title="什么造就了友谊和吸引"></a>什么造就了友谊和吸引</h3><h4 id="易得性"><a href="#易得性" class="headerlink" title="易得性"></a>易得性</h4><ul><li><p>相互交往：住得近，经常见面的人，更有可能产生好感；</p></li><li><p>曝光效应：我们更容易喜欢自己熟悉的东西；从进化的角度来看，这也助于提高我们的生存概率，减少接触危险（广告商充分利用了这一弱点）；</p></li></ul><p>我们不仅存在自我服务倾向，而且也会存在自我中心主义，即偏好那些有我们有关的事物和人；</p><p>情绪和认知是由大脑中不同的区域负责的，情绪先于认知产生，很多时候，我们的认知并非一种对外在客观事物的认知，而是对自己主观情绪态度的解释。这或许也是为什么对陌生的事物容易产生刻板印象的原因。刻板印象作为一种认知，有时候只是对我们主观负面情绪寻找出来的解释；</p><h4 id="外表"><a href="#外表" class="headerlink" title="外表"></a>外表</h4><p>人们会被美丽的外表所吸引，之后产生刻板印象，即美的就是好的（大脑会不自觉的为自己的态度寻找理由）；</p><p>外表吸引力可以用来预测一个人的外向程度和社交技能；这里面或许包含自我实现的预言，自我感觉良好，以及预期他人会喜欢自己，让我们在社交场合更加自信和从容，从而变得更收获他人的喜欢。</p><p>但外表吸引力对提升复杂领域的能力有一定的负面作用，有两方面的原因：</p><ul><li>我们不好区别他人对自己的评价，是基于自己的能力，还是只是因为自己长得好看；</li><li>当我们能够依赖自己的外表实现目标时，我们深入发展自己复杂技能的意愿会降低；</li></ul><p>美丽外表本质上是一种信息的传递，是拥有健康身体和繁殖能力的信号；</p><p>当我们看到他人时，我们的大脑会在无意识的情况下，将对方和自己进行比较。当对方是一个高吸引力得分的人时，我们会降低自我评价，并降低对身边伴侣的评价；</p><blockquote><p>虽然我们无法轻易改变自己的外貌，以提升自身的吸引力，但好消息是，我们可以利用易得性法则，来弥补这方面的缺憾；</p></blockquote><h4 id="相似性"><a href="#相似性" class="headerlink" title="相似性"></a>相似性</h4><p>物以类聚，人以群分。我们更容易喜欢上那些与我们相似性更高的人，即相似产生喜欢；</p><p>我们天生拥有一致性错觉，即我们总是倾向于认为他人会拥有跟我们一样的偏好。因此，当我们发现他人的偏好与我们不同时，我们对对方的好感会降低；尊重和欣赏他人与我们的差异性，对大多数人来说，是一个巨大的挑战。因为它是反直觉的。</p><blockquote><p>这种一致性的错觉，有助于维持友谊，因为它能够帮助人们维持彼此臭味相投的感觉。</p></blockquote><h4 id="被喜欢"><a href="#被喜欢" class="headerlink" title="被喜欢"></a>被喜欢</h4><p>我们更容易喜欢上那些喜欢我们的人，当然，前提是对方的赞美是基于事实的，而且我们不觉得对方是出于功利性的目的。</p><blockquote><p>我们不一定会因为他人的奉承喜欢对方，但我们很容易因为他人的批评讨厌对方，即我们对他人的批评是非常敏感的。负面信息比正面信息更能吸引我们的注意力，例如死亡比新生更能引发我们对生命意义的探寻；这是一种天生的损失厌恶倾向，因为关注风险有助于提高繁衍几率；</p></blockquote><p>如果对方一开始给出消极评价，之后变成积极评价，那么我们会更喜欢对方，因为我们会觉得对方的第二次评价更加真实，同时也因为我们此时存在渴望得到外部承认的需求（这是 PUA 的心理学基础）；</p><blockquote><p>自尊低的人，经常对关系持悲观的态度，这有可能导致自我预言；因为低自尊容易低估伴侣对自己的欣赏程度，同时给对方的积极性评价也会较少，导致双方对关系的满意度较低。</p></blockquote><h4 id="回报"><a href="#回报" class="headerlink" title="回报"></a>回报</h4><p>表面上看我们好像是因为对方的优秀特质喜欢上对方，但更本质上的原因，是因为对方的存在，让我们的自我感觉更加美好了，我们变得更加愉悦了，因此导致我们喜欢上了对方；</p><blockquote><p>我们会喜欢那些给我们带来的回报，大于我们付出的成本的人；不管这种回报是经济层面，还是精神层面都可以（例如对方对我们的观点表示赞同，就会增加我们的精神愉悦，从而让我们更喜欢对方）；</p></blockquote><h3 id="什么是爱情"><a href="#什么是爱情" class="headerlink" title="什么是爱情"></a>什么是爱情</h3><h4 id="激情之爱"><a href="#激情之爱" class="headerlink" title="激情之爱"></a>激情之爱</h4><p>定义：强烈渴望和对方在一起的一种状态；它是一种生理唤醒；</p><blockquote><p>当某个外部因素给我们带来生理唤醒后，我们的大脑会将这种唤醒和另外一方联系在一起，对方会给我们留下更深的印象。例如站在危险的高处，会让我们更容易喜欢上对方；或者一起参加户外运动的伴侣，也会对彼此的关系更加满意；</p></blockquote><blockquote><p>考虑到男性在生理上更容易被唤醒的特点，事实上男性比女性更容易进入激情之爱的状态；</p></blockquote><blockquote><p>突然发现一个有意思的点，激情的消退，或者也有助于伴侣将注意力转移到抚养下一代身上。持续的相互迷恋，或许并不那么有利于专心的养育后代；</p></blockquote><h4 id="伴侣之爱"><a href="#伴侣之爱" class="headerlink" title="伴侣之爱"></a>伴侣之爱</h4><p>定义：一种在情感上深沉的相互依恋的状态；</p><p>激情终将消退，部分幸运的伴侣会进入相互依恋的伴侣之爱的状态；</p><h3 id="哪些因素促进了亲密关系"><a href="#哪些因素促进了亲密关系" class="headerlink" title="哪些因素促进了亲密关系"></a>哪些因素促进了亲密关系</h3><h4 id="依恋"><a href="#依恋" class="headerlink" title="依恋"></a>依恋</h4><p>作为群居性的动物，对他人的依恋，是一种刻在我们基因中的本能和需要；这种需要，从婴儿出生时就强烈的表现出来了，随着时间的推移，在不同的年龄阶段，它会表现出不同的形态；</p><p>我们有依恋别人的需要，反过来，他人对我们的依恋，也会提高我们的幸福感；这种父母和婴儿的双向奔赴，能够极大的提高基因的繁衍成功率；</p><p>依恋有多种类型，例如亲子之间、朋友之间、情侣之间，不管哪种类型的依恋，都有一种共同的元素，即相互理解和支持，重视并享受和对方在一起；</p><p>在孩童时期，我们与父母之间形成某种模式的依恋类型，并在成年后保持相对稳定的状态。</p><h4 id="公平"><a href="#公平" class="headerlink" title="公平"></a>公平</h4><p>真正的友谊：在几乎不可能得到回报的情况下，我们也会去帮助对方；</p><p>追求公平是镌刻在我们基因中的天性。当我们知觉到自己处于一段不公平的关系时，会让双方的关系陷入紧张的状态。如果处理不当，会造成恶性循环，降低双方的关系满意度，甚至最终可能会走向分手；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308072203021.png"></p><h4 id="自我表露"><a href="#自我表露" class="headerlink" title="自我表露"></a>自我表露</h4><p>我们只有确诊足够安全的情况下，我们才会进行自我表露。足够安全往往意味着我们确定自己会得到对方的理解。因此，当我们完成自我表露并取得对方的理解后，我们会有一种获得他人接纳的感觉和体验。这种体验契合我们基因对归属感的需要，因此它会让我们感觉幸福和满足。</p><p>反过来，被表露的人会感受到对方对自己的信任感，这也会满足基因的归属需求。并促进我们也会对方表露自己，从而进入一种良性循环；</p><blockquote><p>《再见爱人》最后的36问环节，正是一种逐渐升级的自我表露过程。这个过程对提升双方的亲密感非常有帮助，它甚至会让两个陌生人爱上彼此。</p></blockquote><h3 id="亲密关系是如何结束的"><a href="#亲密关系是如何结束的" class="headerlink" title="亲密关系是如何结束的"></a>亲密关系是如何结束的</h3><p>离婚是一个事件，但分离是一个过程；</p><p>应对令人痛苦的婚姻关系的几种选择：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308072340341.png"></p><p>行为影响态度，因此幸福的婚姻关系实际上是可以通过有意的练习来获得的。当双方模拟幸福夫妻的方式进行沟通和交往时，就会在无形中改变对待彼此的态度，进而改善婚姻关系（简单来说，就是爱情是可以通过共同的刻意经营来获得的）；</p><blockquote><p>仅仅是通过模拟热恋情侣一样，注视陌生异性的眼睛，也会激发好感甚至爱情；</p></blockquote><p>婚姻关系有点像是在逆水行舟，如果无所作为，那么随着时间流逝，关系也会随之变得冷淡。但如果双方不断付出努力，那么这艘小船就会走得非常远。它是需要终生保持投入的一个过程；</p><h2 id="12、利他：帮助他人"><a href="#12、利他：帮助他人" class="headerlink" title="12、利他：帮助他人"></a>12、利他：帮助他人</h2><h3 id="我们为什么会有帮助行为"><a href="#我们为什么会有帮助行为" class="headerlink" title="我们为什么会有帮助行为"></a>我们为什么会有帮助行为</h3><h4 id="交换理论"><a href="#交换理论" class="headerlink" title="交换理论"></a>交换理论</h4><p>帮助他人很多时候可以让双方都获得好处，受助者可能获得物质收益，施助者可能获得非物质收益，例如社会地位、愉悦感、爱等；帮助他人的收益可以是外部的（例如他人的赞许），也可以是内部的（例如自我价值感）；</p><h5 id="外部回报"><a href="#外部回报" class="headerlink" title="外部回报"></a>外部回报</h5><p>社会或他人对帮助行为的赞许，会引发帮助行为的发生。例如我们会积极帮助那些我们渴望得到对方赞许的人（例如企业想要获得良好的公众形象；个体想要获得对自己有吸引力人的好感等）；</p><h5 id="内部回报"><a href="#内部回报" class="headerlink" title="内部回报"></a>内部回报</h5><p>我们天生具有共情的能力，因此获知他人的痛苦后，也会引发我们的痛苦。通过帮助别人，可以减轻痛苦的感觉（因对他人痛苦无动于衷而产生的内疚感）；</p><p>内疚感可以来源于对他人痛苦的冷漠，也可以来源其他方面，例如说谎或者给他人带来麻烦。</p><blockquote><p>当我们感到内疚时，自我效能是降低的，我们会产生提升自我效能的需要，因此此时的我们更愿意帮助他人，以修复降低的自我效能；</p></blockquote><p>助人为乐并非天生的，它是一种社会化的过程，是个体在社会化的过程中习得的；</p><blockquote><p>小孩一开始并不会从帮助他人的过程中收获快乐，因为人性是自私的；但随着年龄增长，当他们逐渐变成成年人后，他们会从帮助他人的过程中，收获自我满足的愉悦感；</p><p>行为决定态度，当我们做过一些好事后，后续很可能会做更多的好事；</p></blockquote><p>当我们心情愉悦时，我们有更大的概率去帮助别人；当我们快乐时，我们是戴着有色眼镜看待世界的，各种外部事物被我们无意识的渡上了美好的光圈。原本有些我们不会做的中性甚至反感的行为，现在看起来都觉得是可以接受的；</p><blockquote><p>或如古人所云，仓禀实而知礼节。即个体越是放松快乐，越少焦虑痛苦，则与人为善的几率越大；</p></blockquote><h4 id="社会规范理论"><a href="#社会规范理论" class="headerlink" title="社会规范理论"></a>社会规范理论</h4><blockquote><p>社会规范这个词有点抽象，或许用“社会期望”更容易理解，它涉及他人对我们一些适宜行为和应尽义务的期待；</p></blockquote><h5 id="互惠规范"><a href="#互惠规范" class="headerlink" title="互惠规范"></a>互惠规范</h5><p>最常见的一种社会规范是“互惠规范”，即回报那些曾经帮助过我们的人；</p><blockquote><p>互惠规范其实跟平时常被提到一个词有关系，即“关系资源”；所谓的关系资源，就是处于某种互惠状态中，包括相互支持、交流信息、互相信任与合作；</p></blockquote><p>当我们接受了他人的帮助，却不知道自己如何给他人回馈时，我们会感受到自我效能的降低；因此，很多人不愿意主动寻求帮助；</p><blockquote><p>这里貌似会陷入一个死结，即为他人主动提供帮助，有可能会打击对方的自尊心；反过来，为避免自尊心降低，很多人不愿意向他人救助；要如何才能破解呢？或许有一个办法，将帮助行为先用求助行为包装起来；</p></blockquote><h5 id="社会责任规范"><a href="#社会责任规范" class="headerlink" title="社会责任规范"></a>社会责任规范</h5><p>除了互惠外，我们有时也会不考虑回报，去帮助那些陷入困境需要帮助的人；这里有个关键点，即我们如何对困境的归因。当困境的发生是由于外部不可控的因素（例如天灾）造成的，而不是内部原因造成的（例如懒惰），才会引发我们的帮助行为；</p><h5 id="性别与助人规范"><a href="#性别与助人规范" class="headerlink" title="性别与助人规范"></a>性别与助人规范</h5><p>当对方让我们感知到柔弱无助时（例如老人、女性和小孩），我们提供帮助的可能性会更大；</p><blockquote><p>好奇这到底是因为社会规范要求我们帮助弱者，还是我们基因自带帮助弱者的属性？</p></blockquote><h4 id="进化理论"><a href="#进化理论" class="headerlink" title="进化理论"></a>进化理论</h4><p>完全的无私和完全的自私都不是繁衍基因的最佳策略，有条件的自私才是；</p><h5 id="亲缘选择"><a href="#亲缘选择" class="headerlink" title="亲缘选择"></a>亲缘选择</h5><p>关心与我们有血缘关系的人（例如自己的子女），显然非常有助于提高基因繁衍的几率；尤其是将孩子的利益看得比自身利益更重时，但反过来却并非如此，即子女并不会将父母的利益放在自我利益之上，因为那样并不利于繁衍；</p><blockquote><p>在我们决定是否帮助他人时，我们的大脑并不会进行基因方面的计算，它完全是基于直觉反应来进行的。这种直觉反应甚至可以体现在陌生人与自己的相似性。假设对方跟我们的相似点越多或者住得越近，我们喜欢和帮助对方的概率就会越大；</p></blockquote><h5 id="互惠"><a href="#互惠" class="headerlink" title="互惠"></a>互惠</h5><p>当我们预期能够得到回报时（即互惠时），我们有更大的概率帮助别人。</p><blockquote><p>这也解释了为什么相对大城市，在小村落里面，人们会产生更多的互助行为。因为村子里面都是住着一群相互熟悉的人，而不像城市里面是一大堆陌生人；</p></blockquote><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>大部分帮助行为都跟满足自身利益有关（ 不管是外部回报，还是内部回报），但也有少数情况下，会存在无视自身利益的纯粹利他行为。原因或许并不复杂，即我们的大脑并不擅长精确的计算，而是基于情绪进行快速的行动；</p><h3 id="我们何时会帮助"><a href="#我们何时会帮助" class="headerlink" title="我们何时会帮助"></a>我们何时会帮助</h3><h4 id="旁观者数量"><a href="#旁观者数量" class="headerlink" title="旁观者数量"></a>旁观者数量</h4><p>旁观者的数量越多，受害人获得帮助的概率反而越小,，即所谓的旁观者效应；产生该效应的原因包括：</p><ul><li>懈怠效应：个体觉得自己的责任被分摊了，会有他人出手的；</li><li>人众无知：由于旁观者的存在，如果情况不是非常明朗，我们通常不会马上出手，而会先观察一下别人的反应，以便能够了解更多的情况；但大家都这么做时，导致没有人立即行动，结果就会产生人众无知现象，我们会误以为事情并没有那么的紧急或危险；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308131533056.png"></p><h4 id="示范效应"><a href="#示范效应" class="headerlink" title="示范效应"></a>示范效应</h4><p>榜样的力量是强大的，负面的榜样会引发负面的行为，正面的榜样会同样会引发正面的行为。如果我们观察到助人的榜样，就有更大的概率会帮助他人；</p><h4 id="时间压力"><a href="#时间压力" class="headerlink" title="时间压力"></a>时间压力</h4><p>大脑的注意力是有限的，当我们处于时间压力的场景中时，会降低我们帮助他人的几率。</p><h4 id="相似性-1"><a href="#相似性-1" class="headerlink" title="相似性"></a>相似性</h4><p>相似导致喜欢，喜欢引发帮助；</p><blockquote><p>偏爱是我们基因天性的一部分，但是社会规范有时候能够抑制我们的偏爱行为。为了符合社会规范，我们会有意识的隐藏自己的偏爱倾向；</p></blockquote><h3 id="谁会提供帮助"><a href="#谁会提供帮助" class="headerlink" title="谁会提供帮助"></a>谁会提供帮助</h3><h4 id="人格特征"><a href="#人格特征" class="headerlink" title="人格特征"></a>人格特征</h4><p>跟从众行为一般，就单独某个情境而言，人格特征并不能很好的预测个体是否会帮助他人；但是如果将次数增多，那么可以得到帮助他人的平均值，此时人格特征的作用才会显现出来；这些特征包括：更多的积极情绪（乐观）和共情能力、更高的自我效能（自信）等；</p><h4 id="宗教信仰"><a href="#宗教信仰" class="headerlink" title="宗教信仰"></a>宗教信仰</h4><p>与人格特征类似，对于某个具体的情境，宗教信仰的行为预测性不高；但是在自愿提供长期帮助的情境中（例如做志愿者或者捐赠），宗教信仰有比较显著的相关性；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308131645446.png"></p><blockquote><p>事实上，宗教信仰不仅与长期的利他行为相关，还与是否积极参与团体各种团体活动相关（例如社区服务、邻里关系、投票、陪审团工作等）；</p></blockquote><h3 id="如何增加帮助行为"><a href="#如何增加帮助行为" class="headerlink" title="如何增加帮助行为"></a>如何增加帮助行为</h3><h4 id="去除对帮助的抑制"><a href="#去除对帮助的抑制" class="headerlink" title="去除对帮助的抑制"></a>去除对帮助的抑制</h4><h5 id="减少模糊性，提高责任感"><a href="#减少模糊性，提高责任感" class="headerlink" title="减少模糊性，提高责任感"></a>减少模糊性，提高责任感</h5><p>任何能够唤醒自我意识（通过突出个人特征）和社会责任的行为，都有助于提高个体的利他行为几率；</p><h5 id="内疚感和自我形象"><a href="#内疚感和自我形象" class="headerlink" title="内疚感和自我形象"></a>内疚感和自我形象</h5><p>内疚感例子：先要求帮个大忙，再要求帮个小忙；</p><p>自我形象例子：要求帮个忙，但将标准降得非常低，例如只要求捐赠1分钱也可以；这样对方会不好意思拒绝，不然会显得非常小气；</p><h4 id="利他主义的社会化"><a href="#利他主义的社会化" class="headerlink" title="利他主义的社会化"></a>利他主义的社会化</h4><h5 id="宣传教育"><a href="#宣传教育" class="headerlink" title="宣传教育"></a>宣传教育</h5><p>人的天性是自私的，我们的爱通常只局限于亲缘和互惠群体。但可以通过宣传教育，将利他边界扩展到整个社会、国家和人类。</p><blockquote><p>例子：56个民族一家亲、炎黄子孙、中华民族大家庭等等；</p></blockquote><h5 id="树立榜样"><a href="#树立榜样" class="headerlink" title="树立榜样"></a>树立榜样</h5><p>让人们看到社会规范的榜样，能够有效提高人们产生利他行为的几率；</p><blockquote><p>例子：介绍感人事迹的电视节目</p></blockquote><h5 id="动机归因"><a href="#动机归因" class="headerlink" title="动机归因"></a>动机归因</h5><p>帮助利他者将利他行为归因于其内在因素，而不是外在因素时，个体会将自己的行为动机进行内化，从而提高有助于后续帮助他人的概率；</p><p>行为决定态度，当我们做了某种利他行为后，我们会将自己视为乐于助人，我们会改变对自我的态度认知。之后再发生类似的情境时，这种自我认知会提高我们帮助他人的概率；</p><h2 id="13、冲突与和解"><a href="#13、冲突与和解" class="headerlink" title="13、冲突与和解"></a>13、冲突与和解</h2><h3 id="什么会引起冲突"><a href="#什么会引起冲突" class="headerlink" title="什么会引起冲突"></a>什么会引起冲突</h3><h4 id="社会困境"><a href="#社会困境" class="headerlink" title="社会困境"></a>社会困境</h4><p>个体利益的最大化，有时是好事（例如市场之手提高资源利用率），有时则是坏事，例如下面两种常见的社会困境：</p><ul><li>囚徒困境</li><li>公地悲剧</li></ul><p>解决方案：</p><ul><li>建立管制：对资源的如何使用制定规则；</li><li>缩小规模：在小团队中，个体的责任感会提高；而在大团体中，会出现懈怠现象，责任被分散化；</li><li>增加沟通：面对面的交流有助于唤醒责任意识，建立信任，消除信息不对称，找出最佳方案；</li><li>设计激励：增加有益行为的收益，降低不良行为的收益，例如美国的 carpool 车道；</li><li>倡导规范：将有益行为变成某种新的社会规范，或者与现有的社会规范建立联系；</li></ul><h4 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h4><p>当人们意识到资源是有限的（例如工作岗位、社会地位等），且竞争是零和博弈时，人们与其竞争对手之间很容易产生敌意和冲突；</p><h4 id="不公正"><a href="#不公正" class="headerlink" title="不公正"></a>不公正</h4><p>人类的基因中天生内置了一个公正世界的假设，即付出和回报应该是对等的；当某种现象违背该假设，人们会感到愤怒；</p><blockquote><p>公正世界假设：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308131854082.png"></p></blockquote><p>当我们获得超过自己应得的收益后，我们会产生内疚感。为了消除这种内疚感，我们可能会有两种反应：</p><ul><li>补偿对方：让双方的收益差距拉平；</li><li>贬低对方：让自己的额外收益变得合理；</li></ul><p>当我们获得少于自己应得的收益后，我们会产生愤怒感。为了消除这种愤怒感，我们可能会有如下反应：</p><ul><li>贬低自己：让自己的收益变得合理：</li><li>寻求补偿：让自己的收益和对方拉平；</li><li>报复对方：让对方在其他方面付出代价；</li></ul><h4 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h4><p>很多冲突并非双方的目标差异过大，而是源自对另一方目标或动机的误解，而误解导致夸大了彼此间的差异；其实存在误解并不可怕，可怕的是误解会导致自我证实，最后陷入恶性循环，造成冲突升级；</p><blockquote><p>基因中的自我服务偏见是根深蒂固的，因此绝大部分个体是很难自觉的尝试站在对方的角度去思考的；尤其是我们处于紧张状态时，大脑处于被唤醒的状态，只能做出简单化的直觉反应，难以进行理知和复杂的思考；</p></blockquote><p>有趣的是，个体的观念容易走向极端化的同时，还很容易实现大转变，即随着冲突的消失，我们会立即换一种态度看待另一方。例如美国将战时的日本人视为邪恶的，战后重建时视为勤劳聪明的；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308152243569.png"></p><h3 id="怎样获得和平"><a href="#怎样获得和平" class="headerlink" title="怎样获得和平"></a>怎样获得和平</h3><h4 id="接触"><a href="#接触" class="headerlink" title="接触"></a>接触</h4><p>接触并不一定会必然减少冲突，但是由于接触为相互了解和喜欢创造了条件，因此它有几率减少冲突；当然，建立友谊的前提是平等的地位，如果地位不平等，则接触不但无法减少冲突，反而会让双方固化各自的刻板印象；</p><h4 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h4><p>如果双方已产生敌意，那么简单的接触并不一定能够减少冲突，反而有一定的可能会让冲突加剧；如果能够创造机会，让双方进行合作，那么就有可能化解敌意；</p><p>促进合作的方法：</p><ul><li>共同的外部威胁有助于增加内部团结</li><li>设立共同的超级目标，并完成目标（如果目标失败，则反而可能会加剧冲突，因为可能出现彼此责怪）；</li></ul><blockquote><p>作为群居性动物，我们的群体意识是非常强烈和深刻的。即使一开始只是随机对人群进行分组，也会造成成员对各自所属的群体产生偏好；</p><p>有意思的是，与我们越相像的另一个群体，越有可能引发我们的强烈情绪，例如足球的同城德比；猜测有可能是因为越是相近，彼此能够感受到的竞争关系越是明显；</p></blockquote><h4 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h4><p>沟通的三种方式：</p><ul><li>直接谈判：如果双方都不走极端，能够为对方留下余地，那么有很大概率可以谈判成功，实现双赢；</li><li>调解：由双方共同信任的调解人，将非赢即输的思维定势转变成双赢；</li><li>仲裁：有些问题不一定能够调解成功，此时需要引入仲裁来解决冲突；</li></ul><blockquote><p>很多时候我们并没有被教授如何通过沟通来解决冲突的技巧，导致我们的生活经常陷于各种冲突之中，浪费了不必要的宝贵时间；</p></blockquote><h4 id="和解"><a href="#和解" class="headerlink" title="和解"></a>和解</h4><p>冲突的升级经常是死亡上升螺旋，但通过设计一个 GRIT 框架，能够逆转螺旋方向，让冲突强度螺旋降低；</p><blockquote><p>GRIT：逐步、互惠、主动的减少紧张；步骤如下：</p><ul><li>A 方先表达调和的愿望，并承诺会做出一些微小的让步，证明自己的诚意，并邀B方自由的选择一项回报；</li><li>B 方之后也要先表达一下调和的愿望，然后给出自己的回报；</li><li>A 方落实自己先前承诺的让步；</li><li>B 方之后也落实自己先前承诺的让步；</li><li>循环</li></ul></blockquote><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="14、临床领域的应用"><a href="#14、临床领域的应用" class="headerlink" title="14、临床领域的应用"></a>14、临床领域的应用</h2><h3 id="什么导致了临床诊断的偏差"><a href="#什么导致了临床诊断的偏差" class="headerlink" title="什么导致了临床诊断的偏差"></a>什么导致了临床诊断的偏差</h3><h4 id="相关错觉"><a href="#相关错觉" class="headerlink" title="相关错觉"></a>相关错觉</h4><p>我们总是看见自己想看见的，同时忽视自己不想看见的；当我们在心中预设了结论，那么我们总能从外部找到自己想要的一些线索。</p><blockquote><p>所以思维不开放的个体，几乎是不可能被说服的，尤其是个体为自己的想法找到了某种错误的理论基础的情况下（即“信念固着“现象）；</p></blockquote><h4 id="事后诸葛亮"><a href="#事后诸葛亮" class="headerlink" title="事后诸葛亮"></a>事后诸葛亮</h4><p>我们的大脑非常擅长于对各种现象进行解释和关联；当我们不知道最终答案时，我们一般很难理出头绪；但如果我们知道了答案，我们会觉得到处都是头绪；</p><h4 id="自我证实"><a href="#自我证实" class="headerlink" title="自我证实"></a>自我证实</h4><p>当我们预设了倾向后，会影响我们提问和寻找答案的方式，这反过来会造成自我证实。</p><h4 id="临床预测与统计预测"><a href="#临床预测与统计预测" class="headerlink" title="临床预测与统计预测"></a>临床预测与统计预测</h4><p>临床预测的准确性远远不如统计预测，但是人们却乐此不疲，背后的原因在于人们对自己的认知能力存在过度自信；</p><h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><p>我们的大脑在某些方面是很高效的，但这是一把双刃剑，这同时会我们在某些方面很容易出现错误。我们需要时刻警惕自身大脑的局限性，避免过度自信；</p><h3 id="伴随行为问题的认知过程是什么"><a href="#伴随行为问题的认知过程是什么" class="headerlink" title="伴随行为问题的认知过程是什么"></a>伴随行为问题的认知过程是什么</h3><h4 id="抑郁"><a href="#抑郁" class="headerlink" title="抑郁"></a>抑郁</h4><p>消极思维倾向（即消极的自我归因）既是导致抑郁的原因，也是产生抑郁的结果；经常性的自我责备，降低了自我效能。随着时间的积累，最终有可能会造成习得性无助；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308172256746.png"></p><blockquote><p>有没有可能，思维风格只是一个表象。大脑中与制造积极情绪相关的神经递质分泌不足，或许才是背后的根本原因?</p></blockquote><h4 id="孤独"><a href="#孤独" class="headerlink" title="孤独"></a>孤独</h4><p>孤独的定义：感觉自己被群体排斥、不被他人喜欢、无法和他人分享自己的感受、无法融入身边的环境；</p><blockquote><p>男性：被群体排斥时产生孤独；</p><p>女性：被剥夺一段亲密关系时产生孤独；</p></blockquote><p>幸福感不会自动从天而降，需要个体付出一定的行动，和他人建立亲密关系。但孤独者消极的自我归因（认为自己不够好），以及容易对他人形成消极负面的看法，提高了和他人建立亲密关系的难度；</p><h4 id="焦虑"><a href="#焦虑" class="headerlink" title="焦虑"></a>焦虑</h4><p>个体天生有自我展示的需要（即向别人展示自己良好形象的一面），当个体想要给他人留下好印象，但却担心自己可能会表现不好时，就会产生焦虑；</p><p>害羞：焦虑的一种，即过度敏感（高估他人对自己的关注程度）和担心他人的看法；</p><h4 id="疾病"><a href="#疾病" class="headerlink" title="疾病"></a>疾病</h4><p>情绪会影响我们对身体症状的察觉和解释；当我们情绪不佳时，我们有更大的概率感知到身体的信号，并将其解释为某种疾病的预兆；另外，当我们在大脑中预设自己疑似患上某种疾病时，我们会将一些原本无关的症状，与疾病关联起来；</p><blockquote><p>相比男性，女性更关注身体的症状，更愿意承认自己的脆弱，并寻求外界的帮助；</p></blockquote><p>外部压力会引起身体的应激反应，分泌压力激素，唤醒身体进入焦虑状态，以便能够更好的应对压力。但这是有代价的，如果长期处于应激状态，会给其他器官带来副作用，产生病变；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308201053324.png"></p><p>归因风格也会影响疾病，相对悲观者，乐观者通常更少的患病以及更快的从治疗中恢复；</p><h3 id="社会心理治疗的方法有哪些"><a href="#社会心理治疗的方法有哪些" class="headerlink" title="社会心理治疗的方法有哪些"></a>社会心理治疗的方法有哪些</h3><h4 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h4><p>行为疗法：利用行为决定态度的原理和登门槛效应，治疗师通过设计一系列的行为练习，让个体自愿选择，并付出努力完成练习，最终引导个体改变认知；</p><h4 id="打破循环"><a href="#打破循环" class="headerlink" title="打破循环"></a>打破循环</h4><ul><li>社会技能训练：在个体不知情的情况下，给个体刻意安排一些能够带来正反馈的练习。之后个体会觉得是由于个人的努力获得了成功，从而开始建立起自信心，打破恶性循环；</li><li>归因训练：每日记录一些成功和失败的事件，从成功的事件中寻找自己的影响因素，从失败的事情中寻找外在的影响因素；</li></ul><h4 id="内在归因"><a href="#内在归因" class="headerlink" title="内在归因"></a>内在归因</h4><p>让个体将进步归因于自身因素，而不是外部计划，效果才能够持久；否则当环境因素消失时，个体容易故态复萌；</p><h4 id="引导思考"><a href="#引导思考" class="headerlink" title="引导思考"></a>引导思考</h4><p>中心路径的说服才是持久有效的，因此更好的方式是通过提供必要的信息，以及设计良好的问题，引导个体通过自我思考找到答案；</p><blockquote><p>人们更加坚信由自己发现的原理，而不是别人发现的；</p></blockquote><h3 id="社会关系如何促进健康与幸福感"><a href="#社会关系如何促进健康与幸福感" class="headerlink" title="社会关系如何促进健康与幸福感"></a>社会关系如何促进健康与幸福感</h3><h4 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h4><p>人生遭遇逆境和困难是不可避免的，拥有支持性的人际关系，可以让我们知道无论发生什么，自己仍然被爱、被接纳、被尊重，因此能够很好的缓解我们的压力；</p><blockquote><p>即使没有听众，仅仅是将我们心中的各种想法和情绪写下来，也能够非常有效的减轻我们的心理压力和痛苦；</p></blockquote><p>除了社会关系、认知归因外，贫困与不平等也是影响我们身体健康的重要因素；</p><h4 id="幸福感"><a href="#幸福感" class="headerlink" title="幸福感"></a>幸福感</h4><p>亲密关系（友谊和爱人）会极大的影响一个人的生活幸福感；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308222014590.png"></p><p>提升幸福感的方法：</p><ul><li>避免过度追求财富：缺少必要的经济基础，就像缺少健康一样，是让人痛苦的。但反过来，拥有足够的财富，就像拥有健康一样，并不保证幸福；</li><li>控制时间：将大目标拆分成小目标，每天完成一些小目标；生命是由时间组成的，控制了时间，就控制了生命，它会让我们有踏实的感觉；我们常常高估自己每天可以完成的工作量，却又低估了每年可以完成的工作量；</li><li>经常微笑：行为会影响态度，即使我们心情不好，但通过做出微笑的动作，也会转变我们的情绪；</li><li>心流体验：寻找一个能够挑战自我，但同时不容易失败的爱好或工作，这样比较容易进入心流体验，例如园艺、手工等；</li><li>参加运动：生命在于运动，运动通过刺激激素分泌，既能够让我们更加健康，也能够让我们更加快乐；</li><li>充足睡眠：生命在于运动的同时，生命也在于睡眠，后者能够让我们恢复和保持最佳的状态；</li><li>亲密关系：与那些关心自己的人，培育高质量的亲密关系；</li><li>帮助他人：给予比接受会给我们带来更多的快乐；</li><li>感恩日记：提醒自己所拥有的，积极思考能够让我们体验更多的幸福；</li><li>联结伟大：将自己与一个更宏伟的目标进行连接，可以是宗教信仰，也可以是某种崇高的信念；</li></ul><h2 id="15、司法领域的应用"><a href="#15、司法领域的应用" class="headerlink" title="15、司法领域的应用"></a>15、司法领域的应用</h2><h3 id="目击者的证词可靠吗"><a href="#目击者的证词可靠吗" class="headerlink" title="目击者的证词可靠吗"></a>目击者的证词可靠吗</h3><p>只有条件适合时（例如罪犯有某个显著的特征时，目击者的证词才具备中等程度的相关。我们的大脑和眼睛并不是一台录像机，为了高效运转，通常我们只读取部分环境信息（最显著和突出的那部分），然后大脑会自行脑补剩下的部分；这也是为什么我们通常更多是看到自己想要看到的，而不是客观的还原现实；更通俗的说法，即我们所看到的东西，是我们自己构建出来的。</p><p>误导信息效应：当我们在接收外界信息时，这些信息会作为材料，成为我们大脑加工信息的组成部分，因此，最终的加工结果是被污染过的；我们甚至会虚构实际并没有发生的经历；</p><blockquote><p>谎言重复了一千遍，就变成真理了；</p></blockquote><p>当我们一开始自己没有把握的错误观念被某个外界反馈肯定后，我们会极大的增加对这个错误观念的信心，即外界反馈会深深的影响我们，但我们却往往意识不到这种影响。</p><blockquote><p>猜测这也是为什么会发生信念固着的原因；</p></blockquote><p>减少错误的办法：</p><ul><li>训练警察：<ul><li>先用充足的时间引导目击者慢慢回忆和重建场景，然后再用启发性的问题发现更多的细节；</li><li>将列队辨认改成一对一辨认；</li></ul></li><li>训练陪审团：让他们了解何种条件下的目击者证词才</li></ul><h3 id="影响陪审团判断的其他因素"><a href="#影响陪审团判断的其他因素" class="headerlink" title="影响陪审团判断的其他因素"></a>影响陪审团判断的其他因素</h3><h4 id="被告的特征"><a href="#被告的特征" class="headerlink" title="被告的特征"></a>被告的特征</h4><h5 id="外表吸引力"><a href="#外表吸引力" class="headerlink" title="外表吸引力"></a>外表吸引力</h5><p>多数人难以抵制基因的直觉，即喜欢那么长得好看的人。当被告拥有外表吸引力时，会减轻其受到的惩罚，尤其是当证据较为模糊时最为明显；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308232055485.png"></p><h5 id="与陪审员的相似性"><a href="#与陪审员的相似性" class="headerlink" title="与陪审员的相似性"></a>与陪审员的相似性</h5><p>原理同上，相似导致喜欢，喜欢导致轻判；</p><h4 id="法官的指示"><a href="#法官的指示" class="headerlink" title="法官的指示"></a>法官的指示</h4><p>对于非法证据，虽然法官会要求陪审员忽略该证据，但事实上一旦证据被摆出来，我们的大脑便很难摆脱其影响。有时候法官的忽略指示，甚至会起到相反的作用；</p><h4 id="其他因素"><a href="#其他因素" class="headerlink" title="其他因素"></a>其他因素</h4><p>受害者的特征也会影响陪审团的判断，例如受害者过往有犯罪记录，那么人们会减少对受害者的同情；</p><h3 id="什么影响了个体陪审员"><a href="#什么影响了个体陪审员" class="headerlink" title="什么影响了个体陪审员"></a>什么影响了个体陪审员</h3><h4 id="陪审员的理解"><a href="#陪审员的理解" class="headerlink" title="陪审员的理解"></a>陪审员的理解</h4><p>陪审员并非专业的法律从业者，因此他们基本无法正确理解法官提出的各种法律术语，导致他们的判断更多是从自己的生活经验出发，去想象整个故事；更加蛋疼的是，我们的大脑也难以理解统计概率。</p><h4 id="陪审团的选择"><a href="#陪审团的选择" class="headerlink" title="陪审团的选择"></a>陪审团的选择</h4><p>当证据模糊时，陪审员只能依据自己的直觉来做出判断，因此会受其个人价值观和偏好的影响。此时被告对陪审团的选择会发挥一定的作用；</p><h3 id="群体因素对陪审员的影响"><a href="#群体因素对陪审员的影响" class="headerlink" title="群体因素对陪审员的影响"></a>群体因素对陪审员的影响</h3><h4 id="少数派的影响"><a href="#少数派的影响" class="headerlink" title="少数派的影响"></a>少数派的影响</h4><p>少数派极少能够逆转最终结果，除非存在一些特殊的条件；</p><h4 id="群体极化-1"><a href="#群体极化-1" class="headerlink" title="群体极化"></a>群体极化</h4><p>群体极化同样发生在陪审团成员中，集体讨论的结果通常是加强了最初的倾向，而不是改变它；</p><h4 id="宽大"><a href="#宽大" class="headerlink" title="宽大"></a>宽大</h4><p>当证据不充分，无法充分说明有罪时，陪审员的商议结果往往会变得宽大。</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>我们都是普遍的凡人，我们的生物属性决定了我们不可避免会犯各种人类都会犯下的错误。犯错并不要紧，要紧的是我们要永远记得保持开放的大脑，觉知自己出错的可能，这样我们才有可能不断取得进步；</p><h2 id="16、可持续发展应用"><a href="#16、可持续发展应用" class="headerlink" title="16、可持续发展应用"></a>16、可持续发展应用</h2><p>科技的进步，生产力的提高，让我们跳出了马尔萨斯陷阱，过上了100年前的人们所不敢想象的舒适生活。但同时我们也付出了资源的代价，让地球进入了超负荷的状态；</p><h3 id="什么是物质主义和财富"><a href="#什么是物质主义和财富" class="headerlink" title="什么是物质主义和财富"></a>什么是物质主义和财富</h3><p>人们的幸福感并没有随着收入的增加而增加；有两个原因：</p><ul><li>适应能力：我们很快会习惯我们所拥有的，财富带来的愉悦刺激很快就会消退，甚至毒品也是如此；</li><li>社会比较：我们天生有向上比较的倾向，而不是满足于自己所拥有的；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202308242045787.png"></p><p>四个有助于提高生活质量的要素：</p><ul><li>亲密和支持性的社会关系；</li><li>为共同目标一起努力和相互支持的团队；</li><li>积极的特质：如乐观、高自我效能、控制感、外向性；</li><li>参加能够带来心流体验的活动：如园艺、手工等；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;导论&quot;&gt;&lt;a href=&quot;#导论&quot; class=&quot;headerlink&quot; title=&quot;导论&quot;&gt;&lt;/a&gt;导论&lt;/h1&gt;&lt;h3 id=&quot;重要课题&quot;&gt;&lt;a href=&quot;#重要课题&quot; class=&quot;headerlink&quot; title=&quot;重要课题&quot;&gt;&lt;/a&gt;重要课题&lt;/h</summary>
      
    
    
    
    <category term="社科" scheme="https://ccw1078.github.io/categories/%E7%A4%BE%E7%A7%91/"/>
    
    
    <category term="心理学" scheme="https://ccw1078.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>穷查理宝典</title>
    <link href="https://ccw1078.github.io/2023/08/29/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/"/>
    <id>https://ccw1078.github.io/2023/08/29/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/</id>
    <published>2023-08-29T13:57:00.000Z</published>
    <updated>2024-09-23T00:57:25.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普世智慧"><a href="#普世智慧" class="headerlink" title="普世智慧"></a>普世智慧</h2><p>需要将所学的知识搭建成思维模型，不然仅仅拥有一些碎片化的知识，是无法用来分析事物的。</p><p>这个世界很复杂，涉及非常多的领域。不同的领域存在不同的规律，因此需要掌握多套适用不同领域的思维模型。避免只用一套思维模型去套用所有的行业，不然很容易犯下生搬硬套的错误。</p><blockquote><p>对于只掌握锤子的人来说，所有的问题看起来都像是钉子；</p></blockquote><p>数学：基础计算、排列组合、决策树、基础统计；</p><p>会计：它是表达商业活动的语言；</p><p>工程：质量控制、后备系统、断裂点理论</p><p>物理：临界质量</p><p>心理学：大脑认知原理</p><p>经济学：生态系统（专注细分领域）、规模优势（规模越大，成本越低）、完全竞争劣势（无利可图）、比较优势（从事自己擅长的）</p><h2 id="选股艺术"><a href="#选股艺术" class="headerlink" title="选股艺术"></a>选股艺术</h2><p>耐心，等待好机会的出现，然后下重注。不用太多，每十年出现1~2次即可；</p><p>对于优质企业，如果有待发掘的潜力（例如企业隐含成长惯性、拥有优秀管理人员，或者拥有出色的管理制度等），即使当前价格稍高，也可以接受；因为它未来会变得更高；</p><p>激励机制是决定行为的最重要因素；也是识别优秀企业的一个重要指标；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;普世智慧&quot;&gt;&lt;a href=&quot;#普世智慧&quot; class=&quot;headerlink&quot; title=&quot;普世智慧&quot;&gt;&lt;/a&gt;普世智慧&lt;/h2&gt;&lt;p&gt;需要将所学的知识搭建成思维模型，不然仅仅拥有一些碎片化的知识，是无法用来分析事物的。&lt;/p&gt;
&lt;p&gt;这个世界很复杂，涉及非常</summary>
      
    
    
    
    <category term="社科" scheme="https://ccw1078.github.io/categories/%E7%A4%BE%E7%A7%91/"/>
    
    
    <category term="经济" scheme="https://ccw1078.github.io/tags/%E7%BB%8F%E6%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>Vue3</title>
    <link href="https://ccw1078.github.io/2023/08/19/Vue3/"/>
    <id>https://ccw1078.github.io/2023/08/19/Vue3/</id>
    <published>2023-08-19T02:33:00.000Z</published>
    <updated>2024-09-21T23:19:17.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>app.use()</p><p>注册插件，有点像 Express 中的 use；所谓的插件，即具备某些功能的一段代码，这段代码用于添加全局功能；</p><p>插件可以是一个对象，也可以是一个函数；</p><p>如果是一个对象，需要有一个 install 方法，以便调用；该 install 函数的第一个参数是 app，第二个参数是 options</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;)<br><br>app.<span class="hljs-title function_">use</span>(myPlugin, &#123;<br>    <span class="hljs-attr">greetings</span>: &#123;<br>        <span class="hljs-attr">hello</span>: <span class="hljs-string">&quot;Bonjour!&quot;</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// plugins/i18n.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">install</span>: <span class="hljs-function">(<span class="hljs-params">app, options</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 注入一个全局可用的 $translate() 方法</span><br>    app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$translate</span> = <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 获取 `options` 对象的深层属性</span><br>      <span class="hljs-comment">// 使用 `key` 作为索引</span><br>      <span class="hljs-keyword">return</span> key.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">o, i</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (o) <span class="hljs-keyword">return</span> o[i]<br>      &#125;, options)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; $translate(&#x27;greetings.hello&#x27;) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插件的几种使用场景：</p><ul><li>添加一些全局属性和方法；</li><li>添加一个全局资源；</li><li>添加一个全局组件</li><li>添加自定义指令；</li></ul><p>app.config.isCustomElement</p><p>有些元素是从外部引入的，并没有在 vue 中编写，此时需要备注一下哪些元素是自定义的，以免在编译时报错找不到；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-property">config</span>.<span class="hljs-property">isCustomElement</span> = <span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> <span class="hljs-regexp">/^x-/</span>.<span class="hljs-title function_">test</span>(tag);<br></code></pre></td></tr></table></figure><p>app.mount</p><p>将 app 关联到 HTML 文件中的 Tag</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>TodoMVC built with Vue Composition Api and Vuex<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">app-root</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-root</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive 可用来创建一个对象，这个对象可以被多个组件引入，共享使用；</p><p>对象可以有自己的方法，通过调用该方法，改变对象的状态；这个改变会在所有的组件上同时更新；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">reactive</span>(&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;store.increment()&quot;</span>&gt;</span><br>        &#123;&#123; store.count &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了用 reactive 来创建全局对象外，其实 ref 或者函数也可以实现该功能；</p><blockquote><p>函数之所以可以，主要是利用了闭包的特性；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> &#123; ref &#125; from <span class="hljs-string">&quot;vue&quot;</span><br>    <br><span class="hljs-comment">// 保存状态的全局对象</span><br><span class="hljs-type">const</span> <span class="hljs-variable">globalCount</span> <span class="hljs-operator">=</span> ref(<span class="hljs-number">1</span>);<br><br><br>export function <span class="hljs-title function_">useCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 保存状态的局部变量</span><br>    <span class="hljs-type">const</span> <span class="hljs-variable">localCount</span> <span class="hljs-operator">=</span> ref(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">return</span> &#123;<br>        globalCount,<br>        localCount,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 问：reactive 和 ref 有什么区别？</p><p> 答：有以下一些区别：</p><ul><li>reactive 只能处理对象，不能处理原始类型；ref 的底层实现其实最终也有调用 reactive；</li><li>ref 可以通过 .value 重新赋值，reactive 不行，因此 reactive 在处理新的 array 时，不如 ref 重新赋值方便；</li><li>不过 reactive 修改对象的属性时，无须使用 .value，写起来会简单一些；</li></ul> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// reactive 很适合管理一个拥有多个原始类型属性的对象；</span><br><br><span class="hljs-keyword">const</span> person = <span class="hljs-title function_">reactive</span>(&#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">37</span>,<br>   <span class="hljs-attr">isTall</span>: <span class="hljs-literal">true</span>,<br>&#125;); <br><br><span class="hljs-comment">// 以上写法比使用多个 ref 来得方便</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;Albert&quot;</span>);<br><span class="hljs-keyword">const</span> age = <span class="hljs-title function_">ref</span>(<span class="hljs-number">37</span>);<br><span class="hljs-keyword">const</span> isTall = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 但 ref 其实也可以写成下面这样</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-title function_">ref</span>(&#123;<br>   <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;John&quot;</span>,<br>   <span class="hljs-attr">age</span>: <span class="hljs-number">37</span>,<br>   <span class="hljs-attr">isTall</span>: <span class="hljs-literal">true</span>,<br>&#125;); <br></code></pre></td></tr></table></figure></blockquote><p>computed() 其实也是返回一个 ref</p><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>当值 B 依赖于值 A 时，通过 computed 可以实现当 A 变动时，B 实现实时更新；</p><p>computed 接收一个函数做为参数，返回的是一个 ref</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; reacitve, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript"><span class="hljs-keyword">const</span> author = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;john&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">books</span>: [</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue1&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue2&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue3&quot;</span>,</span><br><span class="language-javascript">    ]</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// computed 接收一个函数做为参数，返回的是一个 ref</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> message = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> author.<span class="hljs-property">books</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>  ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>;</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Has Published books:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>computed 的好处是有缓存，也就是说，如果所依赖的值没变的话，它是不会重新计算的；</p><p>实际上 message 也可以定义成一个函数，结果一样，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> author = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;john&quot;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">books</span>: [</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue1&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue2&quot;</span>,</span><br><span class="language-javascript">        <span class="hljs-string">&quot;vue3&quot;</span>,</span><br><span class="language-javascript">    ]</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">message</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> author.<span class="hljs-property">books</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>  ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Has Published books:<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; message() &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="状态管理器"><a href="#状态管理器" class="headerlink" title="状态管理器"></a>状态管理器</h3><p>vue2 的状态管理器，在 vue3 中使用 Pinia</p><h3 id="类与样式绑定"><a href="#类与样式绑定" class="headerlink" title="类与样式绑定"></a>类与样式绑定</h3><p>有多种写法可用来绑定样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">// 方式一: 使用单个 ref<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> isAcitve = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; acitve: isActive &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">// 方式二：使用多个 ref<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> isAcitve = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> hasError = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">       <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;static&quot;</span> </span><br><span class="hljs-tag">       <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">// 方式三：使用对象<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> classObject = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">active</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;classObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">// 方法四：使用数组<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> activeClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;active&#x27;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> errorClass = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;text-danger&#x27;</span>);</span><br><span class="language-javascript">    </span><br><span class="language-javascript"><span class="hljs-keyword">const</span> isActive = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>// 或者<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[&#123;[activeClass]: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>自定义组件上的 class 值，会传递到组件内部的 Tag 上面，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">// 组件 myComponent 内部的内容<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;foo bar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">// 在调用 myComponent 组件时<br><span class="hljs-tag">&lt;<span class="hljs-name">myComponent</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;baz boo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">myComponent</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">// 渲染结果为<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;foo bar baz boo&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果 myComponent 内部有多上根Tag，那么需要指定哪个根 Tag 接收外部传进来的 class 值，示例如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">// 内部有两个根元素 p 和 span，此处指定 p 接收 myComponent 的 class 值<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;$attrs.class&quot;</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>message<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>适用于 class 的绑定规则，同样也适用于 style 的绑定，示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> styleObject = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;30px&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;styleObject&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>当我们想阻止某个事件的冒泡时，可以在绑定的方法中调用 event.stopPropagation()，但 vue 还提供了一种更简便的方法，示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 旧方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">warn</span>(<span class="hljs-params">message, event</span>) &#123;<br>  <span class="hljs-comment">// 这里可以访问原生事件</span><br>  <span class="hljs-keyword">if</span> (event) &#123;<br>    event.<span class="hljs-title function_">preventDefault</span>()<br>  &#125;<br>  <span class="hljs-title function_">alert</span>(message)<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是使用事件修饰符进行绑定的方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--新方法--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warn</span>(<span class="hljs-params">message, event</span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">alert</span>(message)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">    </span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">&quot;warn&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><p>按键修饰符可用于监听键盘上某个特定的键被按下的事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--此处监听 enter 键--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br><br><br><span class="hljs-comment">&lt;!--此处监听 pageDown 键--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.page-down</span>=<span class="hljs-string">&quot;onPageDown&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="鼠标修饰符"><a href="#鼠标修饰符" class="headerlink" title="鼠标修饰符"></a>鼠标修饰符</h3><p>用来监听鼠标事件</p><ul><li>.left  左键</li><li>.right 右键</li><li>.middle  中键</li></ul><h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><p>在处理表单输入时，是需要双向绑定的，即改动 data，会更新 html；而改动 input 时，也会更新 data</p><p>vue 使用 v-model 关键字来实现这种双向绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>多个复选框可以绑定到一个数组或集合</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> checkedNames = <span class="hljs-title function_">ref</span>([]);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>checked names: &#123;&#123; checkedNames &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbot&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jack&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;jack&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbot&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;john&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;john&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbot&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mike&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mike&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;checkedNames&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;mike&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>v-bind 可用于标签的属性绑定</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;&#123; id: &#x27;blue&#x27;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--等同于如下--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--简写如下--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> id = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;abc&quot;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="v-model-修饰符"><a href="#v-model-修饰符" class="headerlink" title="v-model 修饰符"></a>v-model 修饰符</h3><h4 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a>.lazy</h4><p>默认情况下，v-model 的更新是实时的，但可使用 .lazy 修饰符，让更新不再实时，而是触发 change 事件后再更新</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="number"><a href="#number" class="headerlink" title=".number"></a>.number</h4><p>将输入的字符串自动转成数字</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h4><p>自动去除字符串首尾的空格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-mdoel.trim</span>=<span class="hljs-string">&quot;msg&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>最常用的几个生命周期</p><ul><li>onMounted</li><li>onUpdated</li><li>onUnmounted</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408161623575.png"></p><h3 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h3><p>当某个对象的值出现变化时，就执行回调函数；监听的对象可以是如下几种类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 监听单个 ref 对象</span><br><span class="hljs-title function_">watch</span>(x, <span class="hljs-function">(<span class="hljs-params">new_x</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;);<br><br><br><span class="hljs-comment">// 监听 getter 函数</span><br><span class="hljs-title function_">watch</span>(<br><span class="hljs-function">() =&gt;</span> x.<span class="hljs-property">value</span> + y.<span class="hljs-property">value</span>,<br>    <span class="hljs-function">(<span class="hljs-params">sum</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sum of x and y is: &quot;</span>, sum);<br>    &#125;<br>);<br><br><br><span class="hljs-comment">// 监听数组</span><br><span class="hljs-title function_">watch</span>(<br>[x, <span class="hljs-function">() =&gt;</span> y.<span class="hljs-property">value</span>],<br>    <span class="hljs-function">(<span class="hljs-params">[new_x, new_y]</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`new x is <span class="hljs-subst">$&#123;new_x&#125;</span> and new y is <span class="hljs-subst">$&#123;new_y&#125;</span>`</span>);<br>    &#125;<br>);<br></code></pre></td></tr></table></figure><p>watch 并非马上执行，而是当监听对象的值出现变化时，才会执行。因此，如果想让它立即执行，那么需要加个 { immediate: true } 参数；</p><p>默认情况下，如果在回调函数中访问监听对象，此时监听对象的值，是原始状态；如果未被回调函数改变前的状态；如果需要访问改变后的状态，则需要给 watch 传递 { flush: “post” } 选项；</p><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>watchEffect 有点像是 watch 的语法糖，在使用 watch 时，需要显示的指定某个监听对象；watchEffect 则不用，它可以自动从回调函数中判断需要监听的对象；而且是加载后，马上执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> todoId = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://example.com/<span class="hljs-subst">$&#123;todoId.value&#125;</span>`</span>)<br>    data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="访问-DOM"><a href="#访问-DOM" class="headerlink" title="访问 DOM"></a>访问 DOM</h3><p>如果想直接访问 DOM，则可以给标签的 ref 属性设置名称，之后就可以在代码中引用它，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> myInput = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);  <span class="hljs-comment">// 此处用同名变量，实现对 input 标签的引用</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    myInput.<span class="hljs-property">value</span>.<span class="hljs-title function_">focus</span>();</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myInput&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当 ref 被用在子组件上时，此时引用的不再是标签，而是子组件实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./Child.vue&quot;</span>;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> child = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 此处引用的是 Child 实例</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>默认情况下，子组件内部的属性和方法是私有的，父组件无法直接访问，除非子组件使用 defineExpose 进行暴露；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> b = <span class="hljs-title function_">ref</span>(<span class="hljs-number">2</span>);</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-title function_">defineExpose</span>(&#123;</span><br><span class="language-javascript">        a,</span><br><span class="language-javascript">        b,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此时父组件可通过 ref 引用来访问子组件中的 a 和 b 变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 此时 ref 的值为 &#123; a: number, b: number &#125;</span><br></code></pre></td></tr></table></figure><h3 id="组件API"><a href="#组件API" class="headerlink" title="组件API"></a>组件API</h3><p>以下两种形式的 API 是等价的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 组合式 API --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;count++&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- 选项式 <span class="hljs-variable constant_">API</span> --&gt;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">setup</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> &#123; count &#125;;<br>    &#125;,<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;button @click=&quot;count++&quot;&gt;&lt;/button&gt;`</span><br>    <span class="hljs-comment">// template 也可以引用一个模板</span><br>    <span class="hljs-comment">// template: &#x27;#my-template-element&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>父组件可通过 props 向子组件传递数据；子组件可 emit 事件，父组件通过监听事件来获得子组件传递的数据；</p><h3 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h3><p>slot 的作用类似于占位符，可接收由父组件传进来的 HTML 内容，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--AlertBox.vue--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>This is an Error box<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--此处父组合的内容 Something bad happen 会出现中子组件的 slot 位置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">AlertBox</span>&gt;</span>Something bad happen<span class="hljs-tag">&lt;/<span class="hljs-name">AlertBox</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="深入组件"><a href="#深入组件" class="headerlink" title="深入组件"></a>深入组件</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>组件需要注册后才能使用，通过 app.component 方法，可将某个组件注册为全局的组件，之后可以在任意文件中使用该全局组件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.vue&quot;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;);<br><br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyComponent&#x27;</span>, <span class="hljs-title class_">MyComponent</span>);  <span class="hljs-comment">// 全局注册</span><br></code></pre></td></tr></table></figure><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>局部注册：仅在需要使用的位置，导入相应的组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentA.vue&#x27;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ComponentA</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>除了 attribute  外，考虑父组件还可通过 props 传递数据给子组件。因此，最好显式的声明 props，这样有利于 Vue 区分二者；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// props 使用对象，并写上属性值的类型，有助于尽早发现传错参数</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,<br>  <span class="hljs-attr">likes</span>: <span class="hljs-title class_">Number</span><br>&#125;)<br><br><span class="hljs-comment">// 还可以添加校验规则</span><br><span class="hljs-title function_">defineProps</span>(&#123;<br>    <span class="hljs-attr">propA</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">default</span>: <span class="hljs-string">&quot;hello&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">propB</span>: &#123;<br>        <span class="hljs-title function_">validator</span>(<span class="hljs-params">value, props</span>) &#123;<br>            <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].<span class="hljs-title function_">includes</span>(value);<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">propC</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Function</span>, <span class="hljs-comment">// 可以是函数类型</span><br>        <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Default Function&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>Vue 倾向在写 HTML atribute 时，使用传统的 kecal-case 枨，然后它还会自动映射 kebab-case 和 camelCase 格式，以便和传统的 javascript camelCase 保持一致； </p><blockquote><p>个人感觉这种两边讨好的做法不是很好；缺少一致性，容易让人感到困惑；</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">greeting-message</span>=<span class="hljs-string">&quot;hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 当使用 v-bind 时，引号中的内容，实际上是一个表达式，而不是字符串</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 因为使用 v-bind，所以此处的 42 其实是一个 Number 类型，  --&gt;</span><br><span class="hljs-comment">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">:likes</span>=<span class="hljs-string">&quot;42&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">:likes</span>=<span class="hljs-string">&quot;post.likes&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 同理，false 是一个布尔值 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">:is-published</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!-- 表达式自然是支持数组的 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">:commend-ids</span>=<span class="hljs-string">&quot;[234, 245, 273]&quot;</span> /&gt;</span><br><br><span class="hljs-comment">&lt;!--表达式也支持对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">:author</span>=<span class="hljs-string">&quot;&#123; name: &#x27;John&#x27;, age: 47 &#125;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>可通过 v-bind&#x3D;对象，批量绑定多个 prop</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> post = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;My Journey&quot;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--同时绑定了 id 和 title 两个 prop --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BlogPost</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;post&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>注意：prop 是单向绑定，即数据由父组件传递给子组件，这意味着它是只读的，我们不能在子组件的代码中，修改 prop 的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">defineProps</span>([<span class="hljs-string">&#x27;foo&#x27;</span>]);<br><br><span class="hljs-comment">// 以下尝试修改 foo 的值是错误的</span><br>props.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;bar&quot;</span>;<br></code></pre></td></tr></table></figure><p>由于在 Javascript 中，对象类型的参数，实际上是一个引用，因此，虽然无法直接更改对象绑定的变量，但可以改变对象内部的属性。但这是一种不良做法，应该在实践中避免；如有需要修改，应使用 emit 事件的方式；由监听事件的父组件对 prop 进行修改；</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>在组件的 template 模板中，可使用内置的 $emit 函数来触发事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;someEvent&#x27;)&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>事件支持携带参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;someEvent&#x27;, param)&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>通过使用 defineEmit() 宏显式的声明可触发的事件后，会返回一个 emit 函数，能够在代码中直接调用，它的效果跟 template 中的 $emit 是一样的； </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> emit = <span class="hljs-title function_">defineEmits</span>([<span class="hljs-string">&#x27;inFocus&#x27;</span>, <span class="hljs-string">&#x27;submit&#x27;</span>]);</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">buttonClick</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">emit</span>(<span class="hljs-string">&quot;submit&quot;</span>);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="组件-v-model"><a href="#组件-v-model" class="headerlink" title="组件 v-model"></a>组件 v-model</h3><p>通过在子组件上使用 v-model，可以实现父子组件之间数据的双向绑定；父子组件传统的通信方式是使用 prop 和 emit，事实上在组件上使用 v-model 只是一个语法糖，它的底层仍然还是 prop 和 emit，只是它由解释器完成补全；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--父组件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> myRef = <span class="hljs-title function_">ref</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;myRef&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--子组件 Child.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> myRefVar = <span class="hljs-title function_">defineModel</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&#x27;myRefVar&#x27;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以绑定多个 v-model</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">UserName</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model:firstName</span>=<span class="hljs-string">&quot;first&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model:lastName</span>=<span class="hljs-string">&quot;last&quot;</span></span><br><span class="hljs-tag">  /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> firstName = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">&quot;firstName&quot;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> lastName = <span class="hljs-title function_">defineModel</span>(<span class="hljs-string">&quot;lastName&quot;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;firstName&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;lastName&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>组件 v-model 同样支持修饰符，例如 v-model.capitalize，之后在 defineModel 中，可以基于传入的修饰符的值，自定义 set 函数，实现想要的处理；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">v-model.capitalize</span>=<span class="hljs-string">&#x27;myText&#x27;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> [model, modifiers] = <span class="hljs-title function_">defineModel</span>();</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;modifiers&quot;</span>) <span class="hljs-comment">// &#123; capitalize: true &#125;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;text&#x27;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;model&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><br><span class="hljs-comment">&lt;!-- 或者可以针对 modifiers 自定义处理方法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> [model, modifiers] = <span class="hljs-title function_">defineModel</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (modifiers.<span class="hljs-property">capitalize</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUppercase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> value;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="透传-Attributes"><a href="#透传-Attributes" class="headerlink" title="透传 Attributes"></a>透传 Attributes</h3><p>最常见的透传包括 class, style, id 等几个 HTML 标签的属性；但其实 v-on 监听器也会实现透传</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">MyButton</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyButton</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onChildClick&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>当 button 触发点击事件时，onChildClick 和 onClick 两个函数都会被执行，事实上 button 标签绑定了来自父子组件的两个点击事件；</p><h4 id="深层组件继承"><a href="#深层组件继承" class="headerlink" title="深层组件继承"></a>深层组件继承</h4><p>如果子组件的根元素也是一个组件，那么父组件的 attributes 会持续向下一级透传；</p><p>如果不想要继承透传，可在组件选项中设置 inheritAttrs: false</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">defineOptions</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>透传的 attributes 可在 template 中使用 $attris 进行访问</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; $attrs &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>@click 在透传后，子组件可使用 $attrus.onClick 进行访问；</p><p>如果子组件有多个根节点，那么需要显式指定由哪个根节点继承父组件透传的 attris，否则编译器会抛出警告；</p><p>如果想要在 js 代码中访问 attrus，则可以使用 useAttrs</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; useAttrs &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> attrs = <span class="hljs-title function_">useAttrs</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>父组件可通过插横向子组件传递内容；插槽从某种意义上来说，有点像是一个形式参数。子组件本身只提供样式，内容则由参数来决定，这样可以提高子组件的通用性和灵活性；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">FancyButton</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">AwesomeIcon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;plus&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">FancyButton</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 FancyButton.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fancy-btn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 插入的位置 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 最终渲染结果 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fancy-btn&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span>&gt;</span>Click me!<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">AwesomeIcon</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;plus&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408171512456.png"></p><p>作用域：插槽内容可以访问父组件中定义的变量，但无法访问子组件中的数据；</p><p>默认内容：插槽允许指定默认内容，这样当父组件没有传入内容时，可显示默认内容；就像默认参数值一样；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><br>    Submit  <span class="hljs-comment">&lt;!-- 此处的 Submit 为默认内容 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>组件支持多个插槽，为了避免混淆，需要为每个插槽指定名称，这样传入内容的时候，才能够匹配；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 BaseLayout.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 没有名称，默认名称为 default --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BaseLayout</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 此处的内容将匹配到名称为 header 的插槽上 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">footer</span>&gt;</span>  <span class="hljs-comment">&lt;!-- v-slot 支持简写为 # --&gt;</span><br>    <span class="hljs-comment">&lt;!-- 此处的内容将匹配到名称为 footer 的插槽上 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">BaseLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>父组件的插槽名称必须和子组件中的插槽名称完全一样，如果不一样，会无法匹配，因此也无法渲染</p><p>插槽的名称可以是动态的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base-layout</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:</span>[<span class="hljs-attr">dynamicSlotName</span>]&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">base-layout</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="反向传递"><a href="#反向传递" class="headerlink" title="反向传递"></a>反向传递</h4><p>子组件可以将自己的数据，通过插槽，反向传递给父组件</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408171631960.png"></p><h4 id="无渲染组件"><a href="#无渲染组件" class="headerlink" title="无渲染组件"></a>无渲染组件</h4><p>利用插槽机制，再加上 v-slot 让子组件能够向父组件传递数据，那么接下来便出现了一种有趣的用法，即子组件只封装了逻辑，但没有封装要渲染的内容。它在通过逻辑获得数据后，可以将数据传递给父组件，由父组件自行决定如何渲染；</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>当需要向深层次的组件时，使用 props 会导致逐级透传的问题</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408171658227.png"></p><p>Vue 使用 provide&#x2F;inject 机制来解决逐级透传的问题</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202408171731829.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;   </span><br><span class="language-javascript">    <span class="hljs-title function_">provide</span>(&#123; <span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;hello&#x27;</span>&#125;) <span class="hljs-comment">// 此处 message 是键，hello 是值；</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span><br><span class="language-javascript">    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;count&#x27;</span>, count); <span class="hljs-comment">// provide 支持多次调用，以便传入多个值</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>app 可以提供全局依赖&#x2F;注入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(&#123;&#125;);<br><br>app.<span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>); <br></code></pre></td></tr></table></figure><p>在子组件中，使用 inject 来获得想要的数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;message&quot;</span>); <span class="hljs-comment">// 使用 inject 获得想要的数据</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-string">&quot;defaultValue&quot;</span>) <span class="hljs-comment">// inject 支持设置一个默认值</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 默认值也可以使用工厂函数来生成, 第三个参数 true 用来声明默认值是由一个函数生成</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefautlValue</span>(), <span class="hljs-literal">true</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果需要在子组件中更改注入的数据，那么 provide 最好提供一个方法，供子组件调用，而不是直接修改。这样有利于未来的维护；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&quot;North Pole&quot;</span>);</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateLocation</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        location.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;South Pole&#x27;</span>;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">   </span><br><span class="language-javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;location&quot;</span>, &#123;</span><br><span class="language-javascript">        location,</span><br><span class="language-javascript">        updateLocation,</span><br><span class="language-javascript">    &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> &#123; location, updateLocation &#125; = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;location&quot;</span>); <span class="hljs-comment">// 可以解包</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;updateLocation&quot;</span>&gt;</span><br>        &#123;&#123; location &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果提供方想保护自己的数据不能被修改，可以使用 readonly 将其装饰为只读的状态</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, provide, readonly &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;readOnlyCount&#x27;</span>, <span class="hljs-title function_">readonly</span>(count)) <span class="hljs-comment">// 使用 readonly 装饰</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="使用-Symbol-避免命名冲突"><a href="#使用-Symbol-避免命名冲突" class="headerlink" title="使用 Symbol 避免命名冲突"></a>使用 Symbol 避免命名冲突</h4><p>如果构建的应用很大，或者所编写的组件会被很多人调用，那么有可能产生命名冲突。解决办法就是将名称放在一个单独的文件中统一管理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// key.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> myInjectKey = <span class="hljs-title class_">Symbol</span>(); <span class="hljs-comment">// Symbol 会生成一个唯一值，以便作为标识符，避免重名</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 provide 组件中</span><br><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myIndectKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./key.js&quot;</span><br><br><span class="hljs-title function_">provide</span>(myInjectKey, &#123;<span class="hljs-comment">/* something */</span>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在 inject 组件中</span><br><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> &#123; myInjectKey &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./key.js&quot;</span><br><br><span class="hljs-keyword">const</span> injected = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&quot;myInjectKey&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>当应用变得很大时，每次打开便加载所有组件将耗费很长的等待时间，更好的做法是懒加载，即等用到某个组件时，再去加载它；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 普通加截组件的方法</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponet</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./components/MyComponent.vue&quot;</span><br><br><span class="hljs-comment">// 异步加载组件的方法</span><br><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;./components/MyComponent.vue&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="加载错误"><a href="#加载错误" class="headerlink" title="加载错误"></a>加载错误</h4><p>异步加载因为是使用时再加载的，那么有可能因为网络信号不好，导致加载失败，此时可提供一个组件，来应对出错的情况，defineAsyncComponent 支持多个配置选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComp</span> = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;<br>    <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&quot;../components/Foo.vue&quot;</span>),<br>    <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span>,  <span class="hljs-comment">// 例如可显示加载动画</span><br>    <span class="hljs-attr">errComponent</span>: <span class="hljs-title class_">ErrorComponent</span>, <span class="hljs-comment">// 例如在出错时，显示错误提示信息</span><br>    <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,  <span class="hljs-comment">// 设置延迟，有助于让画面过渡更加顺滑，以免加载太快，切换太快，像是页面闪烁</span><br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>, <span class="hljs-comment">// 超时后报错</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><h3 id="组合式函数"><a href="#组合式函数" class="headerlink" title="组合式函数"></a>组合式函数</h3><p>当某个行为逻辑被很多个组件复用时，可以把它抽象到一个公式的函数中，然后由各组件引入使用；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 该函数实时读取鼠标的位置，现抽象到单独的 mouse.js 文件中</span><br><span class="hljs-keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 按照惯例，组合式函数名以“use”开头</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useMouse</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 被组合式函数封装和管理的状态</span><br>  <span class="hljs-keyword">const</span> x = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>  <span class="hljs-keyword">const</span> y = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br>  <span class="hljs-comment">// 组合式函数可以随时更改其状态。</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">event</span>) &#123;<br>    x.<span class="hljs-property">value</span> = event.<span class="hljs-property">pageX</span><br>    y.<span class="hljs-property">value</span> = event.<span class="hljs-property">pageY</span><br>  &#125;<br><br>  <span class="hljs-comment">// 一个组合式函数也可以挂靠在所属组件的生命周期上</span><br>  <span class="hljs-comment">// 来启动和卸载副作用</span><br>  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, update))<br>  <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, update))<br><br>  <span class="hljs-comment">// 通过返回值暴露所管理的状态</span><br>  <span class="hljs-keyword">return</span> &#123; x, y &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在组件中使用 mouse.js --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Script</span> <span class="hljs-attr">setup</span>&gt;</span><br>import &#123; useMouse &#125; from &quot;./mouse.js<br>    const &#123; x, y &#125; = useMouse(); // useMouse 会创建单独的实例，因此各个组件间的状态不会相互影响<br><span class="hljs-tag">&lt;/<span class="hljs-name">Script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们可以将动作拆分成更小的函数，然后不同的函数可以相互组合，这样可以尽可能实现复用；</p><p>例如从后端获取数据是一个很常见的动作，获取的过程涉及三个动作，显示正在获取中；如果成功，显示数据；如果失败，显示失败提示；由于该动作很常见，因此我们可以将它封装成一个单独的函数，以便各个组件可以复用该逻辑；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 传统的方式 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;...&#x27;</span>)</span><br><span class="language-javascript">  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())</span><br><span class="language-javascript">  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> (data.<span class="hljs-property">value</span> = json))</span><br><span class="language-javascript">  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> (error.<span class="hljs-property">value</span> = err))</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span>Oops! Error encountered: &#123;&#123; error.message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span><br>    Data loaded:<br>    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>&#123;&#123; data &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 抽象成单独的函数</span><br><span class="hljs-comment">// fetch.js</span><br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useFetch</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><br>  <span class="hljs-title function_">fetch</span>(url)<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> (data.<span class="hljs-property">value</span> = json))<br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> (error.<span class="hljs-property">value</span> = err))<br><br>  <span class="hljs-keyword">return</span> &#123; data, error &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用封装后的函数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; useFetch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./fetch.js&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> &#123; data, error &#125; = <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">&#x27;...&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>理论上也可以直接使用普通的函数，没有必要将函数封装组装，这种做的好处其实在于让它变成响应式的。因为普通的函数每次执行，都需要手动主动调用。而如果封装成了组件，同时参数为 ref 或者 getter 函数等动态类型，那么每当参数值发生变化时，组件就会自动运行。这是相对普通函数的好处；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> url = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;/initial-url&#x27;</span>)<br><br><span class="hljs-keyword">const</span> &#123; data, error &#125; = <span class="hljs-title function_">useFetch</span>(url)<br><br><span class="hljs-comment">// 这将会重新触发 fetch</span><br>url.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;/new-url&#x27;</span><br></code></pre></td></tr></table></figure><p>另外，也可以在函数式组件中使用 watchEffect 来监听参数变化；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// fetch.js</span><br><span class="hljs-keyword">import</span> &#123; ref, watchEffect, toValue &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useFetch</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br>  <span class="hljs-keyword">const</span> error = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 每次运行前重置</span><br>    data.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span><br>    error.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span><br><br>    <span class="hljs-title function_">fetch</span>(<span class="hljs-title function_">toValue</span>(url)) <span class="hljs-comment">// toValue 的好处是让参数可以支持多种类型，更加灵活</span><br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">json</span>) =&gt;</span> (data.<span class="hljs-property">value</span> = json))<br>      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> (error.<span class="hljs-property">value</span> = err))<br>  &#125;<br>  <br>  <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-comment">// 使用 watchEffect 来监听变化</span><br>    <span class="hljs-title function_">fetchData</span>()<br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> &#123; data, error &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解构重命名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>,<br>&#125;<br><br><span class="hljs-keyword">const</span> &#123;a : a1, b : b2, <span class="hljs-attr">c</span>: c3, d4 = <span class="hljs-string">&#x27;default&#x27;</span>&#125; = obj;<br></code></pre></td></tr></table></figure><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>Vue 有一些内置的指令，例如 v-model、v-show 等，这些指令从本质上来，其实是为了操作和控制 DOM；除了内置指令，Vue 也支持编写自定义的指令，这些指令可以在不同的组件上实现复用；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> vFocus = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">mounted</span>: <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el.<span class="hljs-title function_">focus</span>(), <span class="hljs-comment">// 加载后，可自动对焦</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>vFocus 是一种强制的命名规范，以小写字母 v 开头；</p><p>指令支持多种钩子函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myDirective = &#123;<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;,<br>    <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;,<br>    <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;,<br>    <span class="hljs-title function_">beforeUpdated</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;,<br>    <span class="hljs-title function_">updated</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;,<br>    <span class="hljs-title function_">beforeUnmounted</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;<br>    <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el, binding, vnode</span>)&#123;&#125;<br>&#125;<br><span class="hljs-comment">// el 参数指要操作的元素</span><br><span class="hljs-comment">// binding 是一个对象，主要用来存放要传给指令的值；以便 el 可以读取这些值，进行相应的操作；</span><br><span class="hljs-comment">// vnode 代表绑定元素的底层 VNode</span><br><span class="hljs-comment">// prevVnode 代表之前绑定的底层 VNode</span><br></code></pre></td></tr></table></figure><blockquote><p>注：应避免有组件上面使用自定义指令，而是只在原生的 HTML 元素上使用，以避免冲突，产生预期外的效果；</p></blockquote><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件可用来给 Vue 添加全局功能；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>();<br><br>app.<span class="hljs-title function_">use</span>(myPlugin), &#123;...&#125;;  <span class="hljs-comment">// 全局使用插件</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义插件示例</span><br><br><span class="hljs-keyword">const</span> myPlugin = &#123;<br>    <span class="hljs-attr">install</span>: (app, options) &#123;...&#125;,<br>&#125;<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">myPlugin</span> = (<span class="hljs-params">app, options</span>) =&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="编写插件示例"><a href="#编写插件示例" class="headerlink" title="编写插件示例"></a>编写插件示例</h4><p>该插件给在 app 上注册一个全局可用的 $translate 函数，用来翻译指定字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// plugins/i18n.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">install</span>: <span class="hljs-function">(<span class="hljs-params">app, options</span>) =&gt;</span> &#123;<br>        app.<span class="hljs-property">config</span>.<span class="hljs-property">globalProperties</span>.<span class="hljs-property">$translate</span> = <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> key.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-number">0</span>, i</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span> (o) &#123;<br>                    <span class="hljs-keyword">return</span> o[i];<br>                &#125;<br>            &#125;, options);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引入插件</span><br><span class="hljs-keyword">import</span> i18nPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./plugins/i18n&quot;</span>;<br><br>app.<span class="hljs-title function_">use</span>(i18nPlugin, &#123;<br>    <span class="hljs-attr">greetings</span>: &#123;<br>        <span class="hljs-attr">hello</span>: <span class="hljs-string">&quot;Bonjour!&quot;</span>,<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 使用插件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; $translate(&quot;greetings.hello&quot;)&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插件中也可以引入 provide &#x2F; inject，这样各个组件就可以直接读取插件提供的值了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">install</span>: <span class="hljs-function">(<span class="hljs-params">app, options</span>) =&gt;</span> &#123;<br>        app.<span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;i18n&#x27;</span>, options),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在组件中通过 inject 读取 options --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> i18n = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;i18n&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i18n.<span class="hljs-property">greetings</span>.<span class="hljs-property">hello</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>内置的 Transition 组件，可用来给组件加载或卸载时提供动画效果；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;show =!show&quot;</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Transition</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Transition</span>&gt;</span><br></code></pre></td></tr></table></figure><p>动画效果可以自定义，并且可以命名，以方便管理多种不同的动画效果；</p><p>TransitionGroup 可用来设置列表的动画，当列表添加或删除元素时，呈现动画效果；</p><h3 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h3><p>KeepAlive 可用来缓存实例</p><h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p>Teleport 有点像是一个传送门，用来将组件中的部分模板，传送到外部组件上面；之所以这么做，是为了能够更好的展示传送的内容，避免受到深层嵌套过程中的其他组件的布局影响；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;open = true&quot;</span>&gt;</span>Open Modal<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;open&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;model&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello from the modal<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;open = false&quot;</span>&gt;</span>Close<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Teleport</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Teleport 会改变 DOM 的层级关系，但不会改组件之间的层级关系；</p><h3 id="Suspence"><a href="#Suspence" class="headerlink" title="Suspence"></a>Suspence</h3><p>在某个组件内部存在多个异步组件时，有可能这些异步组件都有自己的异步处理机制，例如显示加载图标。当这些子组件同时加载时，会导致页面上出现多个异步图标。Suspence 的目标是对这些异步状态统一管理，展示统一的加载状态；</p><h2 id="应用规模化"><a href="#应用规模化" class="headerlink" title="应用规模化"></a>应用规模化</h2><h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><p>一个 Vue 文件同时包含 js、html 和  css 三部分内容，即同时包含逻辑、模板和样式数据；</p><p>单文件组件是一种代码的组织方式，如果需要实现的功能非常小，例如只是给静态文件添加一些简单的交互，则可以考虑使用 petite-vue，只有 6k 大小；</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>非常简单的页面，可用 computed 配合监听浏览器的 haschange 来切面页面；它的原理很简单，即 js 代码调用浏览器的接口，更新了 url，触发了 haschange 事件，从而调用监听函数，完成组件的更新，实现页面的切换；</p><p>正式的路由器则使用  Vue Router</p><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>如果多个组件依赖同一份数据，那么使用 props 逐级透传的方式，会让代码变得臃肿。解决办法是将数据封装成一个全局的单例，供各个组件使用；</p><p>其中一个方案是使用 reactive、ref、computed 或者组合式函数，创建一个响应式对象，放在单独的文件中，供各个组件引用；</p><p>如果应用使用服务器渲染，则以上方案变得不太可行；此时需要使用单独的状态管理器，例如 Pinia 或者 Vuex；</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>需要测试的东西：</p><ul><li>单元测试：确保函数正常</li><li>组件测试：确保 component 的功能正常</li><li>端到端测试：类似于集合测试，确保整个应用正常运行；常用框架：Cypress，Playwright，Nightwatch 等；</li></ul><p>其中端到端是最重要的，因为它确保了应用程序的运行正常；</p><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>有两种场景需要用到服务端渲染 SSR：</p><ul><li>SEO 非常重要；</li><li>首页加载速度非常重要；</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="生产部署"><a href="#生产部署" class="headerlink" title="生产部署"></a>生产部署</h3><p>在生产服务器部署，那些提高开发效率的工具就不需要了，因此记得在打包代码是地，排除它们，以缩小文件的体积；</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>Vue 本身包含了优化功能，在绝大部分场景下，vue 的性能都是够用的，除非遇到一些极端的场景，才需要手动优化；</p><p>两个常见的优化指标：</p><ul><li>页面加载速度</li><li>页面更新速度</li></ul><h4 id="页面加载优化"><a href="#页面加载优化" class="headerlink" title="页面加载优化"></a>页面加载优化</h4><p>常用的手段包括：</p><ul><li>服务端渲染</li><li>减小包体积：例如构建工具使用 Tree Shaking，预编译等，避免引入太大的依赖；</li><li>代码分割：实现懒加载；</li></ul><h4 id="页面更新优化"><a href="#页面更新优化" class="headerlink" title="页面更新优化"></a>页面更新优化</h4><p>当 props 变更时，会触发组件的更新，因此，在设计组件时，应该确保它的 props 值尽量稳定，以减少不必要的更新触发；</p><p>v-once 指令可用来标识无需更新的组件，这样进行更新计算时，会跳过该组件；</p><p>v-memo 指令可用来设置更新的条件；</p><p>computed 的计算结果如果发生变化，也会触发更新。 如果是值还好说，可直接比较；如果比较的是对象，那么即使值没有变化，也会触发更新；此时可考虑引入自定义的比较函数；</p><h4 id="通用优化"><a href="#通用优化" class="headerlink" title="通用优化"></a>通用优化</h4><ul><li>大型列表的虚拟化；</li><li>绕开深层级对象的深度检查；</li><li>在大型列表中，减少不必要的组件抽象；</li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="使用-Vue-的多种方式"><a href="#使用-Vue-的多种方式" class="headerlink" title="使用 Vue 的多种方式"></a>使用 Vue 的多种方式</h3><ul><li>独立脚本，像引入 jQuery 一样轻量化使用；</li><li>作为 Web Component 嵌入原有的旧应用；</li><li>单页面应用：主流用法；</li><li>全栈 &#x2F; SSR：适用于 SEO 很重要的场景；</li><li>静态 SSG：静态站点生成 JAMStack，作用静态文件部署；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;app.use()&lt;/p&gt;
&lt;p&gt;注册插件，有点像 Express 中的 use；所谓的插件，即具备某些功能的一段代码，这段代码用于添加全局</summary>
      
    
    
    
    <category term="工具" scheme="https://ccw1078.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="javascript" scheme="https://ccw1078.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue Router 基本用法</title>
    <link href="https://ccw1078.github.io/2023/08/18/Vue%20Router%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>https://ccw1078.github.io/2023/08/18/Vue%20Router%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</id>
    <published>2023-08-18T12:26:00.000Z</published>
    <updated>2024-09-21T23:19:05.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>路由的目的是建立 url 和组件之间的映射关系；当 url 发生变化时，组件也随之更新；</p><h3 id="创建路由器实例"><a href="#创建路由器实例" class="headerlink" title="创建路由器实例"></a>创建路由器实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createMemoryHistory, createRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">HomeView</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./HomeView.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">AboutView</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./AboutView.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> routes = [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">Homeview</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">AboutView</span> &#125;,<br>]<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createMemoryHistory</span>(),<br>    routes,<br>&#125;)<br></code></pre></td></tr></table></figure><p>history 用来记录 url 和路由的双向映射，这里用的是 createMemoryHistory，它会抛开浏览器的 url，完全自我管理；</p><p>如果想要跟浏览器的 url 保持关系，则可使用 createWebHistory 或者 createWebhashHistory；</p><h3 id="注册路由器插件"><a href="#注册路由器插件" class="headerlink" title="注册路由器插件"></a>注册路由器插件</h3><p>创建好路由器实例化，可以用 app.use(router) 将其注册为插件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>();<br>app.<span class="hljs-title function_">use</span>(router);<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&quot;#app&quot;</span>)<br></code></pre></td></tr></table></figure><p>注册该插件后，会完成以下几项工作：</p><ul><li>注册需要的组件，如 RouterLink 和 RouterView</li><li>添加全局属性，如 $router 和 $route</li><li>添加全局组合式函数 useRouter 和 useRoute</li><li>解析初始路由</li></ul><h3 id="访问路由器和当前路由"><a href="#访问路由器和当前路由" class="headerlink" title="访问路由器和当前路由"></a>访问路由器和当前路由</h3><p>在组合式 API 中，可使用 useRouter 和 useRoute 来访问路由器和当前路由；</p><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><p>动态匹配：用于将多个路径匹配到同一个组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./User.vue&quot;</span><br><br><span class="hljs-keyword">const</span> routers = &#123;<br>    <span class="hljs-comment">// 动态参数使用冒号 : 来标识</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/users/:id&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span> &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>可在模板中使用 $route 或者 useRoute 来访问当前路径的参数，例如 $route.params.id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div&gt;<br>        User &#123;&#123; $route.params.id &#125;&#125;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>路由支持多个参数，例如 &#x2F;users&#x2F;:name&#x2F;posts&#x2F;:postId</p><h3 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h3><p>当路由参数出现变化时，为提高性能，避免重新渲染，会直接复用原先的组件。这意味着组件不会重新创建，因此跟创建有关的 hook 函数例如 onMount 也不会重新执行；</p><p>可使用 watch 或者 onBeforeRouteUpdated 来监听变化，并执行相关的操作；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; watch &#125; from &#x27;vue&#x27;<br>    import &#123; useRoute &#125; from &#x27;vue-router&#x27;<br>    <br>    const route = useRoute()<br>    <br>    watch(() =&gt; route.params.id, (newId, oldId) =&gt; &#123;...&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123; onBeforeRouteUpdated &#125; from &#x27;vue-router&#x27;<br>    <br>    onBeforeRouteUpdated(async(to, from) =&gt; &#123;<br>        userData.value = await fetchUser(to.params.id);<br>    &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="捕获所有路由"><a href="#捕获所有路由" class="headerlink" title="捕获所有路由"></a>捕获所有路由</h3><p>通过路径参数的正则表达式，可以匹配任意的路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:pathMatch(.*)*&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;NotFound&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">NotFound</span>&#125;,<br>&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user-:afteruser(.*)&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserGeneric</span> &#125;,<br>]<br></code></pre></td></tr></table></figure><h2 id="路由的匹配语法"><a href="#路由的匹配语法" class="headerlink" title="路由的匹配语法"></a>路由的匹配语法</h2><h3 id="在参数中自定义正则"><a href="#在参数中自定义正则" class="headerlink" title="在参数中自定义正则"></a>在参数中自定义正则</h3><p>当两个路径的前缀相同，只是参数的类型不同时，可使用正则来区分它们；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    <span class="hljs-comment">// 仅匹配数字</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:orderId(\\d+)&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:productName&#x27;</span> &#125;<br>]<br></code></pre></td></tr></table></figure><p>但我个人觉得更好的做法是修改前缀，这样更简单清晰</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/order/:orderId&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/product/:name&#x27;</span> &#125;,<br>]<br></code></pre></td></tr></table></figure><h3 id="可重复的参数"><a href="#可重复的参数" class="headerlink" title="可重复的参数"></a>可重复的参数</h3><p>星号 * 表示 0 个或多个</p><p>加号 + 表示 1 个或多个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    <span class="hljs-comment">// 匹配 /one, /one/two,  /one/two/three</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:chapters+&#x27;</span> &#125;,<br>    <span class="hljs-comment">// 匹配 /, /one, /one/two 等</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/:chapters*&#x27;</span>&#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="Sensitive-与-Strict-路由配置"><a href="#Sensitive-与-Strict-路由配置" class="headerlink" title="Sensitive 与 Strict 路由配置"></a>Sensitive 与 Strict 路由配置</h3><p>默认情况下，路由是不区分大小写的，如需要区分，可添加 sensitive: true 和 strict: true 选项</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>修饰符 ? 可用来标记可选参数，即 0 个或者 1 个；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    <span class="hljs-comment">// 匹配 /users 和 /users/abc</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:userId?&#x27;</span> &#125;,<br>    <span class="hljs-comment">// 匹配 /users 和 /users/123</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:userId(\\d+)&#x27;</span> &#125;<br>]<br></code></pre></td></tr></table></figure><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>组件通常是嵌套的，这种嵌套关系也可以反映在 URL 上面。此时，可在路由中配置 children 子路由来标记这种嵌套关系</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:userId&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>,<br>        <span class="hljs-attr">children</span>: [<br>            &#123;<br>                <span class="hljs-comment">// 匹配 /user/:id/profile</span><br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,<br>                <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserProfile</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">// 匹配 /user/:id/posts</span><br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;posts&quot;</span>,<br>                <span class="hljs-attr">component</span>: <span class="hljs-string">&quot;UserPosts&quot;</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-comment">// 匹配 /user/:id</span><br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                <span class="hljs-attr">component</span>: <span class="hljs-title class_">UserHome</span><br>            &#125;<br>        ]<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><p>路由支持命名，只需将名称备注在 name 字段中即可；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user/:username&quot;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span><br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>该名称可用于 router-link 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link :to=&quot;&#123; name: &#x27;profile&#x27; params: &#123; username: &#x27;erina&#x27; &#125; &#125;&quot;&gt;&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><p>建议使用命名路由，一来这样更方便维护，避免后续因为更改路径，导致很多地方需要跟着改动；二来好的名称也比路径也更容易理解；</p><blockquote><p>路由的命名需要全局唯一，不然会出现冲突；</p></blockquote><h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><h3 id="导航到不同的位置"><a href="#导航到不同的位置" class="headerlink" title="导航到不同的位置"></a>导航到不同的位置</h3><p>router.push(…) 会跳转到新的页面，它同时会向页面 history 的栈中添加记录，这样当用户点击浏览器上面的按钮时，就会返回上一页；</p><p>点击 router-link 组件也会有相同的效果；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-link :to=&quot;...&quot;&gt;&lt;/router-link&gt;<br></code></pre></td></tr></table></figure><p>router.push 可以支持很多种格式，其参数可以是简单的 url，也可以是一个对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 字符串路径</span><br>router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/users/eduardo&#x27;</span>)<br><br><span class="hljs-comment">// 带有路径的对象</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/eduardo&#x27;</span> &#125;)<br><br><span class="hljs-comment">// 命名的路由，并加上参数，让路由建立 url</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">params</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;eduardo&#x27;</span> &#125; &#125;)<br><br><span class="hljs-comment">// 带查询参数，结果是 /register?plan=private</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/register&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">plan</span>: <span class="hljs-string">&#x27;private&#x27;</span> &#125; &#125;)<br><br><span class="hljs-comment">// 带 hash，结果是 /about#team</span><br>router.<span class="hljs-title function_">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">hash</span>: <span class="hljs-string">&#x27;#team&#x27;</span> &#125;)<br></code></pre></td></tr></table></figure><h3 id="替换当前位置"><a href="#替换当前位置" class="headerlink" title="替换当前位置"></a>替换当前位置</h3><p>router.replace 会跳转新页面，作用与 router.push 相同，区别是直接替换当前路由在 history 中的位置，而不是 push；</p><h3 id="横跨历史"><a href="#横跨历史" class="headerlink" title="横跨历史"></a>横跨历史</h3><p>在 history 栈中进行跳转，类似 window.history.go(n)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">go</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 前进1页，与 router.forward 作用相同</span><br>router.<span class="hljs-title function_">go</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// 后退1页，与 router.back 作用相同</span><br>router.<span class="hljs-title function_">go</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 前进3页</span><br>router.<span class="hljs-title function_">go</span>(-<span class="hljs-number">3</span>) <span class="hljs-comment">// 后退3页</span><br></code></pre></td></tr></table></figure><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>给视图进行命名，可以让它们同时同级展示，而不是嵌套展示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;router-view name=&quot;leftSidebar&quot; /&gt;<br>&lt;router-view /&gt; &lt;!-- 没有名称，默认为 default --&gt;<br>&lt;router-view name=&quot;rightSidebar&quot; /&gt;<br></code></pre></td></tr></table></figure><p>当页面上存在多个视图时，需要给各视图映射相应的组件；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = (&#123;<br>    <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHashHistory</span>(),<br>    <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/&quot;</span>,<br>            <span class="hljs-attr">components</span>: &#123;<br>                <span class="hljs-attr">default</span>: <span class="hljs-title class_">Home</span>,<br>                <span class="hljs-attr">leftSidebar</span>: <span class="hljs-title class_">LeftSidebar</span>,<br>                <span class="hljs-attr">rightSidebar</span>: <span class="hljs-title class_">RightSidebar</span>,<br>            &#125;<br>        &#125;<br>    ]<br>&#125;)<br></code></pre></td></tr></table></figure><p>命名视图也是支持嵌套滴；</p><h2 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h2><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重写向：点击 A 路径，重定向跳转到 B 路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可以是 url</span><br><span class="hljs-keyword">const</span> routes = [&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&quot;/&quot;</span> &#125;]<br><br><span class="hljs-comment">// 或者一个对象</span><br><span class="hljs-keyword">const</span> routes = [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/home&quot;</span>, <span class="hljs-attr">redirect</span>: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;homepage&quot;</span> &#125; &#125;<br>]<br><br><span class="hljs-comment">// 或者一个函数</span><br><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/search/:searchText&#x27;</span>,<br>        <span class="hljs-attr">redirect</span>: <span class="hljs-function"><span class="hljs-params">to</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/search&#x27;</span>, <span class="hljs-attr">query</span>: &#123; <span class="hljs-attr">q</span>: to.<span class="hljs-property">params</span>.<span class="hljs-property">searchText</span> &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="相对重定向"><a href="#相对重定向" class="headerlink" title="相对重定向"></a>相对重定向</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:userId/posts&#x27;</span>,<br>        <span class="hljs-attr">redirect</span>: <span class="hljs-function"><span class="hljs-params">to</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;profile&#x27;</span>  <span class="hljs-comment">// 实际结果为 /users/:userId/profile</span><br>        &#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>通过别名，可将任意指定的 url 匹配到相应的组件，而不会受到嵌套结构的限制；</p><h2 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h2><p>如果在组件中读取 $route 的参数，那么意味着使用该组件，将会与 url 强绑定；组件的复用范围受到了很大的限制；解决方法就是不使用 $route，而是给组件传递参数；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 传统的写法，组件与url紧密耦合 --&gt;<br>&lt;template&gt;<br>&lt;div&gt;<br>        User &#123;&#123; $route.params.id&#125;&#125;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 新的写法, id 引用 props，由外部传入，而不是读取路由 --&gt;<br>&lt;script setup&gt;<br>defineProps(&#123;<br>    id: String, // 声明 props 参数<br>&#125;)<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>&lt;div&gt;<br>        User &#123;&#123; id &#125;&#125;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在路由配置中，通过 props:true 选项将 params 声明为 props</span><br><span class="hljs-keyword">const</span> routes = [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user/:id&quot;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>, <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span> &#125;<br>]<br></code></pre></td></tr></table></figure><p>如果路由映射了多个命名视图，那么需要为每个视图单独备注是否启用 props</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> routes = [<br>    &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/user/:id&quot;</span>,<br>        <span class="hljs-attr">components</span>: &#123; <span class="hljs-attr">default</span>: <span class="hljs-title class_">User</span>, <span class="hljs-attr">sidebar</span>: <span class="hljs-title class_">Sidebar</span> &#125;,<br>        <span class="hljs-attr">props</span>: &#123;<br>            <span class="hljs-attr">default</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 启用</span><br>            <span class="hljs-attr">sidebar</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 不启用</span><br>        &#125;<br>    &#125;<br>]<br></code></pre></td></tr></table></figure><p>另外 props 还支持对象或函数类型；</p><h2 id="匹配当前路由的链接"><a href="#匹配当前路由的链接" class="headerlink" title="匹配当前路由的链接"></a>匹配当前路由的链接</h2><p>有时候多个 router-link 在页面上面会以列表的形式出现，此时经常用不同的颜色，来标识当前激活的 link；</p><p>此时需要有一个方法来判断当前处于激活状态的是哪个链接；</p><h2 id="不同的历史记录模式"><a href="#不同的历史记录模式" class="headerlink" title="不同的历史记录模式"></a>不同的历史记录模式</h2><p>有三种历史模式</p><ul><li>Hash 模式：会在 URL 上面添加 # 符号，好处是用户重新刷新页面也不要紧，能够正常处理；</li><li>HTML 模式：URL 跟普通网页的 URL 一模一样，缺点当用户刷新时，会向服务器发送页面请求，需要服务器有相应的处理，不然会出现  404</li><li>Memory 模式：URL 只保存在内存，不在浏览器的 URL 上面体现，缺点是无法使用浏览器的前进和后退，因为没有页面栈；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;入门&quot;&gt;&lt;a href=&quot;#入门&quot; class=&quot;headerlink&quot; title=&quot;入门&quot;&gt;&lt;/a&gt;入门&lt;/h2&gt;&lt;p&gt;路由的</summary>
      
    
    
    
    <category term="工具" scheme="https://ccw1078.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="javascript" scheme="https://ccw1078.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Linux 文件权限</title>
    <link href="https://ccw1078.github.io/2023/08/04/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <id>https://ccw1078.github.io/2023/08/04/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/</id>
    <published>2023-08-04T02:09:00.000Z</published>
    <updated>2024-09-21T23:16:23.254Z</updated>
    
    <content type="html"><![CDATA[<p>drwxrwxrwx</p><ul><li>d 表示目录</li><li>剩下的三组 rwx 分别表示拥有者、拥有者用户组、其他用户对当前文件夹的权限情况</li></ul><p>添加权限使用加号 +</p><p>减少权限使用减号 -</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> g+rwx,u+w,o+x  &lt;file&gt;<br><span class="hljs-comment"># 以上命令的意思是</span><br><span class="hljs-comment"># g+rwx，为用户组增加 rwx 权限</span><br><span class="hljs-comment"># u+w，为用户增加 w 权限</span><br><span class="hljs-comment"># o+x，为其他用户增加 x 权限</span><br><br><span class="hljs-built_in">chmod</span> a-rwx &lt;file&gt;<br><span class="hljs-comment"># a 表示所有三个分组（即拥有者、用户组、其他用户），都取消 rwx 权限</span><br></code></pre></td></tr></table></figure><p>rwx 除了用字母外，也可以用数字来表示，rwx 对应的数字分别是 4、2、1</p><p>rwxrwxrwx 可以用 777 来表示，因为 rwx 三个数字相加，刚好等于 7，有三组的 rwx，因此有 3 个 7</p><p>rwx—— 可以用 700 来表示</p><p>r—w—x 可以用 421 来表示</p><p>rw-rw-r-x 可以用 665 来表示</p><p>本质上来说，数字只是对字母的一种缩写，一种快捷方式，但它也增加了理解的成本；</p><p>如果要将 chmod 运用于所用子目录，可以添加 -R 参数，示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> -R 777 &lt;file&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;drwxrwxrwx&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;d 表示目录&lt;/li&gt;
&lt;li&gt;剩下的三组 rwx 分别表示拥有者、拥有者用户组、其他用户对当前文件夹的权限情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;添加权限使用加号 +&lt;/p&gt;
&lt;p&gt;减少权限使用减号 -&lt;/p&gt;
&lt;figure c</summary>
      
    
    
    
    <category term="文章" scheme="https://ccw1078.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="服务器" scheme="https://ccw1078.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="Linux" scheme="https://ccw1078.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Paperjs</title>
    <link href="https://ccw1078.github.io/2023/07/30/Paperjs/"/>
    <id>https://ccw1078.github.io/2023/07/30/Paperjs/</id>
    <published>2023-07-30T03:49:00.000Z</published>
    <updated>2024-09-21T23:17:55.624Z</updated>
    
    <content type="html"><![CDATA[<p>Paperjs 是一个较流行的 canvas 接口封装库，可以很方便的用来实现绘图功能，基本概念如下：</p><h1 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h1><h2 id="Point-Size-Rectangle"><a href="#Point-Size-Rectangle" class="headerlink" title="Point, Size, Rectangle"></a>Point, Size, Rectangle</h2><p>Point：点，本质上是点的属性描述</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myPt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)  <span class="hljs-comment">// 10,20 分别表示 x,y 坐标</span><br><span class="hljs-comment">// 除了用 X,Y 参数实例化一个点之外，还可以通过传入其他点作为参数来实例化（本质上是复制，彼此后续的改变是独立的，不会相互影响）</span><br><span class="hljs-comment">// 另外也可以调用旧点的 clone() 方法来实现复制</span><br></code></pre></td></tr></table></figure><p>Size：尺寸，用来表示宽度和高度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mySize = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 表示宽度 width 为 10, 高度 height 为 20</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mySize); <span class="hljs-comment">// &#123; width: 0, height: 0 &#125;</span><br></code></pre></td></tr></table></figure><p>Rectangle：矩形，有多种实例化的方法（这些方法让我发现，其背后的实现原理很可能是使用数组来存储参数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myPt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">var</span> mySz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br><span class="hljs-keyword">var</span> myRect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(myPt, mySz);<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">var</span> myRect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">var</span> myRect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>();<br>myRect.<span class="hljs-property">point</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>myRect.<span class="hljs-property">size</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>矢量是一个非常好用的东西，原因：</p><ul><li>它不表示绝对坐标值，而是表示从起点到终点的相对坐标值；</li><li>相对坐标的特性，让矢量可以很方便用来做各种计算；</li></ul><p>两个矢量可以相加，也可以相减，在几何层面，它们其实仅是方向的区别；</p><p>矢量与整数的乘法或除法，也很简单，即相对坐标放大或缩小指定的整数倍数，或者也可以理解为在极坐标中，不改变角度，仅改变矢量长度；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> newVec = oldVec * <span class="hljs-number">3</span> <span class="hljs-comment">// 整数必须写在右边，因为 javascript 解释器默认取左边变量的类型作为计算结果的类型</span><br></code></pre></td></tr></table></figure><p>除了乘法外，也可以通过改变矢量的 length，实现相同的效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> newVec = oldVec * <span class="hljs-number">3</span><br><br><span class="hljs-comment">// 跟下面的算法等价</span><br>newVec.<span class="hljs-property">length</span> = oldVec.<span class="hljs-property">length</span> * <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>矢量拥有角度 angle 属性，可以直接赋值，也可以对其进行计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> vec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vec.<span class="hljs-property">angle</span>); <span class="hljs-comment">// 45</span><br><br><span class="hljs-comment">// 直接赋值</span><br>vec.<span class="hljs-property">angle</span> = <span class="hljs-number">135</span>;<br><span class="hljs-comment">// 或者</span><br>vec.<span class="hljs-property">angle</span> = vec.<span class="hljs-property">angle</span> + <span class="hljs-number">90</span>;<br></code></pre></td></tr></table></figure><p>加减乘除、旋转等计算并不会改变旧的 vector 属性，而是会直接返回一个新的 vector；但当我们直接修改 vector 的属性时，则会改变 vector 的属性值；</p><h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br><br><span class="hljs-comment">// 顺序添加新的点</span><br>myPath.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)); <br>myPath.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>));<br><br><span class="hljs-comment">// 支持一次添加多个点，只需传入多个参数即可</span><br>myPath.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>)); <br><br><span class="hljs-comment">// 支持在现有点之间插入新点</span><br>myPath.<span class="hljs-title function_">insert</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">30</span>, <span class="hljs-number">50</span>));<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// path 有一个 smooth 方法，可以用来将直线转成曲线</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>path.<span class="hljs-property">strokeColor</span> = <span class="hljs-string">&quot;black&quot;</span>;<br>path.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">30</span>, <span class="hljs-number">75</span>));<br>path.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">30</span>, <span class="hljs-number">25</span>));<br>path.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">80</span>, <span class="hljs-number">25</span>));<br>path.<span class="hljs-title function_">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">80</span>, <span class="hljs-number">75</span>));<br>path.<span class="hljs-property">closed</span> = <span class="hljs-literal">true</span>; <span class="hljs-comment">// path 默认是 open 状态，设置为 true 实现闭合</span><br><br>path.<span class="hljs-property">fullySelected</span> = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">var</span> copy = path.<span class="hljs-title function_">clone</span>();<br>copy.<span class="hljs-property">fullySelected</span> = <span class="hljs-literal">true</span>;<br>copy.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> += <span class="hljs-number">100</span>;<br><br>copy.<span class="hljs-title function_">smooth</span>();<br>    <br><span class="hljs-comment">// 自带的 remove 方法可以用来彻底删除对象</span><br>copy.<span class="hljs-title function_">remove</span>();<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061118634.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建 path 类型的圆</span><br><span class="hljs-keyword">var</span> circle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Circle</span>(center_point, radius);<br><br><span class="hljs-comment">// 创建 path 类型的矩形</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Rectangle</span>(point, size);<br><span class="hljs-comment">// 也可以传入 Rectangle 矩形作为实例化的参数</span><br><span class="hljs-keyword">var</span> rect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rectangle</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>));<br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Rectangle</span>(rect);<br><br><span class="hljs-comment">// 创建圆角矩形</span><br><span class="hljs-keyword">var</span> radius = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Size</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Rectangle</span>(rect, radius);<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061147756.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建正多边形，例如正三角形，正十边形等</span><br><span class="hljs-comment">// new Path.RegularPolygon(center, sides, radius)</span><br><span class="hljs-keyword">var</span> triangle = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">RegularPolygon</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">80</span>, <span class="hljs-number">70</span>), <span class="hljs-number">3</span>, <span class="hljs-number">50</span>);<br><span class="hljs-keyword">var</span> decagon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">RegularPolygon</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">200</span>, <span class="hljs-number">70</span>), <span class="hljs-number">10</span>, <span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20230706115151.png"></p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个打勾符号</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(&#123;<br>    <span class="hljs-attr">segments</span>: [[<span class="hljs-number">40</span>, <span class="hljs-number">115</span>], [<span class="hljs-number">80</span>, <span class="hljs-number">180</span>], [<span class="hljs-number">200</span>, <span class="hljs-number">20</span>]],<br>    <span class="hljs-attr">selected</span>: <span class="hljs-literal">true</span><br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20230706115415.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 直接赋值，改成红色</span><br>path.<span class="hljs-property">strokeColor</span> = <span class="hljs-string">&quot;#ff0000&quot;</span>;<br><span class="hljs-comment">// 或者使用 color 对象赋值</span><br>path.<span class="hljs-property">strokeColor</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061157326.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 填充颜色</span><br>path.<span class="hljs-property">fillColor</span> = <span class="hljs-string">&quot;#ff0000&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061159060.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置线段粗细</span><br>path.<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061200049.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// path 两端样式</span><br>path.<span class="hljs-property">storkeCap</span> = <span class="hljs-string">&quot;round&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061201130.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 中间点的样式设置为圆角</span><br>path.<span class="hljs-property">strokeJoin</span> = <span class="hljs-string">&quot;round&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061202130.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 虚线</span><br>path.<span class="hljs-property">dashArray</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>];<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061203136.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// path 的所有相关样式都存在 style 属性中，用该字段对其他 path 进行赋值，可实现样式的复制</span><br><span class="hljs-keyword">var</span> firstPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Circle</span>(&#123;<br><span class="hljs-attr">center</span>: [<span class="hljs-number">80</span>, <span class="hljs-number">50</span>],<br><span class="hljs-attr">radius</span>: <span class="hljs-number">35</span><br>&#125;);<br><br>firstPath.<span class="hljs-property">strokeColor</span> = <span class="hljs-string">&#x27;#ff0000&#x27;</span>;<br>firstPath.<span class="hljs-property">fillColor</span> = <span class="hljs-string">&#x27;blue&#x27;</span>;<br><br><span class="hljs-comment">// secondPath doesn&#x27;t have a strokeColor yet:</span><br><span class="hljs-keyword">var</span> secondPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Circle</span>(&#123;<br><span class="hljs-attr">center</span>: [<span class="hljs-number">160</span>, <span class="hljs-number">50</span>],<br><span class="hljs-attr">radius</span>: <span class="hljs-number">35</span><br>&#125;);<br><br><span class="hljs-comment">// Apply the style of firstPath to that of secondPath:</span><br>secondPath.<span class="hljs-property">style</span> = firstPath.<span class="hljs-property">style</span>;<br><br><span class="hljs-comment">// style 也可以单独实例化，之后再赋值</span><br><span class="hljs-keyword">var</span> newStyle = &#123;<br>    <span class="hljs-attr">strokeColor</span>: <span class="hljs-string">&quot;#ff0000&quot;</span>,<br>    <span class="hljs-attr">fillColor</span>: <span class="hljs-string">&quot;#000000&quot;</span>,<br>    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-number">10</span>,<br>&#125;<br>path.<span class="hljs-property">style</span> = newStyle;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 删除某个样式，只需将该样式的属性值设置为 null 即可</span><br>path.<span class="hljs-property">fillColor</span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-comment">// 如果要删除所有新式，则只需将整个 style 属性设置为 null 即可</span><br>path.<span class="hljs-property">style</span> = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 样式可以继承</span><br>project.<span class="hljs-property">currentStyle</span> = &#123;<br>    <span class="hljs-attr">strokeColor</span>: <span class="hljs-string">&quot;#000000&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 新建的 path 会自动继承 project 的样式</span><br><span class="hljs-keyword">var</span> firstPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title function_">circle</span>(&#123;<br>    <span class="hljs-attr">center</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>],<br>    <span class="hljs-attr">radius</span>: <span class="hljs-number">50</span>,<br>&#125;);<br><br><br><span class="hljs-comment">// 当 project 的样式更新后，后续新创建的 path 会继承新样式</span><br>project.<span class="hljs-property">currentStyle</span>.<span class="hljs-property">strokeWidth</span> = <span class="hljs-number">8</span>;<br>project.<span class="hljs-property">currentStyle</span>.<span class="hljs-property">fillColor</span> = <span class="hljs-string">&#x27;green&#x27;</span>;<br><br><span class="hljs-keyword">var</span> secondPath = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Circle</span>(&#123;<br>    <span class="hljs-attr">center</span>: [<span class="hljs-number">250</span>, <span class="hljs-number">100</span>],<br>    <span class="hljs-attr">radius</span>: <span class="hljs-number">50</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061305415.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// path.simplify() 方法可用来简化组成 path 的 segment 数量，以便减少内存占用，提高性能</span><br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061415995.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// path.flatten(error) 方法可用来将曲线转成多段直线</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>.<span class="hljs-title class_">Circle</span>(&#123;<br><span class="hljs-attr">center</span>: [<span class="hljs-number">80</span>, <span class="hljs-number">50</span>],<br><span class="hljs-attr">radius</span>: <span class="hljs-number">35</span><br>&#125;);<br><br><span class="hljs-comment">// Select the path, so we can inspect its segments:</span><br>path.<span class="hljs-property">selected</span> = <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// Create a copy of the path and move it by 150 points:</span><br><span class="hljs-keyword">var</span> copy = path.<span class="hljs-title function_">clone</span>();<br>copy.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> += <span class="hljs-number">150</span>;<br><br><span class="hljs-comment">// Flatten the copied path, with a maximum error of 4 points:</span><br>copy.<span class="hljs-title function_">flatten</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202307061418054.png"></p><h1 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h1><p>有三个全局的鼠标事件，可以对鼠标操作进行响应，它们分别是</p><ul><li>onMouseDown</li><li>onMouseDrag</li><li>onMouse</li></ul><p>鼠标事件的属性：</p><ul><li>point：当前鼠标位置</li><li>downPoint：鼠标被按下时所在位置</li><li>lastPoint：上一次鼠标事件的位置</li><li>middlePoint：当前位置和上次位置的中点</li><li>delta：当前位置和上次位置的矢量 vector（up 事件该值为按下和松开两个位置的矢量）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 每次按下鼠标时，就给路径添加一个新的点</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>();<br>path.<span class="hljs-property">strokeColor</span> = <span class="hljs-string">&quot;black&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">onMouseDown</span>(<span class="hljs-params">e</span>) &#123;<br>    path.<span class="hljs-title function_">add</span>(e.<span class="hljs-property">point</span>);<br>&#125;<br><br><span class="hljs-comment">// 通过设置全局变量 tool，可控制鼠标的移动距离（最大、最小、固定距离等）</span><br>tool.<span class="hljs-property">minDistance</span> = <span class="hljs-number">20</span>;<br>tool.<span class="hljs-property">maxDistance</span> = <span class="hljs-number">20</span>;<br>tool.<span class="hljs-property">fixedDistance</span> = <span class="hljs-number">30</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Paperjs 是一个较流行的 canvas 接口封装库，可以很方便的用来实现绘图功能，基本概念如下：&lt;/p&gt;
&lt;h1 id=&quot;Geometry&quot;&gt;&lt;a href=&quot;#Geometry&quot; class=&quot;headerlink&quot; title=&quot;Geometry&quot;&gt;&lt;/a&gt;Geo</summary>
      
    
    
    
    <category term="工具" scheme="https://ccw1078.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="javascript" scheme="https://ccw1078.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes mongodb operator</title>
    <link href="https://ccw1078.github.io/2023/06/05/kubernetes%20mongodb%20operator/"/>
    <id>https://ccw1078.github.io/2023/06/05/kubernetes%20mongodb%20operator/</id>
    <published>2023-06-05T00:21:00.000Z</published>
    <updated>2024-09-21T23:16:14.422Z</updated>
    
    <content type="html"><![CDATA[<p>早先在 Kubernetes 中管理 MongoDB statefulset 集群使用 sidecar 的方式，后续官方推出了 kubernetes mongodb operator，变得更加方便了，再也不需要额外的 sidecar pod 来监控数据库的状态了；</p><h2 id="下载相关文件"><a href="#下载相关文件" class="headerlink" title="下载相关文件"></a>下载相关文件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> https://github.com/mongodb/mongodb-kubernetes-operator.git<br></code></pre></td></tr></table></figure><h2 id="创建资源定义"><a href="#创建资源定义" class="headerlink" title="创建资源定义"></a>创建资源定义</h2><p>创建</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -f config/crd/bases/mongodbcommunity.mongodb.com_mongodbcommunity.yaml<br></code></pre></td></tr></table></figure><p>检查是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get crd/mongodbcommunity.mongodbcommunity.mongodb.com<br></code></pre></td></tr></table></figure><h2 id="创建角色资源"><a href="#创建角色资源" class="headerlink" title="创建角色资源"></a>创建角色资源</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl apply -k config/rbac/ --namespace &lt;my-namespace&gt;<br></code></pre></td></tr></table></figure><p>检查是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get role mongodb-kubernetes-operator --namespace &lt;my-namespace&gt;<br><br>kubectl get rolebinding mongodb-kubernetes-operator --namespace &lt;my-namespace&gt;<br><br>kubectl get serviceaccount mongodb-kubernetes-operator --namespace &lt;my-namespace&gt;<br></code></pre></td></tr></table></figure><h2 id="创建-operator"><a href="#创建-operator" class="headerlink" title="创建 operator"></a>创建 operator</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl create -f config/manager/manager.yaml --namespace &lt;my-namespace&gt;<br></code></pre></td></tr></table></figure><p>检查是否创建成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get pods --namespace &lt;my-namespace&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;早先在 Kubernetes 中管理 MongoDB statefulset 集群使用 sidecar 的方式，后续官方推出了 kubernetes mongodb operator，变得更加方便了，再也不需要额外的 sidecar pod 来监控数据库的状态了；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="运维" scheme="https://ccw1078.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="kubernetes" scheme="https://ccw1078.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>人性中的善良天使</title>
    <link href="https://ccw1078.github.io/2022/11/27/%E4%BA%BA%E6%80%A7%E4%B8%AD%E7%9A%84%E5%96%84%E8%89%AF%E5%A4%A9%E4%BD%BF/"/>
    <id>https://ccw1078.github.io/2022/11/27/%E4%BA%BA%E6%80%A7%E4%B8%AD%E7%9A%84%E5%96%84%E8%89%AF%E5%A4%A9%E4%BD%BF/</id>
    <published>2022-11-27T14:51:00.000Z</published>
    <updated>2024-09-23T00:54:28.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上册"><a href="#上册" class="headerlink" title="上册"></a>上册</h1><p>暴力变化的一些重要节点：</p><ul><li>无政府状态进入有政府状态；</li><li>小政府进入集权政府状态；</li><li>理性主义和思想启蒙运动；</li><li>二战后大国之间的新秩序；+</li><li>武装冲突在全球范围内的下降；</li><li>人权概念带来的权利运动；</li></ul><h2 id="陌生的历史"><a href="#陌生的历史" class="headerlink" title="陌生的历史"></a>陌生的历史</h2><p>历史的进步是缓慢的，其跨度要远远超过普通人的一生；而大多数人是不喜欢学习历史的，因此人群中普通存在一种历史近视症；即人们通常只关注到最近几十年的历史，同时误以为是更早的往昔也跟今日大同小异，但事实并非如此；真正的历史，与今日的生活大不相同，甚至说是翻天覆地也不为过；</p><h2 id="平靖进程"><a href="#平靖进程" class="headerlink" title="平靖进程"></a>平靖进程</h2><p>原始人类争斗的三种常见动机</p><ul><li>竞争：为了获得稀缺资源，例如食物或性；</li><li>猜疑：为了获得安全感，先主动消灭潜在威胁；</li><li>荣誉：树立有仇必报的名声，减少他人的挑战；</li></ul><p>通过引入垄断暴力的第三方（即政府）可以解决以上三个方面的问题，从而推动暴力的减少；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108201845.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108201955.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108202121.png"></p><p>政府让人们脱离了霍布斯陷阱，虽然极大降低了暴力的概率；但它在解决一个老问题的同时，出带来了一个新问题，即当权者的暴力；</p><h2 id="文明进程"><a href="#文明进程" class="headerlink" title="文明进程"></a>文明进程</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108203036.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108203100.png"></p><p>欧洲在中世纪及之前的封建社会中，整个欧洲大陆由大大小小无数的地方武装力量组成，好听一点叫贵族，不好听一点叫军阀；这些军阀之间经常发生战争，就像中国的春秋战国时代一样；当出现类似秦始皇式的人物，实现对分散军阀的统一后，暴力也随之进一步减少；</p><p>中央政府发生作用的根本原因，并非集权本身，而是人民对政府的信任，或者说政府的威慑；当人民相信犯罪需要付出代价时，就会三思而后行；当政府不能有效的主持公道时，受到不平等对待的人们就会通过使用暴力来追求自助公正；</p><p>掌握更多资源的社会上层人群，更有能力利用法治的工具来实现正义；但是越底层的人群，则难以充分利用法治。这也迫使他们只能利用非法治的手段；</p><p>不仅同一国家内部不同阶层如此，不同发展程度的国家，也表现出相同的趋势；政府越是有效，该国凶杀率越低；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108204954.png"></p><h2 id="人道主义"><a href="#人道主义" class="headerlink" title="人道主义"></a>人道主义</h2><p>暴力的刑罚在历史上绝大多数时间并非秘密进行，而是公开的；对于大众来说，它更像是一种娱乐活动；在人命如草芥的年代，人们对于他人生命的价值是完全无知和麻木的；直到思想启蒙运动的到来，凭借理性主义运动，以及印刷技术带来的图书出版大爆炸，让思想得到广泛传播，人们通过阅读书籍（如小说）等，逐一破解过往的种种迷思，开始重视审视生命本身的价值；进而推动了大规模残酷刑罚的取消；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108211001.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108211036.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108211206.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108211241.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108211802.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221108211827.png"></p><p>通讯技术的发达，除了让思想更快速的传播，同时还有利于让各种错误的思想充分的暴露在公众视野之中，接受检验和批判，进而被杀死在摇篮之中；信息和言论的自由流动本身是具有力量的，这也是为什么极权国家都会不遗余力的控制言论和出版自由；</p><p>就像物理规律一样，它并不是人们发明的，而是被人们发现的；道德也同样如此，实现整体收益最大化的互惠互利方案，并不是人们发明的，而是客观存在的，它只待人性利用大脑中的理性进行推理，并最终找到它们；</p><h2 id="国际秩序"><a href="#国际秩序" class="headerlink" title="国际秩序"></a>国际秩序</h2><p>虽然一战和二战死亡的绝对人数很多，但如果基于总人口比例进行计算，则比例非常小；中国唐朝的安史之乱，全国大约大约 2&#x2F;3 的人口非正常死亡；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109210602.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109210621.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109211231.png"></p><p>经过对历史上发生过的战争进行统计后，得到了几个结论：</p><ul><li>战争的发生时间是随机的；</li><li>战争的结束时间是随机的；</li><li>战争的死亡人数是随机的</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109212104.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109212132.png"></p><p>战争很像一场博弈论中的消耗战博弈，坚持到最后的人能够赢得战果，失败的人则一无所有；为了避免失败，双方不断押注，即使投入已经远远超过收益，双方也无法停止下来，只能最终有一方弹尽粮绝，胜利才能够见分晓；</p><p>消耗战博弈导致产生悖论，即规模越小的战争，反而更容易结束；而规模越大的战争，反而持续的时间更长，自然结果也是更加的惨烈；</p><p>战争的幂律分布导致产生长尾效应，即超大规模的战争数量很少，但极小规模的暴力却数量巨大，其数量之繁多，以至于这些小规模暴力（如谋杀），其造成的死亡人数要远远超出大规模战争；但它们常常因为规模过小，不被人们所注意并进行统计；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109220405.png"></p><p>历史上发生的绝大多数大规模战争，都是发生在大国之间；可以说国家越大，其卷入战争的可能性也越大；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109220753.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109220813.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109220925.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109221001.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109221046.png"></p><p>欧洲三次大规模人口死亡的原因分别是：</p><ul><li>三十年宗教战争；</li><li>拿破仑战争；</li><li>一战和二战；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221109221610.png"></p><p>在三十年战争之后，各欧洲国家签订了《威斯特伐利亚条约》，奠定了现代国家的雏形；随着主权国家陆续成为主流，原来 500 个分散的欧洲小公国最后慢慢合并到剩下 30 个左右；随着独立政治单位数目的减少，国家之间的战争次数也显著变少了；但国家间战争的破坏力变大了，一部分原因是武器升级了，但更主要的原因是国家的组织动员能力变强了，因此有更多的人被送上了战场，军队也逐渐正规化和常备化，从而提高了战争效率；</p><p>主权国家的崛起跟当时商贸活动的繁荣有很大的关系，因此该时期各主权国家主要的精力投向了贸易活动，从而为 18 世纪的欧洲带来了几十年相对平静的时期；但接下来民族主义运动的兴起，打破了这种平静；浪漫化和军国化的民族主义，将战争推向了历史最高潮；在经历几千万人的死亡后，人们精疲力尽，开始坐下来重新思考战争的意义，以及如何避免再次发生相同的悲剧；二战之后，人类社会迎来了历史上最长久的和平；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221110203323.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221110203420.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221110203836.png"></p><p>影响一个国家卷入战争的三种因素（所谓康德的和平三角）：</p><ul><li>民主：民主政体并非解决问题的万能药，但跟已知的所有其他政体相比，它对本国公民施加的暴力是最少的。民主化程度越高的国家，其卷入战争的可能性也相应减少；</li><li>商贸：市场经济和国际贸易化程度越高的国家，也卷入战争的可能性也越小；</li><li>IGO：政府间组织能够为不同国家就分歧提供了协商的机制，例如维和部队；</li></ul><h2 id="新和平"><a href="#新和平" class="headerlink" title="新和平"></a>新和平</h2><p>大规模暴力除了国家间的战争外，还有以下三种常见的形式：</p><ul><li>内战</li><li>种族屠杀</li><li>恐怖主义</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221110212038.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221110212136.png"></p><p>随着苏联在 1991 年的解体，冷战结束，国家之间因为意识形态冲突而引发战争的可能性大大减少了，内战反而成为主流；相对于专制政权和民主政权，半桶水的半民主政权，反而最容易爆发内部冲突，因为这种政权通常严重腐败，阶层分化，种族冲突，资源集中在少数的权贵阶层手中；</p><p>虽然局域地区的暴力冲突仍然频仍，但其造成的死亡人数要远少于作为暴力机器的国家，并且整体也是呈不断下降的趋势；除了民主和开放贸易外，其中一个重要的原因是国际维和部队的介入，让冲突的双方避免陷入霍布斯陷阱，并提供了冲突的协商机制；另外人道主义组织提供的医疗和食物等资源，也有效的降低了平民的死亡率；</p><p>给他人打标签和分类是人类的天性，它有助于降低认知成本，提高认知效率；但这种天性在社会群体冲突中，会带来巨大的恶，敌对方通常会被非人化，以降低恶行可能带来的道德负担，最后可能会导致对某个群体进行大屠杀；</p><p>实现某种乌托邦的意识形态往往带来最大的破坏力，此时暴力被认为实现远大理想的必须手段；进入 21 世纪后，人们渐渐不再对狂热的意识形态产生兴趣。目前看来，它卷土重来的可能性处于一个历史最低点；</p><p>虽然恐怖主义经常占据着当今国际新闻的头版头条，但事实上跟战争和大屠杀比起来，它造成的伤害在数据上只是一个微不足道的零头和噪声；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114210431.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114210447.png"></p><p>虽然各种数据和指标显示人类社会的暴力数量不断走低，但我们仍然无法就此判断人类将远离战争。因为在诸多地区，仍然存在很多不确定因素，例如俄罗斯的对外扩张、中东的政教一体等等；或许更审慎的说法是发生的频率和间隔，将变得比以往更长一些；</p><h2 id="权力革命"><a href="#权力革命" class="headerlink" title="权力革命"></a>权力革命</h2><p>二战后，欧美国家发生了一系列的权利运动，包括民权、女权、儿童权利、同性恋权利、动物权利等；这些运动在无须中改变着人们的观念，让人们对暴力的容忍度变得越来越低；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114213525.png"></p><h3 id="民权"><a href="#民权" class="headerlink" title="民权"></a>民权</h3><p>私刑和种族迫害在美国的减少</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114213835.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114213857.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114213912.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114213931.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114213951.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114214007.png"></p><h3 id="女权"><a href="#女权" class="headerlink" title="女权"></a>女权</h3><p>家庭暴力以及强奸案例整体呈不断下降的趋势；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114214107.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114214211.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114214243.png"></p><h3 id="儿童权利"><a href="#儿童权利" class="headerlink" title="儿童权利"></a>儿童权利</h3><p>杀婴和弃婴曾经是全世界各地人类社会的普遍现象，但在今天，这种现象已经非常罕见；仅仅在 100 多年前，工厂普通使用童工；仅仅在几十年前，大多数家长还对体罚儿童视为正当，但在欧美国家，虐待儿童已写入法律；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114214623.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221114214652.png"></p><h3 id="同性恋权利"><a href="#同性恋权利" class="headerlink" title="同性恋权利"></a>同性恋权利</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221118213530.png"></p><h3 id="动物权利"><a href="#动物权利" class="headerlink" title="动物权利"></a>动物权利</h3><p>动物权利运动与其他运动最大的区别在于，它没有受害人，即动物权利主张完全是由暴力的潜在施加者人来发起的一场运动；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221118214307.png"></p><h3 id="权利运动的根源"><a href="#权利运动的根源" class="headerlink" title="权利运动的根源"></a>权利运动的根源</h3><p>从本质上来说，我们的很多道德准则是一种违反直觉、文化和宗教的思考和行为；在这个过程中，我们的大脑借助移情和理性能力，设身出地的从他人的角度出发，得出某种更加合理的道德行为；启蒙运动以及它所带来的理性主义、自由主义、人本主义，扮演了重要的作用，是后续各种权利运动的重要根源；启蒙运动在早期的传播是缓慢的，但随着印刷技术、通讯技术、物流工具的日新月异，思想和人员得以在全球范围内快速传播；</p><h1 id="下册"><a href="#下册" class="headerlink" title="下册"></a>下册</h1><p>人性中的某些成分，是制作暴力的机器；但同时人性中还有其他一些成分，能够为我们带来和平；人性本身存在一体两面，一面是魔鬼，一面是天使；</p><h2 id="魔鬼"><a href="#魔鬼" class="headerlink" title="魔鬼"></a>魔鬼</h2><h3 id="暴力天性"><a href="#暴力天性" class="headerlink" title="暴力天性"></a>暴力天性</h3><p>很多人觉得人性本善，但事实上，人类最暴力的阶段是人类的幼儿时期；只是因为这个阶段的个体掌握的武器很少，因此不会造成巨大的伤害；以前人们一直在思考人类在长大的过程中，是如何习得暴力的；但其实这是一个错误的问题，正确的问题其实是反过来的，即暴力的天性是我们与生俱有的，而在长大的过程中，我们是如何学习控制自己，不会随意攻击他人；</p><p>当我们与对手势均力敌时，我们往往并不会向对方施加最大程度的暴力，因为我们意料到对方存在反击的可能性，这种恐惧感让我们保持谨慎和克制；但是如果某个时候，这种恐惧消除，我们能够确保万无一失，没有报复风险时，反而是我们施加最大程度暴力的时刻，因为此时毁灭性的暴力，有利于我们抓住稍纵即逝的机会，一举消灭敌人；</p><h3 id="自利偏差"><a href="#自利偏差" class="headerlink" title="自利偏差"></a>自利偏差</h3><p>人具有展示自身积极面的动力，将自我形象进行美化，作为社会性的动物，这是一项有助于增加繁衍几率的技能，因为这样可以增加他人同自己进行合作的概率；为了避免自我美化被他人识破，我们会在意识层面（骑象人）欺骗自己，从而对自己说出的话深信不疑（语言也是由意识层面进行组织的），这样才不会因为撒谎而被他人识破；</p><p>但是这种自欺行为是不彻底的，它只发生在意识层面；当我们的意识层面被干扰时，只能由潜意识来进行判断时，我们的自利偏差就会消失；也就是说，在潜意识层面（大象），我们一直知道真相；只是意识层面出现自利性的自我欺骗；</p><p>由于自利偏差的存在，在描述一件暴力事件时，施暴者和受害者的角度是非常不同的；二者唯一相同的一点是，他们都会站在自己的角度，为自己的行为进行辩护；</p><h3 id="暴力动机"><a href="#暴力动机" class="headerlink" title="暴力动机"></a>暴力动机</h3><p>暴力行为是动物行为的一个组成部分，有多种不同的脑回路（动机）会触发暴力行为，包括：</p><ul><li>寻求回路：例如捕食行为</li><li>愤怒回路</li><li>防守回路</li><li>优势回路</li></ul><p>暴力的五种分类：</p><ul><li>捕食：将暴力作为实现目标的工具，例如捕食行为；它主要由大脑中的寻求回路触发；</li><li>优势：追求对他人的优势或控制权；</li><li>复仇：用相同的暴力手段为自己受到的伤害进行反击，可由愤怒回路或者寻求回路触发；</li><li>施虐：享受伤害他人带来的愉悦，主要由寻求回路触发；</li><li>意识形态：寻求回路的集体化表现，召唤和组织同伴，通过暴力实现目标；</li></ul><h3 id="捕食"><a href="#捕食" class="headerlink" title="捕食"></a>捕食</h3><p>捕食型暴力将暴力作为实现自身目标的工具或手段，而对受害人没有任何的道德价值考量；人类历史上有大量的暴力行为是捕食性暴力，例如蒙古人的屠城，殖民者屠杀原住民、独裁者的政治清洗、罪犯杀害目击证人等；</p><p>在捕食过程中，如果受害人作出回击，往往会触发捕食者的愤怒回路；同时由于自利偏差的存在，双方会认为自己才是正义的一方，而对方是无理取闹；彼此的复仇开始掉入螺旋升级的漩涡，例如以色列和其阿拉伯邻国；</p><p>自利偏差除了出现在道德领域，还会出现在自我评价领域，也即积极幻觉；人们总是过高的评价自己的能力和好运气，同时还会低估自己遭受厄运的可能性；或许也可以说，积极幻觉跟自我美化其实一脉相承，有助于提升基因的繁衍几率；当人人都自夸时，说真话的人反而会吃亏，从而被淘汰；</p><p>过度自信很容易让人们做出过激的行为，例如对强大的敌人发起战争，自认为必将胜利（例如拿破仑和希特勒），结果是将双方拖入消耗博弈，两败俱伤；</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>优势的地位有利于资源（食物和性）的分配，因此通过竞争优势地位，并且尽量让更多的人知道自己的优势地位，是社会性动物的常态，也是雄性基因的一个重要组成部分；</p><p>实现优势竞争的方法可以是实质性的暴力，也有可能是表演性的暴力；很多物种（包括人类）的雄性在相互竞争时，会以不伤及性命的方式进行较量，当一方认输时，竞争即宣告结束，这一点和捕食性暴力存在很大的不同；</p><p>睾丸素水平的上升会让雄性更有意愿参加优势竞争，这在未婚的年轻男性身上最明显。而随着结婚和养育儿女，雄性的睾丸素会不断下降，从而让男性的注意力从争取交配权上面，更多的转移到养育后代上面；</p><p>人是社会性的动物，因此除了个体优势竞争外，我们还会将自己视为某个团体的一分子，与其他团体进行优势竞争，追求群落优势，例如以球队为代表的各种体育运动，爱国主义、民族主义、种族主义等；对自身所属团体的偏爱，是人的天性，无须习得；如何让自己保持公正，反而是一种需要习得的技能；</p><p>由于追求优势地位是雄性竞争的游戏，而雌性在这方面的天性则弱一些；因此当一个社会中的女性承担更多的责任和工作，拥有更大的社会影响力时，暴力发生的几率也会有所降低一些；</p><blockquote><p>但个体终究是组织机器的一个零件，因此，组织的规模越大越复杂，女性能够发挥的影响力也会随之变得越小；</p></blockquote><h3 id="复仇"><a href="#复仇" class="headerlink" title="复仇"></a>复仇</h3><p>复仇是人类的天性，因为坚定的以牙还牙策略，才能够让竞争对手有所忌惮，从而避免自己被占便宜；复仇人类很多暴力的动机，它是我们的大脑中一个很容易被触发的机关；当我们觉得自己受到欺骗或者其他不公正的对待时，我们会产生很强烈的复仇渴望，甚至愿意为此支付远超收益的成本；这种看似不理性的现象，从基因进化的角度来看，反而是理性的，因为我们需要建立威慑力，才能够避免自己再次受到伤害；复仇背后的动机是为了建立威慑，因此当复仇现场中存在第三方时，复杂行为常常会变得更加的严厉，以提高威慑的效果；</p><p>人性中的自利偏差，让我们严于待人，宽于律已。因此相同的暴力行为，在施害者和受害者的眼里，严重程度有很大的差别。这种差别最终会导致复仇行为没完没了，陷入死循环。就如古语所云，冤冤相报何时了；通过垄断暴力和秉持公正的第三方（国家和司法）介入，可以消除这种恶性循环；</p><p>虽然自利偏差会让复仇不断升级，但是也存在克制升级的因素，包括：亲缘关系、合作关系、对方主动道歉认错等；但道歉要有效果，必须建立在前面两点的基础上，即存在利益关系的情况下才有效果；如果竞争双方完全没有任何合作关系，那么道歉将很难获取另一方的完全信任；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221123184303.png"></p><h3 id="施虐狂"><a href="#施虐狂" class="headerlink" title="施虐狂"></a>施虐狂</h3><p>虐待狂出现的两个前提：</p><ul><li>享受其他人的痛苦，包括四种动机：<ul><li>对生命脆弱性的好奇；</li><li>获得优越感；</li><li>复仇；</li><li>享受快感：如性虐狂；</li></ul></li><li>无视限制施虐的制约；</li></ul><p>防止虐待他人的安全阀：</p><ul><li>悲悯之心；</li><li>文化禁忌；</li><li>生理反感；</li></ul><p>由于生理反感的存在，施虐行为并非天生的，而更多是获得性的；就像人们在克制了对酒、咖啡、茶等苦涩味道的初始反感后，慢慢从中习得快感；</p><h3 id="乌合之众"><a href="#乌合之众" class="headerlink" title="乌合之众"></a>乌合之众</h3><p>人们为了追求意识形态中宣扬的完善世界，可以不惜暴力为手段，造成了人类历史上无数的暴力记录；意识形态之所以容易造成极端，原因在于：</p><ul><li>完美主义，不接受折中；</li><li>为达目的，不择手段；</li><li>视其他异见为彻底的邪恶；</li></ul><p>意识形态的特别之外在于，它不产生于个体身上，而是诞生于群体之中；当个体处于群体之中时，就会涌现异于个体日常行为的新行为特征，即所谓的乌合之众；其中一个重要的原因是当个体将自己视为集体的一份子时，会造成部分自我的消失，因为它不再需要为自己的行为承担全部责任；由于存在从众压力，个体害怕变成异类，因此变得非常容易受到团体其他成员的影响，甚至会主动表现自己的忠诚；异见因此遭到压制，最终导致整个群体的行为和思想进入自我强化，变得越来越极端；</p><blockquote><p>社会心理学中有一些描述此类现象的术语，即人众无知、沉默的螺旋、阿比林悖论；当皇帝的新衣被揭穿时，会导致团体中的很多人的价值崩塌，为了避免出现这种情况，团体成员会自发的压制异见；</p></blockquote><p>当人们犯下恶行后，为了让自己的理性意识能够接受自己的行为，人们会主动美化恶行，自我欺骗，重塑对自身行为的认知，这些扭曲认识的方式包括：</p><ul><li>美化：用模糊两可的中性词汇，掩盖极端的恶行；</li><li>渐进：一开始是非常小的恶，当心理逐步接纳它时，慢慢演化成更大的恶；</li><li>免责：个体被告知不需要为自己的行为承担主要责任；</li><li>疏离：将受害者变成数字</li><li>贬低：将受害者非人化；</li><li>对比：别人比自己更坏；</li></ul><p>意识形态产生于我们原本的一些有益的天性，例如理性、逻辑、目的论等认知能力，它是认知能力这把双刃剑的另外一面；从某种角度来说，它是人类的不治之症；允许信息自由、充分流动的社会，产生有害的意识形态的风险降低；反之，一个社会越是封闭，越是信息审查，意识形态暴力发生的概率就会变得越高；</p><h2 id="天使"><a href="#天使" class="headerlink" title="天使"></a>天使</h2><p>除了黑暗的一面，人性中还存在光明的一面。在光明的一面中，存在几个坚实的力量，让暴力在我们这个时代终于出现了下降；</p><h3 id="移情"><a href="#移情" class="headerlink" title="移情"></a>移情</h3><p>人类的大脑中存在镜像神经元，但这些神经元并非移情的基础或原因；更准确的话，它们的作用是让我们能够想象他人的形为，从而作出更准确的判断；移情更像是一个开关，大脑自我利益的需要开启它，产生情感动机，影响我们的行为；例如当受害者是我们的同伴时，大脑就会开启它；当受害者是我们的敌人时，大脑就会关闭它；</p><p>影响移情开关的两个因素：</p><ul><li>当事人如何理解他人当前的处境同，例如是遭遇了不幸，还是罪有应得；</li><li>当事人如何理解跟他人的关系，例如是盟友，还是敌人；</li></ul><p>同情他人是人类的天性，但是它仅限于发生在共生关系圈里面，即我们的亲人和好友，而不太会发生在合作关系里面，例如工作上的客户、陌生人；</p><p>有两种动机会产生同情：</p><ul><li>自私动机：为自己可以不再目睹对方受苦，给对方提供帮助；</li><li>利他动机：将对方视为自己人，即使可以不用目睹对方受苦，也愿意提供帮助；</li></ul><p>对于陌生人，同情并非我们第一时间的条件反射，但故事（例如小说、电影）可以帮忙我们进入他人的视角，从而激发我们的同情反应；</p><blockquote><p>通俗小说的流行，与人道主义革命，在历史时间上的先后关系，或许并不是一种巧合；</p></blockquote><p>激发同情心并非解决问题的万能药，因为同情心自带的共生关系特性，它不可避免会产生不公平，即我们总是倾向于优先将资源分配给与我们关系最近的人；</p><h3 id="自制"><a href="#自制" class="headerlink" title="自制"></a>自制</h3><p>短视是人类的天性，毕竟在人均寿命只有 30 岁，物质匮乏的时代，及时行乐或许才是更好的生存之道；尽管如此，我们的大脑也存在自制回路；这个回路的能力是否强大，很大一部分跟遗传有关；并且它就像肌肉一样，在使用过程中会发生疲劳，同时也会随着练习变得强壮；</p><p>自制能力跟基因遗传有关，但暴力下降的太快，而基因的演化速度是以代际为单位的，远远慢于社会暴力规模的速度，因此很难说暴力的下降，跟人类基因的筛选有关；</p><h3 id="道德"><a href="#道德" class="headerlink" title="道德"></a>道德</h3><p>在道德禁忌下对他人施加的暴力数量，要远远多于战争和掠夺带来的伤害；太多的人类使用道德作为自己施加暴力的借口，自认为动机高尚；</p><p>道德感是一把双刃剑，在启蒙运动之前，它给整个人类社会带来的伤害，要远远大于福利；道德的可怕之外在于：</p><ul><li>人们认为道德是一种应该普遍被遵守的法则；</li><li>道德会成为人们追求的目标，而无须依赖物质奖赏；</li><li>人类认为违背道德者需要受到惩罚，甚至常常认为自己有义务伸张正义；</li></ul><p>虽然道德禁忌在全世界五花八门，但是背后有其本质上的共通之处；不管何种道德禁忌，最后都可以被大致归纳到以下几个模型中；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221124204414.png"></p><p>道德规范涉及的三要素：</p><ul><li>某人：例如丈夫、同事、邻居等某种社会角色；</li><li>某地：例如家里、商店、公司等某种场景；</li><li>某物：例如食物、钱、时间、劳动力等某种资源；</li></ul><p>不同要素的组合，会产生不同的道德规范；当某个人在某个场合，违反了公认的道德规范时，根据情节的严重性（资源的神圣性），其他人会出现程度不一的情绪反应，轻则困惑，重则愤怒；</p><p>资源交换的三种类型：</p><ul><li>常规交换：普通价值物品之间的交接，例如选择买 A 款车，还是选择买 B 款车；</li><li>禁忌交换：神圣价值与普通价值交换，例如为了金钱，出卖朋友；</li><li>悲剧交换：神圣价值与神圣价值交换，例如两个孩子只有一个有机会活下来，应该把机会留给谁；</li></ul><blockquote><p>政治家在宣传推广某个议案时，常常涉及利益分配的权衡，例如相同的财政预算，应该优先分配给哪个群体；为了推行自己的主张，政治家常常会将普通价值的东西，包装成神圣价值；例如将出兵侵略邻国，说成是确保我们国家的安全；将延长法定退休年龄，说成是为了减轻年轻一代的重负；</p></blockquote><p>多数道德规范在不同的地区、不同的时代有着非常大的差异；某个时代人们觉得理所当然的事情，在今天的我们看来可能觉得不可思议；但同时也有一些道德规范历久弥新，展示了时间和地理上普世性；一般来说，这类规范都有生物基础，例如与家人分享（社群）、尊重长者（权威）、帮助朋友（互惠）；</p><p>在人类的大部分历史中，部落或小规模团体是人们生活圈的主要形式，因此五种道德模型中，神圣、权威、社群占据了更多的权重；而在工业革命之后，随着商贸、物流、信息的自由和加快流动，传统的生活圈被打破了；于是道德规范的权重越来越倾向了另外两个模型：互惠、公平；这种变化趋势减少了因认为他人违反道德规范而引发的暴力惩罚；</p><blockquote><p>中东某些的国家，之所以和邻国关系紧张，很大一部分原因即在于他们觉得自己所捍卫的价值是神圣的，不能用其他利益进行交换，因此他们拒绝和对手进行谈判和妥协；</p><p>打开以上死结的一种可能办法，是将妥协进行神圣性的包装；让双方都觉得对方给出的妥协让步，是对某种神圣价值的承认和退让；当用神圣交接另外一种神圣时，就会大大降低对方产生愤怒的可能性；</p></blockquote><p>另外一种造成道德权重转移的力量，则是来着于当代社会对过往历史越来越深入的研究；当真实的历史被展示在眼前的时候，人们对过往传统的各种浪漫想象，也会随之瓦解；</p><h3 id="理性"><a href="#理性" class="headerlink" title="理性"></a>理性</h3><p>虽然大多数人在大多数生活小事上面，并非如经济学家曾经所假设的那样，是理性人；但是人性天生内置的道德感，是生命演化的结果，其中包含有理性的一面，尤其是在一些性命攸关的重大决策上；即使绝大多数人们无法用语言将其准确的表述出来；</p><p>理性当然不是解决问题的万能药，尽管它的力量有限，但是它仍然可以极大的降低因为无知而带来的巨大破坏；理性思考并不必然产生好的结果，因为这取决于思考者本身的目的是什么，理性本身只是达成目的的手段；如果思考者想要造成破坏，那么理性就会成为增加破坏性的有力工具；</p><p>人是自私的，同时人还具备社会性；因此，当外部社会能够营造一个通过合作实现利益化最大化的环境时，个体通过理性思考，就会更倾向于合作，而不是对抗；因为此时合作对个体更加有利；</p><p>逻辑推理并不是我们的天性，这方面的能力在进化过程中出现的很晚；但是当今社会，随着各个地区受教育水平的提高，个体能够从外部教育环境中习得逻辑推理能力，并有机会用于个体生活的方方面面，进而为自己谋求最大的收益；当一个群体越来越多的由具备逻辑推理能力的个体所组成时，他们就越容易找到实现整体利益最大化的游戏规则；虽然这个过程非常缓慢，但是它会逐渐进入强化循环的状态，越到后面，变得越来越容易；</p><blockquote><p>事实上，人类社会整体的平均智商一直在不断的持续进步，今天普通智商的个体，如果穿越到 100 年前，则变成了那个时代高智商的个体；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20221127210508.png"></p></blockquote><p>自人类诞生之日起，移情、自制、道德等能力就已经内置在我们的身体里面了，但是它们对降低人类暴力的作用相当有限；我们唯一可以寄托希望，只有理性的力量了；</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>与暴力下降趋势没有显著相关的因素：</p><ul><li>武器升级；</li><li>争夺资源；</li><li>经济水平；</li><li>宗教思想；</li></ul><p>与暴力下降趋势显著相关的因素：</p><ul><li>利维坦：国家对暴力的垄断；</li><li>商业贸易：合作创作财富，产生正和博弈；</li><li>女性主义：女性话语权增加；</li><li>移情延伸：识字率、城市化、发达传媒、人员流动；</li><li>理性滚梯：教育普及带来的逻辑推理能力的上升；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;上册&quot;&gt;&lt;a href=&quot;#上册&quot; class=&quot;headerlink&quot; title=&quot;上册&quot;&gt;&lt;/a&gt;上册&lt;/h1&gt;&lt;p&gt;暴力变化的一些重要节点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无政府状态进入有政府状态；&lt;/li&gt;
&lt;li&gt;小政府进入集权政府状态；&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="社科" scheme="https://ccw1078.github.io/categories/%E7%A4%BE%E7%A7%91/"/>
    
    
    <category term="历史" scheme="https://ccw1078.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>可能性的艺术</title>
    <link href="https://ccw1078.github.io/2022/09/12/%E5%8F%AF%E8%83%BD%E6%80%A7%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>https://ccw1078.github.io/2022/09/12/%E5%8F%AF%E8%83%BD%E6%80%A7%E7%9A%84%E8%89%BA%E6%9C%AF/</id>
    <published>2022-09-12T02:17:00.000Z</published>
    <updated>2024-09-23T00:53:33.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><h2 id="何为比较"><a href="#何为比较" class="headerlink" title="何为比较"></a>何为比较</h2><p>我们身处的现实，其实只是这个世界上一万种可能性中的一种；但由于大多数人没有机会经历或见识过其他可能性的样子，因此人们在直觉上常常以为自己身边的世界，代表了全世界的样子；其实这是很危险的，因为我们很容易因此变得狭隘，甚至自大，把个例误为普遍现象；在我们给事物下一个准确的判断之前，我们需要有一个标尺；而这个标尺，需要我们先收集足够多的可能性后，才有可能产生；</p><h2 id="政治的力量"><a href="#政治的力量" class="headerlink" title="政治的力量"></a>政治的力量</h2><p>经济基础决定上层建筑，从大的时间尺度来说，确实如此；但是作为上层建筑的政治制度，在较小的时间尺度内，对经济基础拥有很大的影响力；中国就是一个典型，同样一片土地、同样的人、同样的文化，在改革开放之前和之后，产生了天翻地覆的变化；</p><blockquote><p> 荷兰、英国、美国的崛起，以及中国历代王朝，莫不是如此；战争后，胜利的一方出现英明有力的领导人，建立有利的新秩序，然后引发经济的高速发展，国家开始变得强大；</p></blockquote><h2 id="政治的限度"><a href="#政治的限度" class="headerlink" title="政治的限度"></a>政治的限度</h2><p>政治的力量很大，但却非万能；影响一个国家命运的因素，除了政治制度外，还有其他很多重要的因素，例如文化、宗教、教育、经济周期、内部秩序、国际环境、地理资源等；</p><blockquote><p>达利欧在《原则2》 中罗列了大约 18 个左右的重要因素；</p></blockquote><h1 id="一、全球视野"><a href="#一、全球视野" class="headerlink" title="一、全球视野"></a>一、全球视野</h1><h2 id="1-比较维度"><a href="#1-比较维度" class="headerlink" title="1. 比较维度"></a>1. 比较维度</h2><p>国家最核心的能力是暴力的垄断，其次才是提供公共服务；当国家无法垄断暴力时，暴力就会分散在社会不同群体手中，导致持续的冲突和动荡，巴西、墨西哥等国家即是例子；提供公共服务的前提是政府要有钱，因此征税能力大小，决定了政府提供服务能力的大小；</p><p>民主还是威权，它并不是国家能力大小的原因，更多只是一种决策方式而已，而且也跟决策质量无关；而是跟决策幅度有关；民主能一定程度限制政府的决策范围，避免政策对社会过度汲取；威权则缺少这种限制，只能靠统治阶级自觉；</p><p>政治存在于社会之中，社会是政治生根发芽的土壤；目前暂时还不存在能够医百病的万灵政治药方；不同文化、不同经济，不同宗教，都会对政治的生长带来影响，相同的种子，会长出不一样的果实；橘生淮南与淮北之别；</p><h2 id="2-黄金时代"><a href="#2-黄金时代" class="headerlink" title="2. 黄金时代"></a>2. 黄金时代</h2><p>基因决定了人们只会关注当下，而不是回望过去；只关注自己缺少的，而不是自己已经拥有的；这种天性往往让我们忘记了人类的历史是如何一路走过来的，从而忽略了当下的我们正幸运的生活在异于过往任何历史时期的一个黄金时代中；物质极大的丰富，人均寿命历史顶峰，战争相当遥远，只存在于影视剧中；</p><p>人们更愿意用自己想象中的理想生活，来比照当下的缺失，而不是对照历史，检查自己已经拥有了什么；这种倾向是危险的，因为当我们不知道自己一路如何走来，如何才获得了今天的成就，就瞎折腾的话，最终常常非但没有解决问题，反而创造了更多的问题；</p><h2 id="3-国际格局"><a href="#3-国际格局" class="headerlink" title="3. 国际格局"></a>3. 国际格局</h2><p>在这个业已全球化的时代，没有任何一个国家可以再像古典时代一样，实现与世隔绝，小国寡民，独善其身；不管是否愿意，每个国家的命运，都跟周边甚至遥远的国家戚戚相关，例如英国对印度的殖民，美国对朝鲜的封锁；从某种意义上来说，世界的物理距离已经大大缩小，地球相当于变成了一个村；</p><p>人们对日常生活中接触到观念经常习以为常，潜移默化，以至于我们常常忘了它的出处；民主、自由、平等等观念在今天天广为人知，但事实上这些观念是很新的产物，在 100 年前的中国，几乎没有人知道这些观念是什么东西；而我们现在之所以知道了这些观念，恰恰是因为信奉这些观念的某些强大国家，成功的实现了文化输出；</p><p>这些自由主义的观念缘起于欧洲的思想启蒙运动，但有趣的是，它成了某些实力强大的国家的治国理念；然后这些强权国家持续的经济和文化输出，让这些观念也逐渐出现在发展中国家的日常生活中；</p><p>对于普通民众来说，他们真的在乎拥有绝对的自由吗？所谓自由，更有可能只是某些知识分子的一厢情愿，对于普遍老百姓来说，安全而有归属感的小日子才是他们的人生追求，最多再加上一点点民族自豪感；所以，对于大多数小国家来说，更好的做法或许是回归现实，过好自己的小日子，尽量避免卷入其他国家的战争，保存自己的实力，以期实现长治久安；</p><blockquote><p>对于中美两个大国来说，随着中国崛起后带来的贸易摩擦以及台海问题，对于处在时局中的个体来说，可能面临的挑战是树欲静而风不止；</p></blockquote><h2 id="4-全球化"><a href="#4-全球化" class="headerlink" title="4. 全球化"></a>4. 全球化</h2><p>全球化让资本、原材料、技术实现了自由流动，总体上来说，它提高了资源配置效率，降低了生产成本，让整个世界变得更加富有起来了；但是这种进步发生得太快，它不像工业革命，通过几代人的努力，才实现对外传播；而是在短短的 20 年内，就造成了天翻地覆的变化，中国就是这种变化的最大见证者；</p><p>进步太快造成的问题是，它导致了某些阶层没有足够的时间来适应这种变化，他们面临的困境，或许就像中国 98 年的国企改革下岗潮一样。还没有熬到退休的年龄，但工作已经没了；</p><p>人是有迁移和学习惰性的，经济发展会造成地理上的不平衡，例如中国东部比西部更发达，美国亦是如此；对于受到全球化伤害的那些美国人来说，他们面临的处境就跟当年东北下岗的中年人一样；更糟糕的是，东北人面临的只是南方人的竞争，他们可以通过迁移南方来解决问题；但是当代工人面临的还有机器自动化的竞争，机器人也在跟他们抢饭碗；</p><p>全球化带来的挑战，本质上是发展过快所必需付出的代价；解决挑战的办法，不是开历史倒车，而是需要政府积极干预，帮忙那些失业工人再上岗；就像中国政府过去多年的扶贫政策，帮助那些大山里面的人们走出来，迁移到城镇生活一样；</p><h2 id="5-文化反弹"><a href="#5-文化反弹" class="headerlink" title="5. 文化反弹"></a>5. 文化反弹</h2><p>大多数人的价值观一旦形成，便终身几近不再改变；全球化除了带来商品的流动，还会带来文化的流动；当某种外来文化在很短的时间内在全社会传播开来后，它首先会被年轻人所接受，因为年轻人更接近白纸，没有旧观念的束缚；之后随着涉及人群的蔓延，它最终会到达那些秉持传统价值观念的人群；当这些人惊讶的发现自己已经成为少数派时，会触发他们的危机意识；他们会站出来，努力捍卫传统观念的价值；</p><p>如果文化输入的速度缓慢一点，通过代际慢慢消化，就比较不容易引起反弹现象，社会冲突也会更少；观念的融合是需要时间的，它非一朝一夕之功，而是需要好几代人的努力才有可能完成；</p><h1 id="二、政治转型"><a href="#二、政治转型" class="headerlink" title="二、政治转型"></a>二、政治转型</h1><h2 id="6-民主转型"><a href="#6-民主转型" class="headerlink" title="6. 民主转型"></a>6. 民主转型</h2><p>民主并非目的，而只是手段；安全有序的稳定生活才是人们的首要目标，民主制度并不意味着必然的安全稳定，二者其实并没有本质上的联系；威权制度同样可以带来安全和稳定，例如中国；民主最大的作用，在于为公权力的过渡扩张设置一道防护网；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220910120544.png"></p><p>设立民主制度，决不意味着制度能够自动落地实施，二者之间有一段漫长的道路要走；政治在社会中，因此政治制度的有效实施，需要社会具备合适的土壤条件，它才有可能生根发芽。有可能土壤在一开始就是适合的，但这只是极少数的例外情况；在过去 5000 年的人类社会中，绝大多数人从来没有听说或了解过这个概念；因此，缺少让民主快速生根发芽的土壤，是绝大多数国家的常态；它可能需要好几代人长达上百年的努力，才有可能逐渐改善土质，最终达到成功；这个过程注定不会是一帆风顺的，而更可能是血雨腥风，起起伏伏，进两步退一步的过程；虽然观念的改变是缓慢的，但好的观念有其内在的生命力，随着时间推移，它慢慢就会在每一代人中脑海中扎根，积少成多，聚沙成塔，最终导致量变引起质变；</p><h2 id="7-民主稳固"><a href="#7-民主稳固" class="headerlink" title="7. 民主稳固"></a>7. 民主稳固</h2><p>法国是近代思想启蒙运动的发源地，相比英国和美国，其民主化转型的步伐更加彻底和激进，其转型目标并不局限于政治变革，还同时计划实现经济、社会、文化等一系列改革，因此被后人描述为“大革命”；革命运动给社会带来了剧烈的震荡；但欲速则不达，其结果也同样是惨烈的；</p><p>民主转型的成功，并不必然意味着民主的稳固；国内秩序大周期背后是财富和权力的再分配，绝大多数情况下，它都是通过武力来实现的，成王败寇，胜利者制定最终的秩序；至于这种秩序是否民主，完全由胜利者根据情况随机应变；民主只不过是获取权力的一种手段和工具；当目标达到后，工具可能不再需要而被抛弃；民众观念的水位，决定了转型后的下一步走向，是实现民主的巩固，还是转向威权；江山易改，本性难移。想要在短期内改变人们的思想观念，难于上青天；因此大多数国家在民主转型成功后，又随即进入民主衰退，是合乎情理的大概率事件；</p><h2 id="8-威权倒台"><a href="#8-威权倒台" class="headerlink" title="8. 威权倒台"></a>8. 威权倒台</h2><p>人们常常天真的以为只要威权倒台，就能自动实现民主的落地；事实上，二者中间还隔着十万八千里，最后更可能出现的情况是新威权的崛起。因为搞破坏很容易，谁都可以干；而搞建设很难，只有少数强有力的英明领导者才有可能胜任；</p><p>民主意味着由人民当家作主，但社会是多元化的，内部是各种利益细分群体；在威权体制下，不同利益群体能够实现团结，以对付更大的敌人；但是当外部威胁消失时，民主机制所需要的社会动员，就会让不同群体之间的利益区别浮上水面，从而加深社会群体的分裂；人心不齐，寸步难行；有人要向东，有人要向西，最后很多时间都花在了争吵上面；</p><p>当各群体过于情绪化而不再遵守规则时，社会将重新陷入混乱；于是乎人们又开始呼吁强权来收拾残局，导致威权重现；人性天生的短视，注定了民主过程不可能是一帆风顺的；最终转型能否成功，很大程度依赖于某位强有力的领导人，能否制定出一套有效的新秩序，让整个国家走上正确的轨道，例如中国的邓小平；</p><h2 id="9-共同底线"><a href="#9-共同底线" class="headerlink" title="9. 共同底线"></a>9. 共同底线</h2><p>民主会暴露社会裂痕，虽然基于过半数的选票即可完成选举；但完成选举并不意味着社会分裂的消失；对于那些在选举中失败的群体来说，他们自然会担心自己的利益受损；对于胜利者，能否制度一套有效解决分歧的机制，让双方的裂痕通过机制实现缝合，是决定民主能够稳固的一个重要因素；痛打落水狗是容易的，但它只会带来反抗；对失败者的宽容、接纳与合作，才是艰难而伟大的作法；</p><p>与胜利者的宽容同等重要的，是失败者的心态；愿赌服输，尊重规则和共同的底线，努力在未来扳回一城，这样游戏才有可能玩得下去，而不是恼羞成怒，掀翻棋盘；成功的婚姻，需要夫妻双方共同的努力，失败的婚姻，则只需其中一方摆烂就可以了；一个国家能达到什么样的水平，背后的本质首先是其民众是什么样的水平；当民众水平不足时，民主制度是不可能顺利运转的；</p><h2 id="10-民主局限"><a href="#10-民主局限" class="headerlink" title="10. 民主局限"></a>10. 民主局限</h2><p>民主最大的作用，是限制公权力，它本质上是一个决策程序而已；有好的决策程序，并不意味着好的决策结果；因为最终做决策的是人；如果决策的人本身水平有限，那么决策程序再好也没有什么卵用；同理，威权体制也是如此；中国便是最好的例子；</p><p>印度虽然建国之后便实现了民主转型，但是其经济政策一直沿用苏联的计划经济，跟中国早期一样；印度的改革开放始于90 年代，之后印度经济便开始逐渐进入快车道，快速增长了起来。虽然今天的印度依然存在诸多的问题，但只要方向正确了，问题的解决只是时间的问题；其隔壁的巴基斯坦兄弟，虽然走的是类似中国的威权主义的道路，但其国内经济目前仍然在低位徘徊；</p><h2 id="11-社会压迫"><a href="#11-社会压迫" class="headerlink" title="11. 社会压迫"></a>11. 社会压迫</h2><p>政体的改变是相对容易的，一场战争或者革命，胜利者便能够决定采用何种政体；但是社会的风俗习惯和文化观念的改变是非常缓慢的，它需要几代人的努力才有可能实现；但某种旧的观念习俗，存在着不公正时，例如印度的种姓制度，那么即使政府的法律是公正的，这种社会的不公正消亡，也将经历一段漫长的过程；</p><p>当政府的法律能够站在一个公正的立场时，那么这种社会不公的消失虽然缓慢，但终究是时间的问题；但如果政府本身也是不公的，那么社会不公的消失，就变得遥遥无期了，以至于只能寄希望于下一场战争和革命了；</p><p>更糟糕的是，社会不公会反噬民主，让民主劣币化；民主的有效，依赖于自由平等的竞争，让高效者获益；但是社会不公会限制公平的竞争，让低效者胜出，这也是为什么腐败在印度如此普遍的原因；</p><p>经济基础决定上层建筑，印度今天的种姓制度，源于过去几千年的农业经济和地理环境；随着工业经济、市场经济和资本主义越来越在印度经济中占据主导地位，其带来的一系列社会影响，将慢慢重塑印度社会的观念和习俗，就像中国今天；</p><h2 id="12-威权浪漫"><a href="#12-威权浪漫" class="headerlink" title="12. 威权浪漫"></a>12. 威权浪漫</h2><p>如同民主有局限性一样，威权同样也不是万能的；历史上像邓小平、李光耀这样伟大的威权人物，其实是屈指可数的；更多的是萨达姆、金正日之类的人物；独裁不一定意味着强权，历史上的独裁，更多是以弱独裁的形式存在的，例如民国时代的蒋介石，今天的拉丁美洲国家等；如果一个国家想要实现完全的暴力垄断，那么几乎不可避免要通过一场血流成河的内战来检验各方最终的实力；</p><p>民主的道路是曲折漫长的，威权的道路则是随机赌博的，世上没有万能的解药，政治的背后是社会的复杂性，每个国家做何选择，需要具体情况具体分析，而非一概而论；</p><h1 id="三、国家建构"><a href="#三、国家建构" class="headerlink" title="三、国家建构"></a>三、国家建构</h1><h2 id="13-何为国家"><a href="#13-何为国家" class="headerlink" title="13. 何为国家"></a>13. 何为国家</h2><p>国家的本质是在特定地理范围内实现对暴力的垄断，汉字“國”的繁体写法，说明古代中国已经明白了这一点；其实暴力的分散是自然界的常态，而暴力的垄断反而是一种反常现象；如果一个国家不能实现暴力垄断，那么国家的长治久安就无从谈起，而政府提供公共服务的能力更是要大打折扣；中国由于在 2000 多年前就实现了大一统，因此其暴力垄断和官僚机构有着世界上最悠久的历史，以至于绝大多数中国人已经对此习以为常了，但其实它很不寻常；当下国家仍然晚近出现的国家，受此问题的困扰，例如非洲和拉丁美洲的国家；暴力的垄断和集中，需要一场你死我活的漫长斗争过程，才有可能最终实现；</p><h2 id="14-国家能力"><a href="#14-国家能力" class="headerlink" title="14. 国家能力"></a>14. 国家能力</h2><p>产权的明晰有利于提高效率，因为不明晰的产权，很容易出现公地悲剧；所有人都只想索取而不想投入，最后的结果便是竭泽而渔，国家的出现本质上也是一种产权明晰的过程；</p><p>国家能力的大小，对于社会是非常重要的，因为伴随着暴力的垄断，暴力的发生频率也随之指数级减少；其次强大的国家能力意味着强大的征税能力，没钱难办事；没有税收的保证，政府能够提供的公共服务便非常有限；第三，强大的国家能力也是社会秩序的保证，稳定有序的社会，经济活动才会有繁荣发展的前提；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220910231304.png"></p><p>人们总是将自己熟悉的日常事务当做某种理所当然的常态，但如果我们跳脱当下，着眼于更大的时间和空间跨度来观察时，就会发现事实并非如此；中国历史悠久的中央集权和官僚系统所造就的强大国家能力，对很多控新兴国家来说，其实是非常奢侈的；</p><h2 id="15-战争的作用"><a href="#15-战争的作用" class="headerlink" title="15. 战争的作用"></a>15. 战争的作用</h2><p>从封建制度的权力分散状态，走向中央集权的状态，是一种国家能力的进步；中国是世界上最早完成这种转型的国家，欧洲则晚了约 1500 年才发生这种转变；</p><p>战争是残酷的，结果是惨烈的，非生即死；在这种极端状态下，人们不得不想尽一切办法来获取胜利；这种置之死地而后生的状态，也间接催化出了各种进步；例如权力的集中、技术的创新、制度的变革等；</p><p>秦国之所以能够统一中原，缘起于商鞅变法；那些固守传统的国家，在战争中被打败消灭了；最后活下来的国家，就是那些采用了新技术和新制度的国家；</p><p>从某种意义上来说，战争是国家建构所要付出的代价；因为如果没有战争，就难以统一分散的权力，难以实现对暴力的垄断；</p><h2 id="16-官僚系统"><a href="#16-官僚系统" class="headerlink" title="16. 官僚系统"></a>16. 官僚系统</h2><p>战争可以完成“打天下”的目标，但是实现暴力的垄断，仅仅意味着国家能力的前提，而不是落地；要实现皇权下县，政令通行，需要有一套高效的官僚系统；统治者借助该系统，完成对国家的有效管理，而不是山高皇帝远，政令不出中南海；组织即效率，拥有高效的组织，统治者才能实现强大的动员能力，不管是集中财政办大事，还是集中兵力打大战；</p><p>中国有历史悠久的文官制度，这种早熟在全世界范围是极其罕见的，甚至可以说是独一无二的；其他国家最少也是近 200 年左右才开始出现相同的制度；古代中国，皇帝为了实现权力的集中，必须时刻警惕那些可能对自身权力构成威胁的力量，例如尾大不掉的地方军事势力、富可敌国的商人、信众如云的宗教领袖等；这些人对于皇帝来说都是非常危险的，需要加以限制；</p><p>仅靠皇帝自己显然不可能完成这种限制，因此皇帝需要培养自己的势力，这些势力必须是安全的，不会对自己构成威胁，同时还必须是优秀的人才，才有能力去完成各种困难的任务；历朝历代经过反复试错，最后发现最靠谱的办法，还是通过考试从平民中选拔，同时不允许权力世袭；这样就可以确保其忠诚，并且攘天下英才为已用；</p><p>但国家能力也并非也越大越好，因为物极必反；当领导者英明神武时，自然突飞猛进，一日千里；但如果领导者昏庸无能，那么带来的破坏力，也同样是一日千里；</p><h2 id="17-社会运动"><a href="#17-社会运动" class="headerlink" title="17. 社会运动"></a>17. 社会运动</h2><p>美国是一个非常特殊的国家，绝大多数国家都建立在一片拥有皇权历史的土地之上；但美国是建立在一片没有出现过任何皇权历史的土地上；美国原本是大英帝国的殖民地，美国独立战争的初衷，并不是为了建立自己的国家，而是为了摆脱英国的集权统治；战争胜利后，军队也马上就地解散了；后续只是因为部分代表觉得这是一个成立国家的好机会，大家才重新聚集在一起进行商讨，最终达成共识；但为了避免从一个火坑跳进另外一个火炕，美国反联邦的国父们，殚精竭虑的设计了种种机制，对国家权力进行制衡，甚至不惜让民众保留持枪的权力，以作为最后捍卫个体自由的底线；</p><p>美国国父们的梦想，原本是小政府大社会，但随着时代的变幻，美国政府已今非昔比，财政收入占 GDP 比重从100 年前的 8% 上升到了现在的 30-40% 左右，国家能力已经变得非常强大，同时军费支出也非常庞大，因此它不但保护着自己，还保护着欧洲日本很多盟国；几方面的原因，造成了美国政府职能的转型，一是战争（两次世界大战），二是经济（债务危机），三是公民运动，政府被迫承担越来越多的职责和责任，于是机构和能力也随之变得越来越庞大了；</p><p>除了通过战争来推动改革外，美国和印度则提供了另外一种可能性，即通过社会运动；因为战争的代价过于高昂，而成熟的官僚系统则可遇而不可求；</p><p>但即使社会运动具备可复制性的特征，它仍然强烈依赖于民众意识的觉醒和素质的提高，我们很难期待贫瘠的土壤能够收获理想的果实，印度即是例子；</p><h2 id="18-建构障碍"><a href="#18-建构障碍" class="headerlink" title="18. 建构障碍"></a>18. 建构障碍</h2><p>国家建构并非在一张白纸或者一片空地上，建设一个新的国家和制度，它受限于各种各样的现实条件；这些条件有时会起正面作用，例如同质化的单一民族，让建构变得顺利；有时会起负面作用，让建构变得异常困难；</p><p>如果从全世界所有国家中，选择建构过程最为命运多舛的国家，想必可能非阿富汗莫属，其遇到的障碍包括：</p><ul><li>地理环境：整个国家都是山，地理屏障导致易守难攻，统一成本很高，历史上长期处于封建部落状态；</li><li>地缘政治：周边都是大国，夹在中间，成为大国斗争的棋子，树欲静而风不止，无法获得长期的和平状态；</li><li>民族结构：由多民族组成，统一思想观念的成本高；</li><li>宗教势力：极端宗教主义难以和世俗政治理念相融；但极端宗教并非原产于阿富汗，而是苏联入侵导致上百万难民逃往巴基斯坦后，在当地的宗教学校习得的；乱世为宗教原教旨主义提供了成长环境，就像当年日本侵华，帮忙共产党获得了成长机会一样；</li></ul><h1 id="四、政治文化"><a href="#四、政治文化" class="headerlink" title="四、政治文化"></a>四、政治文化</h1><h2 id="19-观念水位"><a href="#19-观念水位" class="headerlink" title="19. 观念水位"></a>19. 观念水位</h2><p>引起政治制度变革的因素有很多，可以是经济因素，例如欧洲资产阶级和无产阶级的兴起；也可以是战争因素，例如中国的辛亥革命推翻了清王朝；也可能是外部因素，例如二战后美国对日本的统治；但最根本的因素，还是人们的观念；当某种观念开始普及之后，它就会慢慢推动社会变革；同理，如果社会变革超前人们的观念太多，那么这种变革在落地过程中，不可避免会被打折，被迫回归民众的认知水平；</p><blockquote><p>因此对于统治者来说，控制宣传，控制和引导人们的观念是非常重要的；</p></blockquote><p>观念不会无中生有，它首先需要有星星之火，之后才有机会燎原；星星之火并不难，因为 300 年前欧洲的启蒙运动已经为后人种下了火种；当一个国家的经济发展到一定的程度，人民群众解决了温饱问题后，社会主要矛盾会发生变化，例如变成追求平等和正义；如果此时威权领导者没有主 意识或能力引导人们观念的话，那么启蒙思想就会慢慢在人群中扩散开来，最终成为燎原之势，例如韩国；</p><h2 id="20-规则意识"><a href="#20-规则意识" class="headerlink" title="20. 规则意识"></a>20. 规则意识</h2><p>民主并不是简单的改成一人一票的选举后，就叫民主了；“人民当家作主”这六个字，有巨大的内涵，背后需要的门槛非常高。它意味着绝大部分事情再也没有人为我们做决策了，而是需要我们自行组织起来，进行决策；这个过程非常的不简单，它要求大多数公民具有与他人组成团队、制定规则、相互合作、遵守规则，相互妥协，最终形成决策的能力；这种能力，没有相当程度的受教育水准，对于普通人来说，是完全不可想象的，大部分中国人连自己的小区都还管理不好；所以，对于大多数国家来说，民主转型是相对比较容易的，但转型之后，想要实现民主的落地和稳固，则成功者廖廖；</p><p>政治是妥协的艺术，而不是地痞流氓式的意气用事；参与各方需要拥有足够的智慧和耐心， 寻找共赢的方案，退让妥协、各取所需。这些理念的实施和落地，对国民素质的要求是很高的；它决非一朝一夕之功，而是需要几代人的努力和实践才有可能完成；欲速则不达，民主的稳固并没有捷径可走；从另外一个角度来，民主的本质更像是国民素质提高后的一个副产品，而不是原因；</p><h2 id="21-乌合之众"><a href="#21-乌合之众" class="headerlink" title="21. 乌合之众"></a>21. 乌合之众</h2><p>人其实是情绪化的动物，基因决定了我们的天性如此，因为这种决策机制最节省能量，理性的思考决非我们的常态，它需要刻意的训练才有可能实现；当一些非理性的人组成一个庞大的群体时，人性中非理性的一面将被指数级放大，因为身处群体中的个体，再也不需要思考了，一切责任不再是个体的责任，而变成了组织的责任；当个体可以从不道德的行为中获益，却无须为其承担道德或法律责任时，那么人性中恶的部分将被最大程度的激发，整个组织很容易陷入狂热的非理性状态；此时统治者还会通过宣传新的意识形态，来为种种邪恶行为穿上正义的外衣，让执行恶的人再也没有心理上的负担，例如纳粹对犹大人的屠杀；</p><h2 id="22-观念差异"><a href="#22-观念差异" class="headerlink" title="22. 观念差异"></a>22. 观念差异</h2><p>不管是出于地理，历史还是其他原因，不同地区的人们，在某个特定的时间点，其文化差异是客观存在的。这种差异性更多时候体现为价值顺序不同，有些人认为自由先于秩序，有些则反过来；但有趣的是，这种价值观念上的差异，并非人生一出生就自带的，而是从环境中习得的。</p><p>当谎言重复一千遍，就会变成真理，这就是人性的弱点；当某种错误的说法总是在我们的身边反复出现时，我们就会不自觉的接纳它，并将它当作自己主动选择的想法；文化差异会带来冲突，比较糟糕的是观念的冲突跟利益冲突不同，后者是可以协商的，但观念常常是非此即彼，没有协商的余地，因此化解人们心中的观念冲突难度很大；</p><p>当一个国家处于发展上升期时，大家的生活都在改善，普遍都变得更好了，这时出现观念冲突并不明显。但是当一个国家的经济开始走下坡路，蛋糕不断缩小，人们就蛋糕如何分配，有各自不同的想法。于是冲突开始浮上水面；</p><p>财富分配不均是所有国家发展过程中必然会出现的副作用，不同群体之间的财富差距会自然的变大；政府如何应对这一挑战，能否积极有效的干预，极大的关系到了社会矛盾是否会进一步激化，还是会慢慢缓和；</p><h1 id="五、政治经济"><a href="#五、政治经济" class="headerlink" title="五、政治经济"></a>五、政治经济</h1><h2 id="23-政治与经济"><a href="#23-政治与经济" class="headerlink" title="23. 政治与经济"></a>23. 政治与经济</h2><p>政治制度的转型与否，转成什么样的类型，都不必然保证经济会良好发展。因此经济健康发展与否，有自身的一套规律。只要政府按照规律行事，经济自然就会健康发展；反之，如果政府蛮干乱来，例如中国的大跃进运动，那不管是威权政府还是民主政府，最终的结果都是一团糟；</p><h2 id="24-乱来的后果"><a href="#24-乱来的后果" class="headerlink" title="24. 乱来的后果"></a>24. 乱来的后果</h2><p>经济的发展有其固有的规律，但有些政治浪漫主义者，近者如中国的毛泽东，远者如委内瑞拉的查尔期，不顾这些客观规律，认为人定胜天，强制实施了一些倒行逆施的经济政策，其结果便是将整个国家拖入了经济崩溃的深渊；</p><h2 id="25-贫困"><a href="#25-贫困" class="headerlink" title="25. 贫困"></a>25. 贫困</h2><p>自由市场经济不可避免会带来财富分配不均，那些善于此道的人，会掌握更多的财富；而缺少经济头脑的人，则获得的财富要少一些；多劳多得，这本身没有什么问题；但要命的是，这种差异会自我强化，财富越来越往少数人集中，并在代际中传承；当政府不强制干预进行财富再分配的，它将带来一系列的负面影响，最终导致国内秩序崩溃；</p><p>很多时候这种财富不均并非富人对穷人的剥削造成的，而更多是技术进步和产业升级造成的，掌握技术的群体获得了大量红利和财富；技术进步的速度越来越快，使得一些人的工作在还没有退休之前就消失了，于是导致这些人陷入了贫困之中；</p><h2 id="26-局限性"><a href="#26-局限性" class="headerlink" title="26. 局限性"></a>26. 局限性</h2><p>政治的下限很低，错误的制度，会让一个国家变成人间地狱，民不聊生，恶殍遍野，尸骨如山，就像萨拉姆曾经给伊拉克人民带来的灾难一样；但正确的制度，上限也很低。所谓的政治，本质上只是一种决策机制；跟是否能够得到好的决策无关；决策好坏，完全取决于决策人本身的认知水平，也即国民的素质，认知观念的高度；制定良好的政治制度好比设计了公平合理的游戏规则，但规则再好，一群菜鸟也不可能踢出一场好球；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;h2 id=&quot;何为比较&quot;&gt;&lt;a href=&quot;#何为比较&quot; class=&quot;headerlink&quot; title=&quot;何为比较&quot;&gt;&lt;/a&gt;何为比较&lt;/h</summary>
      
    
    
    
    <category term="社科" scheme="https://ccw1078.github.io/categories/%E7%A4%BE%E7%A7%91/"/>
    
    
    <category term="政治" scheme="https://ccw1078.github.io/tags/%E6%94%BF%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>原则-应对变化中的世界秩序</title>
    <link href="https://ccw1078.github.io/2022/09/06/%E5%8E%9F%E5%88%99-%E5%BA%94%E5%AF%B9%E5%8F%98%E5%8C%96%E4%B8%AD%E7%9A%84%E4%B8%96%E7%95%8C%E7%A7%A9%E5%BA%8F/"/>
    <id>https://ccw1078.github.io/2022/09/06/%E5%8E%9F%E5%88%99-%E5%BA%94%E5%AF%B9%E5%8F%98%E5%8C%96%E4%B8%AD%E7%9A%84%E4%B8%96%E7%95%8C%E7%A7%A9%E5%BA%8F/</id>
    <published>2022-09-06T14:00:00.000Z</published>
    <updated>2024-09-23T00:52:40.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-世界是如何运转的"><a href="#第一部分-世界是如何运转的" class="headerlink" title="第一部分 世界是如何运转的"></a>第一部分 世界是如何运转的</h1><h2 id="1-大周期简述"><a href="#1-大周期简述" class="headerlink" title="1. 大周期简述"></a>1. 大周期简述</h2><p>人性的亘古不变决定了人类历史在某种程度存在反复兴衰循环的规律性，包括债务周期、内部周期、外部周期；</p><blockquote><p>国家由个体组成，因此在某些方面的表现跟个体相似；例如随着个体拥有的财富变多，个体就容易变得过度乐观和过度扩张，从而在应对外部的意外事件时，变得脆弱；进而引发矛盾和革命；经济繁荣常常伴随着债务融资泡沫，因为在顺境时，人们总是容易变得过度乐观，以为当前的状态将永远持续下去；</p></blockquote><p>生产力的进步跟人类的知识积累有关，因此它总体上处于稳定且缓慢的上升趋势中，但生产关系则是一种螺旋状态；</p><blockquote><p>生产力的进步让人类能够创造出更多的东西，例如相对我们的祖先，我们拥有的资源更少，但是我们能够创造的物品却更多了，因为我们掌握了更多利用资源的知识和技术；</p></blockquote><blockquote><p>全球实际人均 GDP （取对数值）</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220717180952.png"></p></blockquote><blockquote><p>全球预期寿命</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220717180823.png"></p></blockquote><p>在工业革命之前的农业时代，土地是最重要的生产资料，其对应的生产关系包括国王、贵族、教会等；工业革命后，工业品替代了农产品的主导地位，以资本主义为代表的新型生产关系替代了旧关系；</p><p>提高生产力除了人和生产资料外，还需要资金；而资本主义最重要的作用，是通过建立贷款、债券和股票市场，吸收人们的储蓄，转化成投资，为最具创造力的企业家提供资金，帮忙他们实现创新和发展；</p><p>资本市场为拥有创新想法的生产者提供了资金，使其能够生产产品，创造财富；但与此同时，资本市场也为消费者提供了资金，从而导致容易过度负债，进而加大财富差距，造成社会不公和爆发革命；</p><blockquote><p>虽然从数字曲线观察一场经济危机时，其下跌幅度让人感觉到触目惊心。但身处其中的人们，却是另外一番感受。大部分人并没有失去他们的工作，也没有大量的人口死亡。人们仍然重复着日复一日的生活，唯一的区别可能是生活比过往变得更加艰难了一些；相比之下，天灾和战争给人们带来的感受更加深刻和剧烈；</p></blockquote><p>经济下行周期通常会持续 2-3 年，主要取决于债务重组和债务货币化所花费的时间；如果政府迅速通过印钞填补债务缺口，那么通缩性萧条就会越快结束；</p><blockquote><p>天灾和战争造成的死亡人数</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220717183320.png"></p></blockquote><p>虽然战争和自然灾害给人类社会带来巨大的破坏，但人类拥有顽强生命力，一般在 2-3 年后便能够适应并复原过来；</p><h3 id="大周期中的财富和权力转移"><a href="#大周期中的财富和权力转移" class="headerlink" title="大周期中的财富和权力转移"></a>大周期中的财富和权力转移</h3><p>虽然国家不是严格意义上的生命体，但由于国家是由一个个的个体所组成的，因此它同样拥有自己的生命周期；当某个国家创造或拥有的财富越过其他国家时，它不可避免会变成一股主导势力，进而影响到其他国家；</p><blockquote><p>不同历史时期各个国家的相对地位（最近 500 年）</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220717190140.png"></p><p>最近 1500 年：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220717190220.png"></p></blockquote><h3 id="财富和权力的八个决定因素"><a href="#财富和权力的八个决定因素" class="headerlink" title="财富和权力的八个决定因素"></a>财富和权力的八个决定因素</h3><p>决定一个国家财富和权力的 8 个主要因素：教育、竞争力、创新和技术、经济产出、世界贸易份额、军事实力、金融中心实力、储备货币地位；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220803204648.png"></p><blockquote><p>问：好奇教育指标为什么最早下降？</p><p>答：此处的教育不仅包括传授知识和技能，还包括培养坚韧性格、良好修养和职业道德，从而让人们能够尊重社会规则和法律秩序，并拥有奋斗精神；看到这里，我终于知道教育指标为什么会下降了；因为随着人们的生活变得富裕，后续出生的孩子，越来越少需要帮忙分担家庭责任，从而导致在成长过程中，失去了责任感和坚韧性格的培养过程；</p></blockquote><h3 id="典型的大周期"><a href="#典型的大周期" class="headerlink" title="典型的大周期"></a>典型的大周期</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220803220301.png"></p><h4 id="上升阶段"><a href="#上升阶段" class="headerlink" title="上升阶段"></a>上升阶段</h4><ul><li>秩序重建，一个或多个大国维持和平的外部环境；国内则出现一个强大英明的领导者，建构出一个良好的系统，使得国民能够通过该系统创造财富和权力；</li><li>国民能够接受良好的教育，具备坚韧性格、良好修养和职业道德，人们尊重法律和秩序，相互合作，提高生产率；</li><li>国民愿意从其他国家学习新的知识、技能和技术，并逐渐开始实现创新，发展新的技术；</li><li>由于本国生产的产品具备成本优势，在世界贸易中变得更有竞争力，因此对外贸易份额不断增长；</li><li>政府不断投资基础设施和国民教育，并建立了激励技术创新的经济制度；</li><li>政府建立资本市场，发展股票、债券、贷款，吸引国民的储蓄，为企业的创新提供资金来源；</li><li>由于良好的投资回报，吸引了越来越多的全世界各地的资本，逐渐成为了重要的金融中心；</li><li>庞大的贸易份额和贸易逆差，让持有本国货币变得越来越有吸引力，本国货币逐渐成为全球主要的储备货币；</li></ul><h4 id="顶部阶段"><a href="#顶部阶段" class="headerlink" title="顶部阶段"></a>顶部阶段</h4><ul><li>随着国民变得富有，人们不再艰苦奋斗，劳动力成本上升，竞争力下降，某些低端产业开始转移其他国家；</li><li>本国技术被其他后发国家复制，竞争力开始下降；</li><li>年轻人成长于富裕的生活条件，没有经历过风雨，在应对外部挑战时变得脆弱；</li><li>长期的增长让人们对未来过于乐观，增加了人们的杠杆，导致面对困境时变得脆弱；</li><li>财富分配不均，社会流动固化，底层人们逐渐变得绝望，出现越来越多的社会冲突和矛盾；</li><li>政府不断通过负债来安抚愤怒的底层群众，随着债务越来越高，国家逐渐变得脆弱；</li><li>政府机构逐渐变得官僚和庞大，运作成本变得越来越高；</li><li>为应对外部新兴对手的挑战，军费开支逐渐增多；</li></ul><h4 id="下跌阶段"><a href="#下跌阶段" class="headerlink" title="下跌阶段"></a>下跌阶段</h4><ul><li>当遇到某些外部因素产生经济衰退时，由于债务太大，国家面临违约风险和融资困境，最终政府被迫印钞，导致倾向贬值和通货膨胀；</li><li>由于经济陷入困境，内部不同群体的冲突越发激化，导致出现政治上的极端主义；</li><li>当政府不断向富人加税时，富人开始转移财产，导致经济出现自我强化的空心化趋势；</li><li>随着空心化而来的经济下行，让问题和冲突变得更加激烈和难以调和，最终爆发某种革命或内战，实现财富和权力的重新分配；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220803220432.png"></p><h2 id="2-决定因素"><a href="#2-决定因素" class="headerlink" title="2. 决定因素"></a>2. 决定因素</h2><p>三大周期：</p><ul><li>债务周期；</li><li>内部秩序；</li><li>外部秩序；</li></ul><p>两大力量：</p><ul><li>技术创新</li><li>天灾；</li></ul><p>驱动事件发生的两类决定因素：</p><ul><li>自然 ：地理环境、气候条件；</li><li>人力资本：文化，即人们普遍持有的观念和对待彼此的方式：</li></ul><blockquote><p>自然资本会消失，但人力资本可以再生；拥有良好人力资本的公司，常常可以打败那些仅拥有资源的公司；</p></blockquote><h2 id="3-债务周期"><a href="#3-债务周期" class="headerlink" title="3. 债务周期"></a>3. 债务周期</h2><p>任何实体，不管是个人、公司，还是国家，都可以从资产和负债，收入和支出等两方面的维度来思考它的状态；如果一个实体收入少于支出，那么它就可能会出现违约；</p><p>一个实体的支出，是另一个实体的收入；当某个实体缩减支出时，将发生连锁反应，最终导致整个经济蛋糕的缩小；由于人们已经习惯了现有的生活状态，当环境要求人们节衣缩衣时，人们就很容易就如何分配缩减后的蛋糕产生矛盾和冲突，导致出现政治问题；</p><blockquote><p>养老金和医疗保险对政府来说是一笔债务，这笔债务违约成本很高，一不小心就会产生社会动荡；随着老龄化时代的到来，这笔债务越来越难以偿还。因为支出会不断增加，但收入却不断减少；</p></blockquote><p>当经济处于上升周期时，人们的心态总是过于乐观，倾向于举债购买资产，因为从过往经验来看，资产回报率很高，远远大于利率。因此借债购买资产是有利可图的。但是资产的价格是会变化的，尤其是当人们争相抛售资产时，资产价格将急剧下跌。但是债务的金融却不会轻易变化，最多是利率上的变化；这将导致某个时刻，人们会发现自己拥有的资产，并不如自己想象的那么多，甚至出现资不抵债的现象；</p><p>通常情况下，央行会通过大量印钞，让货币贬值，从而降低人们的债务负担。当人们的债务是以本国货币计价时，这种做法是可行的。但如果债务是以外币计价，那么央行并不具备印钞能力，最终结果将导致该国政府的破产。</p><blockquote><p>由于人性内在的短视，储备货币国家总是会不可避免印了太多造成自身偿还能力的钞票。但出来混总是要还的。持续的货币贬值终将反噬，让其失去储备货币的地位；</p></blockquote><h3 id="货币、信贷和财富"><a href="#货币、信贷和财富" class="headerlink" title="货币、信贷和财富"></a>货币、信贷和财富</h3><p>由于信贷的存在，有很大一部分市场需求，其实是由信贷在支撑的，从某种程度上来说，是人们某种乐观的扩张，即通过借钱来购买；此时如果央行收缩信贷，将会导致这一部分需求减少或者消失；反过来，如果央行扩张信贷，就会增加这部分需求；换句话说，如果人们都使用现金购买，没有任何借贷，那么央行的货币政府将无法发挥作用。但在当今市场经济的社会中，完全没有信贷也是不可能的；</p><p>信贷的流向对未来经济的走势至关重要，因为信贷最终是要偿还的。如果信贷投入到能够在未来带来更高回报的领域，那么这是一种好现象；但如果投入对冲通胀风险的资产，那么新增的信贷无法带来经济增长，反而会导致货币贬值，推高资产价值；换句话说，实体经济的信贷需求是真需求，对冲资产的信贷需求是伪需求；如果货币供应超过市场的真实需求时，货币将会出现贬值；</p><p>当人们手头拥有更多的信贷时，就会增加人们的购买力；当人们购买更多的商品时，就会推高商品的价格；当商品价格上涨时，人们会产生一种错觉，即认为自己的财富变多了。但事实上并没有，因为这些信贷终有一天是需要偿还的；当人们偿还信贷时，就会导致购买力的急剧下降。一个人的支出是另一个人的收入，由于连锁反应，整个社会的购买力都会下降。接着导致商品价格下降，原本虚高的财富价格将被打回原型；</p><p>在短期债务周期的阶段，央行的货币政府能够影响市场的需求变化；但是随着市场主体的债务累积得越来越多，利率越来越低，终有一天，实体经济的货币需求达到了天花板，再增加扩大无法带来收益。此时人们会开始将货币转入通胀对冲资产。货币贬值让债权人失去了持有货币的意愿，因为货币不再是良好的财富贮藏手段。人们开始抛售手头的货币，换成其他更保值的货币或商品。此时，长期债务周期走到了尽头，需要对整个货币体系进行重组；</p><blockquote><p>如果利率为正，那么只要债务累积的足够大，利息支出也将非常巨大。当它超过实体的收入时，实体就会面临债务违约风险；</p><p>如果利率接近零，那么相当于借贷没有成本，储蓄也没有收入。放贷人没有收益，但坏账风险仍然存在。资本市场将失去资金调配的作用，人人都想借钱，并把借钱的钱用于购买其他可以保值的资产；债券持有人将会抛售手头的债券，导致债券价格暴跌。极端情况下，将会导致债券变得一文不值；</p></blockquote><h3 id="长期债务周期"><a href="#长期债务周期" class="headerlink" title="长期债务周期"></a>长期债务周期</h3><ul><li>阶段一：上个周期的债务通过债务重组被消除了，人们对货币失去信心，开始使用硬通货；</li><li>阶段二：为了应对硬通货不便携带的问题，人们开始使用可信赖机构出具的硬通货债权票据；</li><li>阶段三：出于利益诱惑，可信赖机构发行的债权票据，超过了其储存的硬通货数量；</li><li>阶段四：出现债务危机，迫使票据与硬通货开始脱钩；</li><li>阶段五：为了降低违约风险，开始出现法定货币体系，彻底和硬通货脱钩；</li><li>阶段六：如果印钞过度，债权人将抛售债券，造成挤兑，最终货币急剧贬值，人们重新回归硬通货；</li></ul><blockquote><p>货币贬值并不是有意发生的，当商品数量有限，购买需求刚性稳定时，如果所有购买人手头持有的货币增多，出于竞争关系，他们会推高商品的价格；当同等数量的商品，需要以更高的价格采购时，相当于货币发生了贬值；</p><p>当央行增发货币时，如果不控制货币流向，将不可避免会造成通胀。但如果严格控制货币流向，则通胀不一定会发生；</p><p>央行印钞并不会导致债务的消失，而是让实体能够借新债还旧债，缓解债务危机；另外随之产生的货币贬值降低的实体的债务负担；随着债务不断累积，偿债负担仍然会不断变大。下一次的印钞规模也会随之变大。每一次的印钞都会造成货币贬值。印钞规模越大时，货币贬值的幅度就越大。当贬值幅度越过债权人的极限时，就会触发债务抛售，引发挤兑，货币加剧贬值，货币体系崩溃；</p><p>具有讽刺意味的是，当债务负担达到最大值时，对于持有债务的人来说，是非常危险的，但人们对此浑然不觉，相反还觉得自己很安全；</p></blockquote><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220809212211.png"></p><p>长期债务周期大约以 50-100 年为单位进行循环，虽然整个周期很长，但周期结束时的债务重组时间一般很短，只有几个月，最多不超过三年，取决于政府的反应速度；每一类货币体系都会经历 2-4 次的大规模债务（造成 30% 或更多的债务减记或者货币贬值，但暂时不足以引发货币体系崩溃）；</p><h2 id="4-货币价值的演变"><a href="#4-货币价值的演变" class="headerlink" title="4. 货币价值的演变"></a>4. 货币价值的演变</h2><p>大多数人会关注自己拥有的资产价格，但却很少关注货币价格。事实上，所有的货币都会经历贬值和消亡的过程；</p><blockquote><p>本质上来说，货币贬值通过剥削债权人，将财富转移给了债务人；</p></blockquote><h3 id="货币相对于什么出现贬值"><a href="#货币相对于什么出现贬值" class="headerlink" title="货币相对于什么出现贬值"></a>货币相对于什么出现贬值</h3><p>对于法定货币来说，它其实是一种购买力的指标，这个指标并非固定，而是浮动的。相同的货币金额，在不同的时间点，购买力会有所不同。但总体来说，都是趋向不断贬值的过程；因为法定货币不是稀缺的，它是可以被无限创造出来的。因此，那些在本质上稀缺的物品，可以作为判断货币实际所代表的购买力的变化。这些稀缺物品可以是黄金、艺术品、房地产等；</p><h4 id="货币相对于黄金的价值"><a href="#货币相对于黄金的价值" class="headerlink" title="货币相对于黄金的价值"></a>货币相对于黄金的价值</h4><blockquote><p>1600 年以后，世界上主要的三种储备货币相对黄金的汇率变化情况</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220813153401.png"></p></blockquote><blockquote><p>1850 年以来，世界上主流国家货币相对黄金的汇率变化情况</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220813153532.png"></p></blockquote><blockquote><p>储存黄金是没有利息的，但法定货币的储蓄一般有利息。通过将利息纳入考虑，法定货币相对黄金整体来说是升值的，但货币存在完全消失的风险；详见以下表格：现金相对黄金的总回报率：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220813154049.png"></p></blockquote><p>总结：</p><ul><li>从以上两个图表可以发现，货币的贬值并不是渐进的，而是突发和偶然的；</li><li>1970 年之所以出现断崖式下跌，是因为在此之前，货币与黄金挂钩，实行金本位制；但之后二者脱钩，变成法定货币体系；</li><li>2000 年之后，由于利率相对通胀率不断走低，有时甚至出现零利率或负利率，导致现金货币的回报率开始持续下降；</li><li>当切换成法定货币体系后，由于货币进入不断贬值的趋势，因此最终只有少数国家的货币能够相对黄金保持正回报率；当利率走高时，持有货币回报率更高；当利率走低且央行不断印钞时，则持有黄金的回报率更高；</li></ul><h4 id="货币相对于商品和服务的价值"><a href="#货币相对于商品和服务的价值" class="headerlink" title="货币相对于商品和服务的价值"></a>货币相对于商品和服务的价值</h4><p>通过计算并比较黄金和货币相对于消费者价格指数的回报率，可以更好的看出黄金和货币的内在价值变化；</p><blockquote><p>相对于消费者价格指数，黄金的实际回报率：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220813163122.png"></p></blockquote><blockquote><p>相对于消费者价格指数，纸币的实际回报率：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220813163209.png"></p></blockquote><h3 id="货币贬值并失去储备货币地位的典型模式"><a href="#货币贬值并失去储备货币地位的典型模式" class="headerlink" title="货币贬值并失去储备货币地位的典型模式"></a>货币贬值并失去储备货币地位的典型模式</h3><ul><li>信贷宽松和印钞会造成货币贬值，同时也会造成债务贬值；对于债权人来说，这是个坏消息；但对于债务人来说，这是一个好消息；</li><li>当货币贬值和债务贬值过于严重时，债权人就会抛售货币，转而持有其他更加保值的资产；</li><li>为了避免货币因为抛售出现进一步贬值，央行只好通过印钞，会购买债权人抛售的货币和债务；虽然这么做可以暂时缓解问题，但从长期来说，却强化了货币和债务贬值的趋势；</li><li>当货币贬值越来越严重，同时该国家的经济和军事实力在走弱，失去主导地位时，那么其他国家就会放弃使用该国货币作为储备货币，因为风险越来越大；</li></ul><h2 id="5-内部秩序和混乱大周期"><a href="#5-内部秩序和混乱大周期" class="headerlink" title="5. 内部秩序和混乱大周期"></a>5. 内部秩序和混乱大周期</h2><p>人是社会性动物。某个组织内部成员之间如何相处，将决定了一个实体最终能够获得的结果。而所谓的组织制度，其实是一种规定成员之间应该如何相处的规则；制度以及人们对制度的反应，共同造成了最终的结果；</p><p>生命的终极目标是为了生存和繁衍，而这两项行为都需要资源。因为获取资源（财富）和分配资源（权力）构成了截止为止，人类社会的永恒主题；</p><h3 id="内部周期的六个阶段"><a href="#内部周期的六个阶段" class="headerlink" title="内部周期的六个阶段"></a>内部周期的六个阶段</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220813173737.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220814124649.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220814124707.png"></p><p>整个周期平均大约持续 100 年左右，但上下浮动很大。当上一个周期结束，进入下一个周期之前，其所需要的时间也不一样，它最终取决于两个方法，一个新的领导人能够多快实现暴力垄断，以及多快重现构建新的有利于经济发展的秩序；</p><blockquote><p>在抗日战争结束后，国共花了 5 年的时间完成了内战；但之后构建新的秩序花了 30 年，直到 1978 年改革开放后，经济秩序才开始慢慢步入正轨；</p></blockquote><p>对于个体来说，身处大周期的最后阶段是非常糟糕的。但幸运的是，不同国家所处阶段并不同步。从全球范围来说，各个国家所处的阶段各不相同。因此个体可以通过分散投资或财富转移来降低风险；</p><h4 id="阶段一：获得和巩固权力"><a href="#阶段一：获得和巩固权力" class="headerlink" title="阶段一：获得和巩固权力"></a>阶段一：获得和巩固权力</h4><p>这个阶段主要有两件事情：</p><ul><li>打败外部竞争者，获得控制权；</li><li>内部争斗权力，清洗异己，巩固已获得的权力；</li></ul><h4 id="阶段二：建立新秩序"><a href="#阶段二：建立新秩序" class="headerlink" title="阶段二：建立新秩序"></a>阶段二：建立新秩序</h4><p>此阶段的主要工作是建立官僚机构，完善资源配置体系，因此对领导人的要求跟上一个阶段不同，它更需要“土木工程师”式的领导者，而不是军事将领；只有极少数领导者能够同时胜任这两个阶段的使命，例如唐太宗、罗马皇帝奥古斯都等；</p><h4 id="阶段三：和平与繁荣"><a href="#阶段三：和平与繁荣" class="headerlink" title="阶段三：和平与繁荣"></a>阶段三：和平与繁荣</h4><p>此阶段经济快速增长，人均财富上升，生活条件不断改善。整个社会出现生产力、创造力的爆发；例如俾斯麦时期的德国、李光耀时期的新加坡、肯尼迪时期的美国、邓小平时期的中国等；</p><p>这个阶段是整个周期中最健康的一段时间，如果领导者能够做出正确的决策，就能够在这个阶段维系越长的时间，反之则会滑入第四个阶段；</p><h4 id="阶段四：泡沫时期"><a href="#阶段四：泡沫时期" class="headerlink" title="阶段四：泡沫时期"></a>阶段四：泡沫时期</h4><p>当人们经历越长时间的阶段三，就越容易形成一种错觉，即美好的日子将会永远的持续下去。盲目乐观会造成人们在消费和投资领域都过度举债。一方面是因为人性的贪婪，另一方面是因为人性的欲望；人们认为这些债务在未来能够很容易偿还，但事实并非如此；</p><p>在这个阶段，国家为了保护自己在全球范围内的利益，投入越来越来的资金用于军事建设。而基础设施的投入开始变少，导致生产率提高逐渐变缓；</p><h4 id="阶段五：高债务和冲突时期"><a href="#阶段五：高债务和冲突时期" class="headerlink" title="阶段五：高债务和冲突时期"></a>阶段五：高债务和冲突时期</h4><p>当某个国家面临债务危机时，有两种做法：</p><ul><li>开源节流：向有钱人多征税，同时节省开支；这种做法带来的痛苦很明显，会直接影响很多原本接受政府福利的人群，从而激发人们的不满；同时富人会隐藏和转移财富，导致政府收不到预期中的税收。而富人减少投资，会进一步恶化情况；</li><li>印钞：这种做法带来的痛苦最小，因此也是很多政府的首选方式，除非该政府无法印钞，例如债务以非本国货币计算；</li></ul><p>当某个国家陷入债务危机时，政府通过创造货币和信贷，对债务进行重组或者让货币贬值并不一定是坏的做法。关键点在于这些新创造的货币和信贷，最终是否能够被投入到提高生产率的活动中（例如教育、科研、基础设施等）。如果可以的话，那么未来收入将大于支出，从而走出债务危机。但如果这些新增的货币和信贷没有进入能够提高生产率的活动中，而是被投入到对冲通胀的资产中，那么债务危机只会变得更加严重，债权人会抛售货币和债务，导致货币将会出现大幅贬值，最终让政府和所有民众的购买力大幅缩水；</p><p>导致某个国家内部出现巨大冲突的典型有害组合包括：</p><ul><li>政府和民众的财务状况都很糟糕，背负大量的债务，或者一些类似债务的义务；</li><li>不同群体之间存在巨大的财富和价值观冲突，人们互相憎恨，难以达成共识并相互合作；</li><li>出现严重的外部负面冲击，例如新冠疫情等；</li></ul><p>除了以下三个组合，如果某个国家内部再叠加出现下面的情况，则情况将进一步恶化，出现内部革命或内战的概率大大增加：</p><ul><li>坠落：富人堕落和奢侈的生活方式，很容易激发穷人的愤怒，恶化双方对彼此的刻板印象；</li><li>官僚主义：它成了实施良好政策的阻力，既得利益者只关心个体自己的利益，而不是从大局出发；</li><li>民粹主义和极端主义：世界是复杂的，最佳决策通常需要某个问题的专家和精英来思考对策。但是当民众感到愤怒，对精英失去信心时，认为他们不能改变他们的生存状况，那么声称代表民众利益的领导人便有机会上台；不管是左翼的民粹，还是右翼的民粹，最终结果只能是问题的进一步恶化；</li><li>族群斗争：当不同群体之间的冲突加剧时，人们的对立情绪就会变得更加严重，从而更容易将不同群体的成员妖魔化，将对方视为造成当前各种问题的源头，例如特朗普对拉美移民的打击；</li><li>真相消失：随着人们变更情绪化，各种媒体出于利益考量，以及在各种力量的裹挟之下，其宣传的内容变得越发失真，人们开始越来越无法掌握事实和真相；睁眼所看到的，都是相互对立的情绪；</li><li>放弃规则：社会有序运转的前提是各参与方都认为遵守游戏规则拥有最高优先级；但是当人们认为实现自我诉求比规则更重要时，社会将会进入混乱的“内战”状态；激情压过理性会自我强化，直到局面不可收拾，内战爆发；</li></ul><h4 id="阶段六：内战"><a href="#阶段六：内战" class="headerlink" title="阶段六：内战"></a>阶段六：内战</h4><p>当一个国家的领导者未能在阶段五力挽狂澜时，整个国家将不可避免的滑入阶段六：内部战争；</p><p>内战的信号：</p><ul><li>出现准军事组织，而司法系统和警察系统变成了某些人的政治武器；</li><li>出现暴力抗议事件，尤其是当有人为此牺牲时，事态将迅速恶化；</li></ul><blockquote><p>通常民主体制对于群体之间的分歧会更有韧性，但是在应对第五阶段的挑战时，仍会受到极大的挑战。因为民主意味着协商和妥协，但此时的人们过于情绪化，缺少耐心，寄希望于出现一位强有力的领导者来快速实现自己的诉求。强有力的领导者很多，但和平缔造者却很少，可以说是凤毛麟角，更经常出现的是强有力的民粹主义者，导致局面最终走向崩溃；之后人们只能寄希望于出现强有力的革命者结束内战的局面，重新缔造和平；</p></blockquote><p>内战的结果有两种，一种推翻旧体制，建立新体制，另一种则没有改变体制；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220814104859.png"></p><p>但现有体制无法产生重大变革时，人们就会寻求推翻这个体制，重新构建新的秩序，以便能够改善大部分人的生活状况；除了少数例外，绝大部分时候，内战都是极其残酷的。</p><p>大多数情况下，内战的结果是权力从右派向左移，但也有少数例外，例如一战后的德国、意大利、日本等；而新的政体最终能够成功，关键是它是否能够带来经济繁荣，从而改善大部分人的财富状况；</p><blockquote><p>权力向左派转移一般出现于财富被少数人占领，大部分人非常贫穷，因此想要重要实现财富分配；权力向右派转移则出现于大部分人相对以前已经变得富有，但是现在秩序崩溃，进入了某种无政府的状态，因此多数民众渴望出现一个强有力的领导，带领国家走出困境；</p></blockquote><p>内忧常常伴随着外患，因为当一个国家内部陷入混乱时，对于其他国家来说正是扩大自身利益的最佳时机；同时国内领导人也会发现通过树立统一的外部敌人，能够更加有效的团结国内分裂势力；</p><h2 id="6-外部秩序和混乱大周期"><a href="#6-外部秩序和混乱大周期" class="headerlink" title="6. 外部秩序和混乱大周期"></a>6. 外部秩序和混乱大周期</h2><p>国家的本质是暴力的垄断，而国与国之间，由于不存在暴力垄断，因此彼此的争端更接近于丛林法则，谁的拳头大，谁说了算；</p><p>国家之间的斗争主要包括五个维度：</p><ul><li>贸易战：通过关税、配额等方式来相互限制；</li><li>技术战：限制技术共享；</li><li>地缘战：建立区域性的联盟，将国与国的斗争，上升为联盟与联盟之间的竞争；</li><li>金融战：限制资本流动、实施经济制裁等；</li><li>军事战：发动军事力量消灭对方；</li></ul><p>一般来说，当涉及国家生存问题，且已经没有其他和平手段能够处理冲突的时，才会最终爆发战争；而外部冲突的激发，常常也伴随着巨大的内部矛盾，即内忧外患往往同时发生；</p><blockquote><p>战争造成的死亡人口百分比</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220814160657.png"></p></blockquote><h3 id="决定因素"><a href="#决定因素" class="headerlink" title="决定因素"></a>决定因素</h3><p>面包和大炮都是需要花钱的，如果一个国家不能够同时满足这两项需求，那么就将面临内部或外部反对势力的攻击；不管是内部战争还是外部战争，都是在打“钱”；谁拥有更多的财富，就能够在战争中坚持得更久，有更大的概率战胜对手；因此，拥有更多的财富是最重要的一种优势；</p><p>有些战争是必须的，例如避免失去自由成为亡国奴的反侵略战争；但绝大部分战争是愚蠢的，因为付出的金钱和生命，远远大于获得的收益，最终的结果是双输；</p><p>阻碍不同国家之间实现双赢的常见原因包括：</p><ul><li>囚徒困境；</li><li>针锋相对的升级；</li><li>相互误解；</li><li>担心让步的代价；</li></ul><p>相互了解对方的底线，最解决争端过程中最重要的环节。因为双方最重要的东西往往不同，因此总是存在某种能够达成平衡的双赢方案，关键是彼此要有耐心去了解对方并坐下来协商，从而避免热战；</p><h3 id="战争前夜"><a href="#战争前夜" class="headerlink" title="战争前夜"></a>战争前夜</h3><p>在战争爆发之前，双方一般会在很长的一段时间内相互试探对方的实力和底线，冲突首先会在经济、技术、地缘政治、金融等领域展开；</p><p>将经济政策武器化的常见手段：</p><ul><li>没收、冻结敌方在本国的资产；</li><li>单方面拒绝偿还敌方债务（例如美国拒绝偿还中国持有的美国国债） ；</li><li>限制资本市场准入：例如美国阻止中国资本进入其本国的资本市场；</li><li>禁运和封锁：禁止敌方在本国或第三方国家开展贸易活动，从而切断对方的出口创收和重要原材料的进口；</li></ul><h3 id="战争爆发"><a href="#战争爆发" class="headerlink" title="战争爆发"></a>战争爆发</h3><p>当敌对的双方势均力敌时，则双方都有可能发起战争；当力量不对等时，则战争只可能由强势的一方发起。因为对于弱势方来说，发动战争相当于自杀；</p><p>战争的走势难以预测，因此什么情况都有可能发生。但有一点是肯定的，即战争是残酷的、痛苦的，甚至是毁灭性的；</p><h3 id="战时经济政策"><a href="#战时经济政策" class="headerlink" title="战时经济政策"></a>战时经济政策</h3><p>战争爆发后，为了赢得战争，资源的使用原则将从平时的经济效益变成军事用途，这意味着政府将控制几乎产品的供应；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220814175129.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220814175203.png"></p><p>当战争爆发后，法定货币便失去了其他国家的信任，因此国家之间开始使用硬通货（如黄金）进行结算；由于战争会强力破坏一个国家原本的工业体系，很多企业被迫从民用转为军工，另外有很多企业会破产，在战争结束后，大部分企业的股票价值已经完全消失；为了应付急剧上升的军费开支，绝大多数政府都会大量印钞，从而造成货币贬值。对于个体来说，将手头持有的债务和货币转换为黄金是更好的选择；</p><h2 id="7-从大周期的角度思考投资"><a href="#7-从大周期的角度思考投资" class="headerlink" title="7. 从大周期的角度思考投资"></a>7. 从大周期的角度思考投资</h2><p>所有的投资，本质上都是以当前的一次性付出，来换取未来更大的收入；因此，驱动市场的包含四个主要因素：</p><ul><li>经济增长率</li><li>通胀率</li><li>风险溢价：相对于持有现金，投资者愿意承担多大的风险；即确认性收入和不确定性收入之间的差额；例如假设成功率只有 50%，那么投资者要求至少能赚多少钱，才愿意冒这个险，例如赚 2 倍以上；</li><li>折现率：未来某个金额的现金收入，折算成当前时点的金额；</li></ul><p>市场上有很多种类型的资产可以购买，不同类型的资产在不同的场景下，会有不同的回报表现；通过购买多种不同类型的资产，形成投资组合；如果能够对未来的市场情况进行预判，那么最有可能提前构建最佳回报的投资组合；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220818204534.png"></p><p>市场上多数投资者对大的历史周期没有概念，其中有少数人会研究最近几十年的历史。但这远远不够，需要站在更大的时间尺度和地理范围中，才能够看到更大的经济图景；</p><h3 id="资本主义和市场大周期"><a href="#资本主义和市场大周期" class="headerlink" title="资本主义和市场大周期"></a>资本主义和市场大周期</h3><p>货币的发明和大规模使用，深刻的改变了人们的生活。人们储藏财富的方式，由过去的持有实物资产，转变成了持有金融资产，例如股票、债券、现金等；</p><p>金融资产在人们生活中扮演的作用是如此的普及，以致人们常常忘了它的虚拟性，它其实只是一种支付承诺；在大周期中的某些时段，金融资产有可能出现急剧的贬值，甚至完全的灭失；</p><p>人们的支付承诺可以无限大，但人们的支付能力却是有限的。但作出的承诺远远大于能力时，就会出现债务违约和经济危机；为了缓解危机，政府通常会印发货币，将问题推迟到未来解决；但由于货币本身并没有内在价值，过量的印钞，会造成货币的贬值。当人们突然醒悟过来，对货币价值失去信任时，政府的印钞再也无法缓解危机了；</p><h3 id="从投资的角度看大周期"><a href="#从投资的角度看大周期" class="headerlink" title="从投资的角度看大周期"></a>从投资的角度看大周期</h3><p>投资风险：</p><ul><li>投资回报低于预期；</li><li>投资灭失；</li><li>投资回报被分走的比例大于预期；</li></ul><p>投资灭失是一种非常可怕的风险，因为只要经历一次，就永决不覆，再也没有翻盘的机会了；在过去的 100 年中，10 个全球最发达的国家中，有 7 个经历过至少一次的投资灭亡 （主要是因为战争），只要美国和英国两个幸运儿例外；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220818214317.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220818214352.png"></p><p>在一战爆发之间的那 50 年里面，各主要欧洲国家并没有发生战争，而且经济高速增长。因此，对于生活在那个年代的人来说，一战的爆发是非常突然和意外的。</p><blockquote><p>但现在的全球和地区政治格局与一战之前已经有了很大的不同，为了能够吸取一战和二战的教训，大部分欧洲国家加入了共同的军事联盟，而且大部分欧洲国家都已经完成了民主转型，理论上爆发战争的概率很小。但是目前世界上仍然有很多国家没有完成民主转型，例如俄罗斯、中国、朝鲜等国家；苏联解体之后，美国一家独大，维持了全球秩序，但随着未来美国进一步衰退，这种和平局面有多大的概率能够持续？</p></blockquote><p>绝大多数投资者，会在股票最低价抛出，因为他们一是出于恐慌，二是需要现金（例如偿还债务）；同时他们还会在股份最高点是买入，因为此时他们拥有最多的现金；</p><p>在美国，不同投资方式，以及不同人群，其所要缴纳的税收比例不同，但回顾历史后发现，在任意一个 20 年的周期中，税率基本都占到了 20-25% 左右的比例，即赚 100 块钱中，实际最后拿到是 75 块；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220818230142.png"></p><h3 id="回顾资本市场大周期"><a href="#回顾资本市场大周期" class="headerlink" title="回顾资本市场大周期"></a>回顾资本市场大周期</h3><p>在周期的上行阶段，债务不断增长，经济繁荣；当债务增长超过临界点后，出现债务危机时，进入周期的下行阶段；之后央行通过印钞，导致货币和金融资产贬值，使得金融资产和实物资产回归平衡；然后经济重新进入下一个繁荣期，金融资产重新获得高回报；</p><blockquote><p>金融资产占总资产的份额</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220818231053.png"></p></blockquote><blockquote><p>纸币的实际回报率（相对于消费者价格指数）</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220818231126.png"></p></blockquote><p>每当股票+债券组合的投资回报率下跌时，黄金的回报率就会上涨，说明此时人们转成持有硬通货进行避险</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220818231340.png"></p><p>创造货币和信贷会带来经济繁荣（通过印钞或降低利率），因为人们相当于借未来的钱到现在花；此时还会失去资产价格上涨，所以表面看上去好像大家还变得更加富有了。但其实这是一种错觉，因为借来的钱，在未来某一天终究是要还的。但集中还债的那天，资产价格就会跌回原型；</p><p>上述游戏在发达国家已经玩了很久一段时间了，但是现在有点玩不下去了，因为利率已经降到了接近零的历史最低位；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220818231943.png"></p><blockquote><p>在极低利率的情况下，需要获得与当前投资金额同等购买力所需要的年份</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220818232227.png"></p></blockquote><p>对于投资者来说，投资的目的是在未来获得比当前更大的回报；但是当利率为零甚至为负时，这种投资就变得没有意义了。因为未来的回报大概率已经不可能了。对于投资者来说，此时最好的做法不是投资债券或持有现金，而是购买实物资产；</p><h1 id="第二部分-500-年世界发展史"><a href="#第二部分-500-年世界发展史" class="headerlink" title="第二部分 500 年世界发展史"></a>第二部分 500 年世界发展史</h1><h2 id="8-过去500年简述"><a href="#8-过去500年简述" class="headerlink" title="8. 过去500年简述"></a>8. 过去500年简述</h2><h3 id="1500年的世界"><a href="#1500年的世界" class="headerlink" title="1500年的世界"></a>1500年的世界</h3><p>在公元 1500 年左右的那个时代，国家的概念还没有出现；由于交通技术落后，世界各地区之间的联系很少，接近相互隔绝的状态；每个地区还处于家天下的状态，地区之间为了争夺财富和权力，彼此纷争不断；人权概念更是无法想象，阶级固化和不平等，底层人民被所在地区的封建领主接近当作某种形式的财产；宗教机构比现今的影响力大得多（除了中国）；</p><h3 id="1500年世界各大国"><a href="#1500年世界各大国" class="headerlink" title="1500年世界各大国"></a>1500年世界各大国</h3><ul><li>欧洲：主要由几个大家族统治，同时还存在着由小家族上千个的小公国，公国之间几乎战争不断；</li><li>亚洲：中国明朝正值最鼎盛的时期，是当时全球最强大的国家。印度还处于分裂状态，莫卧尔王朝还要再等 100 年之后才开始崛起；</li><li>中东：由奥斯曼帝国控制，伊朗（波斯）的萨法维王朝正在崛起中；</li><li>美洲：存在两个大的帝国，分别是位于墨西哥的阿兹特克和南美的印加帝国，之后被欧洲人带来的瘟疫给灭了；</li><li>非洲：由数十个小国组成，其中最大的一个是西非的桑海帝国，贸易是其主要的经济来源；</li></ul><h3 id="1500年以来世界发生的变化"><a href="#1500年以来世界发生的变化" class="headerlink" title="1500年以来世界发生的变化"></a>1500年以来世界发生的变化</h3><p>人的思想观念变化是缓慢的，但其影响力却是最大和最持久的；</p><h4 id="商业革命（12-16世纪）"><a href="#商业革命（12-16世纪）" class="headerlink" title="商业革命（12-16世纪）"></a>商业革命（12-16世纪）</h4><p>奥斯曼帝国与欧洲基督教的持续战争，导致陆上商路受阻，意大利人凭借优越的地理位置，通过控制地中海的商路变得发达了起来；当时意大利的政治制度与其他欧洲地区不同，它不是封建制，而是主要由商人主导的城邦制；这种制度为商业提供了良好的发展条件，出现了一系列重要的商业工具，例如薄记、合同仲裁、债券、银行、标准化货币等；</p><h4 id="文艺复兴（14-17世纪）"><a href="#文艺复兴（14-17世纪）" class="headerlink" title="文艺复兴（14-17世纪）"></a>文艺复兴（14-17世纪）</h4><p>仓廪实而知礼节，随着意大利商人变得富人，他们开始投资艺术和科学，推动了商业和科学艺术之间进入相互强化的状态，产生了很多文艺作品和技术工具，例如印刷机、造船和航海技术等，为后续的进一步发展奠定了重要的基础；</p><h4 id="探险和殖民时代（15-18世纪）"><a href="#探险和殖民时代（15-18世纪）" class="headerlink" title="探险和殖民时代（15-18世纪）"></a>探险和殖民时代（15-18世纪）</h4><p>造船和航海技术的进步，让人们开始寻找新的海上商路，原本是为了打破意大利人的商业壁垒，却意外促成了大航海时代的到来；葡萄牙向东跟中国和印度建立了贸易联系，西班牙向西发现了美洲大陆；</p><p>彼时的明朝也进行了多次大规模的航海探险，但最终却突然完全终止了这类活动，转而进入闭关锁国的状态；</p><h4 id="宗教改革-1517-1648"><a href="#宗教改革-1517-1648" class="headerlink" title="宗教改革 1517-1648"></a>宗教改革 1517-1648</h4><p>教会对民众的过度汲取，引起了人们的不满。而印刷机的发明推动了印刷品的广泛传播，人们的思想观念开始变化，导火索被点燃。越来越多的民众开始站起来反对教会的腐败。宗教改革对一个国家的影响力巨大，很快便让整个国家陷入了分裂和内战的状态；</p><h4 id="三十年战争之后的新世界秩序（1648）"><a href="#三十年战争之后的新世界秩序（1648）" class="headerlink" title="三十年战争之后的新世界秩序（1648）"></a>三十年战争之后的新世界秩序（1648）</h4><p>天主教国家和新教国家之间的对抗，持续了好几十年才结束。最终双方签订《威斯特伐利亚条约》，约定了国家之间的地理边界，以及各国人民拥有自由处理本国事务的权利。这一权利意味着真正意义上的国家概念的诞生；</p><h4 id="资本主义的发明（17世纪）"><a href="#资本主义的发明（17世纪）" class="headerlink" title="资本主义的发明（17世纪）"></a>资本主义的发明（17世纪）</h4><p>荷兰人通过建立股票和债券市场，让企业能够高效的筹措社会闲散资金来提高生产力，推动了资本主义制度的诞生。之后该制度深远的改变了整个世界的经济运作方式，让全球生产率开始进入快速增长的状态；</p><h4 id="科学革命（16-17世纪）"><a href="#科学革命（16-17世纪）" class="headerlink" title="科学革命（16-17世纪）"></a>科学革命（16-17世纪）</h4><p>宗教改革让人们开始质疑教会的权威，之后人们便开始走得越来越远，重新思考和质疑生活中的各种原本习以为常的观念，从而推动了科学革命的到来，人类生产力开始进入加速增长的时期；</p><h4 id="第一次工业革命（18-19世纪）"><a href="#第一次工业革命（18-19世纪）" class="headerlink" title="第一次工业革命（18-19世纪）"></a>第一次工业革命（18-19世纪）</h4><p>科学革命带来了工业革命，借助机器，人类生产力得到释放。生产模式开始转型，由之前的农业生产，转入工业生产。同等面积的土地，能够承载更多的人口。工业生产的集中化和规模化需要，促进了城市的诞生；而城市的诞生，让人们对公共基础设施和服务的需求上升，从而推动了政府职能和各种公共机构（如银行、法院等）的不断完善；</p><h4 id="启蒙运动与革命时代（17-18世纪）"><a href="#启蒙运动与革命时代（17-18世纪）" class="headerlink" title="启蒙运动与革命时代（17-18世纪）"></a>启蒙运动与革命时代（17-18世纪）</h4><p>科学革命带来的思想观念变化，原本只限于少数群体，但之后在 18-19 世纪通过启蒙运动得到了广泛的传播。当大多数人们开始接受这些新观念时，旧有的政治和宗教制度开始瓦解，各国纷纷出现了各种革命浪潮，旧有的君主被推翻；</p><h4 id="拿破仑战争及之后的新世界秩序（1803-1815年）"><a href="#拿破仑战争及之后的新世界秩序（1803-1815年）" class="headerlink" title="拿破仑战争及之后的新世界秩序（1803-1815年）"></a>拿破仑战争及之后的新世界秩序（1803-1815年）</h4><p>拿破仑试图统一欧洲，但这一目标对当时法国的国力来说并不现实，因此他最终失败了，英国及其盟国胜出；胜利国在维也纳召开会议，制定新的秩序，让各欧洲大陆国家保持势均力衡的状态，以避免下一次战争的爆发。该会议之后，欧洲出现了很长一段时间的和平（大约 100 年）；彼时的英国有点类似于二战后的美国，是当时世界上最强大的国家；</p><h4 id="西方列强进入亚洲（19世纪）"><a href="#西方列强进入亚洲（19世纪）" class="headerlink" title="西方列强进入亚洲（19世纪）"></a>西方列强进入亚洲（19世纪）</h4><p>搞定欧洲后，英国开始进军亚洲，完全控制了印度，同时也让中国和日本结束了闭关锁国的状态，向其开放贸易；</p><h4 id="第二次工业革命（1850年至20世纪初）"><a href="#第二次工业革命（1850年至20世纪初）" class="headerlink" title="第二次工业革命（1850年至20世纪初）"></a>第二次工业革命（1850年至20世纪初）</h4><p>19 世纪后半叶爆发了第二次工业革命，出现了蒸汽火车、电话等重大的发明；美国成为这些发明最重要的受益者，实现了社会财富的快速增长；</p><h4 id="共产主义的出现（1848年）"><a href="#共产主义的出现（1848年）" class="headerlink" title="共产主义的出现（1848年）"></a>共产主义的出现（1848年）</h4><p>财富分配的严重不均和巨大的贫富差距，引发了人们的普遍不满，共产主义得到越来越多的支持。之后在俄国和中国成为执政党的主要政治纲领；</p><h2 id="9-荷兰帝国与荷兰盾的大周期兴衰"><a href="#9-荷兰帝国与荷兰盾的大周期兴衰" class="headerlink" title="9. 荷兰帝国与荷兰盾的大周期兴衰"></a>9. 荷兰帝国与荷兰盾的大周期兴衰</h2><p>荷兰国家很小，人口很少，在 1581 年独立之前，原本归属奥斯曼帝国统治；荷兰人凭借其经济、金融和海上军事力量，变成了强大的帝国和世界储备货币；</p><h3 id="独立"><a href="#独立" class="headerlink" title="独立"></a>独立</h3><p>与周期国家连续不断的战争让哈布斯堡王朝变得虚弱和疲惫，内部冲突持续累积，而最后的三十年战争则完成了最终一击。在这个过程中，荷兰抓信了机会，最终得以独立；</p><h3 id="兴起"><a href="#兴起" class="headerlink" title="兴起"></a>兴起</h3><p>1581 - 1625 年是荷兰崛起的时期，一些重要的因素在荷兰发生：</p><ul><li>强有力的领导人建立了新的秩序和高效的政治制度；</li><li>重视教育、储蓄、才能，不断投资基础设施；</li><li>开放、包容，富有创造性的社会；</li><li>通过海外贸易变得富裕和强大；</li><li>通过发展军事力量，在与他国的商业冲突中保护了自己的商业利益；</li><li>建立了高效的银行和货币体系，成为金融中心；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220820190141.png"></p><blockquote><p>荷兰出版的书籍占全世界的比例</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220820190240.png"></p></blockquote><blockquote><p>荷兰的重大发明占全世界的比例</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220820190331.png"></p></blockquote><h3 id="发明资本市场"><a href="#发明资本市场" class="headerlink" title="发明资本市场"></a>发明资本市场</h3><p>荷兰发明了资本主义，包括：</p><ul><li>股票：降低普通人投资企业所有权的门槛，也为企业获得融资提供了极大的便利；</li><li>交易所：让股票可以流通，</li><li>银行：为本国人和外国人提供融资，帮助荷兰盾变成世界储备货币；</li></ul><h3 id="新的世界秩序"><a href="#新的世界秩序" class="headerlink" title="新的世界秩序"></a>新的世界秩序</h3><p>哈布斯堡王朝输掉了三十年战争，被迫签订《威斯特伐利亚条约》，承认属下各邦国的自治权，开启了现代国家的先河。荷兰并非这场战争的主要参与者，损失比较小。但荷兰从战争之后的长时间和平稳定期中得到快速发展；</p><h3 id="顶峰"><a href="#顶峰" class="headerlink" title="顶峰"></a>顶峰</h3><p>在到达顶部后，荷兰原本的优势条件开始逆转，包括：</p><ul><li>人工成本上升，成本优势不再；</li><li>英国学习了荷兰的创新，并通过工业革命获得成本优势；</li><li>多次对外战争，例如英荷战争，消耗了荷兰国力；</li><li>荷兰东印度公司的贸易航线，被英国封锁，荷兰失去主要经济来源；</li><li>战争造成的债务导致国家减少了教育和基础设施的投入，后继创新乏力；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220823222040.png"></p><h3 id="衰落"><a href="#衰落" class="headerlink" title="衰落"></a>衰落</h3><p>东印度公司投资回报降低，投资资金转入回报更高的英国东印度公司；为挽救东印度公司，荷兰银行发行货币为其提供贷款；过多的印钞导致货币快速贬值，造成了人们的挤兑，荷兰失去了世界储备货币的地位；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220823222004.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220823221936.png"></p><h2 id="10-大英帝国和英镑的大周期兴衰"><a href="#10-大英帝国和英镑的大周期兴衰" class="headerlink" title="10. 大英帝国和英镑的大周期兴衰"></a>10. 大英帝国和英镑的大周期兴衰</h2><p>一个国家在成为真正的大国之前，有很长的一段崛起过程。在这个过程中，该国家通过投资教育和基础设施获得后续竞争力，即通过技术创新而带来的成本优势和军事实力；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220823224243.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220823224511.png"></p><h3 id="兴起-1"><a href="#兴起-1" class="headerlink" title="兴起"></a>兴起</h3><p>在启蒙运功中，以培根为代表的思想家，提出了以人为中心的思想，其中有两点非常重要：</p><ul><li>政府的权力来自人民，而非上帝；</li><li>社会应该以理性和科学为基础；</li></ul><p>三十年战争推翻了旧王朝，《威斯特伐利亚条约》让欧洲分裂成很多个小国家，不同国家紧接着爆发了内战，争夺财富和权力真空；英国也是如此，内战推翻了旧君主；受启蒙运动的影响，起义者建立了以法律为基础的议会制度，同时也为后续的任人唯贤奠定了基础；</p><p>随着时间的推移，英国的新制度开始展现其优势，经济变得越来越繁荣，政府税收越来越多（是同时期法国的两倍多），国力变得强盛；</p><h4 id="工业革命"><a href="#工业革命" class="headerlink" title="工业革命"></a>工业革命</h4><p>荷兰国土过小，煤矿和铁矿资源不如英国丰富；丰富的矿产资源为英国的工业革命提供了很大的成本优势；事实力所有国家的生产力都在不变提高，但英国的增长速度更快，慢慢就赶超了其他竞争对手；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824200109.png"></p><p>随着英国财政变得更加充足，它开始增加军事投入，一方面是保护海外利益，另一方面则为了实现海外扩张，从其他竞争对手那里抢夺原本由对手垄断的贸易路线和市场份额（荷兰在这一场竞争中最后被打败了）；</p><h4 id="为何不是法国"><a href="#为何不是法国" class="headerlink" title="为何不是法国"></a>为何不是法国</h4><p>法国当时是欧洲大陆的学术中心，启蒙运动的主要思想家大多是法国学者。原本法国也有机会崛起，但如下几个因素限制了它的发展：</p><ul><li>缺少像英国那样的议会体制，君主制下的政府，国王权力不受控制，无法像英国政府低成本发国债，这导致了政府债务成本很高，财政主要依赖于税收；</li><li>一系列入不敷出代价高昂的战争消耗了实力；</li><li>财富分配不均，沉重的税收引发了普通民众的反抗；</li></ul><p>一系列问题最终将法国导向了大革命，政府的过量印钞引发了恶性通货膨胀，经济崩溃，政府破产，内战爆发；</p><h4 id="拿破仑"><a href="#拿破仑" class="headerlink" title="拿破仑"></a>拿破仑</h4><p>拿破仑从内战的混乱中胜出，让局势稳定了下来；但比较糟糕的是，拿破仑的目标过于宏大，计划将法国的制度推广到所有欧洲国家。这为他树立了各式各样的敌人，最终寡不敌众，其对手在英国不断支援的情况下，最终打败了法国；</p><h4 id="维也纳会议"><a href="#维也纳会议" class="headerlink" title="维也纳会议"></a>维也纳会议</h4><p>法国被打败后，欧洲各主要国家签订了《维也纳协议》，其核心思想是保持欧洲各国家之间的势力均衡，遏制而非摧毁法国，避免后续再次爆发战争；</p><p>维也纳会议的最大受益者是英国，不仅削弱了原先的竞争对手，也让其接下来近 100 年中能够专注于发展殖民经济和贸易，控制了印度、加拿大、澳大利亚等地区，成了日不落帝国；</p><h3 id="顶峰-1"><a href="#顶峰-1" class="headerlink" title="顶峰"></a>顶峰</h3><p>随着英国贸易在全球经济中占据越来越大的份额，英磅无可争议的变成了全球储备货币；这一地位同时也反过来巩固了其经济和军事方面的优势；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824203622.png"></p><p>由于英国持续保持经常账户盈余，使其拥有额外的资金投资海外新兴市场，从而获得可观的回报，并弥补其本土市场投资回报减少的缺口；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824203746.png"></p><p>在 19 世纪的后半段，英国开始从顶峰慢慢滑落，主要原因包括：</p><ul><li>竞争对手（德国和美国）的崛起，更低的成本，更高效的组织制度，更多的发明创新；</li><li>英国由于财富分配的极度不平等，既得利益者产业升级动机不足，而底层人民矛盾激化，罢工越来越多；</li></ul><h4 id="德国"><a href="#德国" class="headerlink" title="德国"></a>德国</h4><p>在维也纳会议之后，德国地区原本是多个小邦国组成，但在之后的 100 年中，普鲁士军队逐渐统一了各个邦国。同时在强有力的领导人俾斯麦的带领下，实现了崛起；</p><p>德国采取了一系列有利于经济发展的措施，包括重视法治建设、教育投入、企业扶持等；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824210458.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824210714.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824210758.png"></p><p>虽然俾斯麦领导有方，但当时的德国仍然是君主制，缺少任人唯贤的基础，继任者威廉二世开始偏离轨道，不再以势力均衡为目标，而是计划成为欧洲大国；这一方针让其他国家感受到威胁，各方开始陷入军备竞赛的囚徒博弈，局势越来越朝着战争的方向发展；在一战爆发之前，各国之前的商贸往来比任何历史时期都更加密切，经济增长速度也是创历史新高，因此谁也没有预料到战争的来临；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824211704.png"></p><h4 id="巴黎会议"><a href="#巴黎会议" class="headerlink" title="巴黎会议"></a>巴黎会议</h4><p>1815 年维也纳会议的势力均衡理念，为欧洲带来了 100 年的和平；但 1919 年巴黎会议订下的《凡尔赛和约》，瓜分了战败国的领土，并让战败国承担了巨额战争赔款的代价；成王败寇的理念，为二战的到来埋下了伏笔；</p><h3 id="衰落-1"><a href="#衰落-1" class="headerlink" title="衰落"></a>衰落</h3><h4 id="战争"><a href="#战争" class="headerlink" title="战争"></a>战争</h4><p>原本一战已经是史上最惨烈的战争，没想二战比一战更加惨烈；战争完全摧毁了欧洲，英国也未能幸免，背上了巨额的战争债务，财政入不敷出，再也难以维持之前对各海外殖民地的控制，各殖民地区纷纷独立，这又反过来加剧了英国的收入下滑；</p><p>为了应对财政危机，英国政府不得不多次印钞，从而造成英磅多次的大规模贬值，进而又使得各国的投资者不再持有英镑，最终失去了储备货币的地位；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824214648.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824215108.png"></p><h4 id="欧盟"><a href="#欧盟" class="headerlink" title="欧盟"></a>欧盟</h4><p>两次世界大战让欧洲各国意识到了分裂的代价，而团结的价值巨大；这一共识也促使了后续欧盟的诞生；欧盟是一个超国家的机构，设有法院，用来解决争端；也有议会，用来立法；加入欧盟的成员，要求遵守欧盟的法规；该机构有权征税和发放贷款；随着后续成员通过越来越多的规定，其涉及范围变得越来越多，例如关税约定、开放边界等；其核心目标是形成经济和政治联盟，避免战争再次发生；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824220338.png"></p><p>虽然欧盟让欧洲各国实现了团结，避免了战争；但它并没有改变欧洲面临的长期债务周期下行阶段的命运；负债过高、创新不足、成员国财富不均等因素，让欧盟各国的经济持续疲软，基本面表现不佳；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220824220718.png"></p><h2 id="11-美国和美元的大周期兴衰"><a href="#11-美国和美元的大周期兴衰" class="headerlink" title="11. 美国和美元的大周期兴衰"></a>11. 美国和美元的大周期兴衰</h2><blockquote><p>美国关键决定因素指数</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220825211943.png"></p></blockquote><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220825212119.png"></p><h3 id="兴起-2"><a href="#兴起-2" class="headerlink" title="兴起"></a>兴起</h3><p> 美国的崛起过程依然遵循常见的模式，包括建立新秩序、出现强有力的领导人、投资教育和基础设施等；美国的快速崛起主要是二战后，因为当时欧洲的经济已经瘫痪，市场上不存在竞争对手；但在 19 世纪的下半叶，由于第二次工业革命，美国的经济已经开始进入繁荣期；</p><h4 id="美元和美国资本市场"><a href="#美元和美国资本市场" class="headerlink" title="美元和美国资本市场"></a>美元和美国资本市场</h4><p>美国很有意思，出于对集权的恐惧，在建国初的 150 多年中，一直没有设立央行，结果带来了一系列问题，出现非常多次的银行挤兑恐慌，直到 1913 年才设立美联储；</p><p>一战期间，美国由于特殊的地理位置，没有卷入战争，并保持黄金可自由兑换；战争摧毁了投资者对欧洲货币的信心，各欧洲国家的货币被纷纷抛售进而造成贬值，美元成为最佳的替代者；由于美国大量借款给欧洲各个国家，成了实质上的债务计价货币，为之后美元成为储备货币奠定了基础；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220825224509.png"></p><p>一战后的凡尔赛条约带来了新的和平秩序，欧洲各国家重新进入繁荣时期；但人们在经济上升时期总是过于乐观，导致背上了巨额债务；当泡沫破裂时，各国纷纷陷入经济困境；叠加巨大的财富分配不均，矛盾变得激化和不可调合，民粹主义开始获得支持，之前凡尔赛条约埋下的隐患开始浮上水面，局面逐渐变得失控，最终二战爆发；</p><p>就像一战后，二战再次给美国带来了巨大的收益，因为战火未发生在美国本土，因此美国国内的工业生产受战争影响较小，反而因为战争带来大量的出口需求，让美国赚得盆满钵满；</p><h3 id="顶峰-2"><a href="#顶峰-2" class="headerlink" title="顶峰"></a>顶峰</h3><p>在国家内部，由于政府实现暴力垄断，因此法律得以执行；但在国家之间，由于暴力不存在垄断，因此各种国际法规实际上在协调不同国家的冲突时，能力有限，最终的决定因素在于谁拥有更强大的军事力量和军事同盟；</p><blockquote><p>核弹头数量</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220829210043.png"></p></blockquote><h4 id="二战后的经济与货币体系"><a href="#二战后的经济与货币体系" class="headerlink" title="二战后的经济与货币体系"></a>二战后的经济与货币体系</h4><p>二战结束后，为了帮忙欧洲和日本恢复经济，美国推出了马歇尔计划和道奇计划。计划很成功，有四个方面的好处：</p><ul><li>帮忙欧洲和日本更快的重建；</li><li>有助于欧洲和日本购买美国的商品，实现增长；</li><li>有助于形成同盟关系；</li><li>有助于巩固美国的储备货币地位；</li></ul><p>战争的结束大大减少了军事用品的需求，造成了失业；但同时，由于取消了物资配额，国内消费开始增长，一定程度弥补了前者的缺口；同时，援助计划除了带动出口，同时也有助于美国私营部门进行海外投资；战后的繁荣和高增长，让美国公司的股票回报率升高，吸引了全球的资本，加强了美国的金融中心和储备货币的地位；</p><blockquote><p>50-60 年代美国经济快速增长，每个人都可以找到工作，并有能力让子女获接受大学教育，大多数人能够成为中产阶级，失业率很低；</p></blockquote><h4 id="70年代：贸易逆差，低增长，高通胀"><a href="#70年代：贸易逆差，低增长，高通胀" class="headerlink" title="70年代：贸易逆差，低增长，高通胀"></a>70年代：贸易逆差，低增长，高通胀</h4><p>1971 年之前，由于美国政府承诺美元与黄金的自由兑换，考虑持有美元有额外的利息收益，但持有黄金则没有，各种央行纷纷不断增加美元的持有数量；</p><p>随着欧洲和日本经济的快速恢复，其生产的商品逐渐变得有竞争力了起来，并不断蚕食美国企业的市场份额；于是美国开始从贸易顺着变成了逆差；加上太空计划、越南战争、扶贫计划等项目的庞大开支，美国政府入不敷出，于是发行了大量的国债（当市场对美国美元失去信心时，就会争相将美元冲撞成黄金，这时候会造成黄金不够用，于是美国后来只能让美元跟黄金脱钩）；</p><p>到了 60 年代末，美国通胀达到 6% 左右，实际 GDP 增长接近于零；到了 70 年代末，实际 GDP 增长率为 2%，通用胀率约为 14%；黄金和大宗商品的回报率达到了 30% 和 15%；</p><blockquote><p>从 1944 - 1971 年，黄金价格一直保持为 35美元，但是从 1971 年到 1980 年，已经上涨到了 850 美元；</p></blockquote><p>为了应对不断走高的通胀，美联储开始采取货币紧缩政策。该政策并没有带来预期中的流动性紧张，因为央行可以通过印钞，为那些暂时无法收回贷款的银行提供流动性；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220829215119.png"></p><h4 id="1990-2008：全球化、数字化、债务融资拉动的繁荣"><a href="#1990-2008：全球化、数字化、债务融资拉动的繁荣" class="headerlink" title="1990-2008：全球化、数字化、债务融资拉动的繁荣"></a>1990-2008：全球化、数字化、债务融资拉动的繁荣</h4><p>科技的持续快速推动了经济繁荣，但由于过于快速，超过了民众的代际更迭速度，因此很多人因为机器对人工的替代失业了，而另外一部分新兴产业的工人则收益很多，加大了人群之间的贫富差距；</p><h4 id="2008-2020：货币融资拉动的繁荣"><a href="#2008-2020：货币融资拉动的繁荣" class="headerlink" title="2008-2020：货币融资拉动的繁荣"></a>2008-2020：货币融资拉动的繁荣</h4><p>2008 年金融危机之前，美联储大量印钞，以实现量化宽松和购买政府债券；但是这两种政策会推高金融资产价格，有利于持有金融资产的人群，进一步扩大了不同阶层的贫富差距；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220831205712.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220831210643.png"></p><p>贫富差距的加大，也加大了党派之间的分歧；背后其实是对现状变得越来越不满的民众，民粹主义开始抬头；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220831210753.png"></p><p>新冠疫情的爆发，各种经济活动被迫停止，为了避免引发债务危机，各国央行再次大量印钞，购买政府债务，政府拿到现金后，再为各种社会实体提供资金以渡过难关；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220831211116.png"></p><p>当党派分歧变得越来越大时，意味着越难出现相互妥协，导致冲突无法最终解决，之后引发新的矛盾不满，陷入恶性循环；当终有一天人们变得过于情绪化，并无视规则时，往往意味着某种形式的内战或革命的到来；</p><h2 id="12-中国和人民币的大周期兴起"><a href="#12-中国和人民币的大周期兴起" class="headerlink" title="12. 中国和人民币的大周期兴起"></a>12. 中国和人民币的大周期兴起</h2><p>中国政府的领导人跟美国领导人有一点存在很大的不同，即由于中国的历史很大，经历过很多王朝的兴衰更迭，因此历代思想家总结了一系列兴衰的规律，这些思想在一代接一代的领导层中传承。使得领导人在思考国家政治问题时，会站在更宏观和更长周期的视角，例如制定百年大计，这点在美国的国家领导人身上不存在，他们更注重解决当下的问题，而没有将自己视为某个大周期中的一个组成部分；</p><p>在民国之前，绝大多数朝代中国都以贵金属作为计价货币，它的优点是很难出现通货膨胀，缺点则是容易引起流动性不足，不利商业的发展；不过各朝代基本也不是很重视商业的发展（宋朝除外）；</p><h2 id="13-中美关系和战争"><a href="#13-中美关系和战争" class="headerlink" title="13. 中美关系和战争"></a>13. 中美关系和战争</h2><p>当今世界由多个具有影响力的大国组成，因此，国家之间的博弈更像是一盘多维棋局，而不是传统棋局中一对一的场景； 每一步决策和行动，都需要思考可能引起的多个对手的不同反应，局面非常复杂；</p><h3 id="中国和美国的现状"><a href="#中国和美国的现状" class="headerlink" title="中国和美国的现状"></a>中国和美国的现状</h3><p>当今的美国正在大周期的后期，由于之前的过度行为，国家积累了很大的债务；由于美元是储备货币，央行可以通过印钞来为政府提供贷款，同时还可以降低利率，减轻政府的偿债负担。虽然看上去很美好，但是它会慢慢削弱美元的储备货币地位；</p><p>一个国家是否强大，根本上在于其生产力的强大；如果财富分配不均，容易造成社会冲突，进而削弱了生产力；随着中国的崛起和美国的衰弱，两个国家在越来越多的领域产生了竞争关系；</p><h4 id="贸易战"><a href="#贸易战" class="headerlink" title="贸易战"></a>贸易战</h4><p>当国泰民安时，人们更容易保持展现高尚的道德；当冲突激化时， 人们会放低自己的道德要求，寻找借口，攻击敌人，并为自己的不良行为进行辩护，以便吸引人们支持自己；但这种做法只会让情况恶化，因为双方的分歧会变得越来越大，越来越无法达成相互理解和共识；</p><p>关税和进口配额限制，是贸易战中的常规手段；但如果一方切断另外一方的某些必需品供应，则意味着事态的严重升级，进而很容易引发双方的严重冲突；为了降低对美国必须品的进口依赖，中国政府有意识的开始提前作准备，尝试与美国脱钩；</p><h4 id="技术战"><a href="#技术战" class="headerlink" title="技术战"></a>技术战</h4><p>中国科技企业的技术水平正在快速提高，虽然当前仍然很依赖美国和其他国家，但是这种依赖正在减少；随着中国技术水平的提升，其产品与美国制造的产品产生越来越多的竞争；</p><p>中国的人均数据收集量远远高于美国，大数据 + 人工智能 &#x3D; 更好的决策；由于中国拥有更多数量的工程师，大约是美国的 8 倍；因此虽然双方目前还有技术差距，但这种差距正在快速缩小；</p><h4 id="政治战"><a href="#政治战" class="headerlink" title="政治战"></a>政治战</h4><p>对于中国来说，主权问题是不可讨论的，这是当前中国政府的底线；对于非主权问题，中国政府乐意寻求非暴力的解决方案；除了强大自己之外，拉拢盟友也是获胜的重要环节，历史上不乏最强大的国家，最终被多个实力较弱的国家组成的联盟所打败的案例；中国通过“一带一路”计划，不断扩大自己在周边国家的影响力；通过提供经济合作的利益，与对方形成更紧密的合作关系；</p><h4 id="资本战"><a href="#资本战" class="headerlink" title="资本战"></a>资本战</h4><p>通过切断或限制对手的资金来源，能够有效的打击对手的实力；各国央行一般会储备多种国际货币，通过一揽子的方案，提高自身应对风险的能力；</p><blockquote><p>各国央行的储备货币组合</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220904111208.png"></p></blockquote><p>由于美元是各国的主要储备货币，同时在国际贸易中广泛使用；这一有利的地位，赋予了美国更多的制裁他国的能力和选项，既可以限制国外的个人、公司和政府使用美元，也可以限制国内的机构跟对手进行交易；</p><p>美元失去储备货币的风险在逐渐加大，原因包括：</p><ul><li>以美元计价的债务规模越来越大，触发了各国的储备货币比例的安全线；</li><li>美国政府和央行的债券货币化，让持有美元债务的收益率实际为负；</li><li>当美国卷入战争的可能性越大时，持有美元的风险就会变得越来越高；</li><li>中国虽然只持有约 4% 的美国国债，但当两国发生冲突时，美国政府对中国的资本制裁措施，会引发其他国家的恐慌；</li><li>当美国因战争实行外汇管制时，将进一步降低其他国家持有美元的动力；</li><li>受美国制裁的国家，将会发展其他替代支付体系，以降低自身被制裁的风险；</li></ul><h4 id="军事战"><a href="#军事战" class="headerlink" title="军事战"></a>军事战</h4><p>随着技术的进步，每一场新的战争都将带来比过往战争更大的破坏力；因此，当中国和美国爆发热战时，将带来可怕的后果；考虑到后果的严重性，还有另外一种可能性是出现代理人战争。代理人战争也是一种削弱对手实力的有效办法；</p><h4 id="文化战"><a href="#文化战" class="headerlink" title="文化战"></a>文化战</h4><p>观念的分歧常常导致冲突的双方难以相互理解，最终导致矛盾的升级；因此，和平的解决争端的有效办法，是双方能够尝试去理解对方的价值观念和行事方式，并允许对方采取对方觉得最合理的行事方式，而不是按自己的想法去干预对方；</p><p>双方的差异：</p><ul><li>美国：崇尚个人自由，对集体主义持怀疑态度，愿意为了个人自由进行抗争和战斗；</li><li>中国：集体利益高于个人利益，认为集体稳定比个人自由更加重要；</li></ul><h1 id="第三部分-未来"><a href="#第三部分-未来" class="headerlink" title="第三部分 未来"></a>第三部分 未来</h1><h2 id="14-未来"><a href="#14-未来" class="headerlink" title="14. 未来"></a>14. 未来</h2><p>应对未来的办法：</p><ul><li>感知当前正在发生的事情：知道现状和未来的趋势，改变自己，适应新的环境，而不是坚持老一套；</li><li>预估未来可能发生的事情以及相应的概率：预判下一步的趋势走向；</li><li>学会避免被可能发生的事情所伤害：，提前做好一些准备；</li></ul><h3 id="进化"><a href="#进化" class="headerlink" title="进化"></a>进化</h3><p>随着人类知识的不断积累，生产率的不断提高是一种可以预见的未来趋势；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220905214411.png"></p><blockquote><p>全球人均 GDP </p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220905214523.png"></p></blockquote><p>基于过去判断未来在多数情况下是一种合理的做法，但是技术的进步不完全是渐进式的，偶尔会出现突变，导致出现意料之外的情况，例如信息化就是一种突变；突变往往是难以提前预知的，但是我们通过观察一些指标，可以在它发生时，第一时间注意到它；</p><h3 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h3><p>人类社会存在三种类型的周期，包括债务、国内秩序、国际秩序等；这些周期并不会影响到真正的大趋势，但是它们在短期内的破坏力也是很惊人的。时代的一粒尘埃，落在个体身上即是一座大山；因此我们很有必要了解自己当前做处于周期的哪个阶段，以及未来周期会如何演变，从而能够从容应对；</p><blockquote><p>全球人均 GDP 出现下降的情况</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220905215132.png"></p></blockquote><blockquote><p>全球人均财富下降的情况</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220905215208.png"></p></blockquote><blockquote><p>自然灾害造成的死亡人数</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220905215258.png"></p></blockquote><blockquote><p>战争冲突造成的死亡人数</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220905215323.png"></p></blockquote><p>押注那些能够提高生产率的行为，整体上是不会错的。但是应避免过于激进，因为由于周期的存在，过于激进的行为会让自己无法穿越周期，获得最后的胜利；</p><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><h4 id="创新能力"><a href="#创新能力" class="headerlink" title="创新能力"></a>创新能力</h4><p>由于知识存在累积效应，因此人类社会生产率的提高并非匀速，而是加速状态，即随着时间的推移，速度变得越来越快；计算机虽然无法替代人类的思考，但是它可以跟人类的思考相互补充，完成一些仅依赖人类大脑原本无法胜任的场景；这种思考能力的变化，很可能会带来社会财富的转移，即越来越多的财富将集中到拥有这些技术的群体中；但总体上来说，大部分人能够从这些技术进步中获益；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220905221647.png"></p><h4 id="债务周期"><a href="#债务周期" class="headerlink" title="债务周期"></a>债务周期</h4><p>债务周期是影响宏观经济的最重要因素，因此了解各个国家当前所处的债务周期阶段，对预测未来的经济状况有很大的参考意义；</p><p>当前以美元计价的债务规模过于庞大，远远超过了硬通货能够偿付的范围，而且由于制度惯性，债务还在继续增长；为了避免债务违约，印钞是不可避免的，因此长期来看，货币贬值也是不可避免的。而且当债务庞大的无法偿付时，债务重组也是不可避免的。财富将从财富过剩的那部分人转移到财富不足的那部分人手中；这种转移不一定是以暴力的形式出现，它还可以货币贬值的和平形式出现；当这种情况发生时，它将使美元处于失去储备货币地位的风险中，因为人们再也不敢继续大量持有美元了；</p><p>储备货币的衰退不是突然发生的，它会先在较长的一段时间范围内缓慢的发生；然后达到某个临界点后，由于自我强化的恶性循环，快速下坠；该临界点为货币的贬值速度快过于利率，人们持有该货币不但无利可图，还会持续亏损；一旦人们开始抛售，那么就会引发更加快速的贬值和新一轮抛售；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220905222933.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220905223007.png"></p><h4 id="内部秩序"><a href="#内部秩序" class="headerlink" title="内部秩序"></a>内部秩序</h4><p>基本原则：和平带来财富，战争带来损失；不同国家处于内部秩序周期的不同阶段，因此它们面临的内部冲突风险不尽相同；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220905223232.png"></p><p>合作的前提是各方能够遵守事先约定好的规则；当某一方无视规则的时候，合作便难以展开。对规则的无视，是爆发革命或战争的预警信号之一；其次是情绪化的相互攻击，最后是出现流血事件；</p><blockquote><p>美国内部冲突指数</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220906211421.png"></p></blockquote><h4 id="外部秩序"><a href="#外部秩序" class="headerlink" title="外部秩序"></a>外部秩序</h4><p>目前世界上最大的两个国家间冲突分别是中美冲突和俄美冲突；</p><blockquote><p>各国家之间的冲突指数</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220906211808.png"></p></blockquote><p>在 2008 年金融危机之前，中美之间有一段很长的蜜月期，但随着中国的崛起，其生产的产品越来越威胁到了美国原本的市场份额；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220906211929.png"></p><p>在最近的 500 年中，平均每 10 年就会发生一次大国之间的战争。唯一的例外是二战之后的这 70 年，全世界经历了一段前所未有的长期和平；这段和平时间是如此之长，以至于人类开始觉得爆发战争是难以想象的；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220906212222.png"></p><p>战争对于参战的各方都是毁灭性的打击，输家自不用说，赢家也需要付出巨大的代价，各种基础设施被破坏，国家背上巨额债务；中美之间最有可能爆发战争的导火索是台湾，而相互保证毁灭则是目前防止出现热战的最大顾虑；除了中美自身外，双方各自的盟友也很重要。中国的盟友正在增加，而美国则不断减少；</p><h4 id="自然灾害"><a href="#自然灾害" class="headerlink" title="自然灾害"></a>自然灾害</h4><p>从过往历史可以发现自然灾害常常扮演压垮骆驼的最后一根稻草，由于全球平均气温持续高速上升，目前我们正面临未曾经历的灾害风险；干旱、洪涝、高温、地震等自然灾害出现的频率越来越高；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220906213116.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220906213103.png"></p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220906213235.png"></p><p>不同国家所处的地理环境不同，因此面对的灾害风险不尽相同；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220906213335.png"></p><h3 id="其他因素"><a href="#其他因素" class="headerlink" title="其他因素"></a>其他因素</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220906213620.png"></p><p>当一个国家财政状况恶化时，还同时面临很多内部和外部冲突，那么大概率该国家将走向衰弱。因为财政恶化意味缺少足够的资金去解决各种冲突，因此问题只会变得越来越严重，陷入自我强化；</p><blockquote><p>未来各国家的 GDP 增长率预测</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220906214353.png"></p></blockquote><h3 id="未来十年"><a href="#未来十年" class="headerlink" title="未来十年"></a>未来十年</h3><p>内部和外部秩序周期的时间跨度很长，至少以 50 -100 年为单位，因此在未来 10 年中，最大的影响因素是债务周期；债务周期的时间跨度平均为 8 年左右。当出现经济低迷时，央行一般会通过信贷扩张来帮助国家走出经济低迷。因此低迷本身并没有太大的风险，更大的风险反而是过度信贷扩张带来的货币贬值；</p><p>虽然中国的实力正在崛起，并不断逼近美国，但除非出现什么重大技术突破，否则中国在接下去的十年内，应该暂时还没有办法忽略“互相保证毁灭”的威胁；因此双方的大规模热战可能性不大，但有很大的可能会爆发局部冲突，如果美国反对中国统一台湾的话；</p><h3 id="应对未知"><a href="#应对未知" class="headerlink" title="应对未知"></a>应对未知</h3><p>每个人能够了解的信息是非常有限的，因此我们能否穿越周期，最重要的不是我们已经知道了什么了，而是我们是否为不知道的情形做好了充分的准备；</p><ul><li>考虑可能出现的最坏情况，然后思考如何应对该情况，如何能够让自己活下去，这样能够尽量避免出现无法忍受的风险，例如被淘汰出局了；</li><li>分散风险：避免将鸡蛋放在同一个篮子中，而应该放在多个没有相互关联的篮子中；</li><li>延迟满足</li><li>向最聪明的人请教，验证自己对事情的理解是否正确；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一部分-世界是如何运转的&quot;&gt;&lt;a href=&quot;#第一部分-世界是如何运转的&quot; class=&quot;headerlink&quot; title=&quot;第一部分 世界是如何运转的&quot;&gt;&lt;/a&gt;第一部分 世界是如何运转的&lt;/h1&gt;&lt;h2 id=&quot;1-大周期简述&quot;&gt;&lt;a href=&quot;#1-</summary>
      
    
    
    
    <category term="社科" scheme="https://ccw1078.github.io/categories/%E7%A4%BE%E7%A7%91/"/>
    
    
    <category term="经济" scheme="https://ccw1078.github.io/tags/%E7%BB%8F%E6%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>Java 编程思想</title>
    <link href="https://ccw1078.github.io/2022/07/19/Java%20%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
    <id>https://ccw1078.github.io/2022/07/19/Java%20%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</id>
    <published>2022-07-19T00:05:00.000Z</published>
    <updated>2024-09-23T01:27:36.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-对象的概念"><a href="#第1章-对象的概念" class="headerlink" title="第1章 对象的概念"></a>第1章 对象的概念</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>将对象保护起来，让调用对象的人，不能轻易的修改对象内部的实现细节，防止在调用过程中，对象被无意中破坏；</p><blockquote><p>函数式编程，貌似不存在这种担心；为什么 OO 会出现这种情况呢？猜测是因为在内部存储状态造成的，它的实现变得复杂了，对状态有依赖，导致变得脆弱，从而需要提供某种保护；因此，有可能的情况下，应尽量避免出现状态依赖，让对象更加纯粹，这样就无须提供保护；</p><p>后来发现真正的目的并不是保护，而是为了方便后续更改实现；只要调用者没有访问内部的实现细节，那么内部就拥有更改的灵活性；</p></blockquote><h3 id="protected-和-private-区别"><a href="#protected-和-private-区别" class="headerlink" title="protected 和 private 区别"></a>protected 和 private 区别</h3><p>private 是类和调用者之间的屏障，如果非法调用，则编译时会报错；子类不继承父类的 private 成员；</p><p>protected 跟 private 只有一个点不同，即子类可以调用父类 protected 的属性或方法；</p><p>default：默认同一个包中的类，都可以相互访问；</p><h3 id="组合和聚合的区别"><a href="#组合和聚合的区别" class="headerlink" title="组合和聚合的区别"></a>组合和聚合的区别</h3><p>区别在于生命周期，组合对象被删除时，各成员中的子对象也会被删除，但聚合不会；</p><h3 id="is-a-和-is-like-a-的区别"><a href="#is-a-和-is-like-a-的区别" class="headerlink" title="is-a 和 is-like-a 的区别"></a>is-a 和 is-like-a 的区别</h3><p>如果派生类没有添加新的办法，只是覆盖基类的方法，那么基类和派生类之间是 is-a 的关系，二者可以完美替代；</p><p>如果派生类添加了新的方法，则跟基类是 is-like-a 的关系，因为存在新方法，所以不能无脑调用；</p><h3 id="后期绑定"><a href="#后期绑定" class="headerlink" title="后期绑定"></a>后期绑定</h3><p>感觉 Java 的后期绑定有点像 js 等动态语言中的回调，函数做为某个对象的属性，约定共同的名称，例如 callback，届时按规则进行调用即可；甚至动态语言还可以更加灵活，在执行调用地方，传入任意函数做为参数的一部分，以方便调用者后续可以执行该函数；</p><p>OO 通过动态绑定来实现多态，即编译器在编译时，并不知道某个函数会收到什么样的参数，但由于这些参数有共同的方法命名绑定，因此，只需要按名称调用方法，则可以实现预期的调用；</p><blockquote><p>这种动态的特性，在动态语言中是天生的，开发者完全注意不到，也完全没有想到，它在静态语言中，会是一个问题；事实上，Java 也同时是一门解释型的语言，因此才能够拥有这种动态语言的特性；</p></blockquote><h3 id="单继承结构"><a href="#单继承结构" class="headerlink" title="单继承结构"></a>单继承结构</h3><p>Java 中所有的对象都继承自基类 Object，它的好处是让整个语言极大降低了复杂度，也有利于垃圾回收。 C++ 为了兼容 C，所以会更加复杂；</p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>集合是编写代码过程中，非常常用的一种数据结构。相比 Java 的原始数组，集合实现了一些常用的方法，并且能够动态的扩展大小，要方便很多；Java 5 引入泛型后，让集合的使用更加方便了；</p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>Java 使用单继承结构，并要求所有对象都必须存放在堆中，这个设计极大的方便了内存的回收管理；因为只要创建对象，就可以统一调用基类 Object 的方法，触发内存管理；</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>拥有异常处理机制是很重要的，因为如果没有，一旦出错，就意味着程序死掉了，无法从错误中恢复。这非常不利于程序对外提供稳定的服务，而异常处理机制可以让问题局限于某个范围，不至于影响全局；</p><h1 id="第3章-万物皆对象"><a href="#第3章-万物皆对象" class="headerlink" title="第3章 万物皆对象"></a>第3章 万物皆对象</h1><h2 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String s; <span class="hljs-comment">// 创建了一个对象引用</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asd&quot;</span> <span class="hljs-comment">// 创建了一个对象引用，同时还创建了一个对象，并给引用赋值，让其关联对象；</span><br></code></pre></td></tr></table></figure><h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>) <span class="hljs-comment">// 使用 new 关键字来创建对象</span><br></code></pre></td></tr></table></figure><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><h3 id="基本类型的存储"><a href="#基本类型的存储" class="headerlink" title="基本类型的存储"></a>基本类型的存储</h3><p>由于对象保存在堆中，有时候一些简单变量可考虑使用基本类型，这样它们会存储在栈中，无需创建对象，性能会好一些</p><blockquote><p>不过说实话，个人感觉这点微乎其微的性能提升几乎没有意义；</p></blockquote><h3 id="高精度数值"><a href="#高精度数值" class="headerlink" title="高精度数值"></a>高精度数值</h3><p>BigInteger 和 BigDecimal 两个类型用来存储高精度数值，它们也是包装类型，但没有对应的基本类型；</p><blockquote><p>BigDecimal 常用于货币运算，以避免计算过程中出现精度丢失；</p></blockquote><h3 id="数组的存储"><a href="#数组的存储" class="headerlink" title="数组的存储"></a>数组的存储</h3><p>在 C&#x2F;C++ 中，数组是手工分配的内存块，不小心会越界读取，带来不可预测的行为；Java 通过牺牲一些内存空间和计算性能，换取了使用数组的安全和方便性；</p><h2 id="对象清理"><a href="#对象清理" class="headerlink" title="对象清理"></a>对象清理</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在 java 中，以下写法是非法的，会提示变量重复定义，但在 C/C++ 中是合法的，因为后者的作用域较小</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类的创建"><a href="#类的创建" class="headerlink" title="类的创建"></a>类的创建</h2><p>方法名 + 参数类型 的组合构成了方法（函数）的唯一标识（估计是为了实现重载）；</p><p>方法可以返回任何类型的数据，也可以不返回任何数据（需要用关键字 void 标识）；</p><h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h3><p>为了避免类的命名冲突，Java 使用倒序域名来作为包的名称，同时将类放在包中，以尽可能减少重名的情况；</p><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>可以通过 static 关键字定义静态变量或静态方法；所谓的静态，意味着它们是静态存在的，不需要动态创建，也就是说，无须通过 new 创建对象来访问这些变量或方法，只需通过类名，即可访问它们，而且它们也不会在内存中重复创建，只会在加载类的时候，创建一次；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">47</span>; <span class="hljs-comment">// 静态变量</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 静态方法</span><br>        System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 优先通过类名访问静态变量或静态方法，而不是实例化对象后，再通过对象访问；</span><br>StaticTest.i++;<br>StaticTest.sayHello();<br></code></pre></td></tr></table></figure><h1 id="第4章-运算符"><a href="#第4章-运算符" class="headerlink" title="第4章 运算符"></a>第4章 运算符</h1><h2 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h2><p>Long 类型的数值，结尾需要使用字母 L（大小写都可以）来表示；建议用大写，免得混淆；</p><p>16进制有个前缀 0x</p><p>8 进制的前缀为 0</p><p>2 进制的前缀为 0b</p><p>Java 使用 %n 来统一 window 和 unix 两个平台不同的换行符格式；唯一的例外是在 println 函数，仍然使用 &#x2F;n 作为换行；</p><h1 id="第5章-控制流"><a href="#第5章-控制流" class="headerlink" title="第5章 控制流"></a>第5章 控制流</h1><p>if-else, while, do-while, for-in, for</p><p>逗号运算符：可用来定义多个类型相同的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, j = <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><h1 id="第6章-初始化和清理"><a href="#第6章-初始化和清理" class="headerlink" title="第6章 初始化和清理"></a>第6章 初始化和清理</h1><h2 id="利用构造器保证初始化"><a href="#利用构造器保证初始化" class="headerlink" title="利用构造器保证初始化"></a>利用构造器保证初始化</h2><p>Java 和 C++ 一样，强制通过构造器来初始化对象，这样可以避免 C 语言中容易出现的问题，即调用者忘了做初始化的工作，导致出错；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rock</span> &#123;<br>    Rock() &#123; <span class="hljs-comment">// 这是一个构造器，本身没有返回值</span><br>        System.out.print(<span class="hljs-string">&quot;Rock &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">Rock</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Rock</span>(); <span class="hljs-comment">// a 得到的赋值，实际上是 new 关键字的返回值；</span><br></code></pre></td></tr></table></figure><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载的一个使用场景是让类拥有多个不同的构造器，以便接受不同的参数，完成不同的初始化；</p><h2 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h2><p>当定义了一个类，如果没有在类中定义构造函数，编译器会自动给它添加一个无参构造器；如果有在类中定义了有参数的构造器，那么编译器将不再自动创建无参构造器了；此时创建对象必须传参，不然会报错；</p><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>当在方法中 return this 时，可用来构造链式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// housekeeping/Leaf.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    Leaf <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        i++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; <span class="hljs-comment">// 返回 this 实现链式调用</span><br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Leaf</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Leaf</span>();<br>        x.increment().increment().increment().print(); <span class="hljs-comment">// 链式调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外 this 也用于将当前对象作为参数，传给另外一个函数；</p><p>当形参的命名跟内部变量同名时，可以使用 this.field 来处理；</p><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>Java 的内存回收不是实时的，而是要等到内存使用达到某个临界点时，才会触发回收；这会带来一个问题是当程序运行的越久，一方面其占用的内存会变得越来越多；另一方面，清理的工作会变得很大，会占用较多的 CPU 时间，导致短时间内出现性能下降；</p><p>回收前，虚拟机需要先标记仍然存活的对象，一种常见的方法是根搜索机制，即将某些对象标记为根对象，然后从这些对象出发，一层一层的往下遍历，直接没有找不到对象为止；凡是能找到的，就标记为”存活“；之后将存活的对象从一个堆块，复制到另外的新堆块，一方面这样可以排列紧凑，避免空档；另一方面可以将旧堆块标记为可用，实现清空；</p><p>垃圾回收有很多种机制，不同的虚拟机使用不同的机制，一种常见的机制如下：</p><ul><li>将堆分成五块，分别是新生块、中生块1、中生块2、老年块、永生块；</li><li>永生块主要用于存储类库，一般不会回收；（java1.8 之后永生块改成了元数据区）</li><li>新生块、中生块1、中生块2、老年块的空间占比分别是 32 : 4 : 4 : 60；</li><li>所有新增的对象一般先放到新生块中，如果很大，则直接进入老年块，避免频繁触发回收；</li><li>当新生块满了后，触发回收；遍历一遍，没有引用的标记删除；有引用的，代数加1，挪到中生块1；</li><li>中生块1 如果满了，触发回收；删除死的，存活代数加1，复制到中生块2；</li><li>中生块2 如果满了，触发回收；删除死的，存活代数加1，复制到中生块1；</li><li>如果某个对象在中生块的存活代数达到门槛，例如8代，将其挪到老年块；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407191649143.png"></p><p>JIT: Just In Time，及时处理，意思是到了运行的时候，再将字节码编译成机器码；理论上字节码是解释运行的，并没有编译成机器码存储起来；为了提高运行速度，虚拟机可以将一些热点代码，提前编译成机器码，这样就不需要每次调用时，都进行解释了；</p><h2 id="成员初始化"><a href="#成员初始化" class="headerlink" title="成员初始化"></a>成员初始化</h2><p>当一个类被加载时，首先会初始化静态变量，之后分配内存，为内部属性（如有）设置默认值；之后调用构建函数，为、内部属性再次赋值（如有）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">```java<br><span class="hljs-comment">// housekeeping/Mugs.java</span><br><span class="hljs-comment">// Instance initialization</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mug</span> &#123;<br>    Mug(<span class="hljs-type">int</span> marker) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Mug(&quot;</span> + marker + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mugs</span> &#123;<br>    Mug mug1;<br>    Mug mug2;<br>    &#123; <span class="hljs-comment">// [1]  这里非常有意思，它没有 static 标志，但是它会在构造函数调用前先被执行</span><br>      <span class="hljs-comment">// 当存在构造函数时，这种写法可以让代码不管哪个构造函数被调用，都可以被执行 </span><br>        mug1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mug</span>(<span class="hljs-number">1</span>);<br>        mug2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mug</span>(<span class="hljs-number">2</span>);<br>        System.out.println(<span class="hljs-string">&quot;mug1 &amp; mug2 initialized&quot;</span>);<br>    &#125;<br>    <br>    Mugs() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Mugs()&quot;</span>);<br>    &#125;<br>    <br>    Mugs(<span class="hljs-type">int</span> i) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Mugs(int)&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Inside main()&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mugs</span>();<br>        System.out.println(<span class="hljs-string">&quot;new Mugs() completed&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mugs</span>(<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;new Mugs(1) completed&quot;</span>);<br>    &#125;<br>&#125;<br>```<br><br><br></code></pre></td></tr></table></figure><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>Object 类默认的 toString 方法是打印类名和对象地址；</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Spiciness</span> &#123;  <span class="hljs-comment">// enum 实际上是一个类，有自己的方法，例如 ordinal, values 等</span><br>    NOT, MILD, MEDIUM, HOT, FLAMING<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleEnumUse</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Spiciness</span> <span class="hljs-variable">howHot</span> <span class="hljs-operator">=</span> Spiciness.MEDIUM; <span class="hljs-comment">// 使用枚举类型</span><br>        System.out.println(howHot);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumOrder</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Spiciness s: Spiciness.values()) &#123;<br>            System.out.println(s + <span class="hljs-string">&quot;, ordinal &quot;</span> + s.ordinal());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出结果如下</span><br>NOT, ordinal <span class="hljs-number">0</span><br>MILD, ordinal <span class="hljs-number">1</span><br>MEDIUM, ordinal <span class="hljs-number">2</span><br>HOT, ordinal <span class="hljs-number">3</span><br>FLAMING, ordinal <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h1 id="第7章-封装"><a href="#第7章-封装" class="headerlink" title="第7章 封装"></a>第7章 封装</h1><p>之所以要做访问控制，主要出现在类库的开发场景，即所开发的类库会被他人调用。如果不限制访问某些属性，任意由调用者访问，会导致后续难以重构该类库的某些功能实现。因此里面有些属性可能被旧代码访问，因此重构后，可能会导致旧的代码无法正常工作。类库作者因此被绑住了手脚，无法实施进一步的迭代升级；</p><h2 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h2><p>包是一种组织管理源代码文件的方式，以减少命名冲突，让文件更加结构化，方便理解和查找；</p><p>.java 后缀的文件被称为源文件，每个源文件中，只能允许有一个 public 类，但可能有多个非 public 类；同时 public 类的名称需要与源文件名相同；</p><p>当源文件位于某个包中时，需要在源文件的头部写 “package &lt;包名&gt;”</p><h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>通常情况下，默认权限已经够用，但更推荐将不公开的成员设置为 private，例如它可以用来限制调用构造函数，强制要求调用静态方法；</p><blockquote><p>当然，如果整个包都是自用的，没有被外部调用，那么 default 权限一般就够用了；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// hiding/IceCream.java</span><br><span class="hljs-comment">// Demonstrates &quot;private&quot; keyword</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sundae</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Sundae</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">static</span> Sundae <span class="hljs-title function_">makeASundae</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sundae</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IceCream</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//- Sundae x = new Sundae();</span><br>        <span class="hljs-type">Sundae</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> Sundae.makeASundae(); <span class="hljs-comment">// 貌似很适合用于工厂模式中</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口和实现分离"><a href="#接口和实现分离" class="headerlink" title="接口和实现分离"></a>接口和实现分离</h2><p>访问权限带来了接口和实现的分离，即调用者只能调用 public 方法，不能访问细节，因此内部的实现可以根据需要修改；</p><h2 id="类访问权限"><a href="#类访问权限" class="headerlink" title="类访问权限"></a>类访问权限</h2><p>通常类的访问权限是 public，但是也可以是 default；当它是 default 时，它将不能在包外的位置进行初始化；此时它内部的方法即便是 public 也是无法访问的，调用的位置在编译时会报错；default 的类是无法被包外的使用者进行调用的，仅限包类使用；</p><p>正常文件中的类至少有一个是 public，但也可以没有 public；通常它们是一些辅助类，仅限在包中使用，不想给外部的人员调用；</p><p>类只有两种访问权限，要么是 public，要么是 default；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Soup1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Soup1</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// 构造函数设置为 private，不允许外部实例化对象</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Soup1 <span class="hljs-title function_">makeSoup</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 通过调用静态方法，每次返回一个新的对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Soup1</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Soup2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Soup2</span><span class="hljs-params">()</span> &#123;&#125; <span class="hljs-comment">// 构造函数设置为 private，不允许外部实例化对象</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Soup2</span> <span class="hljs-variable">ps1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Soup2</span>(); <span class="hljs-comment">// 此处通过静态方法，先初始化了一个对象</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Soup2 <span class="hljs-title function_">access</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 通过 access 静态方法，返回提前创建好的对象的引用</span><br>        <span class="hljs-keyword">return</span> ps1;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><span class="hljs-comment">// 以上传说中的单例模式，貌似可用于 credentials 的创建，方便全局引用</span><br></code></pre></td></tr></table></figure><p>Java 的访问权限更适用于编写类库供外部调用的场景，如果不是这种场景，例如一个人编写程序，或者每个人编写各自的程序，无须相互调用，那么一般 default 权限就够用了；</p><h1 id="第8章-复用"><a href="#第8章-复用" class="headerlink" title="第8章 复用"></a>第8章 复用</h1><p>在 Java 中有两种复用代码的就去，一种是组合，一种是继承；</p><h2 id="组合语法"><a href="#组合语法" class="headerlink" title="组合语法"></a>组合语法</h2><p>定义新类时，将旧类作为新类的成员；</p><h2 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 extends 关键字来表示继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Detergent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cleanser</span> &#123;<br>  <span class="hljs-comment">// Change a method:</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scrub</span><span class="hljs-params">()</span> &#123;<br>    append(<span class="hljs-string">&quot; Detergent.scrub()&quot;</span>);<br>    <span class="hljs-comment">// 此处调用父类的同名方法，如果调用自己，会出现递归调用（有时递归是必要的，但需要添加条件</span><br>    <span class="hljs-comment">// 以便递归可以终止</span><br>    <span class="hljs-built_in">super</span>.scrub();<br>  &#125;<br>  <span class="hljs-comment">// Add methods to the interface:</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foam</span><span class="hljs-params">()</span> &#123; append(<span class="hljs-string">&quot; foam()&quot;</span>); &#125;<br>  <span class="hljs-comment">// Test the new class:</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Detergent</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Detergent</span>();<br>    x.dilute();<br>    x.apply();<br>    x.scrub();<br>    x.foam();<br>    System.out.println(x);<br>    System.out.println(<span class="hljs-string">&quot;Testing base class:&quot;</span>);<br>    Cleanser.main(args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果某个类设计出来后，是要被包外的使用者进行继承，那么这个类的方法需要是 public 或 protected；private 方法无法被继承，因此也无法被重写；</p><h3 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h3><p>Java 会在派生类的构造函数中，自动插入调用基类构造函数的代码；这意味着，每次创建一个派生类的对象时，也有一个基类的对象被创建出来了；这个基类对象会隐式的包含在派生类的对象中；</p><blockquote><p>这意味着，如果继承的层级很深的话，实例化一个对象时，其实有一大堆对象被创建了出来；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Art</span> &#123;<br>  Art() &#123;<br>    System.out.println(<span class="hljs-string">&quot;Art constructor&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drawing</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Art</span> &#123;<br>  Drawing() &#123;<br>    System.out.println(<span class="hljs-string">&quot;Drawing constructor&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cartoon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Drawing</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cartoon</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Cartoon constructor&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Cartoon</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cartoon</span>();<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">Art constructor</span><br><span class="hljs-comment">Drawing constructor</span><br><span class="hljs-comment">Cartoon constructor</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>当父类的构造函数需要参数时，那么需要手工调用父类的构造函数，并给它传参；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Game</span> &#123;<br>  Game(<span class="hljs-type">int</span> i) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Game constructor&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoardGame</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Game</span> &#123;<br>  BoardGame(<span class="hljs-type">int</span> i) &#123;<br>    <span class="hljs-built_in">super</span>(i);<br>    System.out.println(<span class="hljs-string">&quot;BoardGame constructor&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Chess</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BoardGame</span> &#123;<br>  Chess() &#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-number">11</span>);<br>    System.out.println(<span class="hljs-string">&quot;Chess constructor&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Chess</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chess</span>();<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">Game constructor</span><br><span class="hljs-comment">BoardGame constructor</span><br><span class="hljs-comment">Chess constructor</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>还有一种复用代码的方法是使用委托，虽然 Java 并不直接支持委托，但可以借助第三方工具，来生成委托的方法；所谓的委托，其实就是将方法重新包装一下。可以根据需要，选择性的包装，用不到的就不包装；</p><blockquote><p>感觉有点像是代理模式或者桥接模式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpaceShipDelegation</span> &#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-comment">// 此处将 controls 设置为 private，导致无法直接调用 controls</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">SpaceShipControls</span> <span class="hljs-variable">controls</span> <span class="hljs-operator">=</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpaceShipControls</span>(); <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SpaceShipDelegation</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br>  <span class="hljs-comment">// Delegated methods:</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">back</span><span class="hljs-params">(<span class="hljs-type">int</span> velocity)</span> &#123;<br>    controls.back(velocity);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> velocity)</span> &#123;<br>    controls.down(velocity);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forward</span><span class="hljs-params">(<span class="hljs-type">int</span> velocity)</span> &#123;<br>    controls.forward(velocity);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">left</span><span class="hljs-params">(<span class="hljs-type">int</span> velocity)</span> &#123;<br>    controls.left(velocity);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">right</span><span class="hljs-params">(<span class="hljs-type">int</span> velocity)</span> &#123;<br>    controls.right(velocity);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">turboBoost</span><span class="hljs-params">()</span> &#123;<br>    controls.turboBoost();<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-type">int</span> velocity)</span> &#123;<br>    controls.up(velocity);<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SpaceShipDelegation</span> <span class="hljs-variable">protector</span> <span class="hljs-operator">=</span><br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpaceShipDelegation</span>(<span class="hljs-string">&quot;NSEA Protector&quot;</span>);<br>    protector.forward(<span class="hljs-number">100</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="结合组合与继承"><a href="#结合组合与继承" class="headerlink" title="结合组合与继承"></a>结合组合与继承</h2><p>继承的同时，组合一些东西进来，很常用；</p><p>通常情况下，对象的销毁是由垃圾回收器完成的。但是它什么时候回收是不确定的，有时候我们需要立即回收，例如画图软件的场景，需要销毁一些画好的图形。此时我们需要手工写一些销毁的代码。此时一般会用到 try…finally 语句，以便确保销毁的工作会被执行。同时每个类中，也需要定义自己的销毁方法，以便可以调用，进行销毁；</p><p>@Override 注解虽然不写也不会影响代码的运行，但是写了后有个好处，编译器可以用它来检查重载是否成功。因为有可能返回类型或者参数类型写错，导致没有重载成功；</p><h2 id="组合与继承的选择"><a href="#组合与继承的选择" class="headerlink" title="组合与继承的选择"></a>组合与继承的选择</h2><p>认真思考新类和旧类的关系，到底是 is-a 还是 has-a 的关系；通常优先使用组合；</p><h2 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h2><p>对外部隐藏，但允许派生类的成员访问；</p><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><blockquote><p>继承的本质，是想表明某个新类，是旧类的某种特殊类型；</p></blockquote><p>所谓的向上转型，是指将子类对象，当成父类对象来使用；向上转型是安全的，但向下转型就不太安全了；</p><p>继承虽然是 Java 的一个特色，但实际上它很少用。除非有明确的证据表明继承能够让问题变得简单化。判断的标准即是向上转型，即是否存在需要将派生类当作父类来使用的场景？如果有，那么可以考虑使用继承；</p><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p>final 关键字通常表明这个东西是不能改变的；final 可用在三个地方，分别是数据、方法、类；</p><p>final 数据常用于表示常量；</p><p>final 参数用来表示不能改变该参数指向的对象或变量；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">with</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Gizmo g)</span> &#123; <span class="hljs-comment">// final 参数</span><br>        <span class="hljs-comment">//-g = new Gizmo(); // 非法，g 不可重新赋值</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>final 方法表示该方法不可被子类覆盖；</p><p>如果某个方法在基类中是 private，那么它是隐式 final 的，子类对该方法的覆盖，并非真的覆盖，只是一个同名方法而已；如果子类没有覆盖，甚至连同名方法都没有；只有非 private 的方法，才能够被重写；</p><p>final 类表示该类无法被继承；</p><h2 id="类初始化和加载"><a href="#类初始化和加载" class="headerlink" title="类初始化和加载"></a>类初始化和加载</h2><p>类仅在被用到时，才会被 JVM 加载并初始化；当某个子类被用到时，JVM 会先去加载基类，完成基类的初始化后，再来处理子类的初始化；</p><h1 id="第9章-多态"><a href="#第9章-多态" class="headerlink" title="第9章 多态"></a>第9章 多态</h1><p>多态本质是一种动态绑定，在运行时，基于输入对象的类型，判断要调用的正确方法；在编译时，编译器是不知道要传入什么类型的参数的，所以只能在运行时进行判断；</p><h3 id="陷阱：重写-private-方法"><a href="#陷阱：重写-private-方法" class="headerlink" title="陷阱：重写 private 方法"></a>陷阱：重写 private 方法</h3><p>如果某个方法或属性在基类中声明为 private，则该方法或属性对派生类是隐藏的，在内存中存在，但无法直接调用，相当于没有继承；但是可以间接访问，即调用父类的方法进行访问；</p><p>在派生类中可以起同名的方法；但是这里有个陷阱，当向上转型，即将派生类做类型转换成父类时，调用的同名方法，将会是父类的方法，而不是子类的；</p><h3 id="陷阱：属性与静态方法"><a href="#陷阱：属性与静态方法" class="headerlink" title="陷阱：属性与静态方法"></a>陷阱：属性与静态方法</h3><p>只有方法是可以多态的，属性不能多态；如果在代码中直接访问一个属性，那么在编译时，这个属性的值就已经确定下来了，不是动态绑定的；不过这种情况很少见，有两方面的原因：</p><ul><li>一般会将属性默认设置为 private，因此该属性在子类中是不可见的，默认访问父类的属性值；</li><li>如果子类真的有个属性取值不同，一般也会起个不同的属性名称，以免产生混淆；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Super</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getField</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> field; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Super</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getField</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> field; &#125; <span class="hljs-comment">// 覆盖父类的方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSuperField</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.field; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldAccess</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Super</span> <span class="hljs-variable">sup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>(); <span class="hljs-comment">// 向上类型转换为父类的类型了</span><br>    System.out.println(<span class="hljs-string">&quot;sup.field = &quot;</span> + sup.field +  <span class="hljs-comment">// 结果为 0，读取父类的属性</span><br>      <span class="hljs-string">&quot;, sup.getField() = &quot;</span> + sup.getField());  <span class="hljs-comment">// 结果为 1，读取子类的属性</span><br>    <span class="hljs-type">Sub</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sub</span>();<br>    System.out.println(<span class="hljs-string">&quot;sub.field = &quot;</span> +  <span class="hljs-comment">// 结果为 1，读取子类的属性</span><br>      sub.field + <span class="hljs-string">&quot;, sub.getField() = &quot;</span> + <span class="hljs-comment">// 结果为 1，读取子类的属性</span><br>      sub.getField() +<br>      <span class="hljs-string">&quot;, sub.getSuperField() = &quot;</span> +  <span class="hljs-comment">// 结果为 0，读取父类的属性</span><br>      sub.getSuperField());<br>  &#125;<br>&#125;<br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">sup.field = 0, sup.getField() = 1</span><br><span class="hljs-comment">sub.field = 1, sub.getField() = 1, sub.getSuperField()</span><br><span class="hljs-comment">= 0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果方法是 static 静态的，那么它也没有多态；</p><h2 id="构造器和多态"><a href="#构造器和多态" class="headerlink" title="构造器和多态"></a>构造器和多态</h2><p>构造器有点像是隐式声明的 static 方法，因此不具有多态的特征；</p><h3 id="构造器调用顺序"><a href="#构造器调用顺序" class="headerlink" title="构造器调用顺序"></a>构造器调用顺序</h3><p>在初始化子类对象时，会向上溯源，逐级调用父类的构造器；如果父类没有无参构造器，而子类也没有显式调用父类的有参构造器，那么编译时会报错；</p><p>调用顺序：</p><ul><li>加载子类</li><li>加载父类</li><li>初始化父类属性</li><li>运行父类构造器</li><li>初始化子类属性</li><li>运行子类构造器</li></ul><h3 id="继承和清理"><a href="#继承和清理" class="headerlink" title="继承和清理"></a>继承和清理</h3><p>通常不需要手工清理对象，但是有些特殊情况下可能需要。当需要手工清理时，需要给每个类添加清理的方法，并且清理的顺序应该跟构造顺序相反；每个子类在清理的时候，需要记得调用父类的清理方法，逐级向上传递清理指令；</p><p>有时候某个成员对象可能被多个其他对象共享，此时可能需要引入引用计数来处理；可考虑使用 static 变量来记录引用的次数；</p><h3 id="构造器中的多态方法"><a href="#构造器中的多态方法" class="headerlink" title="构造器中的多态方法"></a>构造器中的多态方法</h3><p>当基类在构造器中调用某个方法时，如果派生类覆盖了该方法，那么在实例化派生类对象时，会优先选择子类的方法来执行。但是此时子类的属性还没有初始化赋值，因此如果读取属性，会得到一个类型默认值；为了避免这种情况，基类构造器中调用的方法，最好是自身的 final 方法，这样可确保不会被覆盖，以免产生预想不到的结果；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Glyph</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Glyph.draw()&quot;</span>);<br>    &#125;<br><br>    Glyph() &#123;<br>        System.out.println(<span class="hljs-string">&quot;Glyph() before draw()&quot;</span>);<br>        draw();<br>        System.out.println(<span class="hljs-string">&quot;Glyph() after draw()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RoundGlyph</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Glyph</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    RoundGlyph(<span class="hljs-type">int</span> r) &#123;<br>        radius = r;<br>        System.out.println(<span class="hljs-string">&quot;RoundGlyph.RoundGlyph(), radius = &quot;</span> + radius);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;RoundGlyph.draw(), radius = &quot;</span> + radius);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PolyConstructors</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RoundGlyph</span>(<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 输出结果如下</span><br>Glyph() before <span class="hljs-title function_">draw</span><span class="hljs-params">()</span><br>RoundGlyph.draw(), radius = <span class="hljs-number">0</span>  <span class="hljs-comment">// 运行基类构造器时，调用了子类的新方法，但 radius 是类型默认值</span><br>Glyph() after <span class="hljs-title function_">draw</span><span class="hljs-params">()</span><br>RoundGlyph.RoundGlyph(), radius = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h2><p>子类覆盖父类的方法的方法，返回类型可以跟父类方法相同，也可以是父类方法返回的类型的子类型；</p><h2 id="使用继承设计"><a href="#使用继承设计" class="headerlink" title="使用继承设计"></a>使用继承设计</h2><p>组合比继承更加灵活，除非有确切的证据证明使用继承会让事情变得更加简单，否则优先使用组合；因为组合不仅简单，而且使用起来更加灵活，更容易应对需求变化；</p><p>由子类转成父类永远是安全的，因为父的方法不会比子类多；但是反过来就不安全了，因为子类可能存在父类没有新方法；当出现这类型的向下转换时，JVM 在解释代码并运行时，会检查代码中是否调用了父类没有的方法，如果是的话，运行时会报错；</p><h1 id="第10章-接口"><a href="#第10章-接口" class="headerlink" title="第10章 接口"></a>第10章 接口</h1><p>接口或者抽象类，提供了一种将接口与实现分离的结构化方法；</p><h2 id="抽象类和方法"><a href="#抽象类和方法" class="headerlink" title="抽象类和方法"></a>抽象类和方法</h2><p>创建一个抽象类的目的，是为了对外展示一组通用的接口，建立某种接口规范，方便通用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Basic</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unimplemented</span><span class="hljs-params">()</span>;<span class="hljs-comment">// 抽象方法只能放在抽象类中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于抽象类的派生类，它需要为基类的方法提供具体实现；如果不提供，该派生类只能当作一个抽象类，必须添加 abstract 标记，不然编译器会报错；</p><p>即便一个类中没有任何抽象方法，也可以将这个类声明为抽象类。 这样做的好处是可以避免调用者实例化这个类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Uninstantiable</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">g</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Instantiable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Uninstantiable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;f()&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 覆盖抽象类的方法时</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">g</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">22</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Uninstantiable</span> <span class="hljs-variable">ui</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Instantiable</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口创建"><a href="#接口创建" class="headerlink" title="接口创建"></a>接口创建</h2><p>interface 更像是用来建立类之间的使用协议，即告知需要实现的方法名称</p><p>接口的典型应用是给类添加一个形容词，例如 Runnable, Serializable 等；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceWithDefault</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">firstMethod</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">secondMethod</span><span class="hljs-params">()</span>;<br>    <br>     <span class="hljs-comment">// 这里的 default 关键字很有意思，表示某个方法提供了默认实现，子类可以不实现</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;newMethod&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>Java 早期是不允许多继承的，因为多继承让 C++ 变得很复杂；但是 default 接口的引入，让 Java 实际上拥有了多继承的功能；差别在于只能继承方法，不能继承属性；所有属性仍然只能来自基类或者抽象类；</p><h3 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h3><p>接口中的方法默认是 public，但接口中也允许添加静态方法；或许可用来放置一些工具方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> onjava;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Operations</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runOps</span><span class="hljs-params">(Operations... ops)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Operations op: ops) &#123;<br>            op.execute();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><p>创建一个新类时，只能继承自一个抽象类，但是可以继承多个接口；</p><p>通常情况下，普通类已经够用了。因此尽量不要使用接口，也不要使用抽象类，除非有明确证据证明好处很大；当要用时，也尽量使用接口，少用抽象类；</p><h2 id="完全解耦"><a href="#完全解耦" class="headerlink" title="完全解耦"></a>完全解耦</h2><h2 id="多接口结合"><a href="#多接口结合" class="headerlink" title="多接口结合"></a>多接口结合</h2><p>一个派生类可以继承多个接口，反过来，它也可以向上转型为任意一个继承的接口；这样做是安全的；</p><p>如果某个类已知要做为基类，那么优先将其定义为接口</p><h2 id="使用继承扩展接口"><a href="#使用继承扩展接口" class="headerlink" title="使用继承扩展接口"></a>使用继承扩展接口</h2><p>继承多个接口时，可能会出现命名冲突；此时没有特别好的办法，只能是起个不同的名字；</p><h2 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h2><p>策略设计模式：编写一个方法，接收一个方法做为参数；传入的对象，只要遵循这个接口，就是安全的</p><h2 id="接口字段"><a href="#接口字段" class="headerlink" title="接口字段"></a>接口字段</h2><p>在没 enum 类型之前，接口是放置常量的好地方；因为它的成员默认都是 final 和 public 的；</p><h2 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h2><p>可以将接口定义在类的内部；</p><h2 id="接口和工厂方法模式"><a href="#接口和工厂方法模式" class="headerlink" title="接口和工厂方法模式"></a>接口和工厂方法模式</h2><p>通常情况下，初始化一个对象是调用其构造器，而所谓的工厂方法，是调用其内部用于创建对象的方法，返回一个对象；这种做法的好处是将接口与实现进行分离。</p><p>使用接口背后的原因必须是真正存在不同的实现。但是一开始并非如此，所以第一时间使用接口 + 工厂方法是一种过度设计，会带来没有必要的复杂性。只有当真正出现不同实现的那么，才需要考虑是否重构和使用接口；</p><h1 id="第11章-内部类"><a href="#第11章-内部类" class="headerlink" title="第11章 内部类"></a>第11章 内部类</h1><h1 id="第12章-集合"><a href="#第12章-集合" class="headerlink" title="第12章 集合"></a>第12章 集合</h1><h1 id="第13章-函数式编程"><a href="#第13章-函数式编程" class="headerlink" title="第13章 函数式编程"></a>第13章 函数式编程</h1><h1 id="第14章-流式编程"><a href="#第14章-流式编程" class="headerlink" title="第14章 流式编程"></a>第14章 流式编程</h1><h2 id="流支持"><a href="#流支持" class="headerlink" title="流支持"></a>流支持</h2><p>Java 早期是严格面向对象的，后来设计者为其添加流式编程范式，为了不破坏现在的接口，通过在接口中引入 default 巧妙的解决了这一问题；</p><p>Java.util 的集合类都添加了 stream() 方法，可以很方便的将集合转成流；</p><blockquote><p>每个基本类型都有一个包装类，二者的相互转换叫做 box 和 unbox，即装箱和拆箱；</p></blockquote><h2 id="流创建"><a href="#流创建" class="headerlink" title="流创建"></a>流创建</h2><p>Stream.of() 可将一组元素转换成流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamOf</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Stream.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bubble</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bubble</span>(<span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bubble</span>(<span class="hljs-number">3</span>))<br>            .forEach(System.out.pringln);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个集合都可以调用 stream 方法来生成一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Bubble&gt; bubbles = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bubble</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bubble</span>(<span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bubble</span>(<span class="hljs-number">3</span>));<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> bubbles.stream().mapToInt(b -&gt; b.i).sum());<br></code></pre></td></tr></table></figure><h3 id="随机数流"><a href="#随机数流" class="headerlink" title="随机数流"></a>随机数流</h3><p>Random 类提供了一个生成随机数流的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">rand</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">47</span>);<br>rand.ints();<br>rand.longs();<br>rand.doubles();<br>rand.ints(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 控制上下界</span><br></code></pre></td></tr></table></figure><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><h2 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h2><p>当某个计算结果可能返回空值时，可以将其包装在 Optional 类中，然后通过 empty 方法判断是否为空；</p><h3 id="便利函数"><a href="#便利函数" class="headerlink" title="便利函数"></a>便利函数</h3><p>可用来处理当 Optinal 中的值不存在的情况，例如 ifPresent, orElse, 等；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// streams/Optionals.java</span><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Optionals</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">basics</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> &#123;<br>        <span class="hljs-keyword">if</span>(optString.isPresent()) <span class="hljs-comment">// 便利函数 isPresent</span><br>            System.out.println(optString.get()); <br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">&quot;Nothing inside!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ifPresent</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> &#123;<br>        optString.ifPresent(System.out::println);<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">orElse</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> &#123;<br>        System.out.println(optString.orElse(<span class="hljs-string">&quot;Nada&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">orElseGet</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> &#123;<br>        System.out.println(<br>        optString.orElseGet(() -&gt; <span class="hljs-string">&quot;Generated&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">orElseThrow</span><span class="hljs-params">(Optional&lt;String&gt; optString)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(optString.orElseThrow(<br>            () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;Supplied&quot;</span>)));<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Caught &quot;</span> + e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String testName, Consumer&lt;Optional&lt;String&gt;&gt; cos)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot; === &quot;</span> + testName + <span class="hljs-string">&quot; === &quot;</span>);<br>        cos.accept(Stream.of(<span class="hljs-string">&quot;Epithets&quot;</span>).findFirst());<br>        cos.accept(Stream.&lt;String&gt;empty().findFirst());<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        test(<span class="hljs-string">&quot;basics&quot;</span>, Optionals::basics);<br>        test(<span class="hljs-string">&quot;ifPresent&quot;</span>, Optionals::ifPresent);<br>        test(<span class="hljs-string">&quot;orElse&quot;</span>, Optionals::orElse);<br>        test(<span class="hljs-string">&quot;orElseGet&quot;</span>, Optionals::orElseGet);<br>        test(<span class="hljs-string">&quot;orElseThrow&quot;</span>, Optionals::orElseThrow);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第19章-类型信息"><a href="#第19章-类型信息" class="headerlink" title="第19章 类型信息"></a>第19章 类型信息</h1><p>RTTI，在运行时判断类型信息</p><p>面向对象编程的一个基本目的是只需操作基类，然后通过多态，即可得到预期结果，提高代码的适用性，减少代码的变更；</p><h1 id="第25章-设计模式"><a href="#第25章-设计模式" class="headerlink" title="第25章 设计模式"></a>第25章 设计模式</h1><p>所谓的设计模式，相当于解决某类问题的巧妙办法的经验总结，它的核心目的是想隔离变化。也就是说当外界出现变化时，代码需要更改的东西尽量少，降低维护的难度；将易变的事物，和不易变的事物，隔离开来；</p><p>模式可分为三大类：</p><ul><li>创建型：如何创建对象；</li><li>结构型：处理对象与其他对象连接方式，以便外部出现更改时，这部分连接无须更改；</li><li>行为型：封装一些通用的行为；例如迭代器</li></ul><h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>这模式属于行为型，基本原理是在父类定义了整个框架，然后允许子类自定义修改其中少数几个方法，以实现使用者预期的效果；相当于设计者定了个模板，然后使用者微调一些局部，以实现想要的效果；</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>通常情况下，使用构造函数来创建对象；工厂方法的意思是，在类里面单独定义一个创建对象的方法，只允许调用者通过该方法创建对象，而不是直接调用构造函数来创建，而是由这个工厂方法自己去调用构造函数；这样做的好处是，子类可以改写这个方法，不同的子类，可以生产出不同类型的对象；</p><blockquote><p>当初始化对象很简单，使用构造函数是没有问题的；但是如果初始化很复杂，由于构造函数不能继承，每次都需要单独编写，这有可能导致多个子类都在重复的代码；为了便于维护，可通过工厂模式，将初始化对象的代码抽离出来，实现复用，方便维护；</p><p>工厂方法还有一个好处是可以给方法编写更容易理解的名字，而不需要像构造函数一样必须跟类名相同；但感觉这点貌似有点牵强，因为子类一般名字也是有意义的；</p></blockquote><p>对于调用者来说，只需要考虑根据自身需要，创建不同的子类对象，并调用它的通用方法即可；至于这些对象背后如何实现自己的方法，调用者可以不用关系；</p><p>动态工厂：使用反射，传入类型名称，查找类，加载，调用类的构建函数；这样做的好处是可以在使用的时候才加载，不用提前加载；</p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>类似工厂方法，唯一的不同是有多个工厂，不同的工厂生产不同类型的东西；</p><h3 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h3><blockquote><p>也叫建造者模式，builder</p></blockquote><p>不使用构造函数来创建复杂的对象，而是设计一个单独的生成器函数，以便可以根据需要组合起对象；个人感觉这个东西很像是没有参数默认值的一种变通；</p><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>为了实现克隆，但由于对象内部有些属性可能是私有的，所以从外部克隆不可行；可以让对象自己实现一个克隆的方法，供别人调用，这样就可以避开私有的问题了；</p><h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="代理模式和桥接模式"><a href="#代理模式和桥接模式" class="headerlink" title="代理模式和桥接模式"></a>代理模式和桥接模式</h3><p>代理模式顾名思义，就是创建一个二房东出来，将一房东封装起来，二房东自己跟一房东谈，其他房客都跟二房东谈；这样的好处是如果房东有什么变化，变化只局限于两个房东之间，房客不需要变更；</p><h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>某个场景可能拥有多种状态，在不同状态下，需要采取不同的行为表现；传统的方式是写一堆 if else 来做条件判断，这是可行的。只是如果状态真的很多的话，维护起来会比较麻烦；</p><p>状态模式的解决方案，是将每种状态和关联的行为单独抽象出来成为一个对象，然后场景根据当前的状态，关联不同状态对象；场景调用该对象的方法，实现不同的行为表现；为了让场景的调用变得简单，这些对象需要遵循接口规范，需要方法的命名都一样，这样才方便场景的调用；调用后，如果状态发生了改变，那么状态对象还会改变场景的状态值，以便让其关联新的状态对象；</p><blockquote><p>这个模式非常适用于有限状态机的场景，但在实际的业务中，貌似还没有遇到过；</p></blockquote><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>感觉跟状态模式差不同，唯一的区别是策略模式不改变上下文的状态；</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>将一大堆处理拆分一下，每个处理步骤单独抽象成一个对象，该对象只负责一小部分职责；如果通过，就将任务传递给后面步骤的对象；</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>不同的数据来源，用一个适配器，将它们转换成统一的格式，再传递给后面的对象处理；</p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>整合很多复杂的功能和接口，将它们统一起来，对外只提供一个简单的接口，隐藏后端的复杂性，个人感觉跟 HTTP API 接口的理念类似；</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>就是 pub&#x2F;sub，整个列表，将感兴趣的对象添加进去；当事件发生时，逐个通知这些对象；</p><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>添加新功能的一种办法，是给对象添加新的方法；还有一种方法是将对象做为参考传递给一个新方法，让新方法能够访问对象中的数据就可以了；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第1章-对象的概念&quot;&gt;&lt;a href=&quot;#第1章-对象的概念&quot; class=&quot;headerlink&quot; title=&quot;第1章 对象的概念&quot;&gt;&lt;/a&gt;第1章 对象的概念&lt;/h1&gt;&lt;h2 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="计算机" scheme="https://ccw1078.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
    <category term="java" scheme="https://ccw1078.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>置身事内</title>
    <link href="https://ccw1078.github.io/2022/07/04/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/"/>
    <id>https://ccw1078.github.io/2022/07/04/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85/</id>
    <published>2022-07-04T14:18:00.000Z</published>
    <updated>2024-09-23T00:50:17.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、地方政府的权力与事务"><a href="#一、地方政府的权力与事务" class="headerlink" title="一、地方政府的权力与事务"></a>一、地方政府的权力与事务</h2><p>地方政府是整个国家管理环节中重要的一环，中央各项政策的落地，都有赖于地方政府的配合，因此地方政府要处理的事情非常多。事务繁杂的现状，决定了地方与中央存在巨大的信息不对称性，因此中央在大多数事情上面，需要放权给地方自主决策，才能取得更好的因地制宜的效果。改革开放之前实施的计划经济制度，已经被历史证明是行不通的。地方政府要办的事情很多，因此需要花钱的地方也很多。这些钱从哪里来，便成了地方政府日常工作中最核心的一环。只有解决了资金来源问题，地方政府才有可能将事情办成和办好，才能完成上级中央的考核；</p><p>中国是一个超级巨大的国家，任何一个省份拿出来，都相当于一个中型国家。而且地区间的差异很大，部分指标的绝对值可能达到 50-60 倍的差异。这种情况在国外是难以想象的，美国最富州的人均 GDP 最多也只是最穷州的 2 倍多一点，但中国可以达到 5 倍甚至更多。不同地区之间在经济、地理、语言和文化上的巨大差异，决定了国家治理的巨大难度。</p><p>想要了解政府的治理和运作模式，核心是抓住两样东西，一个是权力如何分配，一个是资源如何分配，有权+有钱，才能好办事。</p><h3 id="政府治理的特点"><a href="#政府治理的特点" class="headerlink" title="政府治理的特点"></a>政府治理的特点</h3><p>在民国之前，中国大部分时是两级（朝代初期）和三级（朝代末期）政府，到了新中国时期，逐渐演变成五级政府，即随着技术手段的进步，中央权力越来越能够直接渗透到底层。</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220515212127.png"></p><p>同一级别的政府部门的权力和资源有可能存在很大的差别，例如省会城市 &gt; 非省会城市，县级市 &gt; 县 &gt; 市辖区；这套制度并不是固定的，而是根据实际情况需要，不断的进行调整和变化，以实现国家的一些战略目标。</p><p>我国政府体制的几个特点：</p><ul><li>中央与地方：维持国家的统一需要中央具备权威，但中国巨大的地域范围和差异又要求给地方政府充分授权，才能因地制宜，调动地方积极性和主动性，实现效益最大化；</li><li>党和政府：原则上党负责重大决策和人事任务，政府负责执行；但在实际执行过程中，二者可以说是一体化的；</li><li>条块分割，多重领导：四套班子在中央、省、市、县都完全复制。上下级部门的垂直关系（条条）以业务为主，同级部门的关系（块块）则以领导关系为主，因此人事任免由地方党委负责；</li><li>上级领导与协调：由于不同的部门负责不同事项，权力在各种部门中分散。为了避免跨部门的事宜出现踢皮球，如果该事情经常发生，一般会设置某个领导小组或分管领导，来负责多部门间的协调和推进；否则则优先让该事情在单个部门内部自主决策；</li><li>官僚体系：人事任免是整个官僚制度的核心，为了避免地方尾大不掉，历朝历代对官僚制度不断进行改进，包括官位不可继承、以非血缘关系标准任用官员（如科举、军功等）、官员必须学习某种统一的意识形态（例如儒家思想、马列主义等）、官员由上级任命并不定期多地轮换等；</li></ul><h3 id="外部性与规模经济"><a href="#外部性与规模经济" class="headerlink" title="外部性与规模经济"></a>外部性与规模经济</h3><p>行政区划决定了地方政府的权力范围，一件事情如果没有影响外部，则应该由本地政府自主决策；如果影响了他人，则应该由上级部门协调，以避免出现损人利己的情况；</p><h4 id="公共物品和服务的边界"><a href="#公共物品和服务的边界" class="headerlink" title="公共物品和服务的边界"></a>公共物品和服务的边界</h4><p>政府的核心职能是提供公共服务和物品，这些服务和物品如果被越多人使用，那么越有规模效应。但有些服务是有使用范围的局限的，比例一个实体的公园，仅对居住在公园周边的居民有利，住太远就没有意义了。因此，如果一个公共物品的使用覆盖范围越大，那么它越应该归到越上级的政府（也即行政区别越大的政府层级）去管理。反之，如果使用范围越小，那么越是应该归类到低层级的当地政府部门进行管理；</p><p>政府能够提供的公共服务的覆盖范围，跟所在时代的技术条件有很大的关系，这也是为什么秦始皇需要统一度量衡、货币和语言的原因，因为有利于降低公共服务的成本，实现更大的规模效应。</p><h4 id="人口密度、地理与文化差异"><a href="#人口密度、地理与文化差异" class="headerlink" title="人口密度、地理与文化差异"></a>人口密度、地理与文化差异</h4><p>行政区划中的人群越多，那么相同的公共服务就能够被越多的使用者摊薄。因此，人口密度低的地区，例如新疆、西藏，行政区划就会比较大，这样才能够达到足够多的人群来摊薄行政成本；</p><p>地理条件会影响交通便利性，从而影响了公共服务的覆盖范围，显然不适合让行政官员翻山越岭去提供服务，这样做的成本太高。因此地理环境也会直接影响到行政范围的划分。地形条件其实也是方言形成的原因，而同一个区划，是否使用相同的语言，显示会影响到行政成本。因此，不同方言片区一般划分到不同的行政区划中更合适。</p><p>新中国建立初期，行政区划主要沿用过去的划分。但随着经济发展、技术进步、交通便利，在新的时代衍生了重新划分行政区别的需求，以便能够实现更高效的公共服务，例如大湾区、长三角城市群。</p><blockquote><p>古时代中央政府为了避免地方尾大不掉，在划分行政范围的时候，故意使用犬牙交错的原则，以避免地方政府利用地形天险反抗中央。</p></blockquote><h4 id="行政交界地区的经济发展"><a href="#行政交界地区的经济发展" class="headerlink" title="行政交界地区的经济发展"></a>行政交界地区的经济发展</h4><p>行政区划的交界处，一般经济发展都比较落后，俗称三不管地带，主要有几个原因：</p><ul><li>交界处一般离行政中心比较远，不利于低成本获得公共服务；</li><li>交界处一般也挨着地理山川分界线，相比中心腹地，海拔更高，交通不便，物流成本高；</li><li>交界处一般有多种语言、多种族群杂居，行政沟通成本高；</li></ul><blockquote><p>这也是为什么革命根据地总是出现在这些地区的原因；</p></blockquote><p>行政区划决定了权力范围，因此必然会产生地方保护主义和市场分割现象。从宏观的角度来看，这样会增加成本，并不利于整体的经济发展，因此需要更深入的改革，实现生产要素的市场化程度，例如整合不同区划的用地指标和户籍制度；</p><p>在实现全国整合之前，第一步要实现的是实现区域整合。例如以工业为主的市中心，和以农业为主的县城，二者对政府的公共服务需求不同。如果利用有限的公共资源，尽量满足多样性的需求，是对政府行政能力的挑战。通常有两个方向，一个是扩大县的权力，设置县级市，让县拥有更多的自主权力；另一个是扩大城市，撤县设区，整合县城资源，例如土地指标；</p><h3 id="信息不对称"><a href="#信息不对称" class="headerlink" title="信息不对称"></a>信息不对称</h3><p>有效决策的前提是拥有信息，但获得信息是有成本的。如果成本太高，那么管理起来就会很困难。离业务一线越近的人，了解的信息越多；越远离一线的人，了解的信息越少。因此前者在决策时，拥有比后者更大的成本优势。</p><h4 id="信息与权力"><a href="#信息与权力" class="headerlink" title="信息与权力"></a>信息与权力</h4><p>虽然上级可以推翻下级的所有决策，但是由于上级不见得拥有足够的信息，因此很多事情需要放权给下级政府自主决策，否则上级需要先为收集信息付出很大的成本，才有可能做出正确的决策。所以导致出现”县官不如现管“的现象，其背后的本质原因就在于双方拥有的信息优势不同。事实上行政区域的划分，背后也同样跟信息获取成本有关。</p><h4 id="信息获取与隐瞒"><a href="#信息获取与隐瞒" class="headerlink" title="信息获取与隐瞒"></a>信息获取与隐瞒</h4><p>获取和传递信息需要付出成本，因此作为信息载体的文件和会议，便成为体制内工作的一个重要组成部分。之所以造成这个现象，跟国情有关。因为目前绝大多数政府的事权，都不是通过法案的形式明确下来的，而更多是通过部门规章制度（即各类文件）来划分的，这也造成了有中国特色的文山会海现象。信息的传达以文件为载体，事项的决策则以会议为载体。因此中国政府关于文件和会议，有一套非常详细的制度。</p><p>由于信息会影响决策，因此利益相关方有动机去隐瞒或者扭曲信息。因此上级政府需要对下级进行监督和审计，以免下级政府弄虚做假。</p><p>由于政府管理的事项很多，因此需要获取的信息很多，但是由于各种事项没有清楚的法律界定，因此事情常常有些模糊两可，导致权力和责任容易出现个人化。由于很多事情在决策时，无法掌握足够的信息，因此决策难以使用某种有效的数据指标进行衡量，最终只能采取”一把手责任制“，导致权力向一把手集中，存在专权和腐败的隐患。这也同时导致上级在关键岗位选拔下级时，更看重的是该下级是否可信。</p><h3 id="激励相容"><a href="#激励相容" class="headerlink" title="激励相容"></a>激励相容</h3><h4 id="垂直管理"><a href="#垂直管理" class="headerlink" title="垂直管理"></a>垂直管理</h4><p>激励相容表示 A 想实现某事，此时 B 也有意愿和能力实现该事，那么 A 和 B 之间满足激励相容的原则。政府的权力分配，需要尽量满足激励相容原则。政府内部的事务可以分为具体和抽象两大类，前者指有成熟的标准做法，同时结果也容易量化考核，例如海关；后者指需要因地适宜，灵活变通的事情，例如发展地方经济，该目标没有标准答案，各个地方应该根据本地区的优劣势，选择不同的发展方案。</p><p>如果某件事情的成功与否，跟当地政府是否配合密不可分，那么该事情最好放权给地方管理，上级政府主要负责考核结果即可，这样符合激励相容原则。如果不这么做，改成由上级政府垂直管理，那么二者就不容易形成默契的配合，因为二者的利益经常会存在冲突。例如地方为了快速发展经济，有可能放松监管力度，允许一些灰色操作。但上级政府出于长远考量，不允许放松，例如环保；</p><p>中国政府实现条块管理，但具体到某个部门，是以条为主，还是以块为主，则应该具体问题具体分析，避免一刀切，才能最有效的实现管理目标。</p><h4 id="地方管理"><a href="#地方管理" class="headerlink" title="地方管理"></a>地方管理</h4><p>属地管理原则适用于实现一些抽象目标，例如发展地方经济。上级政府既要放权给下级政府，同时也要在实现目标后，给予下级政府有效的奖励，这样才能够调动下级政府的积极主动性。同时上级政府也要在大方向上把握分寸，避免下级政府为了实现目标不择手段，竭泽而渔。</p><blockquote><p>外部性、规模经济、信息成本、激励相容等，都是用来划分事权的原则，这些属于制度设计范畴。除此之外，通过加强教育宣传，让官员和民众能够就大方向上的价值观达成共识，也能够有效减少冲突和矛盾。事务划分并非中央和地方两极化，有些事情两头都有涉及，例如，此时则多设置为共同事权；</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>中国地方政府并非仅仅如国外主流定位的公共服务和物品的提供者，它的权力非常广泛和巨大。为了能够实现发展的目标，地方政府深度参与到市场经济中，既是裁判，也是球员。中国独特的土地国有制度，让地方政府零成本获得了原始资本积累，这是其他国家所不具备的优势。</p><p>为了吸引大企业入驻，地方政府做的事情非常多，包括提供基础设施（土地一级开发，七通一平）、低成本土地转让或出租、协助办理管制行业的牌照、协助企业获得银行贷款、通过地方投资平台和国企进行注资入股、提供各式补贴和税收优惠等；可以说企业发展所需要的各式资源，很大都掌握在地方政府手里。因此地方能够有效的融合这些资源，来完成招商引资的目标。</p><p>各级政府事权的划分，受到客观规律的支配，包括外部性和规模经济、信息不对称、激励相容等，因此事权如何划分大部分时间内都是较为稳定的。办事就要花钱，没钱难办事，因此财权的划分需要参考事权，才能起到最好的效果。</p><h2 id="二、财税与政府行为"><a href="#二、财税与政府行为" class="headerlink" title="二、财税与政府行为"></a>二、财税与政府行为</h2><p>没钱难办事，因此研究政府的行为时，仅靠看文件是不够的，更重要的是看政府如何花钱。后者才真正决定了政府的工作重心和意图。</p><p>事权主要在地方政府，因此地方政府的预算支出占全国总支出的比例达到了 85%，但是有意思的是，地方的财政收入只占全国财政总收入的 50% 左右，中间差额的部分，主要靠中央转移支付来弥补。这个设计很有意思，相当于中央掌握着地方的钱袋子，间接实现了中央对地方的控制，同时也催生了地方政府强烈的创收动机，导致出现了土地财政。</p><blockquote><p>1994 年税收改革，是一个重大的转折点；在 1994 年之前，地方的财权和事权是基本匹配的，但这也带来了一系列问题，并最终导致了 1994 年的改革；</p></blockquote><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220523215133.png"></p><h3 id="分税制改革"><a href="#分税制改革" class="headerlink" title="分税制改革"></a>分税制改革</h3><h4 id="财政包干及后果"><a href="#财政包干及后果" class="headerlink" title="财政包干及后果"></a>财政包干及后果</h4><p>改革开放后，为了避开直接对所有权进行改革的意识形态阻力，受家庭联产承包责任制的启发，政府从使用权切入，搞承包制，小至家庭，中至国有和集体企业，大到地方财政，都在实施不涉及所有权转移的承包制。1980 - 1984 年，财政包干制先在部分地区进行了实验，之后在 1985 年开始全国推行，即传说中的“分灶吃饭”。</p><p>各地区实施的承包制五分八门，但大原则都是按照约定的比例和金额上缴完中央后，剩下的都归地方支配。因此地方政府有很大的动力增加财源。这种动力催生了乡镇企业的兴起，通过大力发展乡镇企业，能够为地方政府带来很多收入。在 1995 年乡镇企业发展的高峰时期，创造了 6000 多万的就业岗位。</p><p>承包制确实有利于快速激发基层的生产积极性，迅速扭转了计划经济造成的不利局面。不过由于地方和中央存在天然的信息不对称性，很多地方政府通过设置各种预算外收费，截取了很大的一部分收入，造成了中央财政收入在国民经济中所占的比例越来越小，中央越来越失去了话语权，无法有效实现其战略目标。俗话云，手里没把米，叫鸡都不来。</p><h4 id="分税制改革与央地博弈"><a href="#分税制改革与央地博弈" class="headerlink" title="分税制改革与央地博弈"></a>分税制改革与央地博弈</h4><p>1994 年的税制改革后，税收主要分为三类，分别对应不同的受益对象，例如中央税（例如关税）归中央，地方税（如营业税）归地方，增值税则由双方共享；并设立了国税和地税两套机构，税务机构实行垂直管理，以避免地方政府干预税务影响中央的收入。由于两套税务系统增加了企业的纳税负担，于是在 2018 年，两套机构重新合并在了一起。</p><p>增值税是税收大头，整体占比达 25%，在改革之前，属于地方税。改革后，中央拿走了 75%，导致地方收入锐减。为了避免地方抵制，中央承诺返还，以保证地方政府在改革后，仍然能够获得和改革前相同的收入。</p><p>企业收入税是第二大税种，占比接近 25%；在改革之前，企业所得税按隶属关系上缴，央企交中央，地方国企交地方。因此地方有很大的动机创办各种纳税多的企业，例如烟厂和酒厂，而且实施地方保护主义，使用行政手段避免异地产品流入本地市场。改革后，中央和地方实行六四分，中央得六，地方得四。为了减少改革阻力，中央同样制定了返还政策；很多地方政府为了在改革后第二年获得更多的返还金额，不惜突击征税以扩大基数；</p><p>分税制整体上来说是一次相当成功的改革，它带来了诸多好处。中央掌握更多的财权后，能够集中力量办大事，加大了宏观调控的能力，为后续的各项重大工程（如国防建设）和重大改革（如国企改革）奠定了经济基础。但它也造成了地方政府事权和财权的不匹配，从而催生了地方政府通过土地财政进行创收的现象。</p><h3 id="土地财政"><a href="#土地财政" class="headerlink" title="土地财政"></a>土地财政</h3><h4 id="招商引资与税收"><a href="#招商引资与税收" class="headerlink" title="招商引资与税收"></a>招商引资与税收</h4><p>分税制改革前，企业所得税按隶属关系上缴，改革后，按所在地上缴。因此地方政府有强烈的动机招商引资，增加本地区企业的数量和规模（尤其是重资产的制造业，例如石化、汽车等），从而获得更多的税收。</p><p>由于税收主要来源于企业（接近90%），并且增值税在生产环节征收，而不是在消费环节收，因此地方政府的财政支出侧重服务企业（例如基础设施建设），而不是服务民生（教育、医疗等），重生产，轻消费。它的好处是让中国在短时间内成为了制造业大国，缺点是各地区存在重复建设，导致容易出现产能过剩。</p><blockquote><p>最近几年，中央强调投资和消费的平衡，截至 2018 年，在财政支出占比中，社会文教支出上升到了 40%；</p></blockquote><h4 id="土地财政-1"><a href="#土地财政-1" class="headerlink" title="土地财政"></a>土地财政</h4><p>中国土地制度比较特殊，城市土地归国家所有，农村土地归集体所有。如果农业用地要转变用途，变成生产用地，那么需要办理征地手续，才能变成国有土地。这个制度造成了后续的城乡割裂，城市土地因为稀缺造成了价值连城，而大量的农村土地却得不到合理的利用。</p><blockquote><p>中央也意识了土地二元制度所造成的以上问题，因此于 2020 年开始推动土地制度改革，以便在未来建议全国统一的土地市场；</p></blockquote><p>刚开始实施税改时，国有土地的价值还没有显现。转折点是 1998 年的房改，实施住房货币化，停止单位福利分房。同时新版的土地管理法强制要求农业用地转建设用地必须办理征地手续，直接导致了城市土地在建设用途上的稀缺性和垄断性。</p><blockquote><p>1999 - 2000 年时期，国有土地转让机制还未成熟，有些房地产企业通过关系，获得一些国有企业转让的土地，然后按规定缴纳少量土地出让金后，便获得了开发许可。由于利润巨大，存在着很多腐败现象。为了治理腐败，中央于 2001 年开始推行招拍挂制度；之后地方政府开始大量征收农民用地然后进行有偿转让，获得了巨大的财政收入。2003 年土地相关收入（出让金 + 税费）已达到地方预算收入比例的 55%，现在则高达 80-90%；</p></blockquote><p>虽然地方政府通过出让土地获得了大量收入，但实际上并没有利润，因为地方政府同时又将收入投入到了土地开发环节中，例如拆迁补偿和“七通一平”等基础设施建设环节；事实上，土地收入并非地方政府的目标，通过土地换取商业经济活动，才是它的最终目标。因此地方政府在出让工业用地时，价格是非常低的，几乎等于白送。然后通过限制商业和住宅用地的供给比例，制造稀缺性，推高了该类土地的价格来获得收入补偿。</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220601205557.png"></p><h4 id="税收、地租与地方政府间竞争"><a href="#税收、地租与地方政府间竞争" class="headerlink" title="税收、地租与地方政府间竞争"></a>税收、地租与地方政府间竞争</h4><p>事实上由于企业选择入驻地区的灵活性，地方政府也很难抬高工业用地的出让价格，因为它需要面临其他地区的激烈竞争。但商住用地主要服务本地居民，因此不存在地区间的竞争问题。</p><p>地方政府通过利用手中掌握的税收和土地资源，开展招商引资工作。但由于行政区划的属地特点，不同地区的地方政府之间，无法实现资源的互补，例如土地指标。一线城市用地非常紧张，但指标有限，同时地处大西北地区的地方政府其指标却用不完。</p><p>经济发展存在马太效应，头部城市随着各种资源越来越集中，获得了更大的规模性，从而具有更大的成本优势。此时后发的中西部城市已经无法与之竞争，只能寻找差异化策略。因此旧的机制已经不适用于新的经济发展情况了。</p><h3 id="纵向不平衡与横向不平衡"><a href="#纵向不平衡与横向不平衡" class="headerlink" title="纵向不平衡与横向不平衡"></a>纵向不平衡与横向不平衡</h3><p>虽然实行分税制后，中央通过转移支付弥补了地方收入的不足，但是由于转移支付是从上往下支付的，因此各级政府为了发展本级政府的目标，总是会截留一部分，最后便导致了基层政府极度缺钱。</p><h4 id="基层财政困难"><a href="#基层财政困难" class="headerlink" title="基层财政困难"></a>基层财政困难</h4><p>分税制叠加上级权威，导致出现了财权上层截留，事权下层加压的现象。从全国平均数字看，财政预算收入勉强够发工资，但地区间存在不平衡。东部沿海地区通过土地收入，发完工资后，尚有余钱搞建设。西部地区则连发工资的钱都不够，但基层政府收到的办事任务并没有减少。因此，为了弥补亏空，基层政府出现了乱收费和拖欠现象，导致干群关系紧张和出现各种群体性事件；</p><p>为了应对基层政府财政困难的问题，中央出台了几项措施：</p><ul><li>取消农业税和各种乱收费，提高农民收入；</li><li>中央承担部分农村公共服务费用，减轻基层政府负担，例如九年义务教育经费、新农合、新农保；</li><li>奖励地方政府减少编制，减少冗余人员；</li><li>上级政府统筹基层财政，例如乡财县管和省直管县，规范基层政府的支出，减少中间层政府的截留；</li></ul><blockquote><p>虽然省直管县的初衷是为了减少市级政府的截留问题，但这种做法有利有弊。一是当需要管理的县太多时，省级政府经常管不过来，而监管不力导致县里容易出现腐败；二是县和市之间的协作变少了，各搞各的，不利于统筹发展；</p></blockquote><h4 id="地区间不平衡"><a href="#地区间不平衡" class="headerlink" title="地区间不平衡"></a>地区间不平衡</h4><p>东部沿海的运输成本优势，在中国加入世贸组织后，得到了突显。而产业聚集则逐渐加大了东西部之间的发展差距。中央通过转移支付，尽量缩小地区间的差异，但目前差距仍然非常明显。因为虽然中央拨款让各省的人均支出大致相等，但其中很大一部分都被各级政府截留了，导致最后到了基层政府手上已经没有多少。</p><p>中央的转移支付分为一般性和专项性两种，大约是六四开；前者地方政府可以自由支配。后者则是专项专用。其设计的初发点是为了避免地方失去发展动力，坐等发钱。但最终结果跟初衷正好相反。由于资源有限，各级政府在分配款项时，并非平均分配，而是优先安排给重点项目，而有经济优势的地区，更容易有大项目；另外此项转移支付通常会要求地方政府出配套资金，有经济优势的地区更容易出得起配套；另外经济发达的地区，更有资源做好上级政府的公关，导致能够通过关系拿到更多的转移支付；</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>分税制改革可以说是牵一发而动全身，这项改革直接造成了后续出现的各种社会现象；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220601222345.png"></p><p>虽然土地财政为地方政府贡献了很大一部分收入，但是它并不是一个地区发展的主要资金来源，可能只占了三分之一。真正的大头，其实是依附于土地之上的银行信贷。地方政府通过杠杆，撬动了更大体量的资金；它的好处是推动了经济的快速发展，坏处则是地方政府背负了越来越大的债务；</p><h2 id="三、政府投融资与债务"><a href="#三、政府投融资与债务" class="headerlink" title="三、政府投融资与债务"></a>三、政府投融资与债务</h2><p>大多数农业活动并没有很高的技术附加值，因此土地如果用来发展农业的话，本身价值有限。不管哪个地区或国家，都拥有大量的土地，而且传统上也都是用来发展农业。但如果将土地用于发展高附加值产业的话，它的价值便产生巨大的变化。中国经济制度中最特殊的一点是土地是国有的，因此政府通过有计划的产业规划和招商引资，能够将工商业引导到指定区域（城市土地）中，让该地区的土地价值暴涨。之后政府通过金融杠杆（允许银行为土地提供贷款）放大可使用的资金规模，完成更多的基础设施建设和土地一级开发，推动下一轮的循环。</p><h3 id="城投公司与土地金融"><a href="#城投公司与土地金融" class="headerlink" title="城投公司与土地金融"></a>城投公司与土地金融</h3><p>相对于买卖基金股票的金融投资，实业投资的复杂度高了不止一个数量级，一旦涉入，中途就很难脱身离场，需要一直坚持直到项目成功为止，不然会有很大的沉没成本，不像金融投资那样可以随时变现离场。中国政府不仅掌握着土地资源，还掌握着金融资源。在经济发展过程中，政府并不只是一个公共服务提供者，还是一个经济活动的深度参与者。政府不仅通过投资建设基础设施来提供公共服务，还参与了很多工业项目投资。</p><h4 id="地方政府融资平台"><a href="#地方政府融资平台" class="headerlink" title="地方政府融资平台"></a>地方政府融资平台</h4><p>虽然从法律的角度，各级政府不能直接从银行贷款，但是由于政府可以管理国有企业，因此政府通过国资委设立独资的国有企业，便能够间接通过该企业从银行获得贷款了。这种类型的国企一般称为“地方政府融资平台”，相当于地方政府参与实体经济活动的一个马甲。</p><p>成都宽窄巷子即是融资平台的一个典型案例，成都政府国资委通过成立独资国企开发和运营该项目。这类型项目的三个常见特征：</p><ul><li>地方政府为项目注入土地使用权；</li><li>地方政府前期提供项目补贴，作为项目盈利前的运营资金；</li><li>由于存在地方政府的隐性担保，项目能够从银行获得大量贷款；</li></ul><blockquote><p>地方政府除了自己成立国企进行经营外，更常见的做法是和民企合作，地方政府负责提供土地，民企负责经营，二者各占一部分股份，例如上海新天地；</p></blockquote><h4 id="工业园区开发"><a href="#工业园区开发" class="headerlink" title="工业园区开发"></a>工业园区开发</h4><p>成都宽窄巷子是一个旅游类项目，占比较少。更常见的项目是工业园区开发和城市基础设施建设，例如苏州工业园区即是一个典型案例；该项目由两家地方国企主要负责，一家负责土地一级开发（九通一平，将生地变成熟地），另一家负责二级开发（建设、招商、运营等工作）；</p><blockquote><p>苏州工业园区占地接近 300 平方公里，2019 年 GDP 接近 3000 亿，财政预算收入接近 400 亿，体量巨大，比常规的地级市还大。</p></blockquote><p>苏州工业园区之所以能够获得很大的成功，有两个重要因素，一个是其地理位置，位于长三角；二是园区运营管理水平，有效聚合本地资源和优势产业，形成集群</p><blockquote><p>脱离这两个因素的话，貌似这种模式在中西部地区很难复制。</p></blockquote><p>产业园区的重点是招商，因此租金需要很便宜才有吸引力。因此该类项目的一个特点是盈利周期非常长，导致有意愿和能力参与的民企比较少，华夏幸福是这少数中的一家。它的模式是产城结合。从地方政府手中低价获得土地后，一部分用来建造工业园，一部分用来建造住宅。用后者赚的钱，补贴前者，同时跟地方政府进行税收分成，有点像是在小规模造城。从某种意义上来说，跟很多地方政府的土地财政模式没有本质区别。</p><blockquote><p>这种地方政府和企业合作的项目，称为 PPP 模式，起源于国外。只是在中国，更多是国企参与，而非民企。</p></blockquote><h3 id="地方政府债务"><a href="#地方政府债务" class="headerlink" title="地方政府债务"></a>地方政府债务</h3><p>在 94 年税改后，中央拿走了税收的大头，虽然地方政府通过转移支付和税收返还能够弥补一部分缺口，但也仅仅勉强够发放当地公务员的薪资，如果想要进一步发展经济，就需要增加收入渠道。由于中国的特殊制度，土地所有权归属国家和集体，因此地方政府通过土地质押，从银行获得了杠杆资金。这种杠杆资金本质上是预支未来的收入。如果这些借来的钱，能够投入到有回报的项目，那么未来的收益就能够偿还今天的债务。但如果投资失败，则存在无法偿还到期债务的风险。</p><blockquote><p>对于地方政府，其投资的项目通常为基础设施和工业项目，如果这些项目带来了经济增长和人口流入，那么该地区未开发的土地就会升值。地方政府通过在未来出让这些升值后的土地，就能够偿还债务。但是如果地方政府的没有带来经济增长的话，那么未来的债务则难以偿还（例如贵州赤水当前即面临这个问题）；</p><p>08 年金融危机时，中央放松了信贷和项目审批门槛，因此泥沙俱下，很多地方政府的投资项目并不优质，导致累积债务风险。这些风险最后都需要付出代价来化解。</p></blockquote><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220612082805.png"></p><h4 id="国家开发银行与城投债"><a href="#国家开发银行与城投债" class="headerlink" title="国家开发银行与城投债"></a>国家开发银行与城投债</h4><p>政府有很多投资项目其实是没有正收益的，因为这些项目经济是一些民生服务项目，例如地铁、公路、公园、自来水等（即使有收入，回报周期也非常的漫长）。仅靠每年的财政收入，是很难支撑这类项目的开发和运营的。但这些项目却又是发展地方经济不可或缺的配套设施。因此政府需要从其他正收益的项目获得转移支付，才能够实现一揽子方案。</p><p>赚钱的项目大家抢着做，亏钱的项目没人做，因此将每个项目独立运作的话，显然难以落地，需要打包才行。城投公司的出现，即是为了实现这种打包。只要所有项目的总收益是正的，那么城投公司就能够从银行获得贷款，推动所有项目的落地。02 年全国推行招拍挂之后，城投公司开始能够从土地增值中获得额外收益，来偿还银行的贷款。</p><blockquote><p>为城投公司提供融资的银行主要为国开行、四大行、城商行等，大致三分天下。前两者由于资金来源稳定，能够承担项目周期长的风险。而城商行的资金则主要来源短期同业融资。因此当市场出现流动性紧张时，容易出现资金链断裂风险；</p></blockquote><p>城投公司的资金来源除了银行贷款外， 还有一部分来源债券（即城投债）；由于这种债券背后有政府作隐性担保，因此在市场上很畅销，但绝大多数被银行购买和持有，缺少流动性，导致金融风险仍然集中在银行手上，没有分散到广大投资者手中；</p><blockquote><p>高风险高收益，低风险低收益。债券原本最大的作用，是通过价格机制，适配市场上不同风险偏好的投资人。但城投债由于低风险，导致这种适配没有出现。</p></blockquote><h4 id="地方债务与风险"><a href="#地方债务与风险" class="headerlink" title="地方债务与风险"></a>地方债务与风险</h4><p>对于有限责任公司来说，其债务仅范围于注册资本范围。但中国地方政府通过设立企业参与经济的特殊性，导致形成了隐性负债。虽然这些债务表面上局限于国企内部，但市场普通认为背面政府会提供隐性担保，因此放大了杠杆和风险。</p><p>截至 2018 年，地方债+中央债约占 GDP 的 80%，跟其他发达国家比较的话，这个比例并不高。但问题在于债务呈现区域不平衡的状态。欠发达地区和低层级政府的债务风险和负担更高，容易出现债务危机。</p><p>中国政府的债务以投资基础设施项目为主，发达国家则以民生保障为主。虽然基础设施类项目的收入低，回报周期很长，但存在一定的外部效应，能够带动相关产业的发展。虽然地方政府的隐性担保可以让融资平台借新债还旧债，但是由于收入低，仍然不足以覆盖利息成本，因此绝大多数地方政府都需要为融资平台提供财政补贴。</p><blockquote><p>地方政府之所以有钱提供补贴，原因在于融资平台的投资，带动了地价的上升。因此地方政府通过卖地获得额外的收入。如果土地市场遇冷，地价下跌或者流拍，地方政府捉襟见肘，入不敷出；</p></blockquote><h4 id="地方债的治理和改革"><a href="#地方债的治理和改革" class="headerlink" title="地方债的治理和改革"></a>地方债的治理和改革</h4><p>地主债的治理始于 2010 年，治理方法之一是让地方政府发行公债，置换融资平台的银行贷款和城投债；但为了避免地方债务进一步增加，发债规模需要由中央统一管理。该方法有三个好处：</p><ul><li>公债利率低，大约只有 3-4%，低于银行贷款的 7-8%，低利率一来可以降低地方政府的利息负担，二来也避免因低风险收益高，挤占银行发放给企业的贷款额度；</li><li>公债周期长，降低了资金错配成本；</li></ul><p>治理方法二是剥离融资平台和地方政府的隐性担保关系。当发生债务纠纷时，法院不再支持政府为融资平台出具的保函，以便让融资平台回归为普通国企。但由于融资平台负债规模很大，而地方发债规模有上限，因此无法在短期内完成置换工作，还有很长的路要走；</p><p>治理方法三是增加对银行的监管，避免银行将过多的资金借贷给融资平台；</p><p>治理方法四是对官员实现终身问责制，以抑制官员过度举债的行为；该方法的监管难点倒不在于举债规模，而在于如何避免官员将债务投资到没有收益的项目；</p><h3 id="招商引资中的地方官员"><a href="#招商引资中的地方官员" class="headerlink" title="招商引资中的地方官员"></a>招商引资中的地方官员</h3><p>由于科举制度的存在，历朝历代都注重从社会中选拔精英作为官员来源，因此中国自古以来有学而优则仕的传统。即使到今天，这一传统依然存在。公务员队伍的平均学历水平要远高于整体社会的平均水平。在中国的公务员系统中，中央公务员只占5%左右，剩下的都是地方公务员组成；相对其他国家，这一比例是非常特殊的，例如美国达到 19%，日本 14%；</p><blockquote><p>背后的原因估计在于中国地方社会缺少自治的传统，因此所有的公共事务，都是统一由政府机构进行处理的，从而导致了官僚队伍的庞大；</p></blockquote><h4 id="官员政绩与激励机制"><a href="#官员政绩与激励机制" class="headerlink" title="官员政绩与激励机制"></a>官员政绩与激励机制</h4><p>由于僧多粥少，大多数普通政府职员并没有太多的晋升机会，但是他们的收入通常跟所在部门的绩效或地区济发展水平和财政收入相关，因此他们也有一定的经济利益动机促进当地的经济发展。</p><p>多数地级市的书记和市长平均任期只有 3 年左右，这意味着中国每年有三分之一的地级市会更换市委书记或者市长。由于基础设施类的项目建设周期长，至少 2-3 年起步。为了在任职内做成成绩，新上任的官员会快速上马大项目和大工程。</p><p>2016 年之前，由于旧官员调任后不再需要对原任内的债务承担责任，而新官员通常也不理旧账，因此导致了地方债务快速增长，加大了风险，同时也导致了重复建设、产能过剩、投资边际效益递减等问题；针对该问题，中央开始提出供给侧改革的战略方向，并调整了对官员选拔的考核机制，不再唯 GDP 论，而是更加全面和综合的全面考核，既有经济方面，也有文化、民生、生态等方面；</p><p>政绩关乎晋升，但机会只跟一把手有关，对于绝大多数（99%）的基层公务员来说，晋升跟他们并没有关系。因此他们更看重的是自己能够获得的工资、奖金、补贴等经济收入；</p><h4 id="腐败与反腐败"><a href="#腐败与反腐败" class="headerlink" title="腐败与反腐败"></a>腐败与反腐败</h4><p>政府主导投资和依赖土地金融获得财政收入，以及权力高度集中于一把手的局面，直接导致了土地相关环节成了腐败的重灾区。2013 年党的十八大之后，反腐败成为中央最重要的工作内容之一。截至 2019 年，查处了 15.6 万县处级以上干部，其中包括 1.8 万厅局级干部和 400 多名中管干部；</p><p>虽然腐败严重，但它却与中国的经济高速发展并行，且在不同的时期呈现不同的特点：</p><ul><li>80 年代，价格双轨制导致的“官倒”和“投机倒把”；</li><li>90 年代，国企改革带来的国有资产流失；</li><li>2000 年之后，土地开发相关的利益输送成为主流；</li></ul><p>腐败有两种主要形式，一种是掠夺式腐败，政府官员对企业或民众进行敲诈勒索，这类腐败在 80-90 年代主体体现为乱收费和乱罚款，现在由于技术进步，已经很少见了，因为很容易追查；第二种是官商勾结式腐败，二者相互进行利益输送，这类腐败是主流。</p><p>党的十八大后，将反腐败作为整个社会改革中重要的一环，在连续多年的高压推进下，取得了很大的进展。民众对政府的满意度从 35% 提升到了 65%，尤其是对中央政府的满意度达到了 80 分以上；</p><p>反腐败的根源办法还是需要简政放权，官员手中的权力越少，就越不容易有腐败的机会。党在十九大之后的战略方向，也开始往转变政府职能，继续简政放权的方向调整，逐渐成为服务型的政府；</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>94 年税制改革后，虽然中央通过转移支付，维持地方的收入不减少，但地方债务仍然快速增长，其背后的原因在于地方承担了经济发展的重任，需要花钱的地方非常多，因此需要通过土地金融杠杆进行举债。解决这个问题的根源性措施，可能在于是否转变政府的角色，由生产投资型政府，逐渐过渡到服务型的政府。</p><blockquote><p>能否实现角色转型，还需要考量当政府退出原本的生产投资职能后，社会机构能否填补有效该职能；</p></blockquote><h2 id="四、工业化中的政府角色"><a href="#四、工业化中的政府角色" class="headerlink" title="四、工业化中的政府角色"></a>四、工业化中的政府角色</h2><p>中国今天的市场经济是从计划经济转型而来的，因此地方政府掌握着很多源自计划经济时代的资源，例如金融系统、国企、土地等。这些资产让地方政府有机会尝试参与到市场经济中，对整个市场经济进行强有力的干涉；由于实业投资的复杂性和连续性，决定了一旦地方政府参与其中，短时间内便是不可逆的，无法轻易退出；</p><p>计划经济的历史原因导致了政府在不同行为的话语权和干预程度各不相同，因此在讨论政府行为时，需要根据行业情况，具体问题具体分析，避免一刀切简单粗暴的看待问题；</p><blockquote><p>每个成功的案例背后,除了政策之外,还有很多其他不确定因素,例如天时、地利、人和等因素。因此我们不能简单的以一个案例的成功，就去质疑另外一个案例的失败；因为有些成功的案例中有一些因素是偶然造成的。</p></blockquote><h3 id="京东方与政府投资"><a href="#京东方与政府投资" class="headerlink" title="京东方与政府投资"></a>京东方与政府投资</h3><p>2012 年，中国显示面板进口总值为 500 亿美元；2020 年，中国生产的显示面板占全球市场 40% 左右的份额；该行业之所以发生如此翻天覆地的大变化，背后的原因在于中国显示面板生产企业的崛起，代表企业如京东方、深天马、华星光电等；显示面板价格的下降，带来了一系列电子产品（如电脑、手机、电视）成本和价格的大幅下降，也间接促成了消费电子产品国产品牌的崛起，如小米、华为等；</p><blockquote><p> 地方政府在显示面板企业崛起的过程中发挥了重大作用，例如有多个国资背景公司是京东方的大股东；</p></blockquote><h4 id="京东方与政府投资的故事"><a href="#京东方与政府投资的故事" class="headerlink" title="京东方与政府投资的故事"></a>京东方与政府投资的故事</h4><p>90 年代国内彩电企业崛起，占领了 90% 左右的市场份额。但当时的 CRT 技术开始被平板液晶所替代，国内企业由于缺少该技术，需要完全依赖进口。国外多家面板企业，如LG、三星、友达等，凭着垄断联合起来操纵市场价格，使得面板价格占到了整个电视价格近八成；</p><blockquote><p>之后中国、美国和欧盟等多个国家对这些面板实施了处罚；</p></blockquote><p>为了打破垄断，国内具有自主技术和研发能力的京东方开始受到资本的关注。 北京市政府牵头为京东方提供大量贷款和利息补贴，让京东方的 5 代线得以建成投产。虽然该条线最后亏损，原来投资方的贷款转成了股权。之后面向智能手机小屏幕的 4.5 代线盈利了，这些股权让投资人在二级市场赚钱了；</p><p>京东方后续建设 6 代线时，由于需要的资金量很大，先后找过深圳和上海市政府，但在谈判过程中，都被更有技术实力的夏普截胡了。但夏普并非真的有意在国内投资设厂，其真正的目的是延迟京东方的建设速度，搅局不久后很快找借口毁约放鸽子退出投资了。之后京东方找到了合肥市政府，而合肥也吸引了深圳和上海的教训，不再理会夏普，最终建成了 6 代线，并在之后继续投资了 8.5 代和 10.5 代线。吸引了大量的上下游企业落户合肥，形成了产业集群。</p><blockquote><p>京东方与地方政府的合作模式并非孤例，国内其他显示面板企业如 TCL 和 华星光电，也走了相同的发展路径。</p></blockquote><h4 id="经济启示"><a href="#经济启示" class="headerlink" title="经济启示"></a>经济启示</h4><p>某些产业（如显示面板、CPU 集成电路）的模板效应很强，但投资建设成本非常高，初始需要大量的建设资金。建成投产后，还会抢占同行的市场份额，降低同行的规模效应。因此后来者在进入该产业时，会受到很多先入局的同行的打压。</p><p>政府在决定是否对本国的新兴产业进行投资扶持时，需要考量的一个重要因素是其国内市场的大小。如果该国人口多市场大，那么投资风险就低。但如果人口少国家小，那么政府的投资风险大，因为巨额的投资成本无法被国内人口摊薄，需要依赖不确定性大的出口市场；</p><blockquote><p>东亚多个国家在 70 年代的经济腾飞，都是相似的模式，即政府主导的产业扶持的结果。但是由于各个国家规模大小不同，其能够扶持的产业数量各不相同；</p></blockquote><p>当政府通过降低了某些上游产业的生产成本，提高竞争优势时，这种优势会溢出到国内的下游产业，带动上下游多个产业的发展；产业的发展优势会形成集聚效应和马太效应，具有优势的产业，就会吸引其他相关的配套产业在周围投资建厂，从而降低了彼此之间的物流成本；</p><p>集聚和规模效应除了会降低成本，还会带来技术创新。因为更低的成本意味着更多的利润，从而能够支撑更多的研发投入。单仅靠模仿和技术引进，虽然也能够造出类似的产品，但是由于相关的知识和技术并没有积累在团队人才中，而不知其所以然，是无法创新的。</p><p>越是复杂的产品，其附加值通常也越高，但也同样需要更多的企业进行分工和协作。这时一个国家营商环境的好坏，会直接影响企业间合作的成本，例如健全的法治、稳定的货币政策等因素都很重要；</p><h4 id="地方政府竞争"><a href="#地方政府竞争" class="headerlink" title="地方政府竞争"></a>地方政府竞争</h4><p>很多新兴产业对自然资源要求不高，而国内的基础设施已经非常发达，物流成本差异不大，因此如果地方政府能够吸引到一些龙头企业落地，便有可能在当地形成产业集聚和外溢效应，例如合肥的京东方、郑州的富士康；</p><p>地方政府之间的竞争，也会有一定的产能过剩的风险，尤其是当引进的行业技术和投资门槛比较时，这种风险会更大，例如光伏产业；</p><h3 id="光伏发展与政府补贴"><a href="#光伏发展与政府补贴" class="headerlink" title="光伏发展与政府补贴"></a>光伏发展与政府补贴</h3><h4 id="光伏产业的故事"><a href="#光伏产业的故事" class="headerlink" title="光伏产业的故事"></a>光伏产业的故事</h4><p>70 年代阿拉伯地区实施石油禁运，导致石油价格飞涨。美国出于战略安全，开始扶持发展新能源产业，其产业规模一度占到 85% 市场份额。之后随着石油危机解除，油价回落，美国也慢慢取消了各种扶持政策；之后产业链优势慢慢转移到更多扶持政策的德国和日本等国家；</p><p>2005 年无锡尚德的成功上市，刺激了很多地方政府纷纷效仿。截至 2010 年，已经有 20 多家中国光伏企业在美国上市；与显示面板产业不同，光伏产业的市场并不是国内，而是面向欧美，因为这些国家为了发展新能源产业，对光伏发电实行补贴。由于光伏发电的成本下降速度快于补贴降低速度，因此中间有利润空间。</p><p>2008 年金融危机让欧美国家大幅降低了光伏发电补贴金融，因此国内的光伏企业一下子面临了产能过剩和债务危机，因为其前期的发展主要依赖于银行贷款。为了应对危机，中央和地方政府出台补贴政策，要求电网收购光电，并对与煤电的成本差异部分实施补贴。虽然这些补贴同样设置了退出机制，但由于存在利润空间，国内光伏企业继续加大产能，以其实现利润最大化。产能的上升很快超过了各地政府的财政能力，各种补贴拖欠越来越多。问题非但没有解决，反而变严重了。长痛不如短痛，2018 年政府最终修改了补贴政策，除了降低补贴金额外，还设置补贴上限。新政策再次对光伏产业形成了巨大的冲击，幸运的是，到了该年底，欧盟取消了对中国的反倾销限制，出口市场重新打开，救了整个光伏产业一命。经过多年的发展，光电成本已经逼近煤电，能够实现平价入网，不用再依赖补贴才能生存了；</p><h4 id="经济启示-1"><a href="#经济启示-1" class="headerlink" title="经济启示"></a>经济启示</h4><p>新能源产业的发展是一个典型的先有鸡还是先有蛋的例子。新兴技术在初期并没有成本优势，例如光电一开始的成本是煤电的几十倍。如果纯粹由市场进行调节，根本没有人会有光电。但是如果没有人用光电，意味着产业技术的研发和更新很慢，无法实现规模效应来降低成本。研发和创新单纯依靠高校实验室的研发是不够的，它还需要很多企业配合落地，边做边学，才能够更快的实现技术的迭代更新；因为有些问题不在实践中应用，就很难发现和暴露出来；</p><p>虽然行业危机会让很多企业破产，但企业的死亡跟人的死亡不同。人死亡什么都没有了，而企业死后，它的成员还在，前期积累的技术仍然在这些人身上。当市场重新回暖时，这些人能够重新聚在一起，东山再起；</p><p>政府的补贴并不必然会导致产业的成功，例如欧洲政府对光伏的补贴比中国更早，力度也更大，但欧洲本土光伏企业最终并没有发展起来，反而是为了中国光伏企业做了嫁衣。可以说补贴不一定成功，但不补贴而连机会也没有。</p><h4 id="地方政府竞争与重复建设"><a href="#地方政府竞争与重复建设" class="headerlink" title="地方政府竞争与重复建设"></a>地方政府竞争与重复建设</h4><p>过度投资和产能过剩并不是地方政府招商引资的必然，即使完全交给社会资本进行主导，也同样面临相同的问题，例如几年前的共享单车即是一例，其本质原因在于供给和需求的匹配存在时间差，需求可以在很短时间内爆发，但供给不行。市场行情好时，不可避免会吸引一大堆企业入场，导致最后的产能过剩。</p><p>重复建设之所以在我国更经常发生，主要有三方面的原因：</p><ul><li>我们是发展中国家，很多市场需求已经由发达国家提前验证，随着人均收入的提高，某些需求的出现是确定性的，例如人们会购买各种家电、汽车等。而不确定性少，就容易吸引投资一拥而上。</li><li>地方政府的招商引资政策是有时效性和不确定性的，如果当下不把握，再过段时间政策很可能就没有了；因此企业即使对未来的市场没把握，也只能先占下位置再说，不然就把机会让给竞争对手了；</li><li>出于考核提拔需要，各地方政府会更愿意追随中央的产业政策，以便提升自己的提拔机会，而不会刻意发展不一样的产业。</li></ul><p>重复投资其实并不全是坏处，它至少有两个作用：</p><ul><li>在短期内可以培养大量产业工人，为后续的优胜劣汰打下基础；</li><li>后期的竞争会迫使产业不断升级和创新，带来更低的成本和更好的质量；</li></ul><p>市场经济的精髓并非避免重复建设，而是避免保护和鼓励竞争。通过反复试错，让企业在竞争中优胜劣汰，变得强大起来。因为如果没有淘汰落后企业，就会形成资源错配，导致劣币驱逐良币。</p><blockquote><p> 江西赛维即是一个典型的反面案例。由于该企业为当地贡献了很多税收和就业，导致地方政府不舍得让它破产，不断救助它，结果反而越陷越深。</p></blockquote><p>政府的产业政府能够帮助产业快速发展，但是需要有退出机制，这样才能让企业在竞争中锻炼成长起来。但各既得利益者除于自我利益的更大化，往往让“破产”通道实施起来不那么顺畅。因为维持僵尸企业，银行可以掩盖坏账，地方政府可以维持税收和就业。牺牲眼前换取未来的作法是反人性的。牺牲未来换取眼前才是人性的选择。所以如何让不好的企业破产，往往说起来容易做起来难。</p><h3 id="政府产业引导基金"><a href="#政府产业引导基金" class="headerlink" title="政府产业引导基金"></a>政府产业引导基金</h3><p>传统的风险投资一般是通过成立私募基金，而地方政府的产业引导基金也借鉴了这种形式，它是一种新的招商引资方式，目的在于能够用更加市场化的方式来扶持相关产业。2014 年产业引导基金开始爆发变多，截至 2019 年，国内已经设立了 1600 多只政府引导基金并到位了 4 万多亿元资金；</p><h4 id="私募基金与政府引导基金"><a href="#私募基金与政府引导基金" class="headerlink" title="私募基金与政府引导基金"></a>私募基金与政府引导基金</h4><p>私募基金一般使用有限合伙的方式成立公司，出钱的人作为 LP（有限合伙人），管理的人作为 GP（普通合伙人）；LP 支付每年固定的管理费用；赚钱的话，扣除事先约定的保定收益，超额部分按约定的比例分成，例如二八分；私募基金的投资标的非常广泛，可以是二级市场，也可以是一级市场或定向增发市场；</p><p>由于 GP 作为企业管理者，经常在媒体前面曝光，因此被大众更广为熟知。业绩好的管理者经常成为明星管理人。私募基金背后的 LP 主要以机构为主，例如国家主权基金、养老基金等；政府引导基金一般以 LP 的身份出现，既有国家主导，也有地方政府主导，例如国家集成电路产业基金、深圳引导基金；</p><p>产业引导基金的特点：</p><ul><li>不直接投资企业，而是作为 LP，将钱交给市场化的私募进行管理和投资，同时也吸引其他社会资本共同参与；</li><li>投资方向有一定要求，以战略新兴产业为主，禁止投资基础设施和房地产行业；</li></ul><p>地方政府一般通过三种方式来管理产业引导基金：</p><ul><li>成立独资的国企，专门管理该基金。适合基金规模很大的场景；</li><li>成立混和所有制公司，和社会资本共同持股管理；适用于中等规模的基金，例如深圳引导基金；</li><li>不成立公司，委托给成熟的基金管理公司进行管理；适用于小规模基金；</li></ul><h4 id="政府引导基金兴起的制度条件"><a href="#政府引导基金兴起的制度条件" class="headerlink" title="政府引导基金兴起的制度条件"></a>政府引导基金兴起的制度条件</h4><p>虽然在 2005 年发改委和财政部就已经明确国家和地方政府可以设立产业引导基金，2007 年修订实施新的《合伙企业法》，为 LP&#x2F;GP 模式提供了法律依据和保障；并于 2010 年允许豁免国有股权划转 10% 给社保基金的义务，但产业基金的爆发式增长要一直等到 2014 年才出现；</p><p>2014 年出台了新版的《预算法》，开始严格限制地方政府在招商引资过程中发放给企业的补贴；地方政府为了避免没用完的预算被上级收回，开始将钱转移到产业基金领域；</p><p>2015 年，发改委和财政部出台了一系列细则，为地方政府提供了操作指南，例如允许基金亏损，不参与干预基金的日常事务等；</p><h4 id="政府引导基金兴起的金融和产业条件"><a href="#政府引导基金兴起的金融和产业条件" class="headerlink" title="政府引导基金兴起的金融和产业条件"></a>政府引导基金兴起的金融和产业条件</h4><p>产业引导基金能否成功，除了吸引大量社会资本参与和找到合格的基金委托人外，最重要的是要有畅通的退出变现制度；从 2003 年起，国家陆续出台了一系列政策，奠定了该制度基础。上交所和深交所之后陆续成立了中小板、创业板、科创板以及注册制等，以降低国内交易所的上市门槛；</p><p>政府产业基金一般以投向新兴战略产业为主，一来符合中央的战略发展方向；二来这些产业附加值大，有利于在未来成为国家经济的中流确砥柱；三来这些产业处于技术前沿，依赖研发和创新，不确定性风险高，更需要社会资本和政府资源的帮助；</p><p>当被投资企业获得成功后，政府的产业引导基金能够套现退出，获得回报，因此更具备可持续发展性，不然传统的补贴方式，投入的资金有去无回；</p><h4 id="引导基金的成绩与困难"><a href="#引导基金的成绩与困难" class="headerlink" title="引导基金的成绩与困难"></a>引导基金的成绩与困难</h4><p>产业引导基金的出资方是地方政府，这种非市场化的出身意味着在运作过程中将存在的一些困难：</p><ul><li>虽然理论上允许亏钱，但如果亏多了很难交待；</li><li>地方政府设立基金的初衷是辅助招商引资，但资金无边界，因此有可能钱出了，但企业没来，为他人作嫁衣；</li><li>产业基金一般需要社会资本配套，以降低风险，但有时候找不到足够多的社会资本，导致流产；</li><li>虽然产业基金一般以母基金的身份出现，但依然需要对子基金实行监督管理，此时就需要要专业的人才。但很多地方体制内的薪酬结构难以吸引到高层次人才；</li></ul><h2 id="五、城市化与不平衡"><a href="#五、城市化与不平衡" class="headerlink" title="五、城市化与不平衡"></a>五、城市化与不平衡</h2><p>中国特有的土地国有制度，为城市化提供了启动资本。但由于地方政府此前重投资、轻民生的政策，导致居民收入和消费增长缓慢，生活水平的提高并没有完全跟上经济发展速度。但地价依赖于房价，房价依赖于居民收入。当经济发展停滞导致居民收入增长缓慢时，当前的土地财政便变得不可持续。最终支撑房价的，其实是城市居民的收入；</p><h3 id="房价与居民债务"><a href="#房价与居民债务" class="headerlink" title="房价与居民债务"></a>房价与居民债务</h3><p>94 年税制改革之前，财政包干制让地方政府大力发展地方乡镇企业，以便可以为地方财政贡献收入来源；94 年税制改革后，由于增值税大头缴交上级，因为地方政策的发展重点变成了城市化，以便宜的土地吸引企业入驻，然后高价出让住宅用地获得财政收入；</p><blockquote><p>随着基础设施逐渐完善，交通物流成本变低，原先主要服务于本地市场的乡镇企业开始慢慢式微；2001 年中国加入 WTO 进一步促成了工业向沿海地区的转移和集中，因为规模效应会带来更大的成本优势；</p></blockquote><h4 id="房价与土地供需"><a href="#房价与土地供需" class="headerlink" title="房价与土地供需"></a>房价与土地供需</h4><p>经济发展存在集聚效应，产业和人口的集中自然会带来住房需求的上涨。但需求上涨并不一定会导致房价上涨，因为还要看供给是否也能够快速上涨。虽然中国各个城市的土地面积是固定的，但是用地指标却是由中央严格管控的。当政府发放的指标过少时，就会导致土地供不应求，房价飞涨。</p><blockquote><p>2006 年~2014 年，500 万以上人口的大城市，其人口增量占全国总量约 40%；但其居住用地的指标增量却只占全国的 20%，供不应求，房价快速上涨；反之，300 万以下人口的城市，用地指标增量占比大于人口增量占比，于是这些城市的房价基本保持稳定；</p><p>之所以会出现这个情况，是因为在 2003~2013 年期间，中央为了支持西部开发，有意分配更多的用地指标到西部。土地指标与人口流入不匹配，东西部地区之间的房价差距被加大了；该政策最后被证明是失败的，并没有起到预期中的效果，人口仍然继续向东部流入；</p><p>2020 年，中央开始探索让用地指标在不同省份和地区之间进行流转，以解决之前的遗留问题；</p></blockquote><h4 id="房价与居民债务：欧美的经济与教训"><a href="#房价与居民债务：欧美的经济与教训" class="headerlink" title="房价与居民债务：欧美的经济与教训"></a>房价与居民债务：欧美的经济与教训</h4><p>二战之前，欧美各国的住房自有率并不高，大多在 40% 以下；但近年来，这一比例上升到了 60% 左右；随着房主变多，他们的政治影响力也随之变大；各项新的政策和法律也开始向保护有房者的方向倾斜，例如避免房价下跌，降低按揭门槛，增加贷款供给等；</p><p>住房按揭贷款本质上是居民的债务负担，当经济下行时，由于收入减少，但按揭还款金额不变，居民可消费加剧减少，进而将恶化国家的经济下行趋势；</p><h4 id="房价与居民债务：-中国的情况"><a href="#房价与居民债务：-中国的情况" class="headerlink" title="房价与居民债务： 中国的情况"></a>房价与居民债务： 中国的情况</h4><p>截至 2018 年底，中国居民债务负担约占全国 GDP 的一半。这个比例虽然低于美国，但已经跟德国和日本差不多；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220627204744.png"></p><p>如果计算居民债务负担与家庭收入比例的话，中国和美国差不多，都达到了 1.7 倍左右，即居民家庭债务是收入的 1.7 倍；但构成中国家庭债务的大头是房贷，约占七成；中国居民的财富以房产为主，美国居民则以股票为主；</p><h4 id="房价与居民债务风险"><a href="#房价与居民债务风险" class="headerlink" title="房价与居民债务风险"></a>房价与居民债务风险</h4><p>房价上涨除了带来债务风险外，还会加大贫富差距，进而带来“消费下渗”，即过大的贫富差距会刺激低收入群体借钱消费；越低收入的人群，其债务负担越重；</p><blockquote><p>2014 ~ 2017 年，中国收入最低的人群中，有 50% 的人储蓄为零，甚至是负数；借钱消费的行为本质上是不可持续的，因为借来的钱并没有用于提高生产力，无法在将来增加收入以偿还债务；</p></blockquote><p>居民债务负担越大，那么当出现经济衰退时，整个经济就会变得更加脆弱；除了遏制房价进一步上涨外，解决债务风险的根本办法，关键在于提高居民的收入，例如鼓励和支持居民迁移到高生产力地区就业；</p><h3 id="不平衡与要素市场改革"><a href="#不平衡与要素市场改革" class="headerlink" title="不平衡与要素市场改革"></a>不平衡与要素市场改革</h3><p>改革开放后，我国居民间收入差距在变大，主要体现在城乡差距和地区差距；之所以会产生这个现象，跟我国限制人口流动的政策有关；</p><h4 id="人口流动与收入平衡"><a href="#人口流动与收入平衡" class="headerlink" title="人口流动与收入平衡"></a>人口流动与收入平衡</h4><p>对于生活在农村的低收入群体，提高收入的最快办法是到城市中寻找工作机会。但过去地方政府对民生投入的不足，例如医疗、教育、养老等，使得低收入群体在城市安家落户的成本较高，不利于人口的流动；</p><p>如果人口能够在地区间自由的流动，那么各地区的人均 GDP 差距就会缩小，例如美国：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220627212834.png"></p><p>以下则是中国的情况：</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220627212930.png"></p><p>由于集聚效应的存在，地区间经济总量差距只会越来越大，而不会变小；即使是发达国家如美国，这种差距也仍然在持续变大；因为减少不平衡的重点不是经济总量，而是人均差异；</p><p>一个城市在规划人口时，只想引入高端人员，不想要低技能人员，这种方式是不可行的。因为城市中的很多服务行业，基本是由低技能员在提供服务的。如果这部分人员比例不足，就会导致各种服务的成本居高不下，收入被生活成本侵蚀，最终也将导致高端人员的流失；</p><h4 id="土地流转与户籍改革"><a href="#土地流转与户籍改革" class="headerlink" title="土地流转与户籍改革"></a>土地流转与户籍改革</h4><p>造成城市中土地供应不足的原因，除了地区间用地指标无法自由流转外，还有很重要的一个原因是土地的城乡二元制；农村大量的土地由于是集体用地而非国有土地，限制条件很多，无法进入土地市场流转；</p><p>虽然中央自 2008 年就允许农村集体用地，在符合规划的条件，享有和国有土地相同的权益。但因为土地金融，地方政府为了提高住宅用地的地价，并未有效落实该政策；</p><p>2015 年，开始有部分城市试点农村土地的流转改革，例如重庆的“地票”制度；当农民将自家的宅基地指标卖给需要指标的地区后，可以获得经济补偿，例如 20 万元&#x2F;亩；重庆市区通过该政策，获得了额外的用地指标，有效稳定了当地的住宅用地供应和房价；</p><p>2017 年，中央提出在集体经营性用地上建设租赁住房的试点，并于 2019 年确定了首批试点城市；这个政策意义重大，因为以前集体经营性用地需要经过当地政府的批准，才能够转成国有土地，进入土地市场；但现在则不需要了，无须转成国有土地，直接享受相同的权益，打破了地方政府对土地供应的垄断；</p><blockquote><p>农村的土地主要有三类，包括宅基地、耕地和集体经营性用地；目前前两者还不能直接交易，具体政策仍然探索中；</p></blockquote><p>除了土地改革外，中央也加快了户籍制度的改革，逐步取消农业和非农户口的区别，并要求地方以常住人口，而非户籍人口规划各项公共服务的供给，实施人地挂钩，以满足每年进城落户人口的用地需求；</p><blockquote><p>人为限制经济要素的流动，终将是不可持续的，并且会造成经济发展的扭曲，降低生产效率；</p></blockquote><h3 id="经济发展与贫富差距"><a href="#经济发展与贫富差距" class="headerlink" title="经济发展与贫富差距"></a>经济发展与贫富差距</h3><p>过去 40 年经济的快速发展，加大了居民间的收入差距；但由于所有人的生活都变好了，因为这种差距的拉大，被大部分人忽视了；但是当社会经济增长停滞时，人们对差距的容忍度变低，此时就会带来很多社会矛盾；</p><h4 id="收入差距"><a href="#收入差距" class="headerlink" title="收入差距"></a>收入差距</h4><p>对于 70 后来说，他们的父母都一样的贫穷，但对于 80 后和 90 后，他们父母之间的差距就变大了。由于存在均值回归，无形的资产，例如身高、智商等，较难以有效的实现代际继承；但有形资产，例如房产、存款，则可以百分百实现代际传承；当社会经济增长变慢时，家庭财富的影响力就会变大，此时越来越多的“拼爹”现象会造成社会的不稳定；</p><h4 id="对收入差距的容忍度"><a href="#对收入差距的容忍度" class="headerlink" title="对收入差距的容忍度"></a>对收入差距的容忍度</h4><p>当经济下行时，受影响最大的是低收入群体，影响最小的是高收入群体；当穷人发现自己的收入在不断缩水时，而富人仍然在赚钱时，就会引起焦虑和愤怒，加剧社会的分裂。这也是 2008 年金融危机后，特朗普上台的原因之一；</p><p>人群相似性也会影响人们对收入差距的容忍度；如果人们觉得收入是因为一些自身无法改变的原因造成的，例如肤色，就更容易变得绝望和愤怒；</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>我国的经济发展主要经历了三个阶段：</p><ul><li>94 年之前的乡镇企业阶段；</li><li>94 年之后的土地城市化阶段；</li><li>13 年之后的人力城市化阶段；</li></ul><p>中国在过去的 40 年间取得了巨大的成就，同时也埋下了一些有待后续解决的问题，例如政府和居民背负了过大的债务负担和风险；</p><h2 id="六、债务与风险"><a href="#六、债务与风险" class="headerlink" title="六、债务与风险"></a>六、债务与风险</h2><p>截至 2018 年，中国的债务总量达到了 GDP 的 258%，这个数字相当惊人，已经超过了德国，达到跟美国相当的程度；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220629211736.png"></p><h3 id="债务与经济衰退"><a href="#债务与经济衰退" class="headerlink" title="债务与经济衰退"></a>债务与经济衰退</h3><p>债务负担过高时，在出现经济衰退时，整个经济就会变得很脆弱，进入崩盘的恶性循环；一是因为抛售资产导致资产价格暴跌，二是资产价格暴跌进一步引起信贷收缩，导致流动性紧张，人们更难借到钱，加重了债务负担；</p><h3 id="债台为何高筑：欧美的教训"><a href="#债台为何高筑：欧美的教训" class="headerlink" title="债台为何高筑：欧美的教训"></a>债台为何高筑：欧美的教训</h3><p>债务源于亘古不变的人性，人的欲望没有止境，因此人们会预支未来的收入作为当前的支出；如果是投资支出，那么这种预支是健康的，因为它会在未来产生更多的收入以偿还债务；但如果是消费支出，那么这种支出是不可持续的，它无法在未来增加收入；</p><h4 id="资金供给与银行管制"><a href="#资金供给与银行管制" class="headerlink" title="资金供给与银行管制"></a>资金供给与银行管制</h4><p>资金的主要供给方是银行，因此资金供给的增加，通常源于金融管制的放松，即银行能够发放更多的贷款，从而增加了市场上的资金供给；</p><p>金融风险的关键环节是银行，因为资金是由银行提供的，其原因主要包括：</p><ul><li>存在杠杆：银行在提供资金时，使用了杠杆，例如美国银行业的杠杆率约为 20 倍（欧洲更高，平均为 50 倍），即银行手头只有 5 元的本钱，但却做着 100 元的贷款生意；</li><li>周期错配：银行的存款和贷款之间通常存在错配，即吸收短期存款，发放长期贷款。虽然存款保险避免了挤兑风险，但现在银行有很多存款来自基金，而基金客户是不受存款保险制度的保护的；</li><li>房产过多：多数国家的银行信贷有大约七成为房产按揭业务，因此当土地和房产价格出现波动时，就会剧烈影响银行的信贷风险；</li><li>风险转移：金融衍生品让银行有机会转移手中的不良贷款，降低了银行风控的积极主动性，放大了风险；</li></ul><h4 id="国际不平衡与国内不平等"><a href="#国际不平衡与国内不平等" class="headerlink" title="国际不平衡与国内不平等"></a>国际不平衡与国内不平等</h4><p>金融全球自由化让信贷不再局限于一个国家，而是变成了全球市场，大大增加了信贷的资金规模；</p><p>国际贸易的不平衡（贸易顺着和逆差），会导致出口方手头持有大量的美元。为了避免美元贬值，很多国家会使用手中的美元购买投资标的，例如美国的国债。这样又相当于将钱借给美国市场了，增加了信贷的资金来源；</p><p>如果穷人收入不足，就会需要从富人手中借贷维持生活，因此分配不均导致过大的贫富差距，也会造成信贷增加；</p><p>富人的钱花不完，穷人又没有钱花。如果富人的钱借给穷人买房的话，长期来看是危险的。因为买房是一种消费行为，它并不会增加穷人在未来的收入，因此如果有一天出现经济衰退，这种风险就会爆发；而且当过多的信贷投入到房地产行业时，也会挤占实体行业的可用信贷额度和成本，并不利于实体企业的长期健康发展；</p><h4 id="实体企业投资需求不足"><a href="#实体企业投资需求不足" class="headerlink" title="实体企业投资需求不足"></a>实体企业投资需求不足</h4><p>当一个国家的制造业出现转移外迁时，如果没有新的高端制造业进行补充，那么实体行业的投资需求就会下降；另外某个行业发展到后期，经常只剩下少量寡头。由于人类自私的天性，行业的集中度越高，那么行业的生产率增长会变得越慢，不利于保持行业的国际领先地位；</p><blockquote><p>当一个国家的经济缺少增长点时，此时如果银行信贷宽松，资金供给过剩，会导致企业脱实向虚，将信贷资金投向资产市场，推动资产价格虚高，加剧社会的财富分化；</p></blockquote><h3 id="中国的债务与风险"><a href="#中国的债务与风险" class="headerlink" title="中国的债务与风险"></a>中国的债务与风险</h3><p>从 2008 年开始，中国债务规模快速上升，直至今天。原本 2021 年中央痛下决心去杠杆，但无奈遇到新一轮疫情失控，导致整个社会经济迅速陷入危机状态之中。因此中央不得不放缓计划，并重新开闸放水。未来的路还很长，能否顺利过关，目前看来还是一个未知数。</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220702161817.png"></p><p>截至 2018 年末，中国债务总量已经占到了 GDP 的 258%；这是一个非常大的数字，而且不同机构的占比跟发达有所不同，大致如下：</p><ul><li>居民：54%</li><li>政府：51%</li><li>企业：154%，比例过高，原因在于中国资本市场不成熟，企业难以使用股权进行融资，只能通过借贷；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220702162333.png"></p><h4 id="企业债务"><a href="#企业债务" class="headerlink" title="企业债务"></a>企业债务</h4><p>国有企业：由于国有企业在中国占据很大的比例，因此国有企业的债务比例也很高，大约占到了 GDP 的 40%；多数国有企业的经营效率和利润率，都比民营企业低，但是因为有政府背书，风险低，银行特别喜欢贷款给它们，扭曲了资金在市场上的配置效率；</p><p>房地产企业：截至 2018 年，房产企业的债务占到了 GDP 的 75%，比例非常大。房企本身也多是高负债率经营，因此当市场出现收缩时，就会马上出现流动性危机，资金链断裂；房价连着地价，地价连着地方政府的财政收入。一旦出现危机，整个金融系统和宏观经济都会受到巨大的影响；</p><h4 id="银行风险"><a href="#银行风险" class="headerlink" title="银行风险"></a>银行风险</h4><p>只要有需求和利润，市场上自然就会有供给。地方政府发展经济的强烈动机，加上政府的信用背书，对银行来说，是一个低风险的资金需求方；老百姓想要买房，而房产的固定性和通用性，也让其成为一种优质的抵押物。于是大量信贷资源不断向地产和房产倾斜。</p><p>虽然中央出台各项措施，严格监控发放给房地产企业的贷款比例。但是由于有很大的市场需求和利润空间，各种影子银行业务层出不穷，以逃避中央的监管，例如银信产品、银证信产品等；</p><p>为了打击影子银行，中央于 2018 年出台了资管新规，有效减少了影子信贷规模。但也付出了一定的代价，即牵连到了很多有正常融资需求的中小企业；</p><h3 id="化解债务风险"><a href="#化解债务风险" class="headerlink" title="化解债务风险"></a>化解债务风险</h3><h4 id="偿还已有债务"><a href="#偿还已有债务" class="headerlink" title="偿还已有债务"></a>偿还已有债务</h4><p>偿还债务有几种办法：</p><ul><li>压缩支出：由于一个人支出是另一个人的收入，因此压缩支出会导致连锁反应，引发经济危机；</li><li>增加收入：短期内难以实现；</li><li>降低利率：可以减少利息支出，多出来的钱可以用来偿还本金；</li><li>增发货币：通货膨胀使得货币贬值，因此相同金额的债务变得没有原来那么值钱了；</li><li>债务转移：央行或政府收购债务，将债务转移到政府手中（即传说中的量化宽松）；</li><li>刺激经济：政府从央行借钱，增加自己的购买力，然后花钱做各种投资，购买社会上的各种服务和产品，例如搞基建，变相增加居民和企业收入；但如果政府从央行手上无限制的借钱，那么很快就会引发恶性通货膨胀；</li></ul><h4 id="限制新增债务"><a href="#限制新增债务" class="headerlink" title="限制新增债务"></a>限制新增债务</h4><p>中国绝大多数债务都跟土地和房产有关，因此限制新增债务时，也需要主要从这两个方面入手；例如限制房价上涨、限制土地金融、限制政府的隐性担保等；但中国过去的经济高速增长主要依赖于负债和投资的增长，因此，当中央限制债务增长时，就不可避免导致经济增速下滑；</p><p>另外，中国非金融企业债务占到了 GDP 近一半比例，因此推动资本市场改革，让企业能够通过股权或债券融资，也是一项能够降低债务比例的根本性措施；但这项改革多年以来一直进展缓慢，其背后的根本原因在于中国的经济发展是政府和国企主导的，而决策者和风险承担者需要对等；因此只要我们没有改变这种经济模式，那么当前的债务局面，就比较难以改变；</p><p>依赖政府投资来拉动经济的模式，并不是万能的，能够带来的经济增长越来越有限，走到了一个瓶颈阶段；如何让市场在资源配置中，发挥更大的作用，也是近两年中央的一个改革方向；</p><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>中国的债务问题与美国不太不同，它并不是金融投机导致的问题，而是由地方政府主导经济导致的资源错配和低效利用的问题；</p><p>地方政府主导经济的模式导致了以下问题：</p><ul><li>无效投资：为了短期利益，不愿意让低效企业破产，而是通过贷款为其输血；</li><li>分配失衡：重投资，轻消费，导致居民收入不足，进而消费不足；</li><li>土地金融：依赖土地财政，过度举债；</li></ul><h2 id="七、国内国际失衡"><a href="#七、国内国际失衡" class="headerlink" title="七、国内国际失衡"></a>七、国内国际失衡</h2><p>自 2001 年中国加入 WTO 后，中国产品在全球经济中的占比开始变得越来越大。由于中国市场规模和产能巨大无比，中国制造业开始不断对其他国家形成冲击；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220702184554.png"></p><h3 id="低消费与产能过剩"><a href="#低消费与产能过剩" class="headerlink" title="低消费与产能过剩"></a>低消费与产能过剩</h3><p>宏观经济一般由三驾马车拉动，包括投资、出口和消费。中国经济的一个特点是消费占比低。很大一部分产能是面向国际市场，而非国内市场；这跟中国政府的收入分配有关，地方政府将财政收入更多用于投资，而不是用于民生；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220702184734.png"></p><p>居民的消费金额 &#x3D; 居民收入 - 居民储蓄；居民消费占 GDP 比例下降，包括两个原因：</p><ul><li>居民收入占 GDP 比例下降了；</li><li>居民储蓄占 GDP 比例上升了；</li></ul><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220702204945.png"></p><h4 id="居民高储蓄"><a href="#居民高储蓄" class="headerlink" title="居民高储蓄"></a>居民高储蓄</h4><p>中国的居民储蓄率很高，大约占到了 25-30% 左右，而欧美普遍都在 10% 以内；居民储蓄率居高不下，原因其实很简单，一是房价快速上升增加了购房成本，居民不得不多存款攒首付；二是教育、医疗和社会保障不足，老百姓不得不存钱来应对此类支出；</p><h4 id="居民低收入"><a href="#居民低收入" class="headerlink" title="居民低收入"></a>居民低收入</h4><p>经营企业需要支付生产要素的成本，这些生产要素包括：土地（租金）、资金（利息）、人工（工资）；由于中国存在人口红利，但工业基础薄弱，地方政策重投资轻民生的政策导向，使得人工收益的增长速度低于资本收益；简单来说，就是政府和企业赚的钱更多，而工人赚的钱比较少；</p><p>由于我们经济和工业基础薄弱，想要后来居上，在初期省吃俭用是少不了的，因为这样才可以将更多的钱投入到升级设备，扩大生产规模的再投资中；这个模式在经济发展的初期是非常有效的，但到了后期效果就不好了，原因包括：</p><ul><li>基础设施已经趋于完善，新增投资边际效益递减；</li><li>居民收入少，无法消化巨大产能；</li><li>贫富差距加大，不利于社会稳定；</li><li>多余产能出口时，容易对其他国家形成冲击，引发贸易冲突；</li></ul><blockquote><p>中央已经意识到了上述问题，因此在十九会议中，提出了新的改革方向，目标是增加民生支出，提高居民收入，控制房价，降低居民生活成本；其中一项重要的措施是要求中央和地方国有企业划转 10% 的股份给社保基金；</p></blockquote><h4 id="产能过剩、债务风险、外部失衡"><a href="#产能过剩、债务风险、外部失衡" class="headerlink" title="产能过剩、债务风险、外部失衡"></a>产能过剩、债务风险、外部失衡</h4><p>投资能够带来的产出是有天花板的。当各行业百废待兴时，此时投资的产出最大。但如果已经进入发达国家的成熟阶段，投资的产出便要小很多。因为很多东西已经建设好饱和了，再投就过剩了；尤其是借钱投资，那么还会累积巨大的债务风险；</p><p>经济发展过于依赖外贸出口也存在很大的风险，因为其他国家的政治经济政策不为我们所控制。当其他国家出现政策波动时，例如反倾销、贸易战等，就会对我们的经济形成冲击；</p><h3 id="中美贸易冲突"><a href="#中美贸易冲突" class="headerlink" title="中美贸易冲突"></a>中美贸易冲突</h3><blockquote><p>从 90 年代开始，美国在绝大部分时间里，都是进口大于出口，长期处于贸易逆差的状态中；但由于美国本身的经济体量也很大，因此该部分逆差并没有占美国 GDP 很大的比例；</p></blockquote><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220703121353.png"></p><p>08 年美国金融危机之前的那几年，刚好也是美国贸易逆差达到顶峰的几年。这并不是巧合，背后的原因正是由于美国高负债带来的繁荣。金融危机之后，美国便进入了艰难的调整阶段。</p><p>中国制造业的崛起，让中国在美国贸易逆差中所占的比例变得越来越大，双方不可避免会产生越来越多的贸易摩擦，因为中国制造的产品，越来越多的威胁到了原本由美国制造的份额；</p><h4 id="就业与政治冲击"><a href="#就业与政治冲击" class="headerlink" title="就业与政治冲击"></a>就业与政治冲击</h4><p>技术进步和产业外迁，让美国制造业在 GDP 中的比例变得越来越小，同时提供的就业岗位变得越来越少。就业关系着很多普通老百姓的生活，当他们失去自己的工作时，难会会将原因归结到是因为外国人抢了他们的工作。因此很多人就会支持贸易保护，而迎合这些民众的候选人便能够获得选票，特朗普的上台即是例子；</p><h4 id="技术冲击"><a href="#技术冲击" class="headerlink" title="技术冲击"></a>技术冲击</h4><p>中国制造曾经是劣质产品的代名词，就像日本曾经所经历的一样。但现在这一情况也不复如此了。不管是工程领域还是基础科学领域，中国都取得长足的进步。虽然目前还没有超过美国，但已经超过德国和日本，位居第二位；</p><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20220703214834.png"></p><p>工业制造是技术创新的基础，没有工业制造，技术创新就不可能落地和迭代，这也是为什么所有的技术强国，也同时是制造业强国。制造业有很强的学习效应、集聚效应和规模效应，因此它是发展中国家赶超发达国家的最好切入点；</p><p>美国普通民众想通过技术封锁限制中国的发展，从短期来看，双方两败俱伤。美国失去了巨大的中国市场，中国失去了快速学习进步的机会；从远期来看，中国终将会慢慢实现国产化，实现对美国产品的替代；</p><h3 id="再平衡与国内大循环"><a href="#再平衡与国内大循环" class="headerlink" title="再平衡与国内大循环"></a>再平衡与国内大循环</h3><p>重投资轻消费会让中国严重依赖于出口来消费巨大的产能，但越来越多的贸易保护和摩擦，让这种模式变得不可持续。让国内的消费占比增长，替代国外需求，才是解决问题的根本措施；</p><p>想要让消费替代投资，成为中国经济增长的主要引擎，就需要改变地方政府的发展模式。由过去以投资为核心，转变为以民生为核心。让民众的生活有更多的保障，敢于消费。</p><p>当地方政府不再需要大规模投资时，自然也不再需要再依赖于土地金融获得资金，这样也能够稳定房价，让房价不会挤占民众的可消费金额；</p><p>另外通过完善资本市场，企业能够更多通过股权和债券融资，民众也有更多的机会参与投资和分享企业红利。转变过去以地方政府为投资主体的局面；简单来说，相当于藏富于民；</p><h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>过去改革开放后的四十后，我们并没有现成的路径可以抄袭。绝大多数时候，我们都是在摸着石头过河情况下过来的。我们之所以能够取得今天的成就，其实最核心的就是四个字：实事求是。在未来，我们依然需要把持这个原则，勇于试错，勇于调整，走出一条适合自己的道路；</p><h2 id="八、政府与经济发展"><a href="#八、政府与经济发展" class="headerlink" title="八、政府与经济发展"></a>八、政府与经济发展</h2><p>市场经济理论算是舶来品，用它来研究中国经济，有一个意外的好处是很容易发现中国市场经济与发达国家存在诸多不同，存在的各种“扭曲”现象。但这种“扭曲”并不一定是坏事，很多时候它是中国根据自身情况进行的某种符合现实的尝试和探索。</p><p>目前我们对经济规律的了解，还是有限的，因此暂时还没有一套放之四海而皆准的解决方案。保持务实和开放的心态，实事求是的试错和调整，才是解决现实社会中具体问题的有效办法，而不是拿着某种理论，生搬硬套，削足适履；完善的市场机制在很多时候并非经济发展的前提条件，它跟发达的市场经济之间，更有可能是某种互为因果的关系。完善的市场机制并非第一天就会有的，它有时候是经济发展到某个阶段的结果，而不是原因。</p><h3 id="地区间竞争"><a href="#地区间竞争" class="headerlink" title="地区间竞争"></a>地区间竞争</h3><p>经济发展快与慢，背后的本质其实是资源使用效率的区别。生产相同的产品，资源使用效率越高，就意味着生产成本越低，产品越是具备市场竞争力。如何让人们不断提高生产效率？方法也很简单，即引入竞争。利用人的驱利性，实现优胜劣汰。</p><blockquote><p>60 年代因为冷战需要，中国实施“三线建设”战略，将很多重要的工厂、科研机构分散到中西部地区，而不是集中在少数大城市里。该战略既为改革开放后，各地乡镇企业的崛起提供了人员和技术等基础，也为之后不同地区间的经济竞争提供了一个相对平均的起跑线。</p><p>乡镇企业的另外一个重要作用是培养了一批产业工人。由于乡镇企业可以让农民就近到工厂里面上班，大大降低了交通和住宿成本，让很多农民能够以较低的成本，改变自身的习惯和认识，接纳新的角色和身份；如果没有这个铺垫，00 年代之后愿意进城打工的人数就会少很多；虽然经济学家都知道工业产出要大于农业，但对于全国几亿农民来说，这种认知的接纳和行动，不是短期内就能够完成的。</p></blockquote><p>中央实施以经济建设为中心的战略，在地区间竞争中体现为以地区的经济发展情况，作为官员提拔的主要指标。这种作法有利有弊。</p><p>好处：</p><ul><li>能够调动地方官员发展经济的积极性；</li><li>也能充分发挥其更了解本地环境的信息优势，实现因地制宜；</li></ul><p>缺点：</p><ul><li>缺少淘汰机制，对于不作为的官员，没有个人损失；</li><li>由于升迁是零和博弈，容易产生以邻为壑的恶性竞争现象；</li><li>由于任期较短，容易产生一些卯吃寅粮，损害长远利益的行为；</li></ul><h3 id="政府的发展与转型"><a href="#政府的发展与转型" class="headerlink" title="政府的发展与转型"></a>政府的发展与转型</h3><p>一个国家能够实现繁荣富强，跟是否拥有一个好的政府是密不可分的。事实上，越是富裕的国家，其政府扮演的作用也相应的越大，而不是越小。</p><blockquote><p>很多国家之所以长期陷于贫穷，跟当地政府缺乏力量有很大关系，例如连社会治安都维持不了，更不用说发展经济了；</p></blockquote><p>事实上政府的很多能力是在经济发展过程中不断锻炼出来的，而不是第一天就能够天然拥有的。一来能力需要时间积累和沉淀，二来也需要投入人力和物力，但政府并不是第一天就能够拥有大量的财政收入的，而是一个循序渐进的过程。</p><p>虽然法治很重要，但法律的制定和落地，是需要时间沉淀。但法治还未健全的情况下，一定程度的政府管制也是解决问题的一种有效办法。在不同的发展阶段，二者的作用比例不同而已。</p><p>没钱难办事，一个强有力的政府离不开足额的税收作为前提。但征税也是需要能力的。既需要一定数量的税收稽查专业，人员，也需要配套强大的信息系统。这些都非一朝一夕能够完成的。</p><blockquote><p>由于征收个人所得税难度很大，因此中国税收的主要收入来源是增值税和企业所得税。前者占比 40%，后者占比 24% 左右，主要是因为这两种税的征收难度要小很多；</p></blockquote><p>在市场机制还不完善的情况下，一个落后国家的经济能否发展起来，很重要的一点是取决于政府是否能够有力的弥补市场机制缺失的环节，让经济更高效的运转起来，提高资源的匹配和使用效率；</p><blockquote><p>并不是每个国家的政府干预都取得了好的结果，成功的案例如中国、韩国等，但在东南亚、拉美地区也有很多失败的案例；</p></blockquote><p>当市场机制、法制环境、资本市场等基础设施变得完善起来后，将资源集中到政府手中的旧模式，则很可能不再是最高效的办法，有可能此时将资源交由市场机制来匹配，由生产型政府转变成服务型政府，或许是更好的方案；</p><blockquote><p>虽然转型服务型政府说来容易，但同样需要钱才能实现。当地方政府不再依赖土地金融时，如何获得收入来源作为补充，才是转型能够成功的关键。目前初步的设想是开征房地产税，以替代土地金融。但该政府影响面极大，还有待论证和试点；</p></blockquote><h3 id="发展目标与发展过程"><a href="#发展目标与发展过程" class="headerlink" title="发展目标与发展过程"></a>发展目标与发展过程</h3><p>对于发达国家来说，核心工作是探索和创新；但对于不发达国家来说，核心工作应该是学习他人成熟的经验和技术，而不是自己搞创新；因为前者投入产出比很高，后者很低；</p><p>中国经济的腾飞，并不一定能够在其他国家复制，因为我们有几个特点，并不是每个国家都拥有的：</p><ul><li>土地国有制度，让地方政府拥有了启动资本；</li><li>控制能力很强的中央政府，能够控制地方政府的发展方向；</li><li>人口红利；</li><li>组织完善的官僚体系；</li></ul><p>任何政策要有效落地，就不可避免要考虑到政策背后各种人群的利益。只有兼顾好这些现实存在的利益群体，才能减少政策的实施阻力，毕竟政治的本质是善于在各种利益间实现妥协，找到折中的方案；</p><p>经济发展不可避免会改变旧的格局，涉及利益的重新分配，因此发展过程伴随着各种冲突和矛盾是必然的。而政府的核心作用，就是化解和协调这些冲突和矛盾。通过设定发展的优先顺序，以及发展的节奏快慢，推动经济向前发展。</p><p>对于当前的中国，最重要的问题并不是我们的经济总量什么时候能够超越美国，而是我们是否已经准备好了进入下一个新的发展阶段的各种条件和基础了；</p><h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p>当前经济学最大的作用是发现和提出问题，而不是解决问题。因为我们对现实的理解仍然还非常有限，因此解决问题的更好方法，是具体问题具体分析，在实践中小心试错，反复调整和改进；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、地方政府的权力与事务&quot;&gt;&lt;a href=&quot;#一、地方政府的权力与事务&quot; class=&quot;headerlink&quot; title=&quot;一、地方政府的权力与事务&quot;&gt;&lt;/a&gt;一、地方政府的权力与事务&lt;/h2&gt;&lt;p&gt;地方政府是整个国家管理环节中重要的一环，中央各项政策的落地，</summary>
      
    
    
    
    <category term="社科" scheme="https://ccw1078.github.io/categories/%E7%A4%BE%E7%A7%91/"/>
    
    
    <category term="经济" scheme="https://ccw1078.github.io/tags/%E7%BB%8F%E6%B5%8E/"/>
    
  </entry>
  
  <entry>
    <title>Python import 用法</title>
    <link href="https://ccw1078.github.io/2022/03/13/Python%20import%20%E7%94%A8%E6%B3%95/"/>
    <id>https://ccw1078.github.io/2022/03/13/Python%20import%20%E7%94%A8%E6%B3%95/</id>
    <published>2022-03-13T07:05:00.000Z</published>
    <updated>2024-09-21T23:18:26.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常规导入"><a href="#常规导入" class="headerlink" title="常规导入"></a>常规导入</h1><h2 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块 Modules"></a>模块 Modules</h2><p>一个 py 文件即相当于一个模块 Module；它可以被其他 py 导入，以便复用其中的代码；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br>math.pi()<br></code></pre></td></tr></table></figure><p>被导入的 py 文件，同时充当了一个命名空间（Namespace），可通过该命名空间访问其内部的变量和函数；</p><p>当使用 from  A import B 时，就把 B 导入到全局命名空间中了，这个时候并没有导入 A；而且导入时 B 还可以重命名 B，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> pi <span class="hljs-keyword">as</span> PI<br></code></pre></td></tr></table></figure><h2 id="包-Packages"><a href="#包-Packages" class="headerlink" title="包 Packages"></a>包 Packages</h2><p>Pacage 也是一个模块，它跟普通模块的区别在于它内部包含了其他模块或者其他 Package</p><blockquote><p>Python 官方文档对 Package 的解释为，当一个模块的内置 path 属性有值时，即是一个 Package；个人感觉包和模块很像目录和文件的关系；</p></blockquote><p>实际使用中，Package 通常是一个包含 py 文件和子目录的文件夹；当给某个文件夹中添加一个 init 文件时，它就变成了一个 pakcage；init 文件中可以放置内容，它表示当 package 被作为模块导入时，该模块包含的内容；它可以为空；</p><blockquote><p>当一个文件夹没有 init 文件时，它仍然会被 Python 解释器视作一个 Package，只是它不是普通的 Package，而是一个特殊的 package，称为命名空间 Package；</p></blockquote><p>通常在导入一个包时，并不导入它里面的子模块和子包。</p><blockquote><p>发现一个有意思的点，当使用 from A import B 时，虽然 A 没有导入进来，但是 B 和 A 的上下级关系是存在的。因此如果有另外一行代表导入了 A，那么即使 A 的 init 文件中没有导入 B，也仍然可以通过 A.B 来访问 B；</p><p>使用 import A.B.C 来导入时，A.B. 表示的是路径关系好像；而且一旦导入成功，B 和 C 的上下级关系就建立了；即使 B 的 init 文件中原本默认没有导入 C，也因为这种关系的建立，使得 B.C 的访问能够成功；</p></blockquote><p>当一个包中的 init 文件为空时，那么导入这个包时，只导入了一个命名空间，并未导入任何具体的模块；</p><blockquote><p>注意：当导入一个模块时，除了会导入模块中的内容外，还会同时创建一个包含该内容的命名空间；当使用不同的导入方法时，同一个模块可以隶属于不同的命名空间；即可以通过多个命名空间访问到相同的模块；</p></blockquote><p>模块本质上面是一个对象，因此可以通过对象的内置方法来访问来模块中的内容，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br>math.__dict__[<span class="hljs-string">&#x27;pi&#x27;</span>]<br></code></pre></td></tr></table></figure><p>在 init 文件中导入包中的模块，可以让包的使用者更方便的使用这些模块，而无须记住相应的路径</p><h2 id="绝对导入和相对导入"><a href="#绝对导入和相对导入" class="headerlink" title="绝对导入和相对导入"></a>绝对导入和相对导入</h2><p>如果代码只在本地使用，不需要共享给他人使用时，使用绝对路径导入是一个不错的方法。但是如果它成为一个包，需要被其他人复用时，那么使用绝对路径就会报错了，此时需要在包中使用相对路径。同时引用该包的人，可通过 pip 安装该包。安装后，包就会被存放在默认的 site_packages 文件夹中，这样在运行脚本时就可以被解释器找到；不然就得修改 PYTHONPATH 环境变量或者调用 sys.path 方法添加包的路径；</p><p>当解释器遇到 import 语句时，它会到三个地方寻找包，分别如下：</p><blockquote></blockquote><ul><li>当前脚本所在的目录；</li><li>环境变量 PYTHONPATH 指向的目录；</li><li>pip 存放依赖的目录；</li></ul><h2 id="安装本地包"><a href="#安装本地包" class="headerlink" title="安装本地包"></a>安装本地包</h2><p>添加配置文件 setup.py，在里面 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> shutil <span class="hljs-keyword">import</span> rmtree<br><br><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> find_packages, setup, Command<br><br><span class="hljs-comment"># Package meta-data.</span><br>NAME = <span class="hljs-string">&#x27;mypackage&#x27;</span><br>DESCRIPTION = <span class="hljs-string">&#x27;My short description for my project.&#x27;</span><br>URL = <span class="hljs-string">&#x27;https://github.com/me/myproject&#x27;</span><br>EMAIL = <span class="hljs-string">&#x27;me@example.com&#x27;</span><br>AUTHOR = <span class="hljs-string">&#x27;Awesome Soul&#x27;</span><br>REQUIRES_PYTHON = <span class="hljs-string">&#x27;&gt;=3.6.0&#x27;</span><br>VERSION = <span class="hljs-string">&#x27;0.1.0&#x27;</span><br><br><span class="hljs-comment"># What packages are required for this module to be executed?</span><br>REQUIRED = [<br>    <span class="hljs-comment"># &#x27;requests&#x27;, &#x27;maya&#x27;, &#x27;records&#x27;,</span><br>]<br><br><span class="hljs-comment"># What packages are optional?</span><br>EXTRAS = &#123;<br>    <span class="hljs-comment"># &#x27;fancy feature&#x27;: [&#x27;django&#x27;],</span><br>&#125;<br><br><span class="hljs-comment"># The rest you shouldn&#x27;t have to touch too much :)</span><br><span class="hljs-comment"># ------------------------------------------------</span><br><span class="hljs-comment"># Except, perhaps the License and Trove Classifiers!</span><br><span class="hljs-comment"># If you do change the License, remember to change the Trove Classifier for that!</span><br><br>here = os.path.abspath(os.path.dirname(__file__))<br><br><span class="hljs-comment"># Import the README and use it as the long-description.</span><br><span class="hljs-comment"># Note: this will only work if &#x27;README.md&#x27; is present in your MANIFEST.in file!</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> io.<span class="hljs-built_in">open</span>(os.path.join(here, <span class="hljs-string">&#x27;README.md&#x27;</span>), encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        long_description = <span class="hljs-string">&#x27;\n&#x27;</span> + f.read()<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    long_description = DESCRIPTION<br><br><span class="hljs-comment"># Load the package&#x27;s __version__.py module as a dictionary.</span><br>about = &#123;&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> VERSION:<br>    project_slug = NAME.lower().replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>).replace(<span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;_&quot;</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(here, project_slug, <span class="hljs-string">&#x27;__version__.py&#x27;</span>)) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-built_in">exec</span>(f.read(), about)<br><span class="hljs-keyword">else</span>:<br>    about[<span class="hljs-string">&#x27;__version__&#x27;</span>] = VERSION<br><br><span class="hljs-comment"># Where the magic happens:</span><br>setup(<br>    name=NAME,<br>    version=about[<span class="hljs-string">&#x27;__version__&#x27;</span>],<br>    description=DESCRIPTION,<br>    long_description=long_description,<br>    long_description_content_type=<span class="hljs-string">&#x27;text/markdown&#x27;</span>,<br>    author=AUTHOR,<br>    author_email=EMAIL,<br>    python_requires=REQUIRES_PYTHON,<br>    url=URL,<br>    packages=find_packages(exclude=[<span class="hljs-string">&quot;tests&quot;</span>, <span class="hljs-string">&quot;*.tests&quot;</span>, <span class="hljs-string">&quot;*.tests.*&quot;</span>, <span class="hljs-string">&quot;tests.*&quot;</span>]),<br>    <span class="hljs-comment"># If your package is a single module, use this instead of &#x27;packages&#x27;:</span><br>    <span class="hljs-comment"># py_modules=[&#x27;mypackage&#x27;],</span><br><br>    <span class="hljs-comment"># entry_points=&#123;</span><br>    <span class="hljs-comment">#     &#x27;console_scripts&#x27;: [&#x27;mycli=mymodule:cli&#x27;],</span><br>    <span class="hljs-comment"># &#125;,</span><br>    install_requires=REQUIRED,<br>    extras_require=EXTRAS,<br>    include_package_data=<span class="hljs-literal">True</span>,<br>    license=<span class="hljs-string">&#x27;MIT&#x27;</span>,<br>    classifiers=[<br>        <span class="hljs-comment"># Trove classifiers</span><br>        <span class="hljs-comment"># Full list: https://pypi.python.org/pypi?%3Aaction=list_classifiers</span><br>        <span class="hljs-string">&#x27;License :: OSI Approved :: MIT License&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: 3.6&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: Implementation :: CPython&#x27;</span>,<br>        <span class="hljs-string">&#x27;Programming Language :: Python :: Implementation :: PyPy&#x27;</span><br>    ],<br>    <span class="hljs-comment"># $ setup.py publish support.</span><br>    cmdclass=&#123;<br>        <span class="hljs-string">&#x27;upload&#x27;</span>: UploadCommand,<br>    &#125;,<br>)<br></code></pre></td></tr></table></figure><p>安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install -e .<br></code></pre></td></tr></table></figure><h1 id="Resources-导入"><a href="#Resources-导入" class="headerlink" title="Resources 导入"></a>Resources 导入</h1><p>在 3.7 版本之后，静态资源文件也支持像包一样处理，只需要在资源所有的文件中添加一个 init 文件即可；然后引入包后，只需要使用内置的 importlib.resources 模块，即可实现对资源文件的读取</p><p>假设包中有如下资源：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">books/<br>│<br>├── <span class="hljs-strong">__init__</span>.py<br>├── alice<span class="hljs-emphasis">_in_</span>wonderland.png<br>└── alice<span class="hljs-emphasis">_in_</span>wonderland.txt<br></code></pre></td></tr></table></figure><p>则可以通过如下方式读取其中的资源文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> importlib <span class="hljs-keyword">import</span> resources<br><br><span class="hljs-keyword">with</span> resources.open_text(<span class="hljs-string">&quot;books&quot;</span>, <span class="hljs-string">&quot;alice.txt&quot;</span>) <span class="hljs-keyword">as</span> fid:<br>    alice = fid.readlines()<br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">data/<br>│<br>├── <span class="hljs-strong">__init__</span>.py<br>└── WPP2019<span class="hljs-emphasis">_TotalPopulationBySex.csv</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> importlib <span class="hljs-keyword">import</span> resources<br><br><span class="hljs-keyword">with</span> resources.open_text(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;WPP2019_TotalPopulationBySex.csv&quot;</span>) <span class="hljs-keyword">as</span> fid:<br>rows = csv.DictReader(fid)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常规导入&quot;&gt;&lt;a href=&quot;#常规导入&quot; class=&quot;headerlink&quot; title=&quot;常规导入&quot;&gt;&lt;/a&gt;常规导入&lt;/h1&gt;&lt;h2 id=&quot;模块-Modules&quot;&gt;&lt;a href=&quot;#模块-Modules&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="文章" scheme="https://ccw1078.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
    <category term="python" scheme="https://ccw1078.github.io/tags/python/"/>
    
  </entry>
  
</feed>
