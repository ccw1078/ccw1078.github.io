<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>流畅的Python | Ccw&#39;s Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="第1章  Python 数据结构一摞 Python 风格的纸牌123456789101112131415import collectionsCard &#x3D; collections.namedtuple(&#x27;Card&#x27;, [&#x27;rank&#x27;, &#x27;suit&#x27;])class FrenchDeck:    ranks &#x3D; [str(n) for n in">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的Python">
<meta property="og:url" content="http://example.com/2017/07/25/%E6%B5%81%E7%95%85%E7%9A%84Python/index.html">
<meta property="og:site_name" content="Ccw&#39;s Blogs">
<meta property="og:description" content="第1章  Python 数据结构一摞 Python 风格的纸牌123456789101112131415import collectionsCard &#x3D; collections.namedtuple(&#x27;Card&#x27;, [&#x27;rank&#x27;, &#x27;suit&#x27;])class FrenchDeck:    ranks &#x3D; [str(n) for n in">
<meta property="og:locale">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261657707.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261807612.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281058984.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281059641.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281059545.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281109644.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261020586.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261039412.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261045205.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261110944.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261114146.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407282027810.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407301247891.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311445182.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311446562.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311447657.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311447765.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311454347.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311501287.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311816737.png">
<meta property="article:published_time" content="2017-07-25T10:34:00.000Z">
<meta property="article:modified_time" content="2024-09-21T10:12:54.733Z">
<meta property="article:author" content="ccw">
<meta property="article:tag" content="软件">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261657707.png">
  
    <link rel="alternate" href="/atom.xml" title="Ccw's Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ccw&#39;s Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-流畅的Python" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2017/07/25/%E6%B5%81%E7%95%85%E7%9A%84Python/" class="article-date">
  <time class="dt-published" datetime="2017-07-25T10:34:00.000Z" itemprop="datePublished">2017-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      流畅的Python
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第1章-Python-数据结构"><a href="#第1章-Python-数据结构" class="headerlink" title="第1章  Python 数据结构"></a>第1章  Python 数据结构</h1><h2 id="一摞-Python-风格的纸牌"><a href="#一摞-Python-风格的纸牌" class="headerlink" title="一摞 Python 风格的纸牌"></a>一摞 Python 风格的纸牌</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrenchDeck</span>:</span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)] + <span class="built_in">list</span>(<span class="string">&#x27;JQKA&#x27;</span>)</span><br><span class="line">    suits = <span class="string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="variable language_">self</span>._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> <span class="variable language_">self</span>.suits</span><br><span class="line">    					<span class="keyword">for</span> rank <span class="keyword">in</span> <span class="variable language_">self</span>.ranks]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._cards)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, position</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">self</span>._cards[position]</span><br></pre></td></tr></table></figure>

<p>上面这个代码示例惊艳到我了，让我对 Python 的类刮目相看；此刻我才开始开始意识到内置方法的存在；</p>
<p>例如它仅仅因为实现了 _<em>len_</em> 和 _<em>getitem_</em> 两个特殊方法，便使得这个类能够自动使用 Python 的内置函数，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 len 函数获得数量</span></span><br><span class="line"> deck = FrenchDeck()</span><br><span class="line"> <span class="built_in">len</span>(deck)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用索引访问列表中的元素</span></span><br><span class="line">deck[<span class="number">0</span>]</span><br><span class="line">deck[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用内置的标准库，例如 random，从列表中随机读取元素</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">choice(deck)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动支持切片操作</span></span><br><span class="line">deck[:<span class="number">3</span>]</span><br><span class="line">deck[<span class="number">12</span>::<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动可迭代</span></span><br><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> deck:</span><br><span class="line">    <span class="built_in">print</span>(card)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 自动支持 in 运算符</span></span><br><span class="line">Card(<span class="string">&quot;Q&quot;</span>, <span class="string">&quot;hearts&quot;</span>) <span class="keyword">in</span> deck</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只需定义排序规则，即可自动支持内置的 sorted 排序函数</span></span><br><span class="line">suit_values = <span class="built_in">dict</span>(spades=<span class="number">3</span>, hearts=<span class="number">2</span>, diamonds=<span class="number">1</span>, clubs=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spades_high</span>(<span class="params">card</span>):</span><br><span class="line">    rank_value = FrenchDeck.rands.index(card.rand)</span><br><span class="line">    <span class="keyword">return</span> rank_value * <span class="built_in">len</span>(suit_values) + suite_values[card.suit]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> <span class="built_in">sorted</span>(deck, key = spades_high):</span><br><span class="line">    <span class="built_in">print</span>(card)</span><br></pre></td></tr></table></figure>



<h2 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h2><p>特殊方法是为了给解释器调用，从而实现一些内置的功能，而不是为了自己调用；如果是自己调用，那么只需写普通方法即可，无须写特殊方法；</p>
<p>另外，也尽量避免随意添加特殊方法，因为有可能出解释器内置的方法出现命名冲突，导致发生不可预知的情况；</p>
<p>特殊方法还可以用来重载运算符，例如转成字符串，加号，乘号，取绝对值等，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line">    </span><br><span class="line">     <span class="comment"># repr 用来定义对象用字符串如何显示，另外还有一个 str 用来给 str() 或者 print 函数调用</span></span><br><span class="line">     <span class="comment"># 通常定义 repr 即可，它更加通用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(%r, %r)&#x27;</span> % (<span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__abs__</span>(<span class="params">self</span>):  <span class="comment"># 重载了 abs 函数</span></span><br><span class="line">        <span class="keyword">return</span> hypot(<span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>): <span class="comment"># 当调用 bool 函数时，如何判断对象是否为真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="variable language_">self</span>.x <span class="keyword">or</span> <span class="variable language_">self</span>.y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>): <span class="comment"># 重载了加号</span></span><br><span class="line">        x = <span class="variable language_">self</span>.x + other.x</span><br><span class="line">        y = <span class="variable language_">self</span>.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, scalar</span>):  <span class="comment"># 重载了乘号</span></span><br><span class="line">        <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x * scalar, <span class="variable language_">self</span>.y * scalar)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="特殊方法一览"><a href="#特殊方法一览" class="headerlink" title="特殊方法一览"></a>特殊方法一览</h2><p>特殊方法挺多的，有80 多个，其中有 40 个多用于实现算术运算、位运算和比较操作；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261657707.png"></p>
<h2 id="为什么-len-不是普通-方法"><a href="#为什么-len-不是普通-方法" class="headerlink" title="为什么 len 不是普通 方法"></a>为什么 len 不是普通 方法</h2><p>len 的目的是为了读取对象的长度，对于内置类型的对象，它们是用 C 语言的 struct 表示的，struct 里面有个属性存储着长度值，因此在这种情况下，len  会直接去读取 struct 的长度值，而不是调用 _<em>len</em>_ 来计算长度；主要是出于性能考量</p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>通过实现特殊方法，能够让自定义类型表现跟内置类型一样，从而能够直接使用 Python 的很多内置函数，让代码更容易阅读；</p>
<h1 id="第2章-序列构成的数组"><a href="#第2章-序列构成的数组" class="headerlink" title="第2章 序列构成的数组"></a>第2章 序列构成的数组</h1><h2 id="内置序列类型"><a href="#内置序列类型" class="headerlink" title="内置序列类型"></a>内置序列类型</h2><p>Python 有两种序列类型，一种存放的是对象的引用，因此它可以容纳任何类型，称为容器序列；一种存放值，而不是引用，因此只能放相同类型的值，称为扁平序列；</p>
<p>序列按照能否修改，可分为可变序列和不可变序列</p>
<ul>
<li>可变序列（Mutable Sequence）：list, bytearray, array.array, collections.deque, memoryview</li>
<li>不可变序列（Sequence）：tuple, str, bytes</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261807612.png"></p>
<h2 id="列表推导和生成器表达式"><a href="#列表推导和生成器表达式" class="headerlink" title="列表推导和生成器表达式"></a>列表推导和生成器表达式</h2><p>列表推导式（list comprehension）非常适合用来创建新的列表，这种写法更容易读懂；如果列表推导太长，则可以改用传统的 for 循环；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts</span><br><span class="line">[(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;L&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;S&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>生成器表达式用来其他类型的序列；生成器表达式使用圆括号，而不是方括号；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols) <span class="comment"># 由于生成器表达式是函数的唯一参数，所以无需用括号括起来</span></span><br><span class="line">(<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array.array(<span class="string">&#x27;I&#x27;</span>, (<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)) <span class="comment"># 非唯一参数，所以多加了一层括号</span></span><br><span class="line">array(<span class="string">&#x27;I&#x27;</span>, [<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>])</span><br></pre></td></tr></table></figure>

<p>生成器表达式每次产生一个运算结果，而不是一下生成整个列表，这样可以节省内存，尤其是元素多的时候，非常明显</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">&#x27;%s %s&#x27;</span> % (c, s) <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes): <span class="comment"># 一次只生成一个计算结果，而非整个列表</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(tshirt)</span><br><span class="line">...</span><br><span class="line">black S</span><br><span class="line">black M</span><br><span class="line">black L</span><br><span class="line">white S</span><br><span class="line">white M</span><br><span class="line">white L</span><br></pre></td></tr></table></figure>

<h2 id="元组不仅仅是不可变的列表"><a href="#元组不仅仅是不可变的列表" class="headerlink" title="元组不仅仅是不可变的列表"></a>元组不仅仅是不可变的列表</h2><p>元组是不可变列表，但其实它存放的数据，也可以基于顺序来表达不同的含义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traveler_ids = [(<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;31195855&#x27;</span>), (<span class="string">&#x27;BRA&#x27;</span>, <span class="string">&#x27;CE342567&#x27;</span>), (<span class="string">&#x27;ESP&#x27;</span>, <span class="string">&#x27;XDA205856&#x27;</span>)]</span><br><span class="line"><span class="comment"># 位置1是国家，位置2是代号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lax_coordinates = (<span class="number">33.9425</span>, -<span class="number">118.408056</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>latitude, longitude = lax_coordinates <span class="comment"># 元组拆包</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b, a = a, b</span><br><span class="line"><span class="comment"># 使用拆包，实现变量的值交换</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(*t) <span class="comment"># 星号 * 可用来将元组拆包成函数的函数</span></span><br></pre></td></tr></table></figure>

<p>星号* 可用来存放拆包的余下元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">5</span>)  <span class="comment"># 星号 * 用来存放剩余元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放在中间的位置也可以</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *body, c, d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, body, c, d</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放在开头的位置也可以</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*head, b, c, d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>head, b, c, d</span><br><span class="line">([<span class="number">0</span>, <span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="嵌套元组拆包"><a href="#嵌套元组拆包" class="headerlink" title="嵌套元组拆包"></a>嵌套元组拆包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">&#x27;Tokyo&#x27;</span>,<span class="string">&#x27;JP&#x27;</span>,<span class="number">36.933</span>,(<span class="number">35.689722</span>,<span class="number">139.691667</span>)), <span class="comment"># 嵌套的元组</span></span><br><span class="line">    (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line">    (<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line">    (<span class="string">&#x27;Sao Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas: <span class="comment"># 嵌套拆包</span></span><br><span class="line">    <span class="keyword">if</span> longitude &lt;= <span class="number">0</span>: </span><br><span class="line">    	<span class="built_in">print</span>(fmt.<span class="built_in">format</span>(name, latitude, longitude))</span><br></pre></td></tr></table></figure>

<h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>City = namedtuple(<span class="string">&#x27;City&#x27;</span>, <span class="string">&#x27;name country population coordinates&#x27;</span>) <span class="comment"># 定义元组结构</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo = City(<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)) <span class="comment"># 赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo</span><br><span class="line">City(name=<span class="string">&#x27;Tokyo&#x27;</span>, country=<span class="string">&#x27;JP&#x27;</span>, population=<span class="number">36.933</span>, coordinates=(<span class="number">35.689722</span>,</span><br><span class="line"><span class="number">139.691667</span>)) <span class="comment"># 各个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo.population ➌</span><br><span class="line"><span class="number">36.933</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo.coordinates</span><br><span class="line">(<span class="number">35.689722</span>, <span class="number">139.691667</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;JP&#x27;</span></span><br></pre></td></tr></table></figure>

<p>具名元组有一些内置的属性和方法，包括：</p>
<ul>
<li>_fields 属性，用来查看所有字段的名称</li>
<li>_make() 方法，用来创建实例</li>
<li>_asdict() 方法，用来返回 OrderDict</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>City._fields </span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;country&#x27;</span>, <span class="string">&#x27;population&#x27;</span>, <span class="string">&#x27;coordinates&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LatLong = namedtuple(<span class="string">&#x27;LatLong&#x27;</span>, <span class="string">&#x27;lat long&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi_data = (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, LatLong(<span class="number">28.613889</span>, <span class="number">77.208889</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi = City._make(delhi_data) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi._asdict() </span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Delhi NCR&#x27;</span>), (<span class="string">&#x27;country&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>), (<span class="string">&#x27;population&#x27;</span>, <span class="number">21.935</span>), (<span class="string">&#x27;coordinates&#x27;</span>, LatLong(lat=<span class="number">28.613889</span>, long=<span class="number">77.208889</span>))])</span><br></pre></td></tr></table></figure>

<p>相对列表，元组没有添加和删除元素的方法，其他方法则都差不多；</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片有个特殊的用法，即 s[a : b : c]，它表示在 a ~ b 的区间内，以 c 为间隔取值；即  s[start : stop : step]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;bicycle&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">3</span>] <span class="comment"># 正序，间隔 3 取值</span></span><br><span class="line"><span class="string">&#x27;bye&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">1</span>] <span class="comment"># 倒序，间隔 1 取值</span></span><br><span class="line"><span class="string">&#x27;elcycib&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">2</span>]  <span class="comment"># 倒序，间隔 2 取值</span></span><br><span class="line"><span class="string">&#x27;eccb&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">12</span>::<span class="number">13</span>] <span class="comment"># 正序，从 12 开始，间隔 13 取值，</span></span><br></pre></td></tr></table></figure>

<p>切片有个很有意思的用法，它可以让代码更易读</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>SKU = <span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DESCRIPTION = <span class="built_in">slice</span>(<span class="number">6</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>UNIT_PRICE = <span class="built_in">slice</span>(<span class="number">40</span>, <span class="number">52</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>QUANTITY = <span class="built_in">slice</span>(<span class="number">52</span>, <span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ITEM_TOTAL = <span class="built_in">slice</span>(<span class="number">55</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> line_items:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(item[UNIT_PRICE], item[DESCRIPTION]) <span class="comment"># 此处的 UNIT_PRICE 也可硬编码，但这样写更优雅</span></span><br><span class="line">...</span><br><span class="line">$<span class="number">17.50</span> Pimoroni PiBrella</span><br><span class="line">$<span class="number">4.95</span> 6mm Tactile Switch x20</span><br><span class="line">$<span class="number">28.00</span> Panavise Jr. - PV-<span class="number">201</span></span><br><span class="line">$<span class="number">34.95</span> PiTFT Mini Kit 320x240</span><br></pre></td></tr></table></figure>

<p>切片也可用来赋值，或者删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>] <span class="comment"># 赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>] <span class="comment"># 删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>::<span class="number">2</span>] = [<span class="number">11</span>, <span class="number">22</span>] <span class="comment"># 赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = <span class="number">100</span> <span class="comment"># 不可行，右侧需要是可迭代对象，不能是数值</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">100</span>] <span class="comment"># 可行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h2 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用 + 和 *"></a>对序列使用 + 和 *</h2><p>加号 + 用来表示将两个序列拼接起来，并返回一个新的序列；</p>
<p>乘号 * 表示重复多份序列并拼接起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l * <span class="number">5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> * <span class="string">&#x27;abcd&#x27;</span></span><br><span class="line"><span class="string">&#x27;abcdabcdabcdabcdabcd&#x27;</span></span><br></pre></td></tr></table></figure>

<p>特别注意，在 [a] * n 这个表达式中，如果 a 是一个引用，那么复制出来的是 n 个引用，并且这 n 个引用实际上指向同一个对象；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确用法，使用列表推导式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;X&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误用法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span>] * <span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;O&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]] <span class="comment"># 虽然有三个列表，但指向同一个对象</span></span><br></pre></td></tr></table></figure>

<h2 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h2><p>自增 +&#x3D; 或者自乘 *&#x3D; 实际上调用的是 _<em>iadd</em>_  和  _<em>imul</em>_ 方法，如果一个类没有实际  iadd 方法，那么解释器就会调用 add 方法来计算，此时相当于 a &#x3D; a + b，因此，如果 a + b 返回的是一个新的对象，那么 a 将指向该新的对象，而不是改变旧对象的值；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4311953800</span> ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l *= <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4311953800</span> ➋</span><br></pre></td></tr></table></figure>

<p>元组是不可变的，当在元组里面放入一个可变序列时，会出现异常情况，即该可变序列可被改变，但是无法将改变后的新序列，赋值给元组的引用；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment <span class="comment"># 赋值给 t[2] 的时候报错了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]) <span class="comment"># 成功改变了序列</span></span><br></pre></td></tr></table></figure>

<h2 id="list-sort-方法和内置函数-sorted"><a href="#list-sort-方法和内置函数-sorted" class="headerlink" title="list.sort 方法和内置函数 sorted"></a>list.sort 方法和内置函数 sorted</h2><p>list.sort 会就地修改列表，返回 None</p>
<p>sorted 则不会修改原列表，而是会返回一个新的列表；</p>
<h2 id="用-bisect-来管理已排序的序列"><a href="#用-bisect-来管理已排序的序列" class="headerlink" title="用 bisect 来管理已排序的序列"></a>用 bisect 来管理已排序的序列</h2><p>bisect 用来从有序列表中查找某个值的插入位置，满足插入后原序列的顺序不变；</p>
<p>insort 用来将元素插入到有序列表中，插入后顺序保持不变；</p>
<h2 id="当列表不是首选时"><a href="#当列表不是首选时" class="headerlink" title="当列表不是首选时"></a>当列表不是首选时</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>array.array：数组里面存储的不是对象，而是字面值（例如数字，在内存中直接用字节表示即可）；因此它的读定性能要高很多；但因此它能够存储的类型也比较有限，只有少数几种；</p>
<p>创建数组时，需要通过参数指定类型，以便解释器能够决定如何分配内存空间；</p>
<h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><blockquote>
<p>memory view</p>
</blockquote>
<p>在不复制内容的情况下，操作数组的切片，例如 Numpy；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = array.array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv = <span class="built_in">memoryview</span>(numbers) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(memv)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv[<span class="number">0</span>] </span><br><span class="line">-<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct = memv.cast(<span class="string">&#x27;B&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct.tolist() </span><br><span class="line">[<span class="number">254</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct[<span class="number">5</span>] = <span class="number">4</span> <span class="comment"># 此处的赋值，改变的是高位字节部分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1024</span>, <span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># 原本的 0，因为高位字节改变，变成了 1024</span></span><br></pre></td></tr></table></figure>

<h3 id="Numpy-和-SciPy"><a href="#Numpy-和-SciPy" class="headerlink" title="Numpy 和 SciPy"></a>Numpy 和 SciPy</h3><p>操作高阶数组和矩阵的利器；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = numpy.arange(<span class="number">12</span>) ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape ➌</span><br><span class="line">(<span class="number">12</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape = <span class="number">3</span>, <span class="number">4</span> ➍</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">[ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">[ <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="双向队列和其他形式的队列"><a href="#双向队列和其他形式的队列" class="headerlink" title="双向队列和其他形式的队列"></a>双向队列和其他形式的队列</h3><p>虽然可以用列表在模拟队列，但是性能并不好，尤其是在头部插入新元素时；双向队列更方便，而且可以指定长度，在超出长度时，会自动删除较早的内容；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq = deque(<span class="built_in">range</span>(<span class="number">10</span>), maxlen=<span class="number">10</span>) ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(<span class="number">3</span>) <span class="comment"># 旋转，将最后3个元素，放到前面来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(-<span class="number">4</span>) <span class="comment"># 将头部 4 个元素，放到后面去</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.appendleft(-<span class="number">1</span>) <span class="comment"># 添加到头部，会自动删除尾部溢出的部分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extend([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]) <span class="comment"># 添加到尾部，会删除头部溢出的部分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extendleft([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]) <span class="comment"># 逐一添加到头部，因此顺序会反过来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], maxlen=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>注：append 和 popleft 是原子操作，因此是线程安全的；</p>
<p>除了双向队列，还有以下几种队列，分别是：</p>
<ul>
<li>queue：如果队列满了，不会自动删除旧元素，而是会被锁住；因此可用来控制活跃线程的数量； </li>
<li>multiprocessing：用于进程间的通信</li>
<li>asyncio：用于异步编程</li>
<li>heapq：堆队列</li>
</ul>
<h1 id="第3章-字典和集合"><a href="#第3章-字典和集合" class="headerlink" title="第3章 字典和集合"></a>第3章 字典和集合</h1><h2 id="字典构造方法"><a href="#字典构造方法" class="headerlink" title="字典构造方法"></a>字典构造方法</h2><blockquote>
<p>如果一个对象是可散列的，那么它的散列值需要不可变，而且这个对象需要实现 hash 和 eq 方法，以便可以计算散列值并和其他对象做比较；</p>
</blockquote>
<p>字典有很多种构造方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">dict</span>(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>([(<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b == c == d == e</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h2 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h2><p>字典可以从任何以键值对作为元素的可迭代对象中构造出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>DIAL_CODES = [ ➊</span><br><span class="line"><span class="meta">... </span>(<span class="number">86</span>, <span class="string">&#x27;China&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">91</span>, <span class="string">&#x27;India&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">1</span>, <span class="string">&#x27;United States&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">62</span>, <span class="string">&#x27;Indonesia&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">55</span>, <span class="string">&#x27;Brazil&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">92</span>, <span class="string">&#x27;Pakistan&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">880</span>, <span class="string">&#x27;Bangladesh&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">234</span>, <span class="string">&#x27;Nigeria&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">7</span>, <span class="string">&#x27;Russia&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">81</span>, <span class="string">&#x27;Japan&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_code = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> DIAL_CODES&#125; <span class="comment"># 构造1 country : code</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_code</span><br><span class="line">&#123;<span class="string">&#x27;China&#x27;</span>: <span class="number">86</span>, <span class="string">&#x27;India&#x27;</span>: <span class="number">91</span>, <span class="string">&#x27;Bangladesh&#x27;</span>: <span class="number">880</span>, <span class="string">&#x27;United States&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">&#x27;Pakistan&#x27;</span>: <span class="number">92</span>, <span class="string">&#x27;Japan&#x27;</span>: <span class="number">81</span>, <span class="string">&#x27;Russia&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Brazil&#x27;</span>: <span class="number">55</span>, <span class="string">&#x27;Nigeria&#x27;</span>:</span><br><span class="line"><span class="number">234</span>, <span class="string">&#x27;Indonesia&#x27;</span>: <span class="number">62</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;code: country.upper() <span class="keyword">for</span> country, code <span class="keyword">in</span> country_code.items() <span class="comment"># 构造2 code : country </span></span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> code &lt; <span class="number">66</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;UNITED STATES&#x27;</span>, <span class="number">55</span>: <span class="string">&#x27;BRAZIL&#x27;</span>, <span class="number">62</span>: <span class="string">&#x27;INDONESIA&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;RUSSIA&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常见的映射方法"><a href="#常见的映射方法" class="headerlink" title="常见的映射方法"></a>常见的映射方法</h2><p>有个 setdefault 方法不常用，但其实很不错。它的用法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">&quot;abc&quot;</span>: <span class="number">123</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.setdefault(<span class="string">&quot;abc&quot;</span>, <span class="number">456</span>) <span class="comment"># 如果 abc 没值，则赋值456；如果有值，则返回值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>



<h2 id="映射的弹性键查询"><a href="#映射的弹性键查询" class="headerlink" title="映射的弹性键查询"></a>映射的弹性键查询</h2><p>通常情况下，当我们使用 dict[key] 的方式访问时，如果该 key 不存在，会出现报错；而 collencts.defaultdict 可以处理这种情况；它会将该键为一个预先设定好的默认值，并返回该值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">WORD_RE = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line">index = collections.defaultdict(<span class="built_in">list</span>) <span class="comment"># list 代表默认的构造方法，如键不存在，则会调用该构造方法，构造默认值</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">1</span>], encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = <span class="keyword">match</span>.group()</span><br><span class="line">            column_no = <span class="keyword">match</span>.start()+<span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line">            index[word].append(location)</span><br></pre></td></tr></table></figure>

<p>defaultdict 仅在  dict[key] 下有效，在 dict.get(key) 是无效的，后者不会调用预设的工作方法；defaultdict  背后的工作原理是因为实现了  _<em>missing</em>_ 方法；当 _<em>getitem</em>_ 找不到键名时，默认会调用 missing 方法；因此，只要有实现该方法，即可以实现默认值的初始化和返回；</p>
<p>考虑到 missing 会被调用，那么就可以在这里设置手脚；例如将键名由数值转换字符串，以支持不管传入哪种类型，都可以找到对应的键；</p>
<h2 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h2><h3 id="collections-OrderDict"><a href="#collections-OrderDict" class="headerlink" title="collections.OrderDict"></a>collections.OrderDict</h3><p>会记录每个键的添加顺序，然后可以删除最晚或者晚早添加的键；</p>
<h3 id="collections-ChainMap"><a href="#collections-ChainMap" class="headerlink" title="collections.ChainMap"></a>collections.ChainMap</h3><p>ChainMap 会将多个 dict 组合成一个 chain，让它表现起来，像是一个 dict</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>baseline = &#123;<span class="string">&#x27;music&#x27;</span>: <span class="string">&#x27;bach&#x27;</span>, <span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;rembrandt&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adjustments = &#123;<span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;van gogh&#x27;</span>, <span class="string">&#x27;opera&#x27;</span>: <span class="string">&#x27;carmen&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm = ChainMap(baseline, adjustments)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm</span><br><span class="line">ChainMap(&#123;<span class="string">&#x27;music&#x27;</span>: <span class="string">&#x27;bach&#x27;</span>, <span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;rembrandt&#x27;</span>&#125;, &#123;<span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;van gogh&#x27;</span>, <span class="string">&#x27;opera&#x27;</span>: <span class="string">&#x27;carmen&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(cm)</span><br><span class="line">[<span class="string">&#x27;art&#x27;</span>, <span class="string">&#x27;opera&#x27;</span>, <span class="string">&#x27;music&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm[<span class="string">&#x27;music&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;bach&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm[<span class="string">&#x27;art&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;rembrandt&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm.values()</span><br><span class="line">ValuesView(ChainMap(&#123;<span class="string">&#x27;music&#x27;</span>: <span class="string">&#x27;bach&#x27;</span>, <span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;rembrandt&#x27;</span>&#125;, &#123;<span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;van gogh&#x27;</span>, <span class="string">&#x27;opera&#x27;</span>: <span class="string">&#x27;carmen&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="collections-Counter"><a href="#collections-Counter" class="headerlink" title="collections.Counter"></a>collections.Counter</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = collections.Counter(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)  <span class="comment"># 计算每个键的出现次数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.update(<span class="string">&#x27;aaaaazzz&#x27;</span>) <span class="comment"># update 会递增键的出现次数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.most_common(<span class="number">2</span>) <span class="comment"># 可以返回最常见的 n 个键，此处是最常见的 2 个键</span></span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">10</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cnt = Counter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> word <span class="keyword">in</span> [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    cnt[word] += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cnt</span><br><span class="line">Counter(&#123;<span class="string">&#x27;blue&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;green&#x27;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="collections-UserDict"><a href="#collections-UserDict" class="headerlink" title="collections.UserDict"></a>collections.UserDict</h3><p>用于让用户继承来编写子类，与 dict 的不同之处在于它是纯 Python 实现；而 dict 为了性能，某些功能的实现并不完全按照规范；</p>
<h2 id="子类化-UserDict"><a href="#子类化-UserDict" class="headerlink" title="子类化 UserDict"></a>子类化 UserDict</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现 dict[key] 不管 key 是字符串还是数字，都可以正常访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrKeyDict</span>(collections.UserDict):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>[<span class="built_in">str</span>(key)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> <span class="variable language_">self</span>.data</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, item</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data[<span class="built_in">str</span>(key)] = item</span><br></pre></td></tr></table></figure>

<p>一些好用的方法</p>
<p>update</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>td1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>td2 = &#123;<span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>td1.update(td2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>td1</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



<h2 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h2><p>Python 的标准库并不支持不可变映射类型，但是有个变通的办法来实现相同的效果，即通过 MappingProxyType，从名字可以看得出来它是一个代理，这个代理是只读的；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>:<span class="string">&#x27;A&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy = MappingProxyType(d) <span class="comment"># 创建一个代理</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy</span><br><span class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">&#x27;A&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">1</span>] <span class="comment"># 代理是可以访问的</span></span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment"># 但是不可以修改，会报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;mappingproxy&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">2</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy <span class="comment"># 代理可以实时的看到 d 更新后的效果</span></span><br><span class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">&#x27;A&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;B&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h2><p>集合 set 是一些对象的集合，它可以用来去重；集合中的元素必须是可散列的；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(l)</span><br><span class="line">&#123;<span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">set</span>(l))</span><br><span class="line">[<span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>集合有一些自己的运算符，以便计算合集、交集、差集等；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 &amp; 符号求交集</span></span><br><span class="line">found = <span class="built_in">len</span>(needles &amp; haystack)</span><br></pre></td></tr></table></figure>

<h3 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h3><p>创建空集需要使用 set()， 而不是 { }，不然就变成了字典了；</p>
<p>s1 &#x3D; {1, 2, 3}  的性能比 s2 &#x3D; set([1, 2, ,3])，因为后者涉及先构造列表的动作；</p>
<h3 id="集合推导"><a href="#集合推导" class="headerlink" title="集合推导"></a>集合推导</h3><p>集合推导和列表推导的唯一差别在于方括号 [ ] 还是花括号 { }</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> unicodedata <span class="keyword">import</span> name ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">256</span>) <span class="keyword">if</span> <span class="string">&#x27;SIGN&#x27;</span> <span class="keyword">in</span> name(<span class="built_in">chr</span>(i),<span class="string">&#x27;&#x27;</span>)&#125; ➋</span><br><span class="line">&#123;<span class="string">&#x27;§&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;¢&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;¤&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;¥&#x27;</span>, <span class="string">&#x27;μ&#x27;</span>, <span class="string">&#x27;×&#x27;</span>, <span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;¶&#x27;</span>, <span class="string">&#x27;£&#x27;</span>, <span class="string">&#x27;©&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;°&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;÷&#x27;</span>, <span class="string">&#x27;±&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;¬&#x27;</span>, <span class="string">&#x27;®&#x27;</span>, <span class="string">&#x27;%&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h3><p>集合有不少专属的操作，这些操作很多是通过对运算符的重载来实现的；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281058984.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281059641.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281059545.png"></p>
<h2 id="dict-和-set-背后"><a href="#dict-和-set-背后" class="headerlink" title="dict 和 set 背后"></a>dict 和 set 背后</h2><p>dict 和 set 背后的实现原理是散列，这样性能就不会因为元素数量的增长出现大多波动；散列本质上是以空间换时间；列表则是以时间换空间；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281109644.png"></p>
<h3 id="dict-的实现及其结果"><a href="#dict-的实现及其结果" class="headerlink" title="dict 的实现及其结果"></a>dict 的实现及其结果</h3><blockquote>
<p>注：所有由用户自定义的对象，都是可散列的；因为它的散列值是由 id() 来生成的，跟对象本身的值没有关系。因此所有这些自定义对象，即使值相同，由于 id 不同，它们也是不相等的；</p>
</blockquote>
<p>相比列表，元组会比较节省空间；一方面是因为它无须重复存储键名，另一方面是它不需要用到散列；</p>
<p>应避免在迭代的过程中，对字典进行修改，它会给迭代带来扰乱，有可能导致出错，或者结果错乱；</p>
<p>字典 dict 是不可散列的，所以无法直接将 dict 添加到 set 中；</p>
<p>字典 dict 的键名顺序是有可能会变化的，例如当出现散列冲突时或者扩容时；</p>
<h1 id="第4章-文本和字节序列"><a href="#第4章-文本和字节序列" class="headerlink" title="第4章 文本和字节序列"></a>第4章 文本和字节序列</h1><h2 id="字符问题"><a href="#字符问题" class="headerlink" title="字符问题"></a>字符问题</h2><p>在 Python3，字符统一使用 Unicode 进行表示（称为码位），这样能够涵盖所有的已知字符，而且这个字符的 Unicode 也是固定的；但是在存储的时候，可以有多种编码方法（将码位转成字节序列），例如 UTF8, UTF16 等；使用不同的编码方法存储，就需要使用相应的解码方法读取，这样出来的结果才是正确的；</p>
<h2 id="字节概要"><a href="#字节概要" class="headerlink" title="字节概要"></a>字节概要</h2><p>在 Python3，有 bytes 和 bytearray 两种字节序列类型，其内部的元素是 0~255 的整数；</p>
<ul>
<li>bytes[0]，返回一个元素；</li>
<li>bytes[:1]，返回一个切片，即一段新的序列</li>
</ul>
<p>虽然二进制序列在底层是整数序列，但是显示的字面量有多种可能，包括：</p>
<ul>
<li>ASCII 字符</li>
<li>制表符、换行符、回车符、斜杠等特殊符号；</li>
<li>十六进制转义表示</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;caf\xc3\xa9&#x27;</span>  <span class="comment"># caf 刚好可以用 Ascii  表示，后来两个只能用十六进制表示</span></span><br></pre></td></tr></table></figure>





<h2 id="基本的编解码器"><a href="#基本的编解码器" class="headerlink" title="基本的编解码器"></a>基本的编解码器</h2><h2 id="了解编解码问题"><a href="#了解编解码问题" class="headerlink" title="了解编解码问题"></a>了解编解码问题</h2><h2 id="处理文本文件"><a href="#处理文本文件" class="headerlink" title="处理文本文件"></a>处理文本文件</h2><h2 id="为了正确比较而规范化-Unicode-字符串"><a href="#为了正确比较而规范化-Unicode-字符串" class="headerlink" title="为了正确比较而规范化 Unicode 字符串"></a>为了正确比较而规范化 Unicode 字符串</h2><h2 id="Unicode-文本排序"><a href="#Unicode-文本排序" class="headerlink" title="Unicode 文本排序"></a>Unicode 文本排序</h2><h2 id="Unicode-数据库"><a href="#Unicode-数据库" class="headerlink" title="Unicode 数据库"></a>Unicode 数据库</h2><h2 id="支持字符串和字节序列的双模式-API"><a href="#支持字符串和字节序列的双模式-API" class="headerlink" title="支持字符串和字节序列的双模式 API"></a>支持字符串和字节序列的双模式 API</h2><h1 id="第5章-一等函数"><a href="#第5章-一等函数" class="headerlink" title="第5章 一等函数"></a>第5章 一等函数</h1><h2 id="把函数视为对象"><a href="#把函数视为对象" class="headerlink" title="把函数视为对象"></a>把函数视为对象</h2><p>first class 函数满足以下条件：</p>
<ul>
<li>能够在运行时创建</li>
<li>能够赋值给变量或者数据结构中的元素；</li>
<li>能够做为参数传递给函数；</li>
<li>能够做为结果从函数调用中返回；</li>
</ul>
<p>简而言之，函数就像一个对象一样（事实上在底层实现也是如此，函数即对象）；</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数：higher-order function，接受函数做为参数，或者返回结果为参数；</p>
<p>常用的 map 和 filter，可以用列表推导式和生成器表达式进行替代，看起来更容易理解，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(func, <span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line">[func(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">filter</span>(<span class="keyword">lambda</span> n : n % <span class="number">2</span>, <span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>) <span class="keyword">if</span> i % <span class="number">2</span>]</span><br></pre></td></tr></table></figure>



<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>由于 python 的 lambda 函名函数只能写单行的表达式，因此表达能力非常有限，导致使用场景非常少；常用于高阶函数的函数参数；类似下面这个样子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(<span class="keyword">lambda</span> n : n % <span class="number">2</span>, <span class="built_in">range</span>(<span class="number">6</span>))</span><br></pre></td></tr></table></figure>



<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>调用运算符，即一对括号，不仅可以运用在函数上，其实也可以运用在普通对象上；</p>
<p>可用 callable 函数来判断某个对象是否可以调用</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261020586.png"></p>
<h2 id="用户定义的可调用类型"><a href="#用户定义的可调用类型" class="headerlink" title="用户定义的可调用类型"></a>用户定义的可调用类型</h2><p>事实上所有对象都是可以调用的，只要对象有实现  call 方法即可；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261039412.png"></p>
<h2 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h2><blockquote>
<p>函数内省，function introspection，这个翻译名称有点奇怪；</p>
</blockquote>
<p>由于函数是一个对象，因此其实这个对象内部存储着很多与函数有关的信息，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261045205.png"></p>
<h2 id="从定位参数到仅限关键字参数"><a href="#从定位参数到仅限关键字参数" class="headerlink" title="从定位参数到仅限关键字参数"></a>从定位参数到仅限关键字参数</h2><p>python 的函数参数处理机制非常灵活强大，既支持固定位置的参数形式，也支持按关键字进行匹配的参数形式。同时还支持使用 * 单星号或者 ** 双星号，将不固定数量的任意个参数，打包成一个可迭代对象，以便在函数体内部进行访问；其中单个星号打包成 tuple 元组的形式；两个星号打包成字典 dict 的形式；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261110944.png"></p>
<h2 id="获取关于参数的信息"><a href="#获取关于参数的信息" class="headerlink" title="获取关于参数的信息"></a>获取关于参数的信息</h2><p>函数内部的属性，可用来做一起有用的事情，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261114146.png"></p>
<p>此处使用了装饰器，装饰器会检查 hello 函数内部属性中存储的与参数有关的信息。检查后，它会发现 hello 函数需要一个 person 函数；因此，它可以用 query 对象中，获取相应的 person 值，然后作为参数，传递给 hello 函数；</p>
<p>_<em>default_</em>  存储函数参数的默认值；</p>
<p>_<em>code_</em>  是一个对象，它也存储着函数的相关信息，例如：</p>
<ul>
<li>co_varnames 存储着参数名称 + 局部变量名称</li>
<li>co_argcount 存储着函数的参数个数；</li>
</ul>
<p>直接访问 code 对象或者 default 不是很方便，不过有个 inspect 库提供了方便的查看方式；</p>
<h2 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h2><p>函数注解可用来给参数和返回值备注类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clip</span>(<span class="params">text:<span class="built_in">str</span>, max_len:<span class="string">&#x27;int &gt; 0&#x27;</span>=<span class="number">80</span></span>) -&gt; <span class="built_in">str</span>: <span class="comment"># 备注参数和返回值的类型</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;省略&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>注解会存储在函数的 _<em>annotations</em>_ 属性中；</p>
<p>注解本身不会做任何事情，有注解跟没有注解是一样的；但是注解可以给第三方工具（例如框架、装饰器等）提供有用的信息，例如 IDE 或者 Lint 工具可以利用注解来检查；</p>
<h2 id="支持函数式编程的包"><a href="#支持函数式编程的包" class="headerlink" title="支持函数式编程的包"></a>支持函数式编程的包</h2><h3 id="operator-模块"><a href="#operator-模块" class="headerlink" title="operator 模块"></a>operator 模块</h3><p>operator 模块提供了一些算术运算符函数，它让代码更加简单易懂；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">   <span class="keyword">return</span> reduce(mul, <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)) <span class="comment"># mul 函数可用来计算两个数值的乘积</span></span><br></pre></td></tr></table></figure>

<p>itemgetter 可用来读取元组中的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>metro_data = [</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;Sao Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> city <span class="keyword">in</span> <span class="built_in">sorted</span>(metro_data, key=itemgetter(<span class="number">1</span>)): <span class="comment"># itemgetter(1) 等同于 lamba fields : fields[1]</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(city)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处的 itemgetter 的两个参数，表示读取两个位置的值，组成元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cc_name = itemgetter(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> city <span class="keyword">in</span> metro_data:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(cc_name(city))</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;JP&#x27;</span>, <span class="string">&#x27;Tokyo&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;IN&#x27;</span>, <span class="string">&#x27;Delhi NCR&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;MX&#x27;</span>, <span class="string">&#x27;Mexico City&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;New York-Newark&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;BR&#x27;</span>, <span class="string">&#x27;Sao Paulo&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>attrgetter 与 itemgetter 的不同之处在于它使用名称来提取对象的属性；</p>
<p>methodcaller 接受一个参数，表示要调用的函数名称，然后它可以在之后传入的对象中调用相应的方法；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> methodcaller</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;The time has come&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase = methodcaller(<span class="string">&#x27;upper&#x27;</span>) <span class="comment"># 表示调用 upper 方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase(s)  <span class="comment"># 在 s 身上调用 upper 方法</span></span><br><span class="line"><span class="string">&#x27;THE TIME HAS COME&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hiphenate = methodcaller(<span class="string">&#x27;replace&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;-&#x27;</span>) <span class="comment"># 调用 replace 方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hiphenate(s)  <span class="comment"># 在 s 身上调用</span></span><br><span class="line"><span class="string">&#x27;The-time-has-come&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-functools-partial-冻结参数"><a href="#使用-functools-partial-冻结参数" class="headerlink" title="使用 functools.partial 冻结参数"></a>使用 functools.partial 冻结参数</h3><p>partial 可用来将某个函数的参数设置为固定值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = partial(mul, <span class="number">3</span>) <span class="comment"># mul 原本接受两个参数，此处将 mul 的第一个参数固定 3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">7</span>) <span class="comment"># 调用时，只需传入第二个参数即可计算出结果</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(triple, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)))  </span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure>



<h1 id="第6章-使用一等函数实现设计模式"><a href="#第6章-使用一等函数实现设计模式" class="headerlink" title="第6章 使用一等函数实现设计模式"></a>第6章 使用一等函数实现设计模式</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在函数作为一等公民时，很多设计模式就有了更简单的实现方法了；例如策略模式中，每个策略对应一个类；实际上它们都可以简单替换成函数即可，完全没有必要单独为了调用它而去实例化一个对象；</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式的本意是想在命令的调用者（操作对象）和接收者（实现对象）之间进行解耦，这样调用者无须了解各个接收者具体是什么接口，而让它们对接口进行统一命名；但其实有更简单的做法，即直接将各个实现绑定到调用者身上就可以了，有点像回调那样；</p>
<p>面向对象之所以要搞成那么复杂，完全是因为它们不能接受函数作为参数，而是只能接受对象做为参数，然后再去调用对象的方法，这样就不得不对所调用的方法有个规范命名，不然就不知道如何调用；但如果能够接受函数作为参数，那就完全不一样了，直接将形参当作函数调用即可，非常简单直观，容易理解；</p>
<h1 id="第7章-函数装饰器和闭包"><a href="#第7章-函数装饰器和闭包" class="headerlink" title="第7章 函数装饰器和闭包"></a>第7章 函数装饰器和闭包</h1><h2 id="装饰器基础知识"><a href="#装饰器基础知识" class="headerlink" title="装饰器基础知识"></a>装饰器基础知识</h2><p>装饰器是一个可调用的对象，类似函数，它的参数是另外一个函数，它的目的是对该函数进行打包封装，干些额外的工作；它的执行结果有可能会返回参数函数，也有可能是返回另外一个新的函数或可调用对象，并赋值给原本作为参数的函数名称，这样调用者并不知道这个函数可能已经被替换了；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;running target()&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 上面的写法跟下面的写法是一个意思</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;running target()&quot;</span>)</span><br><span class="line">    </span><br><span class="line">target = decorate(target);</span><br></pre></td></tr></table></figure>



<h2 id="Python-何时执行装饰器"><a href="#Python-何时执行装饰器" class="headerlink" title="Python 何时执行装饰器"></a>Python 何时执行装饰器</h2><p>注意，在定义装饰器的代码文件被加载时，装饰器会被立即执行，此时被装饰的函数还没有被调用；</p>
<h2 id="使用装饰器改进策略模式"><a href="#使用装饰器改进策略模式" class="headerlink" title="使用装饰器改进策略模式"></a>使用装饰器改进策略模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">promos = [] </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">promotion</span>(<span class="params">promo_func</span>): </span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion </span><span class="comment"># 使用装饰器，在添加新的折扣策略时，不容易遗漏</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fidelity</span>(<span class="params">order</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;为积分为1000或以上的顾客提供5%折扣&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="meta">    @promotion</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@promotion </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bulk_item</span>(<span class="params">order</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;单个商品为20个或以上时提供10%折扣&quot;&quot;&quot;</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">        	discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br></pre></td></tr></table></figure>



<h2 id="变量作用域规则"><a href="#变量作用域规则" class="headerlink" title="变量作用域规则"></a>变量作用域规则</h2><p>python 在编译函数定义时，它会先检查函数中声明的局部变量；</p>
<ul>
<li>如果变量存在，那么之后使用变量时，解释器只会在本地作用域中寻找；</li>
<li>如果不存在，那么就会到函数的定义环境中寻找全局变量；</li>
</ul>
<p>global 关键字可用来告知某个变量为全局的，以引导解释器到正确的位置查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f3</span>(<span class="params">a</span>):</span><br><span class="line"><span class="meta">... </span><span class="keyword">global</span> b</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(a)</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(b)</span><br><span class="line"><span class="meta">... </span>b = <span class="number">9</span></span><br></pre></td></tr></table></figure>



<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>如果函数引用了某个变量，该不在其定义内部定义，而是在函数外部定义的，那么解释器会在函数对象中，保留一个指向该外部变量的引用，以便在使用该变量时，能够取到相应的值；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    series = [] </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">new_value</span>):</span><br><span class="line">         <span class="comment"># 此处引用的 series 变量在 averager 外部定义，averager 对象属性中会保存它的引用</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = <span class="built_in">sum</span>(series)</span><br><span class="line">        <span class="keyword">return</span> total/<span class="built_in">len</span>(series)</span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>

<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407282027810.png"></p>
<h2 id="nonlocal-声明"><a href="#nonlocal-声明" class="headerlink" title="nonlocal 声明"></a>nonlocal 声明</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">new_value</span>):</span><br><span class="line">        count += <span class="number">1</span> </span><br><span class="line">        <span class="comment"># 此处的表达式等同于 count = count + 1，因此解释器会将 count 当作局部变量</span></span><br><span class="line">        <span class="comment"># 因此在执行 count + 1 会出现报错</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了解决以上问题，需要用 nonlocal 关键字将 count 和 total 声明为非局部变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">new_value</span>):</span><br><span class="line">    	<span class="keyword">nonlocal</span> count, total <span class="comment"># 声明 nonlocal</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>



<h2 id="实现一个简单的装饰器"><a href="#实现一个简单的装饰器" class="headerlink" title="实现一个简单的装饰器"></a>实现一个简单的装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clock</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clocked</span>(<span class="params">*args</span>): <span class="comment"># 不支持关键字参数</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_str = <span class="string">&quot;, &quot;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[%0.8fs] %s(%s) -&gt; %r&#x27;</span> % (elapsed, name, arg_str, result))</span><br><span class="line">     <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>

<p>支持关键字参数的版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clock</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>) </span><span class="comment"># 用于将函数属性从 func 复制到 clocked 函数中，例如函数名称等</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clocked</span>(<span class="params">*args, **kwargs</span>):  <span class="comment"># 支持关键字参数</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">&quot;, &quot;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">&#x27;%s=%r&#x27;</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> <span class="built_in">sorted</span>(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">&quot;, &quot;</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">&quot;, &quot;</span>.join(arg_lst)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[%0.8fs] %s(%s) -&gt; %r &#x27;</span> % (elapsed, name, arg_str, result))</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>



<h2 id="标准库中的装饰器"><a href="#标准库中的装饰器" class="headerlink" title="标准库中的装饰器"></a>标准库中的装饰器</h2><h3 id="使用-lru-cache-缓存"><a href="#使用-lru-cache-缓存" class="headerlink" title="使用  lru_cache  缓存"></a>使用  lru_cache  缓存</h3><p>lru_cache  可以帮助缓存函数的计算结果，如果下次再传入相同的参数，则直接从缓存中返回计算结果，不再重复计算，这会极大的提高性能，尤其是存在大量重复计算的场景，例如计算斐波契那数列；</p>
<blockquote>
<p>lru 的全称 least recently used</p>
</blockquote>
<h3 id="单分派泛函数"><a href="#单分派泛函数" class="headerlink" title="单分派泛函数"></a>单分派泛函数</h3><blockquote>
<p>所谓的分泛函数是指这个函数的功能用于分别派分任务，它根据参数值，使用一串 if elif else 来分别调用相应的函数；在 OO 的语言中一般叫重载，但 Python 不支持重载；</p>
</blockquote>
<p>singledispatch 装饰器，可以将多个函数组合成一个泛函数；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch  </span><span class="comment"># 将 htmlize 包装成了泛函数，之后它可以注册不同的参数 </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">htmlize</span>(<span class="params">obj</span>):</span><br><span class="line">    content = html.escape(<span class="built_in">repr</span>(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;pre&gt;&#123;&#125;&lt;/pre&gt;&#x27;</span>.<span class="built_in">format</span>(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(<span class="params"><span class="built_in">str</span></span>)  </span><span class="comment"># 注册重载 str 类型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">text</span>):</span><br><span class="line">    content = html.escape(text).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&lt;br&gt;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;&lt;p&gt;&#123;0&#125;&lt;/p&gt;&#x27;</span>.<span class="built_in">format</span>(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(<span class="params">numbers.Integral</span>) </span><span class="comment"># 注册重载 int 类型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">n</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;&#x27;</span>.<span class="built_in">format</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(<span class="params"><span class="built_in">tuple</span></span>) </span><span class="comment"># 注册 tuple 类型</span></span><br><span class="line"><span class="meta">@htmlize.register(<span class="params">abc.MutableSequence</span>)  </span><span class="comment"># 可多个类型叠加</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">seq</span>):</span><br><span class="line">    inner = <span class="string">&#x27;&lt;/li&gt;\n&lt;li&gt;&#x27;</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;&lt;ul&gt;\n&lt;li&gt;&#x27;</span> + inner + <span class="string">&#x27;&lt;/li&gt;\n&lt;/ul&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>singledispatch 可以用来装饰自己编写的函数，也可以用来装饰他人编写的函数；</p>
<h2 id="叠放装饰器"><a href="#叠放装饰器" class="headerlink" title="叠放装饰器"></a>叠放装饰器</h2><p>装饰器支持叠放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#等同于</span></span><br><span class="line">f = d1(d2(f))</span><br></pre></td></tr></table></figure>



<h2 id="参数化装饰器"><a href="#参数化装饰器" class="headerlink" title="参数化装饰器"></a>参数化装饰器</h2><p>通过创建一个装饰器工厂函数，便可使装饰器支持传入参数；调用该装饰器工厂函数时，返回的是真正的装饰器；</p>
<h1 id="第8章-对象引用、可变性和垃圾回收"><a href="#第8章-对象引用、可变性和垃圾回收" class="headerlink" title="第8章 对象引用、可变性和垃圾回收"></a>第8章 对象引用、可变性和垃圾回收</h1><h2 id="变量不是盒子"><a href="#变量不是盒子" class="headerlink" title="变量不是盒子"></a>变量不是盒子</h2><p>变量本身是一个独立的东西，我们借助它，让它指向某个对象，以方便实现引用该对象；</p>
<h2 id="标识、相等性和别名"><a href="#标识、相等性和别名" class="headerlink" title="标识、相等性和别名"></a>标识、相等性和别名</h2><p>在 Python 中，判断两个对象是否相同，有两种方法，一种是 &#x3D;&#x3D; 两个等号，一种是使用关键字 is，它们的意思是不一样的；&#x3D;&#x3D; 会调用对象的 __eq __ 方法进行判断，它比的是值相等即可，is 等是判断对象的 id，相当于内存的地址；</p>
<p>由于 is 比较的是地址，因为使用 is 进行判断它的性能很好；因为使用 &#x3D;&#x3D; 进行判断的话，需要遍历对象的属性值；</p>
<p>object 类型的 eq 方法比较的是 id，但是其他大多数内置类型的 eq 方法比较的是值；</p>
<p>当元组用于保存对象时，它保存的是对象的引用。虽然元组本身不可变，但这个引用背后的对象自身是可以变的；</p>
<h2 id="默认做浅复制"><a href="#默认做浅复制" class="headerlink" title="默认做浅复制"></a>默认做浅复制</h2><p>如果要做深复制，需要使用 deepcopy 方法；浅复制则使用 copy 方法；</p>
<h2 id="函数的参数作为引用时"><a href="#函数的参数作为引用时" class="headerlink" title="函数的参数作为引用时"></a>函数的参数作为引用时</h2><p>千万不要将函数参数的默认值设置为可变对象，而应该设置为 None；因为如果是可变对象，那么在函数载入时，会自动创建出来；这样导致多次不传参数的调用该函数时，多个函数都会指向该默认值，造成相互影响；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HauntedBus</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, passengers=[]</span>): <span class="comment"># 这里默认值 [] 是大忌，千万要避免</span></span><br><span class="line">        <span class="variable language_">self</span>.passengers = passengers</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.passengers.append(name)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drop</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.passengers.remove(name)</span><br></pre></td></tr></table></figure>

<p>如果函数的参数是一个可变对象，那么让函数对该对象进行修改，会直接作用到外部的实参对象上。有时候，这是想要的结果，有时候则不是非预期的结果。如果是非预期的结果，那么函数内部应对该实参进行复制；</p>
<h2 id="del-和垃圾回收"><a href="#del-和垃圾回收" class="headerlink" title="del 和垃圾回收"></a>del 和垃圾回收</h2><p>del 关键字并不是用来销毁对象的，而仅仅是切割变量和对象之间的引用关系；当对象的引用数量为零时，销毁的工作会垃圾回收器处理；</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用不会增加对象的引用计数，这样不会对对象的垃圾回收带来干扰；一般用于有生命周期限制的缓存管理中；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set) ➊</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref</span><br><span class="line">&lt;weakref at <span class="number">0x100637598</span>; to <span class="string">&#x27;set&#x27;</span> at <span class="number">0x100636748</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() ➋</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; ➌</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() ➍</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span> ➎</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span> ➏</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>WeakValueDictionary 是一种可变映射（字典也是一种可变映射），映射指向的值是对象的弱引用；当对象被回收时，对应的键会自动从 WeakValueDictionary 中被删除；因此，它很适合用来做缓存；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cheese</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kind</span>):</span><br><span class="line">    	<span class="variable language_">self</span>.kind = kind</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;Cheese(%r)&#x27;</span> % <span class="variable language_">self</span>.kind</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stock = weakref.WeakValueDictionary() <span class="comment"># 实例化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>catalog = [Cheese(<span class="string">&#x27;Red Leicester&#x27;</span>), Cheese(<span class="string">&#x27;Tilsit&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>Cheese(<span class="string">&#x27;Brie&#x27;</span>), Cheese(<span class="string">&#x27;Parmesan&#x27;</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cheese <span class="keyword">in</span> catalog:</span><br><span class="line"><span class="meta">... </span>stock[cheese.kind] = cheese <span class="comment"># 将 stock 的键映射到 cheese 实例上</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(stock.keys())</span><br><span class="line">[<span class="string">&#x27;Brie&#x27;</span>, <span class="string">&#x27;Parmesan&#x27;</span>, <span class="string">&#x27;Red Leicester&#x27;</span>, <span class="string">&#x27;Tilsit&#x27;</span>] ➌</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> catalog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(stock.keys())</span><br><span class="line">[<span class="string">&#x27;Parmesan&#x27;</span>] <span class="comment"># 为什么删除 catalog 后，没有全部删除，而是还剩下一个？</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> cheese <span class="comment"># for 循环中的 cheese 是全局变量，因此需要显式删除，不然仍然有一个引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(stock.keys())</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>不是每个 python 对象都可以被弱引用，例如常用的 list 和 dict 实例无法被弱引用，但是它们的子类可以；set 实例也可以</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;list的子类，实例可以作为弱引用的目标&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">a_list = MyList(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># a_list可以作为弱引用的目标</span></span><br><span class="line">wref_to_a_list = weakref.ref(a_list)</span><br></pre></td></tr></table></figure>



<h2 id="Python-对不可变类型施加的把戏"><a href="#Python-对不可变类型施加的把戏" class="headerlink" title="Python 对不可变类型施加的把戏"></a>Python 对不可变类型施加的把戏</h2><p>使用一个元组构建另外一个元组，结果得到的是同一个元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = <span class="built_in">tuple</span>(t1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>在 CPython 中，当对象的引用数量为零，会立即触发垃圾回收。但其他 Python 实现则不一定如此；这里涉及到性能的权衡；</p>
<h1 id="第9章-符合-Python-风格的对象"><a href="#第9章-符合-Python-风格的对象" class="headerlink" title="第9章 符合 Python 风格的对象"></a>第9章 符合 Python 风格的对象</h1><h2 id="对象表示形式"><a href="#对象表示形式" class="headerlink" title="对象表示形式"></a>对象表示形式</h2><p>Python 默认使用两个函数来表示对象的字符串形式，它们分别是 repr() 和 str() 函数。它们实际上调用的是对象的 _<em>repr</em>_ 和 _<em>str</em>_ </p>
<p>另外还有一个 bytes() 函数会调用 _<em>bytes</em>_ 方法来返回字节序列；</p>
<h2 id="再谈向量类"><a href="#再谈向量类" class="headerlink" title="再谈向量类"></a>再谈向量类</h2><p>以下是自定义向量类的待实现功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(v1.x, v1.y) <span class="comment"># 能够通过点运算符，直接访问属性</span></span><br><span class="line"><span class="number">3.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = v1 <span class="comment"># 支持元组拆包</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 <span class="comment"># repr 的显示格式</span></span><br><span class="line">Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_clone = <span class="built_in">eval</span>(<span class="built_in">repr</span>(v1)) <span class="comment"># 基于 repr 结果生成对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v1_clone <span class="comment"># 支持 == 运算符</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(v1) <span class="comment"># str 的实现</span></span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = <span class="built_in">bytes</span>(v1)  <span class="comment"># 生成实例的二进制表示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets</span><br><span class="line"><span class="string">b&#x27;d\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(v1) <span class="comment"># 支持 abs 方法，返回实例的模</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(v1), <span class="built_in">bool</span>(Vector2d(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment"># 支持 bool 方法，模为零时，返回 False</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>



<h2 id="备选构造方法"><a href="#备选构造方法" class="headerlink" title="备选构造方法"></a>备选构造方法</h2><h2 id="classmethod-与-staticmethod"><a href="#classmethod-与-staticmethod" class="headerlink" title="classmethod 与 staticmethod"></a>classmethod 与 staticmethod</h2><p>classmethod 修饰的函数，调用时，不需要实例化对象；该函数的第一个参数是类本身，从而可以借助该函数，访问类的相关成员；</p>
<p>classmethod 的一个常见用途时定义额外的构造方法，一般该构造方法会对传入的数据进行清洗，之后再构造对象；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">frombytes</span>(<span class="params">cls, octets</span>): <span class="comment"># 第一个参数不是 self, 而是类本身</span></span><br><span class="line">    typecode = <span class="built_in">chr</span>(octets[<span class="number">0</span>]) </span><br><span class="line">    memv = <span class="built_in">memoryview</span>(octets[<span class="number">1</span>:]).cast(typecode) </span><br><span class="line">    <span class="keyword">return</span> cls(*memv) </span><br></pre></td></tr></table></figure>



<h2 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;1 BRL = &#123;rate:0.2f&#125; USD&#x27;</span>.<span class="built_in">format</span>(rate=brl) <span class="comment"># rate 表示具名变量</span></span><br><span class="line"><span class="string">&#x27;1 BRL = 0.41 USD&#x27;</span></span><br></pre></td></tr></table></figure>

<p>关于如何格式化，python 有一套自己的语法规则，可称之为微语言；这套微语言是可扩展的，可以自定义如何解释 forma_spec 参数</p>
<h2 id="可散列的-Vector2d"><a href="#可散列的-Vector2d" class="headerlink" title="可散列的 Vector2d"></a>可散列的 Vector2d</h2><p>通过实现 _<em>hash</em>_ 和 _<em>eq</em>_ 方法，可将一个不可散列的自定义类的对象，变成可散列的；</p>
<h2 id="Python-的私有属性和受保护的属性"><a href="#Python-的私有属性和受保护的属性" class="headerlink" title="Python 的私有属性和受保护的属性"></a>Python 的私有属性和受保护的属性</h2><p>python 没有类似 Java 中的 private 关键字，而是通过给类成员的名称添加两个下划线前缀，将该成员标记为私有成员，类似这样：__x，但也有一些人喜欢使用一个下划线来表示；</p>
<p>对于私有属性，解释器在实例化对象时，会给这些属性加上类名作为前缀，这样一来，直接用双下划线访问私有属性时，会提示该属性并不存在，从而实现访问控制；但实际上是可以访问的，只是曲折一点，需要加上类名前缀来访问；</p>
<h2 id="使用-slots-类属性节省空间"><a href="#使用-slots-类属性节省空间" class="headerlink" title="使用 slots 类属性节省空间"></a>使用 slots 类属性节省空间</h2><p>默认情况下，类的实例在 _<em>dict_</em> 字段中使用字典来存储属性成员，如果成员比较多的，会占据较大的内存，此时可考虑使用 _<em>slot_</em> 属性来存储以节省内存；它的原理是使用元组来存储，所以节省内存；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector2d</span>:</span><br><span class="line">    __slots__ = (<span class="string">&#x27;__x&#x27;</span>, <span class="string">&#x27;__y&#x27;</span>)</span><br><span class="line">    typecode = <span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="覆盖类属性"><a href="#覆盖类属性" class="headerlink" title="覆盖类属性"></a>覆盖类属性</h2><p>Python 的类属性可以为实例属性提供默认值，这个默认值在实例中可以被重新赋值；</p>
<p>如果要批量处理，则可以考虑定义一个子类，该子类的属性重写，之后使用子类来实例化对象；</p>
<h1 id="第10章-序列的修改、散列和切片"><a href="#第10章-序列的修改、散列和切片" class="headerlink" title="第10章 序列的修改、散列和切片"></a>第10章 序列的修改、散列和切片</h1><p>鸭子类型：只要实现一些约定的接口，即可当作拥有目标类型的特征，并可以像目标类型一样被处理；例如一个类只需要实现 getitem 和  len 两个接口，那么它就可以被当作序列类型一样处理，至于它是谁的子类，并不重要；</p>
<blockquote>
<p>zip 函数可用于并行迭代多个序列，它会将多个序列的对象打包成元组，然后可以拆包赋值给各个变量； </p>
</blockquote>
<h1 id="第11章-接口：从协议到抽象基类"><a href="#第11章-接口：从协议到抽象基类" class="headerlink" title="第11章 接口：从协议到抽象基类"></a>第11章 接口：从协议到抽象基类</h1><h2 id="接口与协议"><a href="#接口与协议" class="headerlink" title="接口与协议"></a>接口与协议</h2><p>一个类只需要实现了某些特定的接口，它就可以被当作特定的类型进行操作（即鸭子类型）；</p>
<p>当一个类实现了 getitem 接口时，即使它没有实现 contains 和 iter 接口，它也是可迭代，并且支持 in 运算符的；因为解释器会调用 getitem 接口来实现以上两项功能；</p>
<blockquote>
<p>Python 类中的方法，第一个参数叫 self 纯粹是一种惯例，其实叫个其他名字也无妨；</p>
</blockquote>
<h2 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h2><p>猴子补丁：如果一个类在定义时，没有定义某个方法；之后在运行时，可以在外部单独定义一个函数，然后把这个函数绑定到类的某个属性上，这样就让类动态获得了某个方法；</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>抽象基类一般用于编写框架的场景，如果是业务场景，几乎不太可能需要自己编写抽象基类，而是使用现成的就可以了；</p>
<p>当继承抽象基类，就需要手工实现抽象基类中规定的所有方法，不管该方法是否用得到；</p>
<h2 id="标准库中的-ABC"><a href="#标准库中的-ABC" class="headerlink" title="标准库中的 ABC"></a>标准库中的 ABC</h2><blockquote>
<p>ABC：抽象基类，abstract base class</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407301247891.png"></p>
<p>不可变集合：Sequence, Mapping, Set</p>
<p>可变集合：MutableSequence, MutableMapping, MutableSet</p>
<h3 id="数字塔"><a href="#数字塔" class="headerlink" title="数字塔"></a>数字塔</h3><p>numbers 包定义了数字抽象基类的线性层次结构：Number &lt; Complex &lt; Real &lt; Rational &lt; Integral；</p>
<h1 id="第12章-继承的优缺点"><a href="#第12章-继承的优缺点" class="headerlink" title="第12章 继承的优缺点"></a>第12章 继承的优缺点</h1><h2 id="子类化内置类型很麻烦"><a href="#子类化内置类型很麻烦" class="headerlink" title="子类化内置类型很麻烦"></a>子类化内置类型很麻烦</h2><p>内置类型的方法不会调用子类覆盖后的方法，它只会调用内置类型原本的方法；因此，不会子类化内置类型，Python 有专门给用户子类化的类型，以 User 开头，例如 UserDict、UserList、UserString 等；</p>
<blockquote>
<p>猜测原因在于内置类型的很多方法，出于性能考虑，是用 C  语言专门优化过的，因此不严格遵行继承的定义；</p>
</blockquote>
<h2 id="多重继承和方法解析顺序"><a href="#多重继承和方法解析顺序" class="headerlink" title="多重继承和方法解析顺序"></a>多重继承和方法解析顺序</h2><p>多重继承会面临菱形问题，即子类继承多个父类中，存在同名的方法，导致子类无法确定应该执行哪个父类的同名方法；</p>
<h2 id="多重继承的真实应用"><a href="#多重继承的真实应用" class="headerlink" title="多重继承的真实应用"></a>多重继承的真实应用</h2><h2 id="处理多重继承"><a href="#处理多重继承" class="headerlink" title="处理多重继承"></a>处理多重继承</h2><h2 id="Django-示例"><a href="#Django-示例" class="headerlink" title="Django 示例"></a>Django 示例</h2><h1 id="第13章-正确重载运算符"><a href="#第13章-正确重载运算符" class="headerlink" title="第13章 正确重载运算符"></a>第13章 正确重载运算符</h1><h1 id="第14章-可迭代对象、迭代器和生成器"><a href="#第14章-可迭代对象、迭代器和生成器" class="headerlink" title="第14章 可迭代对象、迭代器和生成器"></a>第14章 可迭代对象、迭代器和生成器</h1><blockquote>
<p>迭代器模式：惰性加载数据，处理时加载，这样可以用较小的内存，处理很大的数据集；</p>
</blockquote>
<p>Python 中使用生成器来实现迭代器模式；生成器也是为了迭代数据，因此可将它当作迭代器来使用，唯一的区别在于它的惰性；</p>
<p>在 Python3 中，生成器是很普遍的，只是使用的时候没有觉察，例如 range(10) 返回的是一个类似生成器的对象；如果想要获得完整的列表，需要写成 list(range(10))；</p>
<h2 id="可迭代对象和迭代器对比"><a href="#可迭代对象和迭代器对比" class="headerlink" title="可迭代对象和迭代器对比"></a>可迭代对象和迭代器对比</h2><p>区别：从可迭代对象中，获取迭代器；迭代器如果迭代完毕，则不再可用，需要重新构建；</p>
<p>所谓的迭代器，可以理解为一个对象，每次调用它的 next 方法，可返回一个元素；如果空了，会报错；</p>
<blockquote>
<p>通常迭代器还有一个 iter 方法，调用这个方法，可返回迭代器本身；理论上不实现它，也不会影响迭代功能。但如果实现了它，issubclass 方法可将其判断为 Iterator 的子类；</p>
<p>可迭代对象也有一个 iter 方法，调用它，会返回一个新的迭代器；</p>
</blockquote>
<h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="variable language_">self</span>.text = text</span><br><span class="line">        <span class="variable language_">self</span>.words = RE_WORD.findall(text)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(<span class="variable language_">self</span>.text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># iter 使用了 yield 关键字，调用 iter 会返回生成器对象，此时 iter 是个生成器函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> <span class="variable language_">self</span>.words:</span><br><span class="line">        	<span class="keyword">yield</span> word </span><br></pre></td></tr></table></figure>



<h3 id="生成器函数的工作原理"><a href="#生成器函数的工作原理" class="headerlink" title="生成器函数的工作原理"></a>生成器函数的工作原理</h3><p>yield 关键字有点像 await，每次执行到 yield 所在的语句时，会暂停等待；</p>
<blockquote>
<p>for 循环语句会自动捕获并处理迭代器抛出的异常；</p>
</blockquote>
<h2 id="惰性实现"><a href="#惰性实现" class="headerlink" title="惰性实现"></a>惰性实现</h2><p>re 模块除了 findall 函数，还有一个生成器版本的 finditer 函数；它每次只返回一个匹配项；当数据量很大时，可以节省很多内存；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, text</span>):</span><br><span class="line">    	<span class="variable language_">self</span>.text = text </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(<span class="variable language_">self</span>.text)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> RE_WORD.finditer(<span class="variable language_">self</span>.text): <span class="comment"># finditer 返回生成器</span></span><br><span class="line">        	<span class="keyword">yield</span> <span class="keyword">match</span>.group()</span><br></pre></td></tr></table></figure>

<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器表达式有点像是列表推导的惰性版本；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">gen_AB</span>(): <span class="comment"># ➊</span></span><br><span class="line"><span class="meta">... </span>	<span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">yield</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">... </span>	<span class="built_in">print</span>(<span class="string">&#x27;continue&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">yield</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">...	 <span class="built_in">print</span>(<span class="string">&#x27;end.&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()] <span class="comment"># res1 是一个列表，由生成器 gen_Ab 的返回值组成</span></span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res1: <span class="comment"># ➌</span></span><br><span class="line"><span class="meta">... </span>	<span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, i)</span><br><span class="line">...</span><br><span class="line">--&gt; AAA</span><br><span class="line">--&gt; BBB</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()) <span class="comment"># res2 是一个生成器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 </span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x10063c240</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res2: <span class="comment"># 遍历 res2，此时 gen_AB 函数才真正的执行</span></span><br><span class="line">...		<span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, i)</span><br><span class="line">...</span><br><span class="line">start</span><br><span class="line">--&gt; AAA</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; BBB</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, text</span>):</span><br><span class="line">    	<span class="variable language_">self</span>.text = text</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(<span class="variable language_">self</span>.text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用表达式构建一个生成器，而不是用 yield 来生成</span></span><br><span class="line">    <span class="comment"># 生成器表达式是一个语法糖，本质上跟使用 yield 的生成器函数没有区别</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> (<span class="keyword">match</span>.group() <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> RE_WORD.finditer(<span class="variable language_">self</span>.text))</span><br></pre></td></tr></table></figure>

<h2 id="何时用生成器表达式"><a href="#何时用生成器表达式" class="headerlink" title="何时用生成器表达式"></a>何时用生成器表达式</h2><p>生成器表达式是构建生成器的简捷方式，无需通过 def 定义函数来实现；但限于一些简单场景，一行可以搞定的那种；如果业务逻辑比较复杂，一行代码搞不定的话，则仍然需要使用函数来定义；</p>
<p>标准库  itertools 模块中有很多现成的生成器；</p>
<p>itertools.count(start, step)：创建一个数字生成器</p>
<p>itertools.takewhile 给生成器添加条件限制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; <span class="number">3</span>, itertools.count(<span class="number">1</span>, <span class="number">.5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(gen)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure>

<h2 id="标准库中的生成器"><a href="#标准库中的生成器" class="headerlink" title="标准库中的生成器"></a>标准库中的生成器</h2><p>在创建任何生成器前，很有必要先查一下标准库中有哪些生成器可用，以避免重复造轮子；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311445182.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311446562.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311447657.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311447765.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311454347.png"></p>
<h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><p>yield from 可用来作为可迭代对象的生成器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">chain</span>(<span class="params">*iterables</span>):</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>		<span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"><span class="meta">... </span>			<span class="keyword">yield</span> i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(chain(s, t))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的写法，用 yield from 重写如下，可减少一层 for 循环</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">chain</span>(<span class="params">*iterables</span>):</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">for</span> i <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>		<span class="keyword">yield</span> <span class="keyword">from</span> i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(chain(s, t))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h2 id="可迭代的归约函数"><a href="#可迭代的归约函数" class="headerlink" title="可迭代的归约函数"></a>可迭代的归约函数</h2><p>归约函数：接受一个可迭代的对象，返回一个值，例如 reduce 函数；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311501287.png"></p>
<h2 id="深入分析-iter-函数"><a href="#深入分析-iter-函数" class="headerlink" title="深入分析 iter 函数"></a>深入分析 iter 函数</h2><p>iter 函数用于生成迭代器，一般接收一个可迭代对象作为参数；但是它还有个用法是接收两个参数，第一个参数是个可迭代对象，第二个参数是个 predicate，当可迭代对象产生的值满足 predicate 时，就停止产出；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">d6</span>():</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">return</span> randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter = <span class="built_in">iter</span>(d6, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter</span><br><span class="line">&lt;callable_iterator <span class="built_in">object</span> at <span class="number">0x00000000029BE6A0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> roll <span class="keyword">in</span> d6_iter:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(roll)</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>生成器很适合用来处理大数据集，这样可以利用有限的内存，处理无限大的数据，例如大型数据库；</p>
<h2 id="生成器当作协程"><a href="#生成器当作协程" class="headerlink" title="生成器当作协程"></a>生成器当作协程</h2><p>生成器对象有个 send 方法，该方法允许给生成器对象发送消息；</p>
<h1 id="第15章-上下文管理器和-else-块"><a href="#第15章-上下文管理器和-else-块" class="headerlink" title="第15章 上下文管理器和 else 块"></a>第15章 上下文管理器和 else 块</h1><h2 id="else"><a href="#else" class="headerlink" title="else"></a>else</h2><p>else 不仅可以跟 if 搭配使用，还可以跟 for, while, try 搭配使用；在这些场景中，else 实际上是 then 的意思，表示某个动作如果顺利完成了，那么就执行 else 里面的语句；如果没有顺利完成，就不执行；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">	<span class="keyword">if</span> item.flavor == <span class="string">&#x27;banana&#x27;</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 如果 for 循环结束，没有触发 break，那么就执行 else；如果触发，就退出循环，不执行else</span></span><br><span class="line">	<span class="keyword">raise</span> ValueError(<span class="string">&#x27;No banana flavor found!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	dangerous_call()</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    log(<span class="string">&#x27;OSError...&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 如果 dangerous_call 顺利执行，没有报异常，则执行 else；如果报异常，就不执行 else</span></span><br><span class="line">	after_call()</span><br></pre></td></tr></table></figure>

<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with 的目标是安全的实现 try…finally；with 之后的表达式（例如 open 函数）会创建一个上下文管理器对象。该对象有两个方法，分别是 enter 和 exit；with 语句开始执行时，会调用 enter 方法；执行结束后，会调用 exit 方法，类似 finally 的作用；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with...as... 是一个表达式，该表达式的前半段子句，会创建上下文管理器对象，并执行 enter 方法</span></span><br><span class="line"><span class="comment"># enter 方法执行完成后，会将结果返回到 fp 变量上，但 as 并不是必须的，有些场景并不需要返回什么东西</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;mirror.py&#x27;</span>) <span class="keyword">as</span> fp: </span><br><span class="line"><span class="meta">... </span>src = fp.read(<span class="number">60</span>) <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当解释器执行完整个 with 块的语句后，会调用 exit 方法，清理现场</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下是一个上下文管理器类的示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LookingGlass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>): <span class="comment"># 做准备工作</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        <span class="variable language_">self</span>.original_write = sys.stdout.write </span><br><span class="line">        sys.stdout.write = <span class="variable language_">self</span>.reverse_write </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;JABBERWOCKY&#x27;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_write</span>(<span class="params">self, text</span>): <span class="comment"># 实际干活的方法</span></span><br><span class="line">    	<span class="variable language_">self</span>.original_write(text[::-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>): <span class="comment"># 做清理工作</span></span><br><span class="line">        <span class="keyword">import</span> sys </span><br><span class="line">        sys.stdout.write = <span class="variable language_">self</span>.original_write </span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Please DO NOT divide by zero!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br></pre></td></tr></table></figure>

<p>contextlib 模块中有一些现成的工作，可用来创建自定义的 context 类（上下文管理器）；</p>
<h2 id="contextmanager"><a href="#contextmanager" class="headerlink" title="@contextmanager"></a>@contextmanager</h2><p>contextmanager 装饰器可以简化上下文管理器的定义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager </span><span class="comment"># 该装饰器会将 looking_glass 函数包装成带有 enter 和 exit 方法的类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">looking_glass</span>():</span><br><span class="line">	<span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_write</span>(<span class="params">text</span>): </span><br><span class="line">    	original_write(text[::-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">    sys.stdout.write = reverse_write </span><br><span class="line">    msg = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    	<span class="keyword">yield</span> <span class="string">&#x27;JABBERWOCKY&#x27;</span> <span class="comment"># 这里 yield 起到了类似分隔的作用，enter 执行到这里，后面由 exit 执行</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        msg = <span class="string">&quot;Please DO NOT divide by zero&quot;</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.stdout.write = original_write</span><br><span class="line">        <span class="keyword">if</span> msg:</span><br><span class="line">            <span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure>

<p>个人感觉所谓的上下文管理器，本质上也像是一个实现了约定协议的鸭子类型，只要按照协议实现 enter 和 exit 方法即可；</p>
<h1 id="第16章-协程"><a href="#第16章-协程" class="headerlink" title="第16章 协程"></a>第16章 协程</h1><p>yield 有两个兽性，一个是生成，一个是退让；这两个意思刚好是协程的描述；</p>
<p>当 yield 放在表达式的左边时，它做为生成器使用；</p>
<p>当 yield 放在表达式的右边时，它做为协程使用，等待传入值；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">simple_coroutine</span>(): <span class="comment"># ➊</span></span><br><span class="line"><span class="meta">... </span>	<span class="built_in">print</span>(<span class="string">&#x27;-&gt; coroutine started&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>	x = <span class="keyword">yield</span> <span class="comment"># yield 右边没有值，意味着它生成 None</span></span><br><span class="line"><span class="meta">... </span>	<span class="built_in">print</span>(<span class="string">&#x27;-&gt; coroutine received:&#x27;</span>, x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro <span class="comment"># 生成器已经创建，但是还没有启动，需要通过 next 让它启动</span></span><br><span class="line">&lt;generator <span class="built_in">object</span> simple_coroutine at <span class="number">0x100c2be10</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(my_coro) <span class="comment"># 通过 next 来启动生成器</span></span><br><span class="line">-&gt; coroutine started</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">42</span>) <span class="comment"># 给 yield 传值，仅当协程处于暂停状态时，才能够给它传值</span></span><br><span class="line">-&gt; coroutine received: <span class="number">42</span></span><br><span class="line">Traceback (most recent call last): <span class="comment"># ➏</span></span><br><span class="line">...</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>协和在 yield 关键字所在的位置暂停执行</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311816737.png"></p>
<p>使用协程重新设计平均值计算器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">averager</span>():</span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 永远不会停止，可以无限计算平均值</span></span><br><span class="line">        term = <span class="keyword">yield</span> average <span class="comment"># 等待外部传入值，外部每传一次，就计算一次总体平均值</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 以下是使用示例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager() <span class="comment"># 创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(coro_avg) <span class="comment"># 激活</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>) <span class="comment"># 传值</span></span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">5</span>)</span><br><span class="line"><span class="number">15.0</span></span><br></pre></td></tr></table></figure>

<p>使用协程时，经常容易忘记要先激活它。为了避免这种错误，可考虑定义一个帮忙激活的装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coroutine</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义一个装饰器：帮忙预激`func`&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">primer</span>(<span class="params">*args,**kwargs</span>): ➊</span><br><span class="line">        gen = func(*args,**kwargs) ➋</span><br><span class="line">        <span class="built_in">next</span>(gen) <span class="comment"># 激活</span></span><br><span class="line">        <span class="keyword">return</span> gen ➍</span><br><span class="line">    <span class="keyword">return</span> primer</span><br></pre></td></tr></table></figure>

<p>在调用生成器的 send 函数时，如果给它传递的参数类型有误，会导致它抛出异常，从而终止协程；</p>
<p>生成器有一个 throw 方法可用于触发异常；如果生成器内部有处理异常的代码，则执行；如果没有，则冒泡；</p>
<p>生成器还有一个 close 方法可用于抛出 exit 异常</p>
<h2 id="yield-from-1"><a href="#yield-from-1" class="headerlink" title="yield from"></a>yield from</h2><p>yield from 带来了双向通讯机制，貌似可用来实现异步编程；先定义生成器，然后激活它；之后向它发送数据；当数据处理完成后，会触发异常，获得处理结果；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">&#x27;Result&#x27;</span>, <span class="string">&#x27;count average&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">averager</span>(): </span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> <span class="comment"># 感觉此处有点像是一个点位符，等待外部传值进来，或许应该叫 await</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 当外部传 None 进来时，就中断退出循环</span></span><br><span class="line">        	<span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average) <span class="comment"># 中断循环后，返回计算结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 委托生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grouper</span>(<span class="params">results, key</span>):</span><br><span class="line">    <span class="comment"># 这里为什么要循环？</span></span><br><span class="line">    <span class="comment"># 答：为了不断接收外面传进来的值</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">        <span class="comment"># 关键字 yield from 默认会让当前函数返回一个生成器，可惜这个关键字很不直观</span></span><br><span class="line">        <span class="comment"># send 传进来的值，会通过传入 averager，yield from 有点像管道的作用</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()  <span class="comment"># 这里的 yield from 很像 await</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 客户端（调用方）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">data</span>):</span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key) <span class="comment"># grouper 返回生成器</span></span><br><span class="line">        <span class="built_in">next</span>(group) <span class="comment"># 预激活 # 激活后，开始进入 while 循环，在 yield from 处暂停</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value) <span class="comment"># send 将值传给 averager，开始与内部的子生成器通讯</span></span><br><span class="line">        group.send(<span class="literal">None</span>) <span class="comment"># 传入None，中断子生成器，让委托生成器获得结果</span></span><br><span class="line">    <span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure>

<p>yield from 跟 await 有一个很大的不同，即 yield from 在将工作做到一半后，将控制权还给调用者，由调用者做剩下的工作；</p>
<blockquote>
<p>据说  python 后来引入了 await</p>
</blockquote>
<h1 id="第19章-并发模型"><a href="#第19章-并发模型" class="headerlink" title="第19章 并发模型"></a>第19章 并发模型</h1><p>协程: coroutine，一个可以暂停并重新运行自己的函数；</p>
<p>协程的特点在于可以通过关键字，标识出异步的位置，然后交出控制权，让主程序的其他部分获得控制权；自己则进入队列，等待异步的代码执行完毕；改变自己状态，等待被唤醒，继续运行自己余下部分的代码；</p>
<blockquote>
<p>没想到 Python 有一个全局锁（GIL），每次只允许一个线程占有，那这就意味着 python 无法同时利用多核的优势好像，除非起多个进程，就像 js 的 cluster 一样；</p>
<p>Python 解释器每隔一定的时间（貌似是 5ms），会释放 GIL，以便其他线程能够获取锁；另外，任意一个函数在调用 syscall 时，它都会释放 GIL；</p>
</blockquote>
<blockquote>
<p>书里面的 spinner 案例，看起来很奇怪，因为协程的结束，竟然是由调用者的代码发起的，跟 js 好像不太一样；但是 await 貌似是一样的；</p>
<p>后来发现，协程也可以自己结束，不需要外部让它结束；书上的案例只是示范说可以主动干预。但其实正常使用场景是不干预，让它自行运行结束，返回结果；</p>
<p>问：好奇有无可能用装饰器，将非协程的代码，包装成协程代码？答：想了一下，虽然可能，但是由于非协程代码里面，在遇到 I&#x2F;O 任务时，没有使用 await 交出控制权，该协程貌似可能会卡在那里等待；</p>
<p>协程能够起作用，貌似重点在于每次遇到 I&#x2F;O 任务时，要主动交出控制权；在 js 里，很多库都是默认异步编写的，因此不容易忘记这个事情。但是在 python 里面，很多库并非天生异步，例如常用的 requests，此时很有必要提高警惕；</p>
<p>当协程获得控制权，处于运行中的状态时，它是无法被取消的。因为只有一个线程，当它在运行时，意味着想要取消它的代码并没有在运行；仅当协程位于队列中，处于等待状态时，才有可能被取消；此时取消它的代码有可能获得了控制权；</p>
</blockquote>
<p>asyncio.run() 函数，做为所有协程运行代码的入口；</p>
<p>asyncio.create_task()，在当前协程中，创建一个新的协程；可基于返回的 task 对象，对新建的协程进行控制；</p>
<p>await coro()，调用 coro，并同步等待它返回结果；</p>
<p>调用 coro() 时，并不意味着 coro 的代码会马上执行，而只是表示将它加入了队列，实际的执行时间取决于事件循环的高度器；</p>
<p>跟 js 一样，await 关键字必须用在 async 定义的函数中；当函数用 async 定义时，它是一个协程；每次对该函数的调用，都是都它加入事件循环的队列中；而 await 表示交给当前协程对 CPU 的使用，即停止运行，让调度器去运行其他协程；等 await 的事件结束时，调度器会重新安排它运行；</p>
<h2 id="GIL-的真实影响"><a href="#GIL-的真实影响" class="headerlink" title="GIL 的真实影响"></a>GIL 的真实影响</h2><p>各种处理网络请示的库，如 requests，在发起请示后，会释放当前线程的 GIL，以便其他线程可以抢占；但如果只有一个线程，那么抢占并没有意义。仅在多线程时，抢占才有意义；而且即使抢占成功，后续 requests 仍然会再次被分配 GIL，但此时它有可能仍然还没有取得响应，因此会浪费掉一些性能；但总的来说，多线程有助于提高 I&#x2F;O 的并发处理能力；但不适用于 CPU 密集型的任务，性能反而变差，因为 CPU 不断在多个线程之间切换，但每次只运行一个线程，最终的性能还不如顺序执行来得快；</p>
<p>另外还有一些库的设计是异步的，但如果当前的代码不是 async 的话，貌似也无法使用 await 来交出控制权？</p>
<blockquote>
<p>当处理计算密集型任务，因为 GIL 的存在，多线程是没有意义的，因为每次只有一个线程在工作；反而不如使用单线程来得简单和高效；如果有多核，则可以考虑使用多进程模式来提高效率；</p>
</blockquote>
<h1 id="第20章-Concurrent-Executors"><a href="#第20章-Concurrent-Executors" class="headerlink" title="第20章 Concurrent Executors"></a>第20章 Concurrent Executors</h1><p>concurrent.futures 库里面，有两个类，分别是 ThreadPoolExecutor 和 ProcessPoolExecutor，它们可以很方便的使用线程或者进程来实现并发；</p>
<p>对使用者来说，背后的线程或进程是透明的，它会自动开启多线程或进程，同时创建任务队列，收集各线程的处理结果；</p>
<p>Python 里面的 futures 有点像 js 里面的 promise；但 futures 一般不直接创建，而是交由框架来创建；开发者可以在更高的抽象维度来使用它，这样可以避免错误使用；</p>
<p>future.done() 方法可用来查询是否计算完成了，但更常见的做法是不查询，而是等待通知，即完成后，调用回调函数即可；</p>
<p>future 有个 add_done_callback 方法，它接受一个回调函数做为参数；注意：该回调函数，将在运行该 future 的线程或进程中直接运行；</p>
<p>future.result() 方法可用于获取计算结果；但 concurrency 和 asyncio 两个库对方法的实现有所不同；concurrency 调用 result 方法时，会造成堵塞，等待结果的返回；同时支持 timeout 参数，超时未返回时，会抛出异常；asyncio 则不支持 timeout 方法，但支持 await 关键字，这样不会造成堵塞；</p>
<p>concurrency 还有一个 as_completed 方法，专门用来读取 result，以避免堵塞，</p>
<p>executor.map() 主要用于一个函数，并发处理多个不同的参数</p>
<p>executor.submit() 则更灵活一些，多个不同的函数，并处理各自不同的参数；最后通过 as_completed 方法收集计算结果；</p>
<h1 id="第21章-异步编程"><a href="#第21章-异步编程" class="headerlink" title="第21章 异步编程"></a>第21章 异步编程</h1><blockquote>
<p>虽然可以通过 async def 来定义异步函数，但是如果函数体中包含一些非异步的操作，比如将文件写入本地，貌似该同步操作有可能会造成堵塞，占用整个线程，直到写入成功？经查证，发现确实如此，在异步函数中，只要有任意一个</p>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>海象符 :&#x3D;，为了省写一行代码，先检查，确认有值后，再赋值；没值的话，就不赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有海象符的时候</span></span><br><span class="line">name = abc.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name:</span><br><span class="line">    <span class="comment"># doA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># doB</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 有海象符后</span></span><br><span class="line"><span class="keyword">if</span> name := abc.get(<span class="string">&quot;name&quot;</span>):</span><br><span class="line">    <span class="comment"># doA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># doB</span></span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/07/25/%E6%B5%81%E7%95%85%E7%9A%84Python/" data-id="cm1c2i81l005rpkhp56ifct2w" data-title="流畅的Python" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/12/js%20%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          js多重继承
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dart/" rel="tag">Dart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kubernetes/" rel="tag">Kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/" rel="tag">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93/" rel="tag">渲染</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%86%E5%90%91/" rel="tag">逆向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">项目管理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 11.43px;">C</a> <a href="/tags/C/" style="font-size: 11.43px;">C++</a> <a href="/tags/Dart/" style="font-size: 10px;">Dart</a> <a href="/tags/Kubernetes/" style="font-size: 10px;">Kubernetes</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/javascript/" style="font-size: 18.57px;">javascript</a> <a href="/tags/kubernetes/" style="font-size: 12.86px;">kubernetes</a> <a href="/tags/python/" style="font-size: 15.71px;">python</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 10px;">图像处理</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 14.29px;">安全</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 12.86px;">微信</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 11.43px;">数据库</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 17.14px;">服务器</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 11.43px;">深度学习</a> <a href="/tags/%E6%B8%B2%E6%9F%93/" style="font-size: 10px;">渲染</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 12.86px;">设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 20px;">软件</a> <a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 10px;">逆向</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 10px;">项目管理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/21/%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/">渲染原理</a>
          </li>
        
          <li>
            <a href="/2024/06/22/VirtualDom%20%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/">VirtualDOM 简易实现</a>
          </li>
        
          <li>
            <a href="/2023/08/19/Vue3/">Vue3</a>
          </li>
        
          <li>
            <a href="/2023/08/18/Vue%20Router%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">Vue Router 基本用法</a>
          </li>
        
          <li>
            <a href="/2023/08/04/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/">Linux 文件权限</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 ccw<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>