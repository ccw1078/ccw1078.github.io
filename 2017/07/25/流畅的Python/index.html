

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ccw">
  <meta name="keywords" content="">
  
    <meta name="description" content="第1章  Python 数据结构 一摞 Python 风格的纸牌 123456789101112131415import collectionsCard &#x3D; collections.namedtuple(&#x27;Card&#x27;, [&#x27;rank&#x27;, &#x27;suit&#x27;])class FrenchDeck:    ranks &#x3D; [str(n) for n">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的Python">
<meta property="og:url" content="https://ccw1078.github.io/2017/07/25/%E6%B5%81%E7%95%85%E7%9A%84Python/index.html">
<meta property="og:site_name" content="Ccw&#39;s Blogs">
<meta property="og:description" content="第1章  Python 数据结构 一摞 Python 风格的纸牌 123456789101112131415import collectionsCard &#x3D; collections.namedtuple(&#x27;Card&#x27;, [&#x27;rank&#x27;, &#x27;suit&#x27;])class FrenchDeck:    ranks &#x3D; [str(n) for n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261657707.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261807612.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281058984.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281059641.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281059545.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281109644.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261020586.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261039412.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261045205.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261110944.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261114146.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407282027810.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407301247891.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311445182.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311446562.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311447657.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311447765.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311454347.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311501287.png">
<meta property="og:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311816737.png">
<meta property="article:published_time" content="2017-07-25T10:34:00.000Z">
<meta property="article:modified_time" content="2024-09-27T06:16:29.574Z">
<meta property="article:author" content="ccw">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261657707.png">
  
  
  
  <title>流畅的Python - Ccw&#39;s Blogs</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"ccw1078.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Ccw's Blogs" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="流畅的Python"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2017-07-25 18:34" pubdate>
          2017年7月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          133 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">流畅的Python</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="%E7%AC%AC1%E7%AB%A0-python-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" tabindex="-1">第1章  Python 数据结构</h1>
<h2 id="%E4%B8%80%E6%91%9E-python-%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%BA%B8%E7%89%8C" tabindex="-1" id="一摞-Python-风格的纸牌">一摞 Python 风格的纸牌</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br>Card = collections.namedtuple(<span class="hljs-string">&#x27;Card&#x27;</span>, [<span class="hljs-string">&#x27;rank&#x27;</span>, <span class="hljs-string">&#x27;suit&#x27;</span>])<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FrenchDeck</span>:<br>    ranks = [<span class="hljs-built_in">str</span>(n) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>)] + <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;JQKA&#x27;</span>)<br>    suits = <span class="hljs-string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-variable language_">self</span>._cards = [Card(rank, suit) <span class="hljs-keyword">for</span> suit <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.suits<br>    					<span class="hljs-keyword">for</span> rank <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.ranks]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>._cards)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, position</span>):<br>    	<span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._cards[position]<br></code></pre></td></tr></table></figure>
<p>上面这个代码示例惊艳到我了，让我对 Python 的类刮目相看；此刻我才开始开始意识到内置方法的存在；</p>
<p>例如它仅仅因为实现了 _<em>len_</em> 和 _<em>getitem_</em> 两个特殊方法，便使得这个类能够自动使用 Python 的内置函数，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 len 函数获得数量</span><br> deck = FrenchDeck()<br> <span class="hljs-built_in">len</span>(deck)<br><br><span class="hljs-comment"># 使用索引访问列表中的元素</span><br>deck[<span class="hljs-number">0</span>]<br>deck[-<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 使用内置的标准库，例如 random，从列表中随机读取元素</span><br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br>choice(deck)<br><br><span class="hljs-comment"># 自动支持切片操作</span><br>deck[:<span class="hljs-number">3</span>]<br>deck[<span class="hljs-number">12</span>::<span class="hljs-number">13</span>]<br><br><span class="hljs-comment"># 自动可迭代</span><br><span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> deck:<br>    <span class="hljs-built_in">print</span>(card)<br>   <br><span class="hljs-comment"># 自动支持 in 运算符</span><br>Card(<span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;hearts&quot;</span>) <span class="hljs-keyword">in</span> deck<br><br><span class="hljs-comment"># 只需定义排序规则，即可自动支持内置的 sorted 排序函数</span><br>suit_values = <span class="hljs-built_in">dict</span>(spades=<span class="hljs-number">3</span>, hearts=<span class="hljs-number">2</span>, diamonds=<span class="hljs-number">1</span>, clubs=<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spades_high</span>(<span class="hljs-params">card</span>):<br>    rank_value = FrenchDeck.rands.index(card.rand)<br>    <span class="hljs-keyword">return</span> rank_value * <span class="hljs-built_in">len</span>(suit_values) + suite_values[card.suit]<br><br><span class="hljs-keyword">for</span> card <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(deck, key = spades_high):<br>    <span class="hljs-built_in">print</span>(card)<br></code></pre></td></tr></table></figure>
<h2 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95" tabindex="-1" id="如何使用特殊方法">如何使用特殊方法</h2>
<p>特殊方法是为了给解释器调用，从而实现一些内置的功能，而不是为了自己调用；如果是自己调用，那么只需写普通方法即可，无须写特殊方法；</p>
<p>另外，也尽量避免随意添加特殊方法，因为有可能出解释器内置的方法出现命名冲突，导致发生不可预知的情况；</p>
<p>特殊方法还可以用来重载运算符，例如转成字符串，加号，乘号，取绝对值等，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> hypot<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span></span>):<br>        <span class="hljs-variable language_">self</span>.x = x<br>        <span class="hljs-variable language_">self</span>.y = y<br>    <br>     <span class="hljs-comment"># repr 用来定义对象用字符串如何显示，另外还有一个 str 用来给 str() 或者 print 函数调用</span><br>     <span class="hljs-comment"># 通常定义 repr 即可，它更加通用</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Vector(%r, %r)&#x27;</span> % (<span class="hljs-variable language_">self</span>.x, <span class="hljs-variable language_">self</span>.y)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__abs__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 重载了 abs 函数</span><br>        <span class="hljs-keyword">return</span> hypot(<span class="hljs-variable language_">self</span>.x, <span class="hljs-variable language_">self</span>.y)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 当调用 bool 函数时，如何判断对象是否为真</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(<span class="hljs-variable language_">self</span>.x <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.y)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>): <span class="hljs-comment"># 重载了加号</span><br>        x = <span class="hljs-variable language_">self</span>.x + other.x<br>        y = <span class="hljs-variable language_">self</span>.y + other.y<br>        <span class="hljs-keyword">return</span> Vector(x, y)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__mul__</span>(<span class="hljs-params">self, scalar</span>):  <span class="hljs-comment"># 重载了乘号</span><br>        <span class="hljs-keyword">return</span> Vector(<span class="hljs-variable language_">self</span>.x * scalar, <span class="hljs-variable language_">self</span>.y * scalar)<br>    <br></code></pre></td></tr></table></figure>
<h2 id="%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88" tabindex="-1" id="特殊方法一览">特殊方法一览</h2>
<p>特殊方法挺多的，有80 多个，其中有 40 个多用于实现算术运算、位运算和比较操作；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261657707.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88-len-%E4%B8%8D%E6%98%AF%E6%99%AE%E9%80%9A-%E6%96%B9%E6%B3%95" tabindex="-1" id="为什么-len-不是普通-方法">为什么 len 不是普通 方法</h2>
<p>len 的目的是为了读取对象的长度，对于内置类型的对象，它们是用 C 语言的 struct 表示的，struct 里面有个属性存储着长度值，因此在这种情况下，len  会直接去读取 struct 的长度值，而不是调用 _<em>len</em>_ 来计算长度；主要是出于性能考量</p>
<h2 id="%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93" tabindex="-1" id="本章小结">本章小结</h2>
<p>通过实现特殊方法，能够让自定义类型表现跟内置类型一样，从而能够直接使用 Python 的很多内置函数，让代码更容易阅读；</p>
<h1 id="%E7%AC%AC2%E7%AB%A0-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84" tabindex="-1">第2章 序列构成的数组</h1>
<h2 id="%E5%86%85%E7%BD%AE%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B" tabindex="-1" id="内置序列类型">内置序列类型</h2>
<p>Python 有两种序列类型，一种存放的是对象的引用，因此它可以容纳任何类型，称为容器序列；一种存放值，而不是引用，因此只能放相同类型的值，称为扁平序列；</p>
<p>序列按照能否修改，可分为可变序列和不可变序列</p>
<ul>
<li>可变序列（Mutable Sequence）：list, bytearray, array.array, collections.deque, memoryview</li>
<li>不可变序列（Sequence）：tuple, str, bytes</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261807612.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F" tabindex="-1" id="列表推导和生成器表达式">列表推导和生成器表达式</h2>
<p>列表推导式（list comprehension）非常适合用来创建新的列表，这种写法更容易读懂；如果列表推导太长，则可以改用传统的 for 循环；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>sizes = [<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>tshirts = [(color, size) <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> colors <span class="hljs-keyword">for</span> size <span class="hljs-keyword">in</span> sizes]<br><span class="hljs-meta">&gt;&gt;&gt; </span>tshirts<br>[(<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>), (<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>), (<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>), (<span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>),<br>(<span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>), (<span class="hljs-string">&#x27;white&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>)]<br></code></pre></td></tr></table></figure>
<p>生成器表达式用来其他类型的序列；生成器表达式使用圆括号，而不是方括号；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>symbols = <span class="hljs-string">&#x27;$¢£¥€¤&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">ord</span>(symbol) <span class="hljs-keyword">for</span> symbol <span class="hljs-keyword">in</span> symbols) <span class="hljs-comment"># 由于生成器表达式是函数的唯一参数，所以无需用括号括起来</span><br>(<span class="hljs-number">36</span>, <span class="hljs-number">162</span>, <span class="hljs-number">163</span>, <span class="hljs-number">165</span>, <span class="hljs-number">8364</span>, <span class="hljs-number">164</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> array<br><span class="hljs-meta">&gt;&gt;&gt; </span>array.array(<span class="hljs-string">&#x27;I&#x27;</span>, (<span class="hljs-built_in">ord</span>(symbol) <span class="hljs-keyword">for</span> symbol <span class="hljs-keyword">in</span> symbols)) <span class="hljs-comment"># 非唯一参数，所以多加了一层括号</span><br>array(<span class="hljs-string">&#x27;I&#x27;</span>, [<span class="hljs-number">36</span>, <span class="hljs-number">162</span>, <span class="hljs-number">163</span>, <span class="hljs-number">165</span>, <span class="hljs-number">8364</span>, <span class="hljs-number">164</span>])<br></code></pre></td></tr></table></figure>
<p>生成器表达式每次产生一个运算结果，而不是一下生成整个列表，这样可以节省内存，尤其是元素多的时候，非常明显</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors = [<span class="hljs-string">&#x27;black&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>sizes = [<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> tshirt <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;%s %s&#x27;</span> % (c, s) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> colors <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> sizes): <span class="hljs-comment"># 一次只生成一个计算结果，而非整个列表</span><br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(tshirt)<br>...<br>black S<br>black M<br>black L<br>white S<br>white M<br>white L<br></code></pre></td></tr></table></figure>
<h2 id="%E5%85%83%E7%BB%84%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%E5%88%97%E8%A1%A8" tabindex="-1" id="元组不仅仅是不可变的列表">元组不仅仅是不可变的列表</h2>
<p>元组是不可变列表，但其实它存放的数据，也可以基于顺序来表达不同的含义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">traveler_ids = [(<span class="hljs-string">&#x27;USA&#x27;</span>, <span class="hljs-string">&#x27;31195855&#x27;</span>), (<span class="hljs-string">&#x27;BRA&#x27;</span>, <span class="hljs-string">&#x27;CE342567&#x27;</span>), (<span class="hljs-string">&#x27;ESP&#x27;</span>, <span class="hljs-string">&#x27;XDA205856&#x27;</span>)]<br><span class="hljs-comment"># 位置1是国家，位置2是代号</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>lax_coordinates = (<span class="hljs-number">33.9425</span>, -<span class="hljs-number">118.408056</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>latitude, longitude = lax_coordinates <span class="hljs-comment"># 元组拆包</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b, a = a, b<br><span class="hljs-comment"># 使用拆包，实现变量的值交换</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">divmod</span>(<span class="hljs-number">20</span>, <span class="hljs-number">8</span>)<br>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">20</span>, <span class="hljs-number">8</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">divmod</span>(*t) <span class="hljs-comment"># 星号 * 可用来将元组拆包成函数的函数</span><br></code></pre></td></tr></table></figure>
<p>星号* 可用来存放拆包的余下元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 星号 * 用来存放剩余元素</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, rest<br>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) <br><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, rest<br>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, [<span class="hljs-number">2</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, rest<br>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, [])<br><br><span class="hljs-comment"># 放在中间的位置也可以</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a, *body, c, d = <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a, body, c, d<br>(<span class="hljs-number">0</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><br><span class="hljs-comment"># 放在开头的位置也可以</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>*head, b, c, d = <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>head, b, c, d<br>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>
<h3 id="%E5%B5%8C%E5%A5%97%E5%85%83%E7%BB%84%E6%8B%86%E5%8C%85" tabindex="-1" id="嵌套元组拆包">嵌套元组拆包</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">metro_areas = [<br>    (<span class="hljs-string">&#x27;Tokyo&#x27;</span>,<span class="hljs-string">&#x27;JP&#x27;</span>,<span class="hljs-number">36.933</span>,(<span class="hljs-number">35.689722</span>,<span class="hljs-number">139.691667</span>)), <span class="hljs-comment"># 嵌套的元组</span><br>    (<span class="hljs-string">&#x27;Delhi NCR&#x27;</span>, <span class="hljs-string">&#x27;IN&#x27;</span>, <span class="hljs-number">21.935</span>, (<span class="hljs-number">28.613889</span>, <span class="hljs-number">77.208889</span>)),<br>    (<span class="hljs-string">&#x27;Mexico City&#x27;</span>, <span class="hljs-string">&#x27;MX&#x27;</span>, <span class="hljs-number">20.142</span>, (<span class="hljs-number">19.433333</span>, -<span class="hljs-number">99.133333</span>)),<br>    (<span class="hljs-string">&#x27;New York-Newark&#x27;</span>, <span class="hljs-string">&#x27;US&#x27;</span>, <span class="hljs-number">20.104</span>, (<span class="hljs-number">40.808611</span>, -<span class="hljs-number">74.020386</span>)),<br>    (<span class="hljs-string">&#x27;Sao Paulo&#x27;</span>, <span class="hljs-string">&#x27;BR&#x27;</span>, <span class="hljs-number">19.649</span>, (-<span class="hljs-number">23.547778</span>, -<span class="hljs-number">46.635833</span>)),<br>]<br><br><span class="hljs-keyword">for</span> name, cc, pop, (latitude, longitude) <span class="hljs-keyword">in</span> metro_areas: <span class="hljs-comment"># 嵌套拆包</span><br>    <span class="hljs-keyword">if</span> longitude &lt;= <span class="hljs-number">0</span>: <br>    	<span class="hljs-built_in">print</span>(fmt.<span class="hljs-built_in">format</span>(name, latitude, longitude))<br></code></pre></td></tr></table></figure>
<h3 id="%E5%85%B7%E5%90%8D%E5%85%83%E7%BB%84" tabindex="-1" id="具名元组">具名元组</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><span class="hljs-meta">&gt;&gt;&gt; </span>City = namedtuple(<span class="hljs-string">&#x27;City&#x27;</span>, <span class="hljs-string">&#x27;name country population coordinates&#x27;</span>) <span class="hljs-comment"># 定义元组结构</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>tokyo = City(<span class="hljs-string">&#x27;Tokyo&#x27;</span>, <span class="hljs-string">&#x27;JP&#x27;</span>, <span class="hljs-number">36.933</span>, (<span class="hljs-number">35.689722</span>, <span class="hljs-number">139.691667</span>)) <span class="hljs-comment"># 赋值</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>tokyo<br>City(name=<span class="hljs-string">&#x27;Tokyo&#x27;</span>, country=<span class="hljs-string">&#x27;JP&#x27;</span>, population=<span class="hljs-number">36.933</span>, coordinates=(<span class="hljs-number">35.689722</span>,<br><span class="hljs-number">139.691667</span>)) <span class="hljs-comment"># 各个</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>tokyo.population ➌<br><span class="hljs-number">36.933</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>tokyo.coordinates<br>(<span class="hljs-number">35.689722</span>, <span class="hljs-number">139.691667</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>tokyo[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;JP&#x27;</span><br></code></pre></td></tr></table></figure>
<p>具名元组有一些内置的属性和方法，包括：</p>
<ul>
<li>_fields 属性，用来查看所有字段的名称</li>
<li>_make() 方法，用来创建实例</li>
<li>_asdict() 方法，用来返回 OrderDict</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>City._fields <br>(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;country&#x27;</span>, <span class="hljs-string">&#x27;population&#x27;</span>, <span class="hljs-string">&#x27;coordinates&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>LatLong = namedtuple(<span class="hljs-string">&#x27;LatLong&#x27;</span>, <span class="hljs-string">&#x27;lat long&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>delhi_data = (<span class="hljs-string">&#x27;Delhi NCR&#x27;</span>, <span class="hljs-string">&#x27;IN&#x27;</span>, <span class="hljs-number">21.935</span>, LatLong(<span class="hljs-number">28.613889</span>, <span class="hljs-number">77.208889</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>delhi = City._make(delhi_data) <br><span class="hljs-meta">&gt;&gt;&gt; </span>delhi._asdict() <br>OrderedDict([(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Delhi NCR&#x27;</span>), (<span class="hljs-string">&#x27;country&#x27;</span>, <span class="hljs-string">&#x27;IN&#x27;</span>), (<span class="hljs-string">&#x27;population&#x27;</span>, <span class="hljs-number">21.935</span>), (<span class="hljs-string">&#x27;coordinates&#x27;</span>, LatLong(lat=<span class="hljs-number">28.613889</span>, long=<span class="hljs-number">77.208889</span>))])<br></code></pre></td></tr></table></figure>
<p>相对列表，元组没有添加和删除元素的方法，其他方法则都差不多；</p>
<h2 id="%E5%88%87%E7%89%87" tabindex="-1" id="切片">切片</h2>
<p>切片有个特殊的用法，即 s[a : b : c]，它表示在 a ~ b 的区间内，以 c 为间隔取值；即  s[start : stop : step]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">&#x27;bicycle&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s[::<span class="hljs-number">3</span>] <span class="hljs-comment"># 正序，间隔 3 取值</span><br><span class="hljs-string">&#x27;bye&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s[::-<span class="hljs-number">1</span>] <span class="hljs-comment"># 倒序，间隔 1 取值</span><br><span class="hljs-string">&#x27;elcycib&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s[::-<span class="hljs-number">2</span>]  <span class="hljs-comment"># 倒序，间隔 2 取值</span><br><span class="hljs-string">&#x27;eccb&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>deck[<span class="hljs-number">12</span>::<span class="hljs-number">13</span>] <span class="hljs-comment"># 正序，从 12 开始，间隔 13 取值，</span><br></code></pre></td></tr></table></figure>
<p>切片有个很有意思的用法，它可以让代码更易读</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>SKU = <span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>DESCRIPTION = <span class="hljs-built_in">slice</span>(<span class="hljs-number">6</span>, <span class="hljs-number">40</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>UNIT_PRICE = <span class="hljs-built_in">slice</span>(<span class="hljs-number">40</span>, <span class="hljs-number">52</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>QUANTITY = <span class="hljs-built_in">slice</span>(<span class="hljs-number">52</span>, <span class="hljs-number">55</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>ITEM_TOTAL = <span class="hljs-built_in">slice</span>(<span class="hljs-number">55</span>, <span class="hljs-literal">None</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> line_items:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(item[UNIT_PRICE], item[DESCRIPTION]) <span class="hljs-comment"># 此处的 UNIT_PRICE 也可硬编码，但这样写更优雅</span><br>...<br>$<span class="hljs-number">17.50</span> Pimoroni PiBrella<br>$<span class="hljs-number">4.95</span> 6mm Tactile Switch x20<br>$<span class="hljs-number">28.00</span> Panavise Jr. - PV-<span class="hljs-number">201</span><br>$<span class="hljs-number">34.95</span> PiTFT Mini Kit 320x240<br></code></pre></td></tr></table></figure>
<p>切片也可用来赋值，或者删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>l = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] = [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>] <span class="hljs-comment"># 赋值</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> l[<span class="hljs-number">5</span>:<span class="hljs-number">7</span>] <span class="hljs-comment"># 删除</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l[<span class="hljs-number">3</span>::<span class="hljs-number">2</span>] = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>] <span class="hljs-comment"># 赋值</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>, <span class="hljs-number">22</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] = <span class="hljs-number">100</span> <span class="hljs-comment"># 不可行，右侧需要是可迭代对象，不能是数值</span><br>Traceback (most recent call last):<br>File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: can only assign an iterable<br><span class="hljs-meta">&gt;&gt;&gt; </span>l[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] = [<span class="hljs-number">100</span>] <span class="hljs-comment"># 可行</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">22</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure>
<h2 id="%E5%AF%B9%E5%BA%8F%E5%88%97%E4%BD%BF%E7%94%A8-%2B-%E5%92%8C-*" tabindex="-1" id="对序列使用-和">对序列使用 + 和 *</h2>
<p>加号 + 用来表示将两个序列拼接起来，并返回一个新的序列；</p>
<p>乘号 * 表示重复多份序列并拼接起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l * <span class="hljs-number">5</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> * <span class="hljs-string">&#x27;abcd&#x27;</span><br><span class="hljs-string">&#x27;abcdabcdabcdabcdabcd&#x27;</span><br></code></pre></td></tr></table></figure>
<p>特别注意，在 [a] * n 这个表达式中，如果 a 是一个引用，那么复制出来的是 n 个引用，并且这 n 个引用实际上指向同一个对象；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 正确用法，使用列表推导式</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>board = [[<span class="hljs-string">&#x27;_&#x27;</span>] * <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>)] <br><span class="hljs-meta">&gt;&gt;&gt; </span>board<br>[[<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>], [<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>], [<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>board[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;X&#x27;</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>board<br>[[<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>], [<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>], [<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>]]<br><br><span class="hljs-comment"># 错误用法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>weird_board = [[<span class="hljs-string">&#x27;_&#x27;</span>] * <span class="hljs-number">3</span>] * <span class="hljs-number">3</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>weird_board<br>[[<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>], [<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>], [<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>]]<br><span class="hljs-meta">&gt;&gt;&gt; </span>weird_board[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;O&#x27;</span> <br><span class="hljs-meta">&gt;&gt;&gt; </span>weird_board<br>[[<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>], [<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>], [<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>]] <span class="hljs-comment"># 虽然有三个列表，但指向同一个对象</span><br></code></pre></td></tr></table></figure>
<h2 id="%E5%BA%8F%E5%88%97%E7%9A%84%E5%A2%9E%E9%87%8F%E8%B5%8B%E5%80%BC" tabindex="-1" id="序列的增量赋值">序列的增量赋值</h2>
<p>自增 += 或者自乘 *= 实际上调用的是 _<em>iadd</em>_  和  _<em>imul</em>_ 方法，如果一个类没有实际  iadd 方法，那么解释器就会调用 add 方法来计算，此时相当于 a = a + b，因此，如果 a + b 返回的是一个新的对象，那么 a 将指向该新的对象，而不是改变旧对象的值；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(l)<br><span class="hljs-number">4311953800</span> ➊<br><span class="hljs-meta">&gt;&gt;&gt; </span>l *= <span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">id</span>(l)<br><span class="hljs-number">4311953800</span> ➋<br></code></pre></td></tr></table></figure>
<p>元组是不可变的，当在元组里面放入一个可变序列时，会出现异常情况，即该可变序列可被改变，但是无法将改变后的新序列，赋值给元组的引用；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">30</span>, <span class="hljs-number">40</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>t[<span class="hljs-number">2</span>] += [<span class="hljs-number">50</span>, <span class="hljs-number">60</span>]<br>Traceback (most recent call last):<br>File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;tuple&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment <span class="hljs-comment"># 赋值给 t[2] 的时候报错了</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]) <span class="hljs-comment"># 成功改变了序列</span><br></code></pre></td></tr></table></figure>
<h2 id="list.sort-%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-sorted" tabindex="-1" id="list-sort-方法和内置函数-sorted">list.sort 方法和内置函数 sorted</h2>
<p>list.sort 会就地修改列表，返回 None</p>
<p>sorted 则不会修改原列表，而是会返回一个新的列表；</p>
<h2 id="%E7%94%A8-bisect-%E6%9D%A5%E7%AE%A1%E7%90%86%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%8F%E5%88%97" tabindex="-1" id="用-bisect-来管理已排序的序列">用 bisect 来管理已排序的序列</h2>
<p>bisect 用来从有序列表中查找某个值的插入位置，满足插入后原序列的顺序不变；</p>
<p>insort 用来将元素插入到有序列表中，插入后顺序保持不变；</p>
<h2 id="%E5%BD%93%E5%88%97%E8%A1%A8%E4%B8%8D%E6%98%AF%E9%A6%96%E9%80%89%E6%97%B6" tabindex="-1" id="当列表不是首选时">当列表不是首选时</h2>
<h3 id="%E6%95%B0%E7%BB%84" tabindex="-1" id="数组">数组</h3>
<p>array.array：数组里面存储的不是对象，而是字面值（例如数字，在内存中直接用字节表示即可）；因此它的读定性能要高很多；但因此它能够存储的类型也比较有限，只有少数几种；</p>
<p>创建数组时，需要通过参数指定类型，以便解释器能够决定如何分配内存空间；</p>
<h3 id="%E5%86%85%E5%AD%98%E8%A7%86%E5%9B%BE" tabindex="-1" id="内存视图">内存视图</h3>
<blockquote>
<p>memory view</p>
</blockquote>
<p>在不复制内容的情况下，操作数组的切片，例如 Numpy；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>numbers = array.array(<span class="hljs-string">&#x27;h&#x27;</span>, [-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>memv = <span class="hljs-built_in">memoryview</span>(numbers) <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(memv)<br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>memv[<span class="hljs-number">0</span>] <br>-<span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>memv_oct = memv.cast(<span class="hljs-string">&#x27;B&#x27;</span>) <br><span class="hljs-meta">&gt;&gt;&gt; </span>memv_oct.tolist() <br>[<span class="hljs-number">254</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>memv_oct[<span class="hljs-number">5</span>] = <span class="hljs-number">4</span> <span class="hljs-comment"># 此处的赋值，改变的是高位字节部分</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>numbers<br>array(<span class="hljs-string">&#x27;h&#x27;</span>, [-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])  <span class="hljs-comment"># 原本的 0，因为高位字节改变，变成了 1024</span><br></code></pre></td></tr></table></figure>
<h3 id="numpy-%E5%92%8C-scipy" tabindex="-1" id="Numpy-和-SciPy">Numpy 和 SciPy</h3>
<p>操作高阶数组和矩阵的利器；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> numpy ➊<br><span class="hljs-meta">&gt;&gt;&gt; </span>a = numpy.arange(<span class="hljs-number">12</span>) ➋<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>array([ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(a)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;numpy.ndarray&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.shape ➌<br>(<span class="hljs-number">12</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.shape = <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ➍<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>array([[ <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>[ <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>],<br>[ <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>]])<br></code></pre></td></tr></table></figure>
<h3 id="%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97%E5%92%8C%E5%85%B6%E4%BB%96%E5%BD%A2%E5%BC%8F%E7%9A%84%E9%98%9F%E5%88%97" tabindex="-1" id="双向队列和其他形式的队列">双向队列和其他形式的队列</h3>
<p>虽然可以用列表在模拟队列，但是性能并不好，尤其是在头部插入新元素时；双向队列更方便，而且可以指定长度，在超出长度时，会自动删除较早的内容；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq = deque(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>), maxlen=<span class="hljs-number">10</span>) ➊<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq.rotate(<span class="hljs-number">3</span>) <span class="hljs-comment"># 旋转，将最后3个元素，放到前面来</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq.rotate(-<span class="hljs-number">4</span>) <span class="hljs-comment"># 将头部 4 个元素，放到后面去</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>], maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq.appendleft(-<span class="hljs-number">1</span>) <span class="hljs-comment"># 添加到头部，会自动删除尾部溢出的部分</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq.extend([<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>]) <span class="hljs-comment"># 添加到尾部，会删除头部溢出的部分</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>], maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq.extendleft([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]) <span class="hljs-comment"># 逐一添加到头部，因此顺序会反过来</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([<span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>], maxlen=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>
<p>注：append 和 popleft 是原子操作，因此是线程安全的；</p>
<p>除了双向队列，还有以下几种队列，分别是：</p>
<ul>
<li>queue：如果队列满了，不会自动删除旧元素，而是会被锁住；因此可用来控制活跃线程的数量；</li>
<li>multiprocessing：用于进程间的通信</li>
<li>asyncio：用于异步编程</li>
<li>heapq：堆队列</li>
</ul>
<h1 id="%E7%AC%AC3%E7%AB%A0-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88" tabindex="-1">第3章 字典和集合</h1>
<h2 id="%E5%AD%97%E5%85%B8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" tabindex="-1" id="字典构造方法">字典构造方法</h2>
<blockquote>
<p>如果一个对象是可散列的，那么它的散列值需要不可变，而且这个对象需要实现 hash 和 eq 方法，以便可以计算散列值并和其他对象做比较；</p>
</blockquote>
<p>字典有很多种构造方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">dict</span>(one=<span class="hljs-number">1</span>, two=<span class="hljs-number">2</span>, three=<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = &#123;<span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>c = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>([<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = <span class="hljs-built_in">dict</span>([(<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-number">3</span>)])<br><span class="hljs-meta">&gt;&gt;&gt; </span>e = <span class="hljs-built_in">dict</span>(&#123;<span class="hljs-string">&#x27;three&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;one&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a == b == c == d == e<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<h2 id="%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC" tabindex="-1" id="字典推导">字典推导</h2>
<p>字典可以从任何以键值对作为元素的可迭代对象中构造出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>DIAL_CODES = [ ➊<br><span class="hljs-meta">... </span>(<span class="hljs-number">86</span>, <span class="hljs-string">&#x27;China&#x27;</span>),<br><span class="hljs-meta">... </span>(<span class="hljs-number">91</span>, <span class="hljs-string">&#x27;India&#x27;</span>),<br><span class="hljs-meta">... </span>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;United States&#x27;</span>),<br><span class="hljs-meta">... </span>(<span class="hljs-number">62</span>, <span class="hljs-string">&#x27;Indonesia&#x27;</span>),<br><span class="hljs-meta">... </span>(<span class="hljs-number">55</span>, <span class="hljs-string">&#x27;Brazil&#x27;</span>),<br><span class="hljs-meta">... </span>(<span class="hljs-number">92</span>, <span class="hljs-string">&#x27;Pakistan&#x27;</span>),<br><span class="hljs-meta">... </span>(<span class="hljs-number">880</span>, <span class="hljs-string">&#x27;Bangladesh&#x27;</span>),<br><span class="hljs-meta">... </span>(<span class="hljs-number">234</span>, <span class="hljs-string">&#x27;Nigeria&#x27;</span>),<br><span class="hljs-meta">... </span>(<span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Russia&#x27;</span>),<br><span class="hljs-meta">... </span>(<span class="hljs-number">81</span>, <span class="hljs-string">&#x27;Japan&#x27;</span>),<br><span class="hljs-meta">... </span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>country_code = &#123;country: code <span class="hljs-keyword">for</span> code, country <span class="hljs-keyword">in</span> DIAL_CODES&#125; <span class="hljs-comment"># 构造1 country : code</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>country_code<br>&#123;<span class="hljs-string">&#x27;China&#x27;</span>: <span class="hljs-number">86</span>, <span class="hljs-string">&#x27;India&#x27;</span>: <span class="hljs-number">91</span>, <span class="hljs-string">&#x27;Bangladesh&#x27;</span>: <span class="hljs-number">880</span>, <span class="hljs-string">&#x27;United States&#x27;</span>: <span class="hljs-number">1</span>,<br><span class="hljs-string">&#x27;Pakistan&#x27;</span>: <span class="hljs-number">92</span>, <span class="hljs-string">&#x27;Japan&#x27;</span>: <span class="hljs-number">81</span>, <span class="hljs-string">&#x27;Russia&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;Brazil&#x27;</span>: <span class="hljs-number">55</span>, <span class="hljs-string">&#x27;Nigeria&#x27;</span>:<br><span class="hljs-number">234</span>, <span class="hljs-string">&#x27;Indonesia&#x27;</span>: <span class="hljs-number">62</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;code: country.upper() <span class="hljs-keyword">for</span> country, code <span class="hljs-keyword">in</span> country_code.items() <span class="hljs-comment"># 构造2 code : country </span><br><span class="hljs-meta">... </span><span class="hljs-keyword">if</span> code &lt; <span class="hljs-number">66</span>&#125;<br>&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;UNITED STATES&#x27;</span>, <span class="hljs-number">55</span>: <span class="hljs-string">&#x27;BRAZIL&#x27;</span>, <span class="hljs-number">62</span>: <span class="hljs-string">&#x27;INDONESIA&#x27;</span>, <span class="hljs-number">7</span>: <span class="hljs-string">&#x27;RUSSIA&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="%E5%B8%B8%E8%A7%81%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E6%B3%95" tabindex="-1" id="常见的映射方法">常见的映射方法</h2>
<p>有个 setdefault 方法不常用，但其实很不错。它的用法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = &#123;<span class="hljs-string">&quot;abc&quot;</span>: <span class="hljs-number">123</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>b = a.setdefault(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">456</span>) <span class="hljs-comment"># 如果 abc 没值，则赋值456；如果有值，则返回值</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure>
<h2 id="%E6%98%A0%E5%B0%84%E7%9A%84%E5%BC%B9%E6%80%A7%E9%94%AE%E6%9F%A5%E8%AF%A2" tabindex="-1" id="映射的弹性键查询">映射的弹性键查询</h2>
<p>通常情况下，当我们使用 dict[key] 的方式访问时，如果该 key 不存在，会出现报错；而 collencts.defaultdict 可以处理这种情况；它会将该键为一个预先设定好的默认值，并返回该值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> collections<br>WORD_RE = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\w+&#x27;</span>)<br>index = collections.defaultdict(<span class="hljs-built_in">list</span>) <span class="hljs-comment"># list 代表默认的构造方法，如键不存在，则会调用该构造方法，构造默认值</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(sys.argv[<span class="hljs-number">1</span>], encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-keyword">for</span> line_no, line <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fp, <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> WORD_RE.finditer(line):<br>            word = <span class="hljs-keyword">match</span>.group()<br>            column_no = <span class="hljs-keyword">match</span>.start()+<span class="hljs-number">1</span><br>            location = (line_no, column_no)<br>            index[word].append(location)<br></code></pre></td></tr></table></figure>
<p>defaultdict 仅在  dict[key] 下有效，在 dict.get(key) 是无效的，后者不会调用预设的工作方法；defaultdict  背后的工作原理是因为实现了  _<em>missing</em>_ 方法；当 _<em>getitem</em>_ 找不到键名时，默认会调用 missing 方法；因此，只要有实现该方法，即可以实现默认值的初始化和返回；</p>
<p>考虑到 missing 会被调用，那么就可以在这里设置手脚；例如将键名由数值转换字符串，以支持不管传入哪种类型，都可以找到对应的键；</p>
<h2 id="%E5%AD%97%E5%85%B8%E7%9A%84%E5%8F%98%E7%A7%8D" tabindex="-1" id="字典的变种">字典的变种</h2>
<h3 id="collections.orderdict" tabindex="-1" id="collections-OrderDict">collections.OrderDict</h3>
<p>会记录每个键的添加顺序，然后可以删除最晚或者晚早添加的键；</p>
<h3 id="collections.chainmap" tabindex="-1" id="collections-ChainMap">collections.ChainMap</h3>
<p>ChainMap 会将多个 dict 组合成一个 chain，让它表现起来，像是一个 dict</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>baseline = &#123;<span class="hljs-string">&#x27;music&#x27;</span>: <span class="hljs-string">&#x27;bach&#x27;</span>, <span class="hljs-string">&#x27;art&#x27;</span>: <span class="hljs-string">&#x27;rembrandt&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>adjustments = &#123;<span class="hljs-string">&#x27;art&#x27;</span>: <span class="hljs-string">&#x27;van gogh&#x27;</span>, <span class="hljs-string">&#x27;opera&#x27;</span>: <span class="hljs-string">&#x27;carmen&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>cm = ChainMap(baseline, adjustments)<br><span class="hljs-meta">&gt;&gt;&gt; </span>cm<br>ChainMap(&#123;<span class="hljs-string">&#x27;music&#x27;</span>: <span class="hljs-string">&#x27;bach&#x27;</span>, <span class="hljs-string">&#x27;art&#x27;</span>: <span class="hljs-string">&#x27;rembrandt&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;art&#x27;</span>: <span class="hljs-string">&#x27;van gogh&#x27;</span>, <span class="hljs-string">&#x27;opera&#x27;</span>: <span class="hljs-string">&#x27;carmen&#x27;</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(cm)<br>[<span class="hljs-string">&#x27;art&#x27;</span>, <span class="hljs-string">&#x27;opera&#x27;</span>, <span class="hljs-string">&#x27;music&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>cm[<span class="hljs-string">&#x27;music&#x27;</span>]<br><span class="hljs-string">&#x27;bach&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cm[<span class="hljs-string">&#x27;art&#x27;</span>]<br><span class="hljs-string">&#x27;rembrandt&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cm.values()<br>ValuesView(ChainMap(&#123;<span class="hljs-string">&#x27;music&#x27;</span>: <span class="hljs-string">&#x27;bach&#x27;</span>, <span class="hljs-string">&#x27;art&#x27;</span>: <span class="hljs-string">&#x27;rembrandt&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;art&#x27;</span>: <span class="hljs-string">&#x27;van gogh&#x27;</span>, <span class="hljs-string">&#x27;opera&#x27;</span>: <span class="hljs-string">&#x27;carmen&#x27;</span>&#125;))<br></code></pre></td></tr></table></figure>
<h3 id="collections.counter" tabindex="-1" id="collections-Counter">collections.Counter</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>ct = collections.Counter(<span class="hljs-string">&#x27;abracadabra&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>ct<br>Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;r&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">1</span>&#125;)  <span class="hljs-comment"># 计算每个键的出现次数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>ct.update(<span class="hljs-string">&#x27;aaaaazzz&#x27;</span>) <span class="hljs-comment"># update 会递增键的出现次数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>ct<br>Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;r&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>ct.most_common(<span class="hljs-number">2</span>) <span class="hljs-comment"># 可以返回最常见的 n 个键，此处是最常见的 2 个键</span><br>[(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">10</span>), (<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">3</span>)]<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>cnt = Counter()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]:<br><span class="hljs-meta">&gt;&gt;&gt; </span>    cnt[word] += <span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cnt<br>Counter(&#123;<span class="hljs-string">&#x27;blue&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;red&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;green&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure>
<h3 id="collections.userdict" tabindex="-1" id="collections-UserDict">collections.UserDict</h3>
<p>用于让用户继承来编写子类，与 dict 的不同之处在于它是纯 Python 实现；而 dict 为了性能，某些功能的实现并不完全按照规范；</p>
<h2 id="%E5%AD%90%E7%B1%BB%E5%8C%96-userdict" tabindex="-1" id="子类化-UserDict">子类化 UserDict</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><br><span class="hljs-comment"># 实现 dict[key] 不管 key 是字符串还是数字，都可以正常访问</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrKeyDict</span>(collections.UserDict):<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__missing__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">raise</span> KeyError(key)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>[<span class="hljs-built_in">str</span>(key)]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__contains__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(key) <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.data<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, item</span>):<br>        <span class="hljs-variable language_">self</span>.data[<span class="hljs-built_in">str</span>(key)] = item<br></code></pre></td></tr></table></figure>
<p>一些好用的方法</p>
<p>update</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>td1 = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Zara&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">7</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>td2 = &#123;<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;female&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>td1.update(td2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>td1<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Zara&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;female&#x27;</span>&#125;<br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure>
<h2 id="%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B" tabindex="-1" id="不可变映射类型">不可变映射类型</h2>
<p>Python 的标准库并不支持不可变映射类型，但是有个变通的办法来实现相同的效果，即通过 MappingProxyType，从名字可以看得出来它是一个代理，这个代理是只读的；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MappingProxyType<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;A&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy = MappingProxyType(d) <span class="hljs-comment"># 创建一个代理</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy<br>mappingproxy(&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;A&#x27;</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy[<span class="hljs-number">1</span>] <span class="hljs-comment"># 代理是可以访问的</span><br><span class="hljs-string">&#x27;A&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-comment"># 但是不可以修改，会报错</span><br>Traceback (most recent call last):<br>File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;mappingproxy&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy <span class="hljs-comment"># 代理可以实时的看到 d 更新后的效果</span><br>mappingproxy(&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;B&#x27;</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy[<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;B&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="%E9%9B%86%E5%90%88%E8%AE%BA" tabindex="-1" id="集合论">集合论</h2>
<p>集合 set 是一些对象的集合，它可以用来去重；集合中的元素必须是可散列的；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>l = [<span class="hljs-string">&#x27;spam&#x27;</span>, <span class="hljs-string">&#x27;spam&#x27;</span>, <span class="hljs-string">&#x27;eggs&#x27;</span>, <span class="hljs-string">&#x27;spam&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">set</span>(l)<br>&#123;<span class="hljs-string">&#x27;eggs&#x27;</span>, <span class="hljs-string">&#x27;spam&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(l))<br>[<span class="hljs-string">&#x27;eggs&#x27;</span>, <span class="hljs-string">&#x27;spam&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p>集合有一些自己的运算符，以便计算合集、交集、差集等；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用 &amp; 符号求交集</span><br>found = <span class="hljs-built_in">len</span>(needles &amp; haystack)<br></code></pre></td></tr></table></figure>
<h3 id="%E9%9B%86%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F" tabindex="-1" id="集合字面量">集合字面量</h3>
<p>创建空集需要使用 set()， 而不是 { }，不然就变成了字典了；</p>
<p>s1 = {1, 2, 3}  的性能比 s2 = set([1, 2, ,3])，因为后者涉及先构造列表的动作；</p>
<h3 id="%E9%9B%86%E5%90%88%E6%8E%A8%E5%AF%BC" tabindex="-1" id="集合推导">集合推导</h3>
<p>集合推导和列表推导的唯一差别在于方括号 [ ] 还是花括号 { }</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> unicodedata <span class="hljs-keyword">import</span> name ➊<br><span class="hljs-meta">&gt;&gt;&gt; </span>&#123;<span class="hljs-built_in">chr</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>, <span class="hljs-number">256</span>) <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;SIGN&#x27;</span> <span class="hljs-keyword">in</span> name(<span class="hljs-built_in">chr</span>(i),<span class="hljs-string">&#x27;&#x27;</span>)&#125; ➋<br>&#123;<span class="hljs-string">&#x27;§&#x27;</span>, <span class="hljs-string">&#x27;=&#x27;</span>, <span class="hljs-string">&#x27;¢&#x27;</span>, <span class="hljs-string">&#x27;#&#x27;</span>, <span class="hljs-string">&#x27;¤&#x27;</span>, <span class="hljs-string">&#x27;&lt;&#x27;</span>, <span class="hljs-string">&#x27;¥&#x27;</span>, <span class="hljs-string">&#x27;μ&#x27;</span>, <span class="hljs-string">&#x27;×&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;¶&#x27;</span>, <span class="hljs-string">&#x27;£&#x27;</span>, <span class="hljs-string">&#x27;©&#x27;</span>,<br><span class="hljs-string">&#x27;°&#x27;</span>, <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;÷&#x27;</span>, <span class="hljs-string">&#x27;±&#x27;</span>, <span class="hljs-string">&#x27;&gt;&#x27;</span>, <span class="hljs-string">&#x27;¬&#x27;</span>, <span class="hljs-string">&#x27;®&#x27;</span>, <span class="hljs-string">&#x27;%&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="%E9%9B%86%E5%90%88%E7%9A%84%E6%93%8D%E4%BD%9C" tabindex="-1" id="集合的操作">集合的操作</h3>
<p>集合有不少专属的操作，这些操作很多是通过对运算符的重载来实现的；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281058984.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281059641.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281059545.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="dict-%E5%92%8C-set-%E8%83%8C%E5%90%8E" tabindex="-1" id="dict-和-set-背后">dict 和 set 背后</h2>
<p>dict 和 set 背后的实现原理是散列，这样性能就不会因为元素数量的增长出现大多波动；散列本质上是以空间换时间；列表则是以时间换空间；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281109644.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="dict-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%85%B6%E7%BB%93%E6%9E%9C" tabindex="-1" id="dict-的实现及其结果">dict 的实现及其结果</h3>
<blockquote>
<p>注：所有由用户自定义的对象，都是可散列的；因为它的散列值是由 id() 来生成的，跟对象本身的值没有关系。因此所有这些自定义对象，即使值相同，由于 id 不同，它们也是不相等的；</p>
</blockquote>
<p>相比列表，元组会比较节省空间；一方面是因为它无须重复存储键名，另一方面是它不需要用到散列；</p>
<p>应避免在迭代的过程中，对字典进行修改，它会给迭代带来扰乱，有可能导致出错，或者结果错乱；</p>
<p>字典 dict 是不可散列的，所以无法直接将 dict 添加到 set 中；</p>
<p>字典 dict 的键名顺序是有可能会变化的，例如当出现散列冲突时或者扩容时；</p>
<h1 id="%E7%AC%AC4%E7%AB%A0-%E6%96%87%E6%9C%AC%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97" tabindex="-1">第4章 文本和字节序列</h1>
<h2 id="%E5%AD%97%E7%AC%A6%E9%97%AE%E9%A2%98" tabindex="-1" id="字符问题">字符问题</h2>
<p>在 Python3，字符统一使用 Unicode 进行表示（称为码位），这样能够涵盖所有的已知字符，而且这个字符的 Unicode 也是固定的；但是在存储的时候，可以有多种编码方法（将码位转成字节序列），例如 UTF8, UTF16 等；使用不同的编码方法存储，就需要使用相应的解码方法读取，这样出来的结果才是正确的；</p>
<h2 id="%E5%AD%97%E8%8A%82%E6%A6%82%E8%A6%81" tabindex="-1" id="字节概要">字节概要</h2>
<p>在 Python3，有 bytes 和 bytearray 两种字节序列类型，其内部的元素是 0~255 的整数；</p>
<ul>
<li>bytes[0]，返回一个元素；</li>
<li>bytes[:1]，返回一个切片，即一段新的序列</li>
</ul>
<p>虽然二进制序列在底层是整数序列，但是显示的字面量有多种可能，包括：</p>
<ul>
<li>ASCII 字符</li>
<li>制表符、换行符、回车符、斜杠等特殊符号；</li>
<li>十六进制转义表示</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b&#x27;caf\xc3\xa9&#x27;</span>  <span class="hljs-comment"># caf 刚好可以用 Ascii  表示，后来两个只能用十六进制表示</span><br></code></pre></td></tr></table></figure>
<h2 id="%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8" tabindex="-1" id="基本的编解码器">基本的编解码器</h2>
<h2 id="%E4%BA%86%E8%A7%A3%E7%BC%96%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98" tabindex="-1" id="了解编解码问题">了解编解码问题</h2>
<h2 id="%E5%A4%84%E7%90%86%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6" tabindex="-1" id="处理文本文件">处理文本文件</h2>
<h2 id="%E4%B8%BA%E4%BA%86%E6%AD%A3%E7%A1%AE%E6%AF%94%E8%BE%83%E8%80%8C%E8%A7%84%E8%8C%83%E5%8C%96-unicode-%E5%AD%97%E7%AC%A6%E4%B8%B2" tabindex="-1" id="为了正确比较而规范化-Unicode-字符串">为了正确比较而规范化 Unicode 字符串</h2>
<h2 id="unicode-%E6%96%87%E6%9C%AC%E6%8E%92%E5%BA%8F" tabindex="-1" id="Unicode-文本排序">Unicode 文本排序</h2>
<h2 id="unicode-%E6%95%B0%E6%8D%AE%E5%BA%93" tabindex="-1" id="Unicode-数据库">Unicode 数据库</h2>
<h2 id="%E6%94%AF%E6%8C%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%E7%9A%84%E5%8F%8C%E6%A8%A1%E5%BC%8F-api" tabindex="-1" id="支持字符串和字节序列的双模式-API">支持字符串和字节序列的双模式 API</h2>
<h1 id="%E7%AC%AC5%E7%AB%A0-%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0" tabindex="-1">第5章 一等函数</h1>
<h2 id="%E6%8A%8A%E5%87%BD%E6%95%B0%E8%A7%86%E4%B8%BA%E5%AF%B9%E8%B1%A1" tabindex="-1" id="把函数视为对象">把函数视为对象</h2>
<p>first class 函数满足以下条件：</p>
<ul>
<li>能够在运行时创建</li>
<li>能够赋值给变量或者数据结构中的元素；</li>
<li>能够做为参数传递给函数；</li>
<li>能够做为结果从函数调用中返回；</li>
</ul>
<p>简而言之，函数就像一个对象一样（事实上在底层实现也是如此，函数即对象）；</p>
<h2 id="%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0" tabindex="-1" id="高阶函数">高阶函数</h2>
<p>高阶函数：higher-order function，接受函数做为参数，或者返回结果为参数；</p>
<p>常用的 map 和 filter，可以用列表推导式和生成器表达式进行替代，看起来更容易理解，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">map</span>(func, <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>))<br>[func(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)]<br><br><span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> n : n % <span class="hljs-number">2</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>))<br>[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>
<h2 id="%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0" tabindex="-1" id="匿名函数">匿名函数</h2>
<p>由于 python 的 lambda 函名函数只能写单行的表达式，因此表达能力非常有限，导致使用场景非常少；常用于高阶函数的函数参数；类似下面这个样子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> n : n % <span class="hljs-number">2</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure>
<h2 id="%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1" tabindex="-1" id="可调用对象">可调用对象</h2>
<p>调用运算符，即一对括号，不仅可以运用在函数上，其实也可以运用在普通对象上；</p>
<p>可用 callable 函数来判断某个对象是否可以调用</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261020586.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="%E7%94%A8%E6%88%B7%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8F%AF%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B" tabindex="-1" id="用户定义的可调用类型">用户定义的可调用类型</h2>
<p>事实上所有对象都是可以调用的，只要对象有实现  call 方法即可；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261039412.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="%E5%87%BD%E6%95%B0%E5%86%85%E7%9C%81" tabindex="-1" id="函数内省">函数内省</h2>
<blockquote>
<p>函数内省，function introspection，这个翻译名称有点奇怪；</p>
</blockquote>
<p>由于函数是一个对象，因此其实这个对象内部存储着很多与函数有关的信息，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261045205.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="%E4%BB%8E%E5%AE%9A%E4%BD%8D%E5%8F%82%E6%95%B0%E5%88%B0%E4%BB%85%E9%99%90%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0" tabindex="-1" id="从定位参数到仅限关键字参数">从定位参数到仅限关键字参数</h2>
<p>python 的函数参数处理机制非常灵活强大，既支持固定位置的参数形式，也支持按关键字进行匹配的参数形式。同时还支持使用 * 单星号或者 ** 双星号，将不固定数量的任意个参数，打包成一个可迭代对象，以便在函数体内部进行访问；其中单个星号打包成 tuple 元组的形式；两个星号打包成字典 dict 的形式；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261110944.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="%E8%8E%B7%E5%8F%96%E5%85%B3%E4%BA%8E%E5%8F%82%E6%95%B0%E7%9A%84%E4%BF%A1%E6%81%AF" tabindex="-1" id="获取关于参数的信息">获取关于参数的信息</h2>
<p>函数内部的属性，可用来做一起有用的事情，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261114146.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>此处使用了装饰器，装饰器会检查 hello 函数内部属性中存储的与参数有关的信息。检查后，它会发现 hello 函数需要一个 person 函数；因此，它可以用 query 对象中，获取相应的 person 值，然后作为参数，传递给 hello 函数；</p>
<p>_<em>default_</em>  存储函数参数的默认值；</p>
<p>_<em>code_</em>  是一个对象，它也存储着函数的相关信息，例如：</p>
<ul>
<li>co_varnames 存储着参数名称 + 局部变量名称</li>
<li>co_argcount 存储着函数的参数个数；</li>
</ul>
<p>直接访问 code 对象或者 default 不是很方便，不过有个 inspect 库提供了方便的查看方式；</p>
<h2 id="%E5%87%BD%E6%95%B0%E6%B3%A8%E8%A7%A3" tabindex="-1" id="函数注解">函数注解</h2>
<p>函数注解可用来给参数和返回值备注类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">clip</span>(<span class="hljs-params">text:<span class="hljs-built_in">str</span>, max_len:<span class="hljs-string">&#x27;int &gt; 0&#x27;</span>=<span class="hljs-number">80</span></span>) -&gt; <span class="hljs-built_in">str</span>: <span class="hljs-comment"># 备注参数和返回值的类型</span><br>	<span class="hljs-string">&quot;&quot;&quot;省略&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>
<p>注解会存储在函数的 _<em>annotations</em>_ 属性中；</p>
<p>注解本身不会做任何事情，有注解跟没有注解是一样的；但是注解可以给第三方工具（例如框架、装饰器等）提供有用的信息，例如 IDE 或者 Lint 工具可以利用注解来检查；</p>
<h2 id="%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%8C%85" tabindex="-1" id="支持函数式编程的包">支持函数式编程的包</h2>
<h3 id="operator-%E6%A8%A1%E5%9D%97" tabindex="-1" id="operator-模块">operator 模块</h3>
<p>operator 模块提供了一些算术运算符函数，它让代码更加简单易懂；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> mul <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>   <span class="hljs-keyword">return</span> reduce(mul, <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>)) <span class="hljs-comment"># mul 函数可用来计算两个数值的乘积</span><br></code></pre></td></tr></table></figure>
<p>itemgetter 可用来读取元组中的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>metro_data = [<br><span class="hljs-meta">... </span>(<span class="hljs-string">&#x27;Tokyo&#x27;</span>, <span class="hljs-string">&#x27;JP&#x27;</span>, <span class="hljs-number">36.933</span>, (<span class="hljs-number">35.689722</span>, <span class="hljs-number">139.691667</span>)),<br><span class="hljs-meta">... </span>(<span class="hljs-string">&#x27;Delhi NCR&#x27;</span>, <span class="hljs-string">&#x27;IN&#x27;</span>, <span class="hljs-number">21.935</span>, (<span class="hljs-number">28.613889</span>, <span class="hljs-number">77.208889</span>)),<br><span class="hljs-meta">... </span>(<span class="hljs-string">&#x27;Mexico City&#x27;</span>, <span class="hljs-string">&#x27;MX&#x27;</span>, <span class="hljs-number">20.142</span>, (<span class="hljs-number">19.433333</span>, -<span class="hljs-number">99.133333</span>)),<br><span class="hljs-meta">... </span>(<span class="hljs-string">&#x27;New York-Newark&#x27;</span>, <span class="hljs-string">&#x27;US&#x27;</span>, <span class="hljs-number">20.104</span>, (<span class="hljs-number">40.808611</span>, -<span class="hljs-number">74.020386</span>)),<br><span class="hljs-meta">... </span>(<span class="hljs-string">&#x27;Sao Paulo&#x27;</span>, <span class="hljs-string">&#x27;BR&#x27;</span>, <span class="hljs-number">19.649</span>, (-<span class="hljs-number">23.547778</span>, -<span class="hljs-number">46.635833</span>)),<br><span class="hljs-meta">... </span>]<br>&gt;&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> itemgetter<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> city <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(metro_data, key=itemgetter(<span class="hljs-number">1</span>)): <span class="hljs-comment"># itemgetter(1) 等同于 lamba fields : fields[1]</span><br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(city)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 此处的 itemgetter 的两个参数，表示读取两个位置的值，组成元组</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cc_name = itemgetter(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> city <span class="hljs-keyword">in</span> metro_data:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(cc_name(city))<br>...<br>(<span class="hljs-string">&#x27;JP&#x27;</span>, <span class="hljs-string">&#x27;Tokyo&#x27;</span>)<br>(<span class="hljs-string">&#x27;IN&#x27;</span>, <span class="hljs-string">&#x27;Delhi NCR&#x27;</span>)<br>(<span class="hljs-string">&#x27;MX&#x27;</span>, <span class="hljs-string">&#x27;Mexico City&#x27;</span>)<br>(<span class="hljs-string">&#x27;US&#x27;</span>, <span class="hljs-string">&#x27;New York-Newark&#x27;</span>)<br>(<span class="hljs-string">&#x27;BR&#x27;</span>, <span class="hljs-string">&#x27;Sao Paulo&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>attrgetter 与 itemgetter 的不同之处在于它使用名称来提取对象的属性；</p>
<p>methodcaller 接受一个参数，表示要调用的函数名称，然后它可以在之后传入的对象中调用相应的方法；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> methodcaller<br><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">&#x27;The time has come&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>upcase = methodcaller(<span class="hljs-string">&#x27;upper&#x27;</span>) <span class="hljs-comment"># 表示调用 upper 方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>upcase(s)  <span class="hljs-comment"># 在 s 身上调用 upper 方法</span><br><span class="hljs-string">&#x27;THE TIME HAS COME&#x27;</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>hiphenate = methodcaller(<span class="hljs-string">&#x27;replace&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-comment"># 调用 replace 方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>hiphenate(s)  <span class="hljs-comment"># 在 s 身上调用</span><br><span class="hljs-string">&#x27;The-time-has-come&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="%E4%BD%BF%E7%94%A8-functools.partial-%E5%86%BB%E7%BB%93%E5%8F%82%E6%95%B0" tabindex="-1" id="使用-functools-partial-冻结参数">使用 functools.partial 冻结参数</h3>
<p>partial 可用来将某个函数的参数设置为固定值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> operator <span class="hljs-keyword">import</span> mul<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> partial<br><span class="hljs-meta">&gt;&gt;&gt; </span>triple = partial(mul, <span class="hljs-number">3</span>) <span class="hljs-comment"># mul 原本接受两个参数，此处将 mul 的第一个参数固定 3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>triple(<span class="hljs-number">7</span>) <span class="hljs-comment"># 调用时，只需传入第二个参数即可计算出结果</span><br><span class="hljs-number">21</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(triple, <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)))  <br>[<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>, <span class="hljs-number">21</span>, <span class="hljs-number">24</span>, <span class="hljs-number">27</span>]<br></code></pre></td></tr></table></figure>
<h1 id="%E7%AC%AC6%E7%AB%A0-%E4%BD%BF%E7%94%A8%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" tabindex="-1">第6章 使用一等函数实现设计模式</h1>
<h2 id="%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" tabindex="-1" id="策略模式">策略模式</h2>
<p>在函数作为一等公民时，很多设计模式就有了更简单的实现方法了；例如策略模式中，每个策略对应一个类；实际上它们都可以简单替换成函数即可，完全没有必要单独为了调用它而去实例化一个对象；</p>
<h2 id="%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F" tabindex="-1" id="命令模式">命令模式</h2>
<p>命令模式的本意是想在命令的调用者（操作对象）和接收者（实现对象）之间进行解耦，这样调用者无须了解各个接收者具体是什么接口，而让它们对接口进行统一命名；但其实有更简单的做法，即直接将各个实现绑定到调用者身上就可以了，有点像回调那样；</p>
<p>面向对象之所以要搞成那么复杂，完全是因为它们不能接受函数作为参数，而是只能接受对象做为参数，然后再去调用对象的方法，这样就不得不对所调用的方法有个规范命名，不然就不知道如何调用；但如果能够接受函数作为参数，那就完全不一样了，直接将形参当作函数调用即可，非常简单直观，容易理解；</p>
<h1 id="%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85" tabindex="-1">第7章 函数装饰器和闭包</h1>
<h2 id="%E8%A3%85%E9%A5%B0%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" tabindex="-1" id="装饰器基础知识">装饰器基础知识</h2>
<p>装饰器是一个可调用的对象，类似函数，它的参数是另外一个函数，它的目的是对该函数进行打包封装，干些额外的工作；它的执行结果有可能会返回参数函数，也有可能是返回另外一个新的函数或可调用对象，并赋值给原本作为参数的函数名称，这样调用者并不知道这个函数可能已经被替换了；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@decorate</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;running target()&quot;</span>)<br>    <br><span class="hljs-comment"># 上面的写法跟下面的写法是一个意思</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">target</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;running target()&quot;</span>)<br>    <br>target = decorate(target);<br></code></pre></td></tr></table></figure>
<h2 id="python-%E4%BD%95%E6%97%B6%E6%89%A7%E8%A1%8C%E8%A3%85%E9%A5%B0%E5%99%A8" tabindex="-1" id="Python-何时执行装饰器">Python 何时执行装饰器</h2>
<p>注意，在定义装饰器的代码文件被加载时，装饰器会被立即执行，此时被装饰的函数还没有被调用；</p>
<h2 id="%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E6%94%B9%E8%BF%9B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F" tabindex="-1" id="使用装饰器改进策略模式">使用装饰器改进策略模式</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">promos = [] <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">promotion</span>(<span class="hljs-params">promo_func</span>): <br>    promos.append(promo_func)<br>    <span class="hljs-keyword">return</span> promo_func<br><br><span class="hljs-meta">@promotion </span><span class="hljs-comment"># 使用装饰器，在添加新的折扣策略时，不容易遗漏</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fidelity</span>(<span class="hljs-params">order</span>):<br>	<span class="hljs-string">&quot;&quot;&quot;为积分为1000或以上的顾客提供5%折扣&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> order.total() * <span class="hljs-number">.05</span> <span class="hljs-keyword">if</span> order.customer.fidelity &gt;= <span class="hljs-number">1000</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><span class="hljs-meta">    @promotion</span><br>    <br><span class="hljs-meta">@promotion </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">bulk_item</span>(<span class="hljs-params">order</span>):<br>	<span class="hljs-string">&quot;&quot;&quot;单个商品为20个或以上时提供10%折扣&quot;&quot;&quot;</span><br>    discount = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> order.cart:<br>        <span class="hljs-keyword">if</span> item.quantity &gt;= <span class="hljs-number">20</span>:<br>        	discount += item.total() * <span class="hljs-number">.1</span><br>    <span class="hljs-keyword">return</span> discount<br></code></pre></td></tr></table></figure>
<h2 id="%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99" tabindex="-1" id="变量作用域规则">变量作用域规则</h2>
<p>python 在编译函数定义时，它会先检查函数中声明的局部变量；</p>
<ul>
<li>如果变量存在，那么之后使用变量时，解释器只会在本地作用域中寻找；</li>
<li>如果不存在，那么就会到函数的定义环境中寻找全局变量；</li>
</ul>
<p>global 关键字可用来告知某个变量为全局的，以引导解释器到正确的位置查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">6</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">f3</span>(<span class="hljs-params">a</span>):<br><span class="hljs-meta">... </span><span class="hljs-keyword">global</span> b<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(a)<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(b)<br><span class="hljs-meta">... </span>b = <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>
<h2 id="%E9%97%AD%E5%8C%85" tabindex="-1" id="闭包">闭包</h2>
<p>如果函数引用了某个变量，该不在其定义内部定义，而是在函数外部定义的，那么解释器会在函数对象中，保留一个指向该外部变量的引用，以便在使用该变量时，能够取到相应的值；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_averager</span>():<br>    series = [] <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>(<span class="hljs-params">new_value</span>):<br>         <span class="hljs-comment"># 此处引用的 series 变量在 averager 外部定义，averager 对象属性中会保存它的引用</span><br>        series.append(new_value)<br>        total = <span class="hljs-built_in">sum</span>(series)<br>        <span class="hljs-keyword">return</span> total/<span class="hljs-built_in">len</span>(series)<br>    <span class="hljs-keyword">return</span> averager<br></code></pre></td></tr></table></figure>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407282027810.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="nonlocal-%E5%A3%B0%E6%98%8E" tabindex="-1" id="nonlocal-声明">nonlocal 声明</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_averager</span>():<br>    count = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>(<span class="hljs-params">new_value</span>):<br>        count += <span class="hljs-number">1</span> <br>        <span class="hljs-comment"># 此处的表达式等同于 count = count + 1，因此解释器会将 count 当作局部变量</span><br>        <span class="hljs-comment"># 因此在执行 count + 1 会出现报错</span><br>        total += new_value<br>        <span class="hljs-keyword">return</span> total / count<br>    <span class="hljs-keyword">return</span> averager<br><br><span class="hljs-comment"># 为了解决以上问题，需要用 nonlocal 关键字将 count 和 total 声明为非局部变量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_averager</span>():<br>    count = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>(<span class="hljs-params">new_value</span>):<br>    	<span class="hljs-keyword">nonlocal</span> count, total <span class="hljs-comment"># 声明 nonlocal</span><br>        count += <span class="hljs-number">1</span><br>        total += new_value<br>        <span class="hljs-keyword">return</span> total / count<br>    <br>    <span class="hljs-keyword">return</span> averager<br></code></pre></td></tr></table></figure>
<h2 id="%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8" tabindex="-1" id="实现一个简单的装饰器">实现一个简单的装饰器</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">clock</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clocked</span>(<span class="hljs-params">*args</span>): <span class="hljs-comment"># 不支持关键字参数</span><br>        t0 = time.perf_counter()<br>        result = func(*args)<br>        elapsed = time.perf_counter() - t0<br>        name = func.__name__<br>        arg_str = <span class="hljs-string">&quot;, &quot;</span>.join(<span class="hljs-built_in">repr</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[%0.8fs] %s(%s) -&gt; %r&#x27;</span> % (elapsed, name, arg_str, result))<br>     <span class="hljs-keyword">return</span> clocked<br></code></pre></td></tr></table></figure>
<p>支持关键字参数的版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> functools<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">clock</span>(<span class="hljs-params">func</span>):<br><span class="hljs-meta">    @functools.wraps(<span class="hljs-params">func</span>) </span><span class="hljs-comment"># 用于将函数属性从 func 复制到 clocked 函数中，例如函数名称等</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clocked</span>(<span class="hljs-params">*args, **kwargs</span>):  <span class="hljs-comment"># 支持关键字参数</span><br>        t0 = time.perf_counter()<br>        result = func(*args, **kwargs)<br>        elapsed = time.perf_counter() - t0<br>        name = func.__name__<br>        arg_lst = []<br>        <span class="hljs-keyword">if</span> args:<br>            arg_lst.append(<span class="hljs-string">&quot;, &quot;</span>.join(<span class="hljs-built_in">repr</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args))<br>        <span class="hljs-keyword">if</span> kwargs:<br>            pairs = [<span class="hljs-string">&#x27;%s=%r&#x27;</span> % (k, w) <span class="hljs-keyword">for</span> k, w <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(kwargs.items())]<br>            arg_lst.append(<span class="hljs-string">&quot;, &quot;</span>.join(pairs))<br>        arg_str = <span class="hljs-string">&quot;, &quot;</span>.join(arg_lst)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[%0.8fs] %s(%s) -&gt; %r &#x27;</span> % (elapsed, name, arg_str, result))<br>    <span class="hljs-keyword">return</span> clocked<br></code></pre></td></tr></table></figure>
<h2 id="%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8" tabindex="-1" id="标准库中的装饰器">标准库中的装饰器</h2>
<h3 id="%E4%BD%BF%E7%94%A8-lru_cache-%E7%BC%93%E5%AD%98" tabindex="-1" id="使用-lru-cache-缓存">使用  lru_cache  缓存</h3>
<p>lru_cache  可以帮助缓存函数的计算结果，如果下次再传入相同的参数，则直接从缓存中返回计算结果，不再重复计算，这会极大的提高性能，尤其是存在大量重复计算的场景，例如计算斐波契那数列；</p>
<blockquote>
<p>lru 的全称 least recently used</p>
</blockquote>
<h3 id="%E5%8D%95%E5%88%86%E6%B4%BE%E6%B3%9B%E5%87%BD%E6%95%B0" tabindex="-1" id="单分派泛函数">单分派泛函数</h3>
<blockquote>
<p>所谓的分泛函数是指这个函数的功能用于分别派分任务，它根据参数值，使用一串 if elif else 来分别调用相应的函数；在 OO 的语言中一般叫重载，但 Python 不支持重载；</p>
</blockquote>
<p>singledispatch 装饰器，可以将多个函数组合成一个泛函数；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> singledispatch<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> abc<br><span class="hljs-keyword">import</span> numbers<br><span class="hljs-keyword">import</span> html<br><br><span class="hljs-meta">@singledispatch  </span><span class="hljs-comment"># 将 htmlize 包装成了泛函数，之后它可以注册不同的参数 </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">htmlize</span>(<span class="hljs-params">obj</span>):<br>    content = html.escape(<span class="hljs-built_in">repr</span>(obj))<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre&gt;&#123;&#125;&lt;/pre&gt;&#x27;</span>.<span class="hljs-built_in">format</span>(content)<br><br><span class="hljs-meta">@htmlize.register(<span class="hljs-params"><span class="hljs-built_in">str</span></span>)  </span><span class="hljs-comment"># 注册重载 str 类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">text</span>):<br>    content = html.escape(text).replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&lt;br&gt;\n&#x27;</span>)<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;p&gt;&#123;0&#125;&lt;/p&gt;&#x27;</span>.<span class="hljs-built_in">format</span>(content)<br><br><span class="hljs-meta">@htmlize.register(<span class="hljs-params">numbers.Integral</span>) </span><span class="hljs-comment"># 注册重载 int 类型</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">n</span>):<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;&#x27;</span>.<span class="hljs-built_in">format</span>(n)<br><br><span class="hljs-meta">@htmlize.register(<span class="hljs-params"><span class="hljs-built_in">tuple</span></span>) </span><span class="hljs-comment"># 注册 tuple 类型</span><br><span class="hljs-meta">@htmlize.register(<span class="hljs-params">abc.MutableSequence</span>)  </span><span class="hljs-comment"># 可多个类型叠加</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_</span>(<span class="hljs-params">seq</span>):<br>    inner = <span class="hljs-string">&#x27;&lt;/li&gt;\n&lt;li&gt;&#x27;</span>.join(htmlize(item) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> seq)<br>	<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;ul&gt;\n&lt;li&gt;&#x27;</span> + inner + <span class="hljs-string">&#x27;&lt;/li&gt;\n&lt;/ul&gt;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>singledispatch 可以用来装饰自己编写的函数，也可以用来装饰他人编写的函数；</p>
<h2 id="%E5%8F%A0%E6%94%BE%E8%A3%85%E9%A5%B0%E5%99%A8" tabindex="-1" id="叠放装饰器">叠放装饰器</h2>
<p>装饰器支持叠放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@d1</span><br><span class="hljs-meta">@d2</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;f&quot;</span>)<br>    <br><span class="hljs-comment">#等同于</span><br>f = d1(d2(f))<br></code></pre></td></tr></table></figure>
<h2 id="%E5%8F%82%E6%95%B0%E5%8C%96%E8%A3%85%E9%A5%B0%E5%99%A8" tabindex="-1" id="参数化装饰器">参数化装饰器</h2>
<p>通过创建一个装饰器工厂函数，便可使装饰器支持传入参数；调用该装饰器工厂函数时，返回的是真正的装饰器；</p>
<h1 id="%E7%AC%AC8%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" tabindex="-1">第8章 对象引用、可变性和垃圾回收</h1>
<h2 id="%E5%8F%98%E9%87%8F%E4%B8%8D%E6%98%AF%E7%9B%92%E5%AD%90" tabindex="-1" id="变量不是盒子">变量不是盒子</h2>
<p>变量本身是一个独立的东西，我们借助它，让它指向某个对象，以方便实现引用该对象；</p>
<h2 id="%E6%A0%87%E8%AF%86%E3%80%81%E7%9B%B8%E7%AD%89%E6%80%A7%E5%92%8C%E5%88%AB%E5%90%8D" tabindex="-1" id="标识、相等性和别名">标识、相等性和别名</h2>
<p>在 Python 中，判断两个对象是否相同，有两种方法，一种是 == 两个等号，一种是使用关键字 is，它们的意思是不一样的；== 会调用对象的 __eq __ 方法进行判断，它比的是值相等即可，is 等是判断对象的 id，相当于内存的地址；</p>
<p>由于 is 比较的是地址，因为使用 is 进行判断它的性能很好；因为使用 == 进行判断的话，需要遍历对象的属性值；</p>
<p>object 类型的 eq 方法比较的是 id，但是其他大多数内置类型的 eq 方法比较的是值；</p>
<p>当元组用于保存对象时，它保存的是对象的引用。虽然元组本身不可变，但这个引用背后的对象自身是可以变的；</p>
<h2 id="%E9%BB%98%E8%AE%A4%E5%81%9A%E6%B5%85%E5%A4%8D%E5%88%B6" tabindex="-1" id="默认做浅复制">默认做浅复制</h2>
<p>如果要做深复制，需要使用 deepcopy 方法；浅复制则使用 copy 方法；</p>
<h2 id="%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E6%97%B6" tabindex="-1" id="函数的参数作为引用时">函数的参数作为引用时</h2>
<p>千万不要将函数参数的默认值设置为可变对象，而应该设置为 None；因为如果是可变对象，那么在函数载入时，会自动创建出来；这样导致多次不传参数的调用该函数时，多个函数都会指向该默认值，造成相互影响；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HauntedBus</span>:<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, passengers=[]</span>): <span class="hljs-comment"># 这里默认值 [] 是大忌，千万要避免</span><br>        <span class="hljs-variable language_">self</span>.passengers = passengers<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pick</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.passengers.append(name)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drop</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.passengers.remove(name)<br></code></pre></td></tr></table></figure>
<p>如果函数的参数是一个可变对象，那么让函数对该对象进行修改，会直接作用到外部的实参对象上。有时候，这是想要的结果，有时候则不是非预期的结果。如果是非预期的结果，那么函数内部应对该实参进行复制；</p>
<h2 id="del-%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" tabindex="-1" id="del-和垃圾回收">del 和垃圾回收</h2>
<p>del 关键字并不是用来销毁对象的，而仅仅是切割变量和对象之间的引用关系；当对象的引用数量为零时，销毁的工作会垃圾回收器处理；</p>
<h2 id="%E5%BC%B1%E5%BC%95%E7%94%A8" tabindex="-1" id="弱引用">弱引用</h2>
<p>弱引用不会增加对象的引用计数，这样不会对对象的垃圾回收带来干扰；一般用于有生命周期限制的缓存管理中；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> weakref<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set) ➊<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>wref<br>&lt;weakref at <span class="hljs-number">0x100637598</span>; to <span class="hljs-string">&#x27;set&#x27;</span> at <span class="hljs-number">0x100636748</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>wref() ➋<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; ➌<br><span class="hljs-meta">&gt;&gt;&gt; </span>wref() ➍<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>wref() <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> ➎<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>wref() <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> ➏<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>WeakValueDictionary 是一种可变映射（字典也是一种可变映射），映射指向的值是对象的弱引用；当对象被回收时，对应的键会自动从 WeakValueDictionary 中被删除；因此，它很适合用来做缓存；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cheese</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, kind</span>):<br>    	<span class="hljs-variable language_">self</span>.kind = kind<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Cheese(%r)&#x27;</span> % <span class="hljs-variable language_">self</span>.kind<br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> weakref<br><span class="hljs-meta">&gt;&gt;&gt; </span>stock = weakref.WeakValueDictionary() <span class="hljs-comment"># 实例化</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>catalog = [Cheese(<span class="hljs-string">&#x27;Red Leicester&#x27;</span>), Cheese(<span class="hljs-string">&#x27;Tilsit&#x27;</span>),<br><span class="hljs-meta">... </span>Cheese(<span class="hljs-string">&#x27;Brie&#x27;</span>), Cheese(<span class="hljs-string">&#x27;Parmesan&#x27;</span>)]<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> cheese <span class="hljs-keyword">in</span> catalog:<br><span class="hljs-meta">... </span>stock[cheese.kind] = cheese <span class="hljs-comment"># 将 stock 的键映射到 cheese 实例上</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(stock.keys())<br>[<span class="hljs-string">&#x27;Brie&#x27;</span>, <span class="hljs-string">&#x27;Parmesan&#x27;</span>, <span class="hljs-string">&#x27;Red Leicester&#x27;</span>, <span class="hljs-string">&#x27;Tilsit&#x27;</span>] ➌<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> catalog<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(stock.keys())<br>[<span class="hljs-string">&#x27;Parmesan&#x27;</span>] <span class="hljs-comment"># 为什么删除 catalog 后，没有全部删除，而是还剩下一个？</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> cheese <span class="hljs-comment"># for 循环中的 cheese 是全局变量，因此需要显式删除，不然仍然有一个引用</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>(stock.keys())<br>[]<br></code></pre></td></tr></table></figure>
<p>不是每个 python 对象都可以被弱引用，例如常用的 list 和 dict 实例无法被弱引用，但是它们的子类可以；set 实例也可以</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span>(<span class="hljs-title class_ inherited__">list</span>):<br><span class="hljs-string">&quot;&quot;&quot;list的子类，实例可以作为弱引用的目标&quot;&quot;&quot;</span><br><br>a_list = MyList(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><br><span class="hljs-comment"># a_list可以作为弱引用的目标</span><br>wref_to_a_list = weakref.ref(a_list)<br></code></pre></td></tr></table></figure>
<h2 id="python-%E5%AF%B9%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E6%96%BD%E5%8A%A0%E7%9A%84%E6%8A%8A%E6%88%8F" tabindex="-1" id="Python-对不可变类型施加的把戏">Python 对不可变类型施加的把戏</h2>
<p>使用一个元组构建另外一个元组，结果得到的是同一个元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t2 = <span class="hljs-built_in">tuple</span>(t1)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t2 <span class="hljs-keyword">is</span> t1<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>在 CPython 中，当对象的引用数量为零，会立即触发垃圾回收。但其他 Python 实现则不一定如此；这里涉及到性能的权衡；</p>
<h1 id="%E7%AC%AC9%E7%AB%A0-%E7%AC%A6%E5%90%88-python-%E9%A3%8E%E6%A0%BC%E7%9A%84%E5%AF%B9%E8%B1%A1" tabindex="-1">第9章 符合 Python 风格的对象</h1>
<h2 id="%E5%AF%B9%E8%B1%A1%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F" tabindex="-1" id="对象表示形式">对象表示形式</h2>
<p>Python 默认使用两个函数来表示对象的字符串形式，它们分别是 repr() 和 str() 函数。它们实际上调用的是对象的 _<em>repr</em>_ 和 _<em>str</em>_</p>
<p>另外还有一个 bytes() 函数会调用 _<em>bytes</em>_ 方法来返回字节序列；</p>
<h2 id="%E5%86%8D%E8%B0%88%E5%90%91%E9%87%8F%E7%B1%BB" tabindex="-1" id="再谈向量类">再谈向量类</h2>
<p>以下是自定义向量类的待实现功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(v1.x, v1.y) <span class="hljs-comment"># 能够通过点运算符，直接访问属性</span><br><span class="hljs-number">3.0</span> <span class="hljs-number">4.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x, y = v1 <span class="hljs-comment"># 支持元组拆包</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>x, y<br>(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>v1 <span class="hljs-comment"># repr 的显示格式</span><br>Vector2d(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>v1_clone = <span class="hljs-built_in">eval</span>(<span class="hljs-built_in">repr</span>(v1)) <span class="hljs-comment"># 基于 repr 结果生成对象</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>v1 == v1_clone <span class="hljs-comment"># 支持 == 运算符</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(v1) <span class="hljs-comment"># str 的实现</span><br>(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>octets = <span class="hljs-built_in">bytes</span>(v1)  <span class="hljs-comment"># 生成实例的二进制表示</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>octets<br><span class="hljs-string">b&#x27;d\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">abs</span>(v1) <span class="hljs-comment"># 支持 abs 方法，返回实例的模</span><br><span class="hljs-number">5.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">bool</span>(v1), <span class="hljs-built_in">bool</span>(Vector2d(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment"># 支持 bool 方法，模为零时，返回 False</span><br>(<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>
<h2 id="%E5%A4%87%E9%80%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95" tabindex="-1" id="备选构造方法">备选构造方法</h2>
<h2 id="classmethod-%E4%B8%8E-staticmethod" tabindex="-1" id="classmethod-与-staticmethod">classmethod 与 staticmethod</h2>
<p>classmethod 修饰的函数，调用时，不需要实例化对象；该函数的第一个参数是类本身，从而可以借助该函数，访问类的相关成员；</p>
<p>classmethod 的一个常见用途时定义额外的构造方法，一般该构造方法会对传入的数据进行清洗，之后再构造对象；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">frombytes</span>(<span class="hljs-params">cls, octets</span>): <span class="hljs-comment"># 第一个参数不是 self, 而是类本身</span><br>    typecode = <span class="hljs-built_in">chr</span>(octets[<span class="hljs-number">0</span>]) <br>    memv = <span class="hljs-built_in">memoryview</span>(octets[<span class="hljs-number">1</span>:]).cast(typecode) <br>    <span class="hljs-keyword">return</span> cls(*memv) <br></code></pre></td></tr></table></figure>
<h2 id="%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%98%BE%E7%A4%BA" tabindex="-1" id="格式化显示">格式化显示</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;1 BRL = &#123;rate:0.2f&#125; USD&#x27;</span>.<span class="hljs-built_in">format</span>(rate=brl) <span class="hljs-comment"># rate 表示具名变量</span><br><span class="hljs-string">&#x27;1 BRL = 0.41 USD&#x27;</span><br></code></pre></td></tr></table></figure>
<p>关于如何格式化，python 有一套自己的语法规则，可称之为微语言；这套微语言是可扩展的，可以自定义如何解释 forma_spec 参数</p>
<h2 id="%E5%8F%AF%E6%95%A3%E5%88%97%E7%9A%84-vector2d" tabindex="-1" id="可散列的-Vector2d">可散列的 Vector2d</h2>
<p>通过实现 _<em>hash</em>_ 和 _<em>eq</em>_ 方法，可将一个不可散列的自定义类的对象，变成可散列的；</p>
<h2 id="python-%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%B1%9E%E6%80%A7" tabindex="-1" id="Python-的私有属性和受保护的属性">Python 的私有属性和受保护的属性</h2>
<p>python 没有类似 Java 中的 private 关键字，而是通过给类成员的名称添加两个下划线前缀，将该成员标记为私有成员，类似这样：__x，但也有一些人喜欢使用一个下划线来表示；</p>
<p>对于私有属性，解释器在实例化对象时，会给这些属性加上类名作为前缀，这样一来，直接用双下划线访问私有属性时，会提示该属性并不存在，从而实现访问控制；但实际上是可以访问的，只是曲折一点，需要加上类名前缀来访问；</p>
<h2 id="%E4%BD%BF%E7%94%A8-slots-%E7%B1%BB%E5%B1%9E%E6%80%A7%E8%8A%82%E7%9C%81%E7%A9%BA%E9%97%B4" tabindex="-1" id="使用-slots-类属性节省空间">使用 slots 类属性节省空间</h2>
<p>默认情况下，类的实例在 _<em>dict_</em> 字段中使用字典来存储属性成员，如果成员比较多的，会占据较大的内存，此时可考虑使用 _<em>slot_</em> 属性来存储以节省内存；它的原理是使用元组来存储，所以节省内存；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector2d</span>:<br>    __slots__ = (<span class="hljs-string">&#x27;__x&#x27;</span>, <span class="hljs-string">&#x27;__y&#x27;</span>)<br>    typecode = <span class="hljs-string">&#x27;d&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="%E8%A6%86%E7%9B%96%E7%B1%BB%E5%B1%9E%E6%80%A7" tabindex="-1" id="覆盖类属性">覆盖类属性</h2>
<p>Python 的类属性可以为实例属性提供默认值，这个默认值在实例中可以被重新赋值；</p>
<p>如果要批量处理，则可以考虑定义一个子类，该子类的属性重写，之后使用子类来实例化对象；</p>
<h1 id="%E7%AC%AC10%E7%AB%A0-%E5%BA%8F%E5%88%97%E7%9A%84%E4%BF%AE%E6%94%B9%E3%80%81%E6%95%A3%E5%88%97%E5%92%8C%E5%88%87%E7%89%87" tabindex="-1">第10章 序列的修改、散列和切片</h1>
<p>鸭子类型：只要实现一些约定的接口，即可当作拥有目标类型的特征，并可以像目标类型一样被处理；例如一个类只需要实现 getitem 和  len 两个接口，那么它就可以被当作序列类型一样处理，至于它是谁的子类，并不重要；</p>
<blockquote>
<p>zip 函数可用于并行迭代多个序列，它会将多个序列的对象打包成元组，然后可以拆包赋值给各个变量；</p>
</blockquote>
<h1 id="%E7%AC%AC11%E7%AB%A0-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E4%BB%8E%E5%8D%8F%E8%AE%AE%E5%88%B0%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB" tabindex="-1">第11章 接口：从协议到抽象基类</h1>
<h2 id="%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8D%8F%E8%AE%AE" tabindex="-1" id="接口与协议">接口与协议</h2>
<p>一个类只需要实现了某些特定的接口，它就可以被当作特定的类型进行操作（即鸭子类型）；</p>
<p>当一个类实现了 getitem 接口时，即使它没有实现 contains 和 iter 接口，它也是可迭代，并且支持 in 运算符的；因为解释器会调用 getitem 接口来实现以上两项功能；</p>
<blockquote>
<p>Python 类中的方法，第一个参数叫 self 纯粹是一种惯例，其实叫个其他名字也无妨；</p>
</blockquote>
<h2 id="%E7%8C%B4%E5%AD%90%E8%A1%A5%E4%B8%81" tabindex="-1" id="猴子补丁">猴子补丁</h2>
<p>猴子补丁：如果一个类在定义时，没有定义某个方法；之后在运行时，可以在外部单独定义一个函数，然后把这个函数绑定到类的某个属性上，这样就让类动态获得了某个方法；</p>
<h2 id="%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB" tabindex="-1" id="抽象基类">抽象基类</h2>
<p>抽象基类一般用于编写框架的场景，如果是业务场景，几乎不太可能需要自己编写抽象基类，而是使用现成的就可以了；</p>
<p>当继承抽象基类，就需要手工实现抽象基类中规定的所有方法，不管该方法是否用得到；</p>
<h2 id="%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84-abc" tabindex="-1" id="标准库中的-ABC">标准库中的 ABC</h2>
<blockquote>
<p>ABC：抽象基类，abstract base class</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407301247891.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>不可变集合：Sequence, Mapping, Set</p>
<p>可变集合：MutableSequence, MutableMapping, MutableSet</p>
<h3 id="%E6%95%B0%E5%AD%97%E5%A1%94" tabindex="-1" id="数字塔">数字塔</h3>
<p>numbers 包定义了数字抽象基类的线性层次结构：Number &lt; Complex &lt; Real &lt; Rational &lt; Integral；</p>
<h1 id="%E7%AC%AC12%E7%AB%A0-%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" tabindex="-1">第12章 继承的优缺点</h1>
<h2 id="%E5%AD%90%E7%B1%BB%E5%8C%96%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%BE%88%E9%BA%BB%E7%83%A6" tabindex="-1" id="子类化内置类型很麻烦">子类化内置类型很麻烦</h2>
<p>内置类型的方法不会调用子类覆盖后的方法，它只会调用内置类型原本的方法；因此，不会子类化内置类型，Python 有专门给用户子类化的类型，以 User 开头，例如 UserDict、UserList、UserString 等；</p>
<blockquote>
<p>猜测原因在于内置类型的很多方法，出于性能考虑，是用 C  语言专门优化过的，因此不严格遵行继承的定义；</p>
</blockquote>
<h2 id="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E5%92%8C%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F" tabindex="-1" id="多重继承和方法解析顺序">多重继承和方法解析顺序</h2>
<p>多重继承会面临菱形问题，即子类继承多个父类中，存在同名的方法，导致子类无法确定应该执行哪个父类的同名方法；</p>
<h2 id="%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%BA%94%E7%94%A8" tabindex="-1" id="多重继承的真实应用">多重继承的真实应用</h2>
<h2 id="%E5%A4%84%E7%90%86%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF" tabindex="-1" id="处理多重继承">处理多重继承</h2>
<h2 id="django-%E7%A4%BA%E4%BE%8B" tabindex="-1" id="Django-示例">Django 示例</h2>
<h1 id="%E7%AC%AC13%E7%AB%A0-%E6%AD%A3%E7%A1%AE%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6" tabindex="-1">第13章 正确重载运算符</h1>
<h1 id="%E7%AC%AC14%E7%AB%A0-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8" tabindex="-1">第14章 可迭代对象、迭代器和生成器</h1>
<blockquote>
<p>迭代器模式：惰性加载数据，处理时加载，这样可以用较小的内存，处理很大的数据集；</p>
</blockquote>
<p>Python 中使用生成器来实现迭代器模式；生成器也是为了迭代数据，因此可将它当作迭代器来使用，唯一的区别在于它的惰性；</p>
<p>在 Python3 中，生成器是很普遍的，只是使用的时候没有觉察，例如 range(10) 返回的是一个类似生成器的对象；如果想要获得完整的列表，需要写成 list(range(10))；</p>
<h2 id="%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AF%B9%E6%AF%94" tabindex="-1" id="可迭代对象和迭代器对比">可迭代对象和迭代器对比</h2>
<p>区别：从可迭代对象中，获取迭代器；迭代器如果迭代完毕，则不再可用，需要重新构建；</p>
<p>所谓的迭代器，可以理解为一个对象，每次调用它的 next 方法，可返回一个元素；如果空了，会报错；</p>
<blockquote>
<p>通常迭代器还有一个 iter 方法，调用这个方法，可返回迭代器本身；理论上不实现它，也不会影响迭代功能。但如果实现了它，issubclass 方法可将其判断为 Iterator 的子类；</p>
<p>可迭代对象也有一个 iter 方法，调用它，会返回一个新的迭代器；</p>
</blockquote>
<h2 id="%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0" tabindex="-1" id="生成器函数">生成器函数</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> reprlib<br><br>RE_WORD = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;\w+&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sentence</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, text</span>):<br>        <span class="hljs-variable language_">self</span>.text = text<br>        <span class="hljs-variable language_">self</span>.words = RE_WORD.findall(text)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="hljs-built_in">repr</span>(<span class="hljs-variable language_">self</span>.text)<br>    <br>    <span class="hljs-comment"># iter 使用了 yield 关键字，调用 iter 会返回生成器对象，此时 iter 是个生成器函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.words:<br>        	<span class="hljs-keyword">yield</span> word <br></code></pre></td></tr></table></figure>
<h3 id="%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" tabindex="-1" id="生成器函数的工作原理">生成器函数的工作原理</h3>
<p>yield 关键字有点像 await，每次执行到 yield 所在的语句时，会暂停等待；</p>
<blockquote>
<p>for 循环语句会自动捕获并处理迭代器抛出的异常；</p>
</blockquote>
<h2 id="%E6%83%B0%E6%80%A7%E5%AE%9E%E7%8E%B0" tabindex="-1" id="惰性实现">惰性实现</h2>
<p>re 模块除了 findall 函数，还有一个生成器版本的 finditer 函数；它每次只返回一个匹配项；当数据量很大时，可以节省很多内存；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> reprlib<br><br>RE_WORD = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;\w+&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sentence</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, text</span>):<br>    	<span class="hljs-variable language_">self</span>.text = text <br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="hljs-built_in">repr</span>(<span class="hljs-variable language_">self</span>.text)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> RE_WORD.finditer(<span class="hljs-variable language_">self</span>.text): <span class="hljs-comment"># finditer 返回生成器</span><br>        	<span class="hljs-keyword">yield</span> <span class="hljs-keyword">match</span>.group()<br></code></pre></td></tr></table></figure>
<h2 id="%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F" tabindex="-1" id="生成器表达式">生成器表达式</h2>
<p>生成器表达式有点像是列表推导的惰性版本；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_AB</span>(): <span class="hljs-comment"># ➊</span><br><span class="hljs-meta">... </span>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br><span class="hljs-meta">... </span>	<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-meta">... </span>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;continue&#x27;</span>)<br><span class="hljs-meta">... </span>	<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;B&#x27;</span><br>...	 <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;end.&#x27;</span>)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>res1 = [x*<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> gen_AB()] <span class="hljs-comment"># res1 是一个列表，由生成器 gen_Ab 的返回值组成</span><br>start<br><span class="hljs-keyword">continue</span><br>end.<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res1: <span class="hljs-comment"># ➌</span><br><span class="hljs-meta">... </span>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--&gt;&#x27;</span>, i)<br>...<br>--&gt; AAA<br>--&gt; BBB<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>res2 = (x*<span class="hljs-number">3</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> gen_AB()) <span class="hljs-comment"># res2 是一个生成器</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>res2 <br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x10063c240</span>&gt;<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res2: <span class="hljs-comment"># 遍历 res2，此时 gen_AB 函数才真正的执行</span><br>...		<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--&gt;&#x27;</span>, i)<br>...<br>start<br>--&gt; AAA<br><span class="hljs-keyword">continue</span><br>--&gt; BBB<br>end.<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> reprlib<br><br>RE_WORD = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;\w+&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sentence</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, text</span>):<br>    	<span class="hljs-variable language_">self</span>.text = text<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="hljs-built_in">repr</span>(<span class="hljs-variable language_">self</span>.text)<br>    <br>    <span class="hljs-comment"># 使用表达式构建一个生成器，而不是用 yield 来生成</span><br>    <span class="hljs-comment"># 生成器表达式是一个语法糖，本质上跟使用 yield 的生成器函数没有区别</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>    	<span class="hljs-keyword">return</span> (<span class="hljs-keyword">match</span>.group() <span class="hljs-keyword">for</span> <span class="hljs-keyword">match</span> <span class="hljs-keyword">in</span> RE_WORD.finditer(<span class="hljs-variable language_">self</span>.text))<br></code></pre></td></tr></table></figure>
<h2 id="%E4%BD%95%E6%97%B6%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F" tabindex="-1" id="何时用生成器表达式">何时用生成器表达式</h2>
<p>生成器表达式是构建生成器的简捷方式，无需通过 def 定义函数来实现；但限于一些简单场景，一行可以搞定的那种；如果业务逻辑比较复杂，一行代码搞不定的话，则仍然需要使用函数来定义；</p>
<p>标准库  itertools 模块中有很多现成的生成器；</p>
<p>itertools.count(start, step)：创建一个数字生成器</p>
<p>itertools.takewhile 给生成器添加条件限制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>gen = itertools.takewhile(<span class="hljs-keyword">lambda</span> n: n &lt; <span class="hljs-number">3</span>, itertools.count(<span class="hljs-number">1</span>, <span class="hljs-number">.5</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(gen)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.5</span>]<br></code></pre></td></tr></table></figure>
<h2 id="%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8" tabindex="-1" id="标准库中的生成器">标准库中的生成器</h2>
<p>在创建任何生成器前，很有必要先查一下标准库中有哪些生成器可用，以避免重复造轮子；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311445182.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311446562.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311447657.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311447765.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311454347.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="yield-from" tabindex="-1" id="yield-from">yield from</h2>
<p>yield from 可用来作为可迭代对象的生成器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">chain</span>(<span class="hljs-params">*iterables</span>):<br><span class="hljs-meta">... </span>	<span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> iterables:<br><span class="hljs-meta">... </span>		<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> it:<br><span class="hljs-meta">... </span>			<span class="hljs-keyword">yield</span> i<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">&#x27;ABC&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>t = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(chain(s, t))<br>[<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># 上面的写法，用 yield from 重写如下，可减少一层 for 循环</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">chain</span>(<span class="hljs-params">*iterables</span>):<br><span class="hljs-meta">... </span>	<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> iterables:<br><span class="hljs-meta">... </span>		<span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> i<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(chain(s, t))<br>[<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure>
<h2 id="%E5%8F%AF%E8%BF%AD%E4%BB%A3%E7%9A%84%E5%BD%92%E7%BA%A6%E5%87%BD%E6%95%B0" tabindex="-1" id="可迭代的归约函数">可迭代的归约函数</h2>
<p>归约函数：接受一个可迭代的对象，返回一个值，例如 reduce 函数；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311501287.png" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90-iter-%E5%87%BD%E6%95%B0" tabindex="-1" id="深入分析-iter-函数">深入分析 iter 函数</h2>
<p>iter 函数用于生成迭代器，一般接收一个可迭代对象作为参数；但是它还有个用法是接收两个参数，第一个参数是个可迭代对象，第二个参数是个 predicate，当可迭代对象产生的值满足 predicate 时，就停止产出；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">d6</span>():<br><span class="hljs-meta">... </span>	<span class="hljs-keyword">return</span> randint(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>d6_iter = <span class="hljs-built_in">iter</span>(d6, <span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d6_iter<br>&lt;callable_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x00000000029BE6A0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> roll <span class="hljs-keyword">in</span> d6_iter:<br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(roll)<br>...<br><span class="hljs-number">4</span><br><span class="hljs-number">3</span><br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>生成器很适合用来处理大数据集，这样可以利用有限的内存，处理无限大的数据，例如大型数据库；</p>
<h2 id="%E7%94%9F%E6%88%90%E5%99%A8%E5%BD%93%E4%BD%9C%E5%8D%8F%E7%A8%8B" tabindex="-1" id="生成器当作协程">生成器当作协程</h2>
<p>生成器对象有个 send 方法，该方法允许给生成器对象发送消息；</p>
<h1 id="%E7%AC%AC15%E7%AB%A0-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8C-else-%E5%9D%97" tabindex="-1">第15章 上下文管理器和 else 块</h1>
<h2 id="else" tabindex="-1" id="else">else</h2>
<p>else 不仅可以跟 if 搭配使用，还可以跟 for, while, try 搭配使用；在这些场景中，else 实际上是 then 的意思，表示某个动作如果顺利完成了，那么就执行 else 里面的语句；如果没有顺利完成，就不执行；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> my_list:<br>	<span class="hljs-keyword">if</span> item.flavor == <span class="hljs-string">&#x27;banana&#x27;</span>:<br>		<span class="hljs-keyword">break</span><br><span class="hljs-keyword">else</span>: <span class="hljs-comment"># 如果 for 循环结束，没有触发 break，那么就执行 else；如果触发，就退出循环，不执行else</span><br>	<span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;No banana flavor found!&#x27;</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>	dangerous_call()<br><span class="hljs-keyword">except</span> OSError:<br>    log(<span class="hljs-string">&#x27;OSError...&#x27;</span>)<br><span class="hljs-keyword">else</span>: <span class="hljs-comment"># 如果 dangerous_call 顺利执行，没有报异常，则执行 else；如果报异常，就不执行 else</span><br>	after_call()<br></code></pre></td></tr></table></figure>
<h2 id="with" tabindex="-1" id="with">with</h2>
<p>with 的目标是安全的实现 try…finally；with 之后的表达式（例如 open 函数）会创建一个上下文管理器对象。该对象有两个方法，分别是 enter 和 exit；with 语句开始执行时，会调用 enter 方法；执行结束后，会调用 exit 方法，类似 finally 的作用；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># with...as... 是一个表达式，该表达式的前半段子句，会创建上下文管理器对象，并执行 enter 方法</span><br><span class="hljs-comment"># enter 方法执行完成后，会将结果返回到 fp 变量上，但 as 并不是必须的，有些场景并不需要返回什么东西</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;mirror.py&#x27;</span>) <span class="hljs-keyword">as</span> fp: <br><span class="hljs-meta">... </span>src = fp.read(<span class="hljs-number">60</span>) <span class="hljs-comment"># </span><br><br><span class="hljs-comment"># 当解释器执行完整个 with 块的语句后，会调用 exit 方法，清理现场</span><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以下是一个上下文管理器类的示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LookingGlass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 做准备工作</span><br>        <span class="hljs-keyword">import</span> sys<br>        <span class="hljs-variable language_">self</span>.original_write = sys.stdout.write <br>        sys.stdout.write = <span class="hljs-variable language_">self</span>.reverse_write <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;JABBERWOCKY&#x27;</span> <br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse_write</span>(<span class="hljs-params">self, text</span>): <span class="hljs-comment"># 实际干活的方法</span><br>    	<span class="hljs-variable language_">self</span>.original_write(text[::-<span class="hljs-number">1</span>])<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_value, traceback</span>): <span class="hljs-comment"># 做清理工作</span><br>        <span class="hljs-keyword">import</span> sys <br>        sys.stdout.write = <span class="hljs-variable language_">self</span>.original_write <br>        <span class="hljs-keyword">if</span> exc_type <span class="hljs-keyword">is</span> ZeroDivisionError: <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Please DO NOT divide by zero!&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span> <br></code></pre></td></tr></table></figure>
<p>contextlib 模块中有一些现成的工作，可用来创建自定义的 context 类（上下文管理器）；</p>
<h2 id="%40contextmanager" tabindex="-1" id="contextmanager">@contextmanager</h2>
<p>contextmanager 装饰器可以简化上下文管理器的定义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> contextlib<br><br><span class="hljs-meta">@contextlib.contextmanager </span><span class="hljs-comment"># 该装饰器会将 looking_glass 函数包装成带有 enter 和 exit 方法的类</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">looking_glass</span>():<br>	<span class="hljs-keyword">import</span> sys<br>    original_write = sys.stdout.write <br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse_write</span>(<span class="hljs-params">text</span>): <br>    	original_write(text[::-<span class="hljs-number">1</span>])<br>        <br>    sys.stdout.write = reverse_write <br>    msg = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>    	<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;JABBERWOCKY&#x27;</span> <span class="hljs-comment"># 这里 yield 起到了类似分隔的作用，enter 执行到这里，后面由 exit 执行</span><br>    <span class="hljs-keyword">except</span> ZeroDivisionError:<br>        msg = <span class="hljs-string">&quot;Please DO NOT divide by zero&quot;</span><br>    <span class="hljs-keyword">finally</span>:<br>        sys.stdout.write = original_write<br>        <span class="hljs-keyword">if</span> msg:<br>            <span class="hljs-built_in">print</span>(msg)<br></code></pre></td></tr></table></figure>
<p>个人感觉所谓的上下文管理器，本质上也像是一个实现了约定协议的鸭子类型，只要按照协议实现 enter 和 exit 方法即可；</p>
<h1 id="%E7%AC%AC16%E7%AB%A0-%E5%8D%8F%E7%A8%8B" tabindex="-1">第16章 协程</h1>
<p>yield 单词本身有两个意思，一个是生成，一个是退让；这两个意思刚好是协程的描述；</p>
<p>当 yield 放在表达式的左边时，它做为生成器使用；</p>
<p>当 yield 放在表达式的右边时，它做为协程使用，等待传入值；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">simple_coroutine</span>(): <span class="hljs-comment"># ➊</span><br><span class="hljs-meta">... </span>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; coroutine started&#x27;</span>)<br><span class="hljs-meta">... </span>	x = <span class="hljs-keyword">yield</span> <span class="hljs-comment"># yield 右边没有值，意味着它生成 None</span><br><span class="hljs-meta">... </span>	<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; coroutine received:&#x27;</span>, x)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine()<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_coro <span class="hljs-comment"># 生成器已经创建，但是还没有启动，需要通过 next 让它启动</span><br>&lt;generator <span class="hljs-built_in">object</span> simple_coroutine at <span class="hljs-number">0x100c2be10</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(my_coro) <span class="hljs-comment"># 通过 next 来启动生成器</span><br>-&gt; coroutine started<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_coro.send(<span class="hljs-number">42</span>) <span class="hljs-comment"># 给 yield 传值，仅当协程处于暂停状态时，才能够给它传值</span><br>-&gt; coroutine received: <span class="hljs-number">42</span><br>Traceback (most recent call last): <span class="hljs-comment"># ➏</span><br>...<br>StopIteration<br></code></pre></td></tr></table></figure>
<p>协和在 yield 关键字所在的位置暂停执行</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311816737.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>使用协程重新设计平均值计算器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>():<br>    total = <span class="hljs-number">0.0</span><br>    count = <span class="hljs-number">0</span><br>    average = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: <span class="hljs-comment"># 永远不会停止，可以无限计算平均值</span><br>        term = <span class="hljs-keyword">yield</span> average <span class="hljs-comment"># 等待外部传入值，外部每传一次，就计算一次总体平均值</span><br>        total += term<br>        count += <span class="hljs-number">1</span><br>        average = total/count<br>        <br><span class="hljs-comment"># 以下是使用示例</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>coro_avg = averager() <span class="hljs-comment"># 创建</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(coro_avg) <span class="hljs-comment"># 激活</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="hljs-number">10</span>) <span class="hljs-comment"># 传值</span><br><span class="hljs-number">10.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="hljs-number">30</span>)<br><span class="hljs-number">20.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="hljs-number">5</span>)<br><span class="hljs-number">15.0</span><br></code></pre></td></tr></table></figure>
<p>使用协程时，经常容易忘记要先激活它。为了避免这种错误，可考虑定义一个帮忙激活的装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">coroutine</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;定义一个装饰器：帮忙预激`func`&quot;&quot;&quot;</span><br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">primer</span>(<span class="hljs-params">*args,**kwargs</span>): ➊<br>        gen = func(*args,**kwargs) ➋<br>        <span class="hljs-built_in">next</span>(gen) <span class="hljs-comment"># 激活</span><br>        <span class="hljs-keyword">return</span> gen ➍<br>    <span class="hljs-keyword">return</span> primer<br></code></pre></td></tr></table></figure>
<p>在调用生成器的 send 函数时，如果给它传递的参数类型有误，会导致它抛出异常，从而终止协程；</p>
<p>生成器有一个 throw 方法可用于触发异常；如果生成器内部有处理异常的代码，则执行；如果没有，则冒泡；</p>
<p>生成器还有一个 close 方法可用于抛出 exit 异常</p>
<h2 id="yield-from-1" tabindex="-1" id="yield-from-2">yield from</h2>
<p>yield from 带来了双向通讯机制，貌似可用来实现异步编程；先定义生成器，然后激活它；之后向它发送数据；当数据处理完成后，会触发异常，获得处理结果；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>Result = namedtuple(<span class="hljs-string">&#x27;Result&#x27;</span>, <span class="hljs-string">&#x27;count average&#x27;</span>)<br><br><span class="hljs-comment"># 子生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">averager</span>(): <br>    total = <span class="hljs-number">0.0</span><br>    count = <span class="hljs-number">0</span><br>    average = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        term = <span class="hljs-keyword">yield</span> <span class="hljs-comment"># 感觉此处有点像是一个点位符，等待外部传值进来，或许应该叫 await</span><br>        <span class="hljs-keyword">if</span> term <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># 当外部传 None 进来时，就中断退出循环</span><br>        	<span class="hljs-keyword">break</span><br>        total += term<br>        count += <span class="hljs-number">1</span><br>        average = total/count<br>    <span class="hljs-keyword">return</span> Result(count, average) <span class="hljs-comment"># 中断循环后，返回计算结果</span><br><br><span class="hljs-comment"># 委托生成器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grouper</span>(<span class="hljs-params">results, key</span>):<br>    <span class="hljs-comment"># 这里为什么要循环？</span><br>    <span class="hljs-comment"># 答：为了不断接收外面传进来的值</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>: <br>        <span class="hljs-comment"># 关键字 yield from 默认会让当前函数返回一个生成器，可惜这个关键字很不直观</span><br>        <span class="hljs-comment"># send 传进来的值，会通过传入 averager，yield from 有点像管道的作用</span><br>        results[key] = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> averager()  <span class="hljs-comment"># 这里的 yield from 很像 await</span><br>        <br><span class="hljs-comment"># 客户端（调用方）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">data</span>):<br>    results = &#123;&#125;<br>    <span class="hljs-keyword">for</span> key, values <span class="hljs-keyword">in</span> data.items():<br>        group = grouper(results, key) <span class="hljs-comment"># grouper 返回生成器</span><br>        <span class="hljs-built_in">next</span>(group) <span class="hljs-comment"># 预激活 # 激活后，开始进入 while 循环，在 yield from 处暂停</span><br>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:<br>            group.send(value) <span class="hljs-comment"># send 将值传给 averager，开始与内部的子生成器通讯</span><br>        group.send(<span class="hljs-literal">None</span>) <span class="hljs-comment"># 传入None，中断子生成器，让委托生成器获得结果</span><br>    <span class="hljs-built_in">print</span>(results)<br></code></pre></td></tr></table></figure>
<p>yield from 跟 await 有一个很大的不同，即 yield from 在将工作做到一半后，将控制权还给调用者，由调用者做剩下的工作；</p>
<blockquote>
<p>据说  python 后来引入了 await</p>
</blockquote>
<h1 id="%E7%AC%AC19%E7%AB%A0-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B" tabindex="-1">第19章 并发模型</h1>
<p>协程: coroutine，一个可以暂停并重新运行自己的函数；</p>
<p>协程的特点在于可以通过关键字，标识出异步的位置，然后交出控制权，让主程序的其他部分获得控制权；自己则进入队列，等待异步的代码执行完毕；改变自己状态，等待被唤醒，继续运行自己余下部分的代码；</p>
<blockquote>
<p>没想到 Python 有一个全局锁（GIL），每次只允许一个线程占有，那这就意味着 python 无法同时利用多核的优势好像，除非起多个进程，就像 js 的 cluster 一样；</p>
<p>Python 解释器每隔一定的时间（貌似是 5ms），会释放 GIL，以便其他线程能够获取锁；另外，任意一个函数在调用 syscall 时，它都会释放 GIL；</p>
</blockquote>
<blockquote>
<p>书里面的 spinner 案例，看起来很奇怪，因为协程的结束，竟然是由调用者的代码发起的，跟 js 好像不太一样；但是 await 貌似是一样的；</p>
<p>后来发现，协程也可以自己结束，不需要外部让它结束；书上的案例只是示范说可以主动干预。但其实正常使用场景是不干预，让它自行运行结束，返回结果；</p>
<p>问：好奇有无可能用装饰器，将非协程的代码，包装成协程代码？答：想了一下，虽然可能，但是由于非协程代码里面，在遇到 I/O 任务时，没有使用 await 交出控制权，该协程貌似可能会卡在那里等待；</p>
<p>协程能够起作用，貌似重点在于每次遇到 I/O 任务时，要主动交出控制权；在 js 里，很多库都是默认异步编写的，因此不容易忘记这个事情。但是在 python 里面，很多库并非天生异步，例如常用的 requests，此时很有必要提高警惕；</p>
<p>当协程获得控制权，处于运行中的状态时，它是无法被取消的。因为只有一个线程，当它在运行时，意味着想要取消它的代码并没有在运行；仅当协程位于队列中，处于等待状态时，才有可能被取消；此时取消它的代码有可能获得了控制权；</p>
</blockquote>
<p>asyncio.run() 函数，做为所有协程运行代码的入口；</p>
<p>asyncio.create_task()，在当前协程中，创建一个新的协程；可基于返回的 task 对象，对新建的协程进行控制；</p>
<p>await coro()，调用 coro，并同步等待它返回结果；</p>
<p>调用 coro() 时，并不意味着 coro 的代码会马上执行，而只是表示将它加入了队列，实际的执行时间取决于事件循环的高度器；</p>
<p>跟 js 一样，await 关键字必须用在 async 定义的函数中；当函数用 async 定义时，它是一个协程；每次对该函数的调用，都是都它加入事件循环的队列中；而 await 表示交给当前协程对 CPU 的使用，即停止运行，让调度器去运行其他协程；等 await 的事件结束时，调度器会重新安排它运行；</p>
<h2 id="gil-%E7%9A%84%E7%9C%9F%E5%AE%9E%E5%BD%B1%E5%93%8D" tabindex="-1" id="GIL-的真实影响">GIL 的真实影响</h2>
<p>各种处理网络请示的库，如 requests，在发起请示后，会释放当前线程的 GIL，以便其他线程可以抢占；但如果只有一个线程，那么抢占并没有意义。仅在多线程时，抢占才有意义；而且即使抢占成功，后续 requests 仍然会再次被分配 GIL，但此时它有可能仍然还没有取得响应，因此会浪费掉一些性能；但总的来说，多线程有助于提高 I/O 的并发处理能力；但不适用于 CPU 密集型的任务，性能反而变差，因为 CPU 不断在多个线程之间切换，但每次只运行一个线程，最终的性能还不如顺序执行来得快；</p>
<p>另外还有一些库的设计是异步的，但如果当前的代码不是 async 的话，貌似也无法使用 await 来交出控制权？</p>
<blockquote>
<p>当处理计算密集型任务，因为 GIL 的存在，多线程是没有意义的，因为每次只有一个线程在工作；反而不如使用单线程来得简单和高效；如果有多核，则可以考虑使用多进程模式来提高效率；</p>
</blockquote>
<h1 id="%E7%AC%AC20%E7%AB%A0-concurrent-executors" tabindex="-1">第20章 Concurrent Executors</h1>
<p>concurrent.futures 库里面，有两个类，分别是 ThreadPoolExecutor 和 ProcessPoolExecutor，它们可以很方便的使用线程或者进程来实现并发；</p>
<p>对使用者来说，背后的线程或进程是透明的，它会自动开启多线程或进程，同时创建任务队列，收集各线程的处理结果；</p>
<p>Python 里面的 futures 有点像 js 里面的 promise；但 futures 一般不直接创建，而是交由框架来创建；开发者可以在更高的抽象维度来使用它，这样可以避免错误使用；</p>
<p>future.done() 方法可用来查询是否计算完成了，但更常见的做法是不查询，而是等待通知，即完成后，调用回调函数即可；</p>
<p>future 有个 add_done_callback 方法，它接受一个回调函数做为参数；注意：该回调函数，将在运行该 future 的线程或进程中直接运行；</p>
<p>future.result() 方法可用于获取计算结果；但 concurrency 和 asyncio 两个库对方法的实现有所不同；concurrency 调用 result 方法时，会造成堵塞，等待结果的返回；同时支持 timeout 参数，超时未返回时，会抛出异常；asyncio 则不支持 timeout 方法，但支持 await 关键字，这样不会造成堵塞；</p>
<p>concurrency 还有一个 as_completed 方法，专门用来读取 result，以避免堵塞，</p>
<p>executor.map() 主要用于一个函数，并发处理多个不同的参数</p>
<p>executor.submit() 则更灵活一些，多个不同的函数，并处理各自不同的参数；最后通过 as_completed 方法收集计算结果；</p>
<h1 id="%E7%AC%AC21%E7%AB%A0-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B" tabindex="-1">第21章 异步编程</h1>
<blockquote>
<p>虽然可以通过 async def 来定义异步函数，但是如果函数体中包含一些非异步的操作，比如将文件写入本地，貌似该同步操作有可能会造成堵塞，占用整个线程，直到写入成功？经查证，发现确实如此，在异步函数中，只要有任意一个函数是非异步阻塞的，将导致整个调用链都是阻塞的；</p>
</blockquote>
<h1 id="%E5%85%B6%E4%BB%96" tabindex="-1">其他</h1>
<p>海象符 :=，为了省写一行代码，先检查，确认有值后，再赋值；没值的话，就不赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 没有海象符的时候</span><br>name = abc.get(<span class="hljs-string">&quot;name&quot;</span>)<br><span class="hljs-keyword">if</span> name:<br>    <span class="hljs-comment"># doA</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># doB</span><br>    <br>    <br><span class="hljs-comment"># 有海象符后</span><br><span class="hljs-keyword">if</span> name := abc.get(<span class="hljs-string">&quot;name&quot;</span>):<br>    <span class="hljs-comment"># doA</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># doB</span><br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" class="category-chain-item">计算机</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/python/" class="print-no-link">#python</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>流畅的Python</div>
      <div>https://ccw1078.github.io/2017/07/25/流畅的Python/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ccw</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2017年7月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/08/14/jQuery/" title="jQuery">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">jQuery</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/07/15/%E5%BD%B1%E5%93%8D%E5%8A%9B/" title="影响力">
                        <span class="hidden-mobile">影响力</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
