<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 7 | Ccw&#39;s Blogs</title>

  
  <meta name="author" content="ccw">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Ccw&#39;s Blogs"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Ccw&#39;s Blogs" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Ccw&#39;s Blogs</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/11/12/网络是怎样连接的/"><span>网络是怎样连接的</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/11/12/网络是怎样连接的/" rel="bookmark">
        <time class="entry-date published" datetime="2017-11-12T09:01:38.000Z">
          2017-11-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211202084609.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211202085608.png"></p>
<h1 id="浏览器生成消息"><a href="#浏览器生成消息" class="headerlink" title="浏览器生成消息"></a>浏览器生成消息</h1><h2 id="生成-HTTP-请求消息"><a href="#生成-HTTP-请求消息" class="headerlink" title="生成 HTTP 请求消息"></a>生成 HTTP 请求消息</h2><h3 id="从输入网址开始"><a href="#从输入网址开始" class="headerlink" title="从输入网址开始"></a>从输入网址开始</h3><p>URL 网址开头部分为协议，常见协议有：</p>
<ul>
<li>http：访问远程 Web 服务器，例如：<a target="_blank" rel="noopener" href="http://user:password@www.glass.com/dir/file1.html%EF%BC%8C%E6%B3%A8%E6%84%8F">http://user:password@www.glass.com:80/dir/file1.html，注意</a> URL 中可携带用户名和密码，一般都为可省略</li>
<li>ftp：下载或上传文件；同样可以携带用户名和密码（可省略）；</li>
<li>file：读取本地文件；</li>
<li>mailto：发送电子邮件；例如：mailto:<a href="mailto:&#116;&#111;&#x6e;&#x79;&#64;&#x67;&#108;&#x61;&#x73;&#x73;&#46;&#99;&#x6f;&#x6d;">&#116;&#111;&#x6e;&#x79;&#64;&#x67;&#108;&#x61;&#x73;&#x73;&#46;&#99;&#x6f;&#x6d;</a>，冒号后的部分为邮件地址；</li>
<li>news：阅读新闻组的文章，例如：news: comp.protocols.tpc-ip，冒号后的部分为新闻组名称；</li>
</ul>
<h3 id="浏览器先解析-URL"><a href="#浏览器先解析-URL" class="headerlink" title="浏览器先解析 URL"></a>浏览器先解析 URL</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211203074549.png"></p>
<h3 id="省略文件名的情况"><a href="#省略文件名的情况" class="headerlink" title="省略文件名的情况"></a>省略文件名的情况</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.lab.glass.com/dir/%EF%BC%8C%E6%9C%AB%E5%B0%BE%E6%9C%89%E6%96%9C%E6%9D%A0%EF%BC%8C%E4%BD%86%E6%B2%A1%E6%9C%89%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%8C%E5%9B%A0%E6%AD%A4%E8%AE%BF%E9%97%AE%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%80%E8%88%AC%E5%90%8D%E7%A7%B0%E4%B8%BA">http://www.lab.glass.com/dir/，末尾有斜杠，但没有文件名，因此访问目录中的默认文件，一般名称为</a> index.html 或者 default.html；</li>
<li><a target="_blank" rel="noopener" href="http://www.lab.glass.com/dir%EF%BC%8C%E6%9C%AB%E5%B0%BE%E6%B2%A1%E6%9C%89%E6%96%9C%E6%9D%A0%EF%BC%8C%E5%85%88%E5%B0%86">http://www.lab.glass.com/dir，末尾没有斜杠，先将</a> dir 作为文件名来处理，如果找不到，再将其当作目录名来处理；</li>
</ul>
<h3 id="HTTP-的基本思路"><a href="#HTTP-的基本思路" class="headerlink" title="HTTP 的基本思路"></a>HTTP 的基本思路</h3><p>HTTP 是发送数据的一种报文格式规范，由报头和消息体两部分组成，报头是必须的，消息体根据情况是可选的；消息体的格式可以有很多种，以支持不同形式的数据，格式在头部的 content-type 字段中备注；</p>
<p>报头由必要的请求行（首行）和一些可选的字段组成。首行的信息有：</p>
<ul>
<li>方法：GET，POST，PUT 等；</li>
<li>URI：资源路径，例如 &#x2F;dir&#x2F;file.html；</li>
<li>协议版本：例如 HTTP1.1</li>
</ul>
<h3 id="生成-HTTP-请求消息-1"><a href="#生成-HTTP-请求消息-1" class="headerlink" title="生成 HTTP 请求消息"></a>生成 HTTP 请求消息</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211203075657.png"></p>
<h3 id="发送请求后会收到响应"><a href="#发送请求后会收到响应" class="headerlink" title="发送请求后会收到响应"></a>发送请求后会收到响应</h3><p>响应的格式和请求基本一致，也是由报头+可选的消息体组成，报头由响应行+可选的头字段组成；响应行由协议版本+状态码+说明组成，例如 HTTP&#x2F;1.1 200 OK；</p>
<h2 id="向-DNS-服务器查询-Web-服务器的-IP-地址"><a href="#向-DNS-服务器查询-Web-服务器的-IP-地址" class="headerlink" title="向 DNS 服务器查询 Web 服务器的 IP 地址"></a>向 DNS 服务器查询 Web 服务器的 IP 地址</h2><h3 id="IP-地址的基本知识"><a href="#IP-地址的基本知识" class="headerlink" title="IP 地址的基本知识"></a>IP 地址的基本知识</h3><p>整个互联网实际上是由各种小的局域网组成的。每个小的局域网络通过一台路由器对外发放和接受数据，内部则由路由器为各终端设备分配内部 IP 地址进行管理；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211204123954.png"></p>
<h3 id="域名和-IP-地址并用的理由"><a href="#域名和-IP-地址并用的理由" class="headerlink" title="域名和 IP 地址并用的理由"></a>域名和 IP 地址并用的理由</h3><p>IP 地址不好记，而且同一个网站可能会有多个 IP 地址，同时由于设备的宕机和维护，IP 地址还会变动，因此使用人们更容易记住的域名来访问网站是一种更加健壮的方案；</p>
<h3 id="Socket-库提供查询-IP-地址的功能"><a href="#Socket-库提供查询-IP-地址的功能" class="headerlink" title="Socket 库提供查询 IP 地址的功能"></a>Socket 库提供查询 IP 地址的功能</h3><p>操作系统内置的 socket 库提供了查询 IP 地址的功能，这样应用程序只需直接调用该库的功能，即可将域名解析成 IP 地址；</p>
<h3 id="通过解析器向-DNS-服务发出查询"><a href="#通过解析器向-DNS-服务发出查询" class="headerlink" title="通过解析器向 DNS 服务发出查询"></a>通过解析器向 DNS 服务发出查询</h3><p>由于 socket 是使用 C 语言编写的，让它被调用时，实际的过程是预先分配一段内部，用来存储后续的结果，然后解析器向 DNS 服务器发出请求，并在得到解析结果后，将其写入预先分配的内存地址中；</p>
<blockquote>
<p>域名解析：resolution，解析器：resolver</p>
</blockquote>
<h3 id="解析器的内部原理"><a href="#解析器的内部原理" class="headerlink" title="解析器的内部原理"></a>解析器的内部原理</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211204124608.png"></p>
<p>DNS 服务器的地址可以有多个来源，例如：</p>
<ul>
<li>由 ISP 运营商提供；</li>
<li>由用户手工在路由器中提供；</li>
<li>由用户手工在网卡的属性中进行设置；</li>
</ul>
<h2 id="全世界-DNS-服务器的大接力"><a href="#全世界-DNS-服务器的大接力" class="headerlink" title="全世界 DNS 服务器的大接力"></a>全世界 DNS 服务器的大接力</h2><h3 id="DNS-服务器的基本工作"><a href="#DNS-服务器的基本工作" class="headerlink" title="DNS 服务器的基本工作"></a>DNS 服务器的基本工作</h3><p>DNS 服务器的工作本质即使就是维护一张域名和 IP 地址的映射记录表。当收到一个域名解析请求后，就在表中分组查询询对应类型的 IP 地址。如果找不到，就将请求转发给下级域名的服务器进行查找；</p>
<blockquote>
<p>注意：这里有一个很重要的点，即 DNS 服务器的解析是分级。不同级的映射记录有可能存储在同一台服务器上面，也有可能存储在不同的服务器上面；另外解析记录还区分类型，例如 A 类型，MX 邮件类型，CNAME 别名类型等；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211204125244.png"></p>
<h3 id="域名的层次结构"><a href="#域名的层次结构" class="headerlink" title="域名的层次结构"></a>域名的层次结构</h3><p>域名是分层次的，每一层使用点号隔开，例如 <a target="_blank" rel="noopener" href="http://www.baidu.com.cn,其中/">www.baidu.com.cn，其中</a> cn 是国家级别的域名，com 是商业类型域名，baidu 则是域名申请者的自定义名称，www 是域名申请者的内部子域名；</p>
<h3 id="寻找相应的-DNS-服务器并获取-IP-地址"><a href="#寻找相应的-DNS-服务器并获取-IP-地址" class="headerlink" title="寻找相应的 DNS 服务器并获取 IP 地址"></a>寻找相应的 DNS 服务器并获取 IP 地址</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211204125537.png"></p>
<h3 id="通过缓存加快-DNS-服务器的响应"><a href="#通过缓存加快-DNS-服务器的响应" class="headerlink" title="通过缓存加快 DNS 服务器的响应"></a>通过缓存加快 DNS 服务器的响应</h3><p> 为了加快响应速度，一般 DNS 服务器上面有会缓存机制，将最近的查询结果缓存起来，这样再收到相同的解析请求时，就可以立即返回结果，而无须再次对外发起请求了；</p>
<h2 id="委托协议栈发送消息"><a href="#委托协议栈发送消息" class="headerlink" title="委托协议栈发送消息"></a>委托协议栈发送消息</h2><h3 id="数据收发操作概览"><a href="#数据收发操作概览" class="headerlink" title="数据收发操作概览"></a>数据收发操作概览</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211204130819.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211204130912.png"></p>
<h3 id="创建套接字阶段"><a href="#创建套接字阶段" class="headerlink" title="创建套接字阶段"></a>创建套接字阶段</h3><p>套接字本质上其实是一个存在于内存中的对象，该对象有多个字段，每个字段存放着管理连接的有关信息，例如 IP 地址、连接状态等；因为网络在本质上是不可靠的，数据在传输过程中会出现丢失或中断，因此需要在本地记录当前的连接状态，这样当发生意外时，仍然能够正常工作；</p>
<p>当应用程序调用 socket 库创建套接字后，被调用的函数会返回一个文件描述符，用来代表该套接字对象，这样应用程序后续的操作，都可以向读写文件一样，与套接字对象进行交互；</p>
<h3 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h3><p>‘连接’相对当于客户端和服务器之间的一种准备工作，对方交换一下必要的信息和状态，例如起始字节等；交换成功后，即表示网络是畅通的，并进入了可通信的阶段；</p>
<blockquote>
<p>由于套接字返回的文件描述符是本地的，因此无法在本机之外使用。因此需要使用端口号来解决这个问题，因为一台机器上，不管是本地计算机，还是远程服务器，正常都会有多个应用程序进行互联网通信，因此需要使用端口号机制来区分不同的应用程序；</p>
</blockquote>
<h3 id="通信阶段"><a href="#通信阶段" class="headerlink" title="通信阶段"></a>通信阶段</h3><p>当连接成功后，应用程序即可调用 socket 库中的 write 函数，将数据写入套接字返回的文件描述符，并使用 read 函数远程服务器返回的响应；</p>
<h3 id="断开阶段"><a href="#断开阶段" class="headerlink" title="断开阶段"></a>断开阶段</h3><p>当客户端收到服务器返回的响应后，本次连接即告结束，但这时不一定马上调用 close 函数断开连接，有两方面的原因：</p>
<ul>
<li>有可能在返回的响应中，发现需要额外的请求数据，例如网页上的图片；</li>
<li>有可能应用程序没有马上读取返回的数据，如果马上释放文件描述符，又恰好被操作系统分配给了另外的应用程序，会导致原应用程序无法读取到数据，或者其他应用程序读取到本不属于自己的数据；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211202211700.png"></p>
<h1 id="用电信号传输-TCP-IP-数据"><a href="#用电信号传输-TCP-IP-数据" class="headerlink" title="用电信号传输 TCP&#x2F;IP 数据"></a>用电信号传输 TCP&#x2F;IP 数据</h1><h2 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h2><h3 id="协议栈的内部结构"><a href="#协议栈的内部结构" class="headerlink" title="协议栈的内部结构"></a>协议栈的内部结构</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211204132441.png"></p>
<h3 id="套接字的实体就是通信控制信息"><a href="#套接字的实体就是通信控制信息" class="headerlink" title="套接字的实体就是通信控制信息"></a>套接字的实体就是通信控制信息</h3><p>套接字的本质就是内存中存放着的一段类似对象的数据结构，该数据结构保存着控制整个连接的各项重要信息，例如连接的源地址、目标地址、端口号、各种连接状态等；各个 socket 函数在需要的时候，就会从该对象读取所需要的信息，来完成自身的工作。并在工作完成后，改写信息，标记最新的状态；</p>
<h3 id="调用-socket-时的操作"><a href="#调用-socket-时的操作" class="headerlink" title="调用 socket 时的操作"></a>调用 socket 时的操作</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211202203557.png"></p>
<h2 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h2><h3 id="连接是什么意思"><a href="#连接是什么意思" class="headerlink" title="连接是什么意思"></a>连接是什么意思</h3><p>所谓连接实际是在做建立通信的初始化动作，这些动作包括准备好发送方和接收方的 IP 地址、端口号、状态、内存分配、MAC 地址等事宜；</p>
<h3 id="负责保存控制信息的头部"><a href="#负责保存控制信息的头部" class="headerlink" title="负责保存控制信息的头部"></a>负责保存控制信息的头部</h3><p>TCP 协议报文的头部数据来源于在上一步的连接阶段初始化好的那些数据（存放在 socket 对象中），主要字段如下：</p>
<ul>
<li>发送方的端口号：16bit</li>
<li>接收方的端口号：16bit</li>
<li>序号：32bit，告知对方当前发送的数据包在所有数据包中的序号；</li>
<li>ACK 号：32bit，告知对方已经收到哪个序号的包了，因此一般是接收方发给发送方才使用；</li>
<li>数据偏移量：4bit，告知对方主体数据在当前数据包的起始位置，因此变相也是头部的长度；</li>
<li>保留字段：6bit</li>
<li>控制位：6bit，告知对方连接指令，包括<ul>
<li>RST：告知对方将强制断开连接</li>
<li>SYN：告知对方将建立连接；</li>
<li>FIN：告知对方将断开连接；</li>
</ul>
</li>
<li>窗口：16bit，告知对方当前可用窗口大小；</li>
<li>校验和：16bit，方便对方检查数据是否有错误</li>
<li>紧急指针：16bit，告知对方应紧急处理的数据位置（说实话暂时不知道有啥使用场景）；</li>
<li>可选字段：长度不固定，较少使用；</li>
</ul>
<h3 id="连接操作的实际过程"><a href="#连接操作的实际过程" class="headerlink" title="连接操作的实际过程"></a>连接操作的实际过程</h3><ul>
<li>客户端的 TCP 模块从 socket 对象中读取需要的值，组成 TCP 报文头部。之后由 IP 模块接手，添加 IP 报文头部，最后交给网卡驱动程序，将数据转成电信号发送出去（此阶段会告知服务端自己的 ACK 序号初始值和窗口大小）。</li>
<li>服务端的网卡驱动程序接收到电信号，转成数据后交给 IP 模块解析出 TCP 报文，之后再转给 TCP 进一步解析出数据；服务端按相同的方式发送报文给客户端（此阶段会告知客户端自己的 ACK 序号初始值和窗口大小）；</li>
<li>客户端收到后，将 socket 对象中的 syn 字段值更新为 1，表示客户端到服务端的通信建立成功；并再次发送 ACK 报文给服务端；</li>
<li>服务端收到后，也将其 socket 对象中的 syn 字段值更新为1，表示服务端到客户端的通信建立成功；</li>
</ul>
<h2 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h2><h3 id="将-HTTP-请求消息交给协议栈"><a href="#将-HTTP-请求消息交给协议栈" class="headerlink" title="将 HTTP 请求消息交给协议栈"></a>将 HTTP 请求消息交给协议栈</h3><p>协议栈并不关心所要发送的内容是什么，无论内容是什么，都看作是一定长度的二进制序列即可；</p>
<p>由于协议栈无法预知应用程序是一次性将数据全部给过来，还是分多次给。因此，在收到数据后，它不一定马上将数据发送出去，而是先将数据放到缓冲区中，然后根据情况来处理；</p>
<ul>
<li>如果收到的数据大于或接近包的最大数据容量（MSS，MTU 扣减头部后的值），则马上将数据发出去，因为多等也无意义；</li>
<li>如果收到的数据小于包的最大容量，则看一下计时器，是否超过了最长可等待时间：<ul>
<li>如果没超过，就再等等；</li>
<li>如果超过了，就把包发出去，即使还没有满；</li>
</ul>
</li>
</ul>
<p>由于应用程序对自己的数据最了解，而栈议栈并不了解，因此协议栈提供了参数选项，应用程序可传递参数给协议栈，告知其准确高效的发送办法；</p>
<h3 id="对较大的数据进行拆分"><a href="#对较大的数据进行拆分" class="headerlink" title="对较大的数据进行拆分"></a>对较大的数据进行拆分</h3><p>当所要发送的数据超过了 MSS 时，就需要对包进行拆分，为每个包加上必要的头部信息，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211207065512.png"></p>
<h3 id="使用-ACK-号确认网络包已收到"><a href="#使用-ACK-号确认网络包已收到" class="headerlink" title="使用 ACK 号确认网络包已收到"></a>使用 ACK 号确认网络包已收到</h3><p>数据包发送出去后，发送方的事情并没有就到此结束，它还需要确认对方是否已经收到；如果没有收到，需要重新发送，直到对方收到为止；</p>
<p>为了让接收方知道当前数据包的序号，发送方会将当前包中数据在完整数据中的偏移量放在头部中，作为序号信息，这样接收方收到该包后，马上就知道这段数据，应该放置在整体数据的具体位置；另外，由于头部中还有一个字段是记录当前数据包的头部长度的，因此接收方也能够很快速的知道从数据包中的哪个具体位置开始读取数据；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211207070602.png"></p>
<h3 id="根据网络包平均往返时间调整-ACK-号等待时间"><a href="#根据网络包平均往返时间调整-ACK-号等待时间" class="headerlink" title="根据网络包平均往返时间调整 ACK 号等待时间"></a>根据网络包平均往返时间调整 ACK 号等待时间</h3><p>发送方需要等待接收方返回 ACK 号，然后再判断是否需要重发。这个等待时间的大小很有讲究，因为太大或太小都需要付出代价；太大的，等待过久，用户体验不好；太小的话，重复发送，导致网络堵塞，最终网络速度变慢，同样用户体验不好；</p>
<p>由于 ACK 的返回速度跟接收方的地理位置有关，理论上双方离得越远，返回的就越慢，因此最好的办法是根据实际情况，动态设置 ACK 等待时间；</p>
<h3 id="使用窗口有效管理-ACK-号"><a href="#使用窗口有效管理-ACK-号" class="headerlink" title="使用窗口有效管理 ACK 号"></a>使用窗口有效管理 ACK 号</h3><p>当有了 ACK 等待时间后，在 ACK 号返回前，如果傻傻的等待，啥事也不做，显然有点浪费资源，因此便产生了滑动窗口的概念。它的意思是根据窗口大小，一次发出一批多个包，然后在收到接收方的 ACK 信号后，再发送下一批；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211207074726.png"></p>
<p>由于接收方为接收数据所分配的缓冲区大小是有上限的，因此当到达的数据过快过多，而数据又未能被及时处理并清空缓冲区的话，就有可能导致缓冲区溢出。为了避免这个情况，接收方会在一开始将自己可用的缓冲区大小告知发送方。发送方在收到该信息后，在不超过该值的情况下，发送合适数量的数据包出去，然后等待接收方下一次告知可用缓冲区大小后，再开始新一轮的发送动作；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211207075419.png"></p>
<blockquote>
<p>虽然这张图显示的好像发送方有等待的情况出现，但在现实情况中，由于接收方的处理速度往往远大于网络速度，因此这种等待的情况不常出现（除非应用程序不来及时取走数据）。接收方在收到数据并清空缓冲区后，发送方的下一个包经常还没有到达，因此接收方发出的窗口大小仍然是完整的大小；</p>
</blockquote>
<h3 id="ACK-与窗口的合并"><a href="#ACK-与窗口的合并" class="headerlink" title="ACK 与窗口的合并"></a>ACK 与窗口的合并</h3><p>如果接收方每次收到包就马上发送 ACK 号，每次缓冲区大小出现变化，就马上发送新的窗口大小，则接收方发送的包数量将大大增加，从而增加网络堵塞的风险。为了降低这种网络，接收方会设置一段等待时间，在该段等待时间内，如果出现多条 ACK 消息和多个窗口消息，则可以将它们合并成一条，这样就可以有效的提高传输效率；</p>
<h3 id="接收-HTTP-响应消息"><a href="#接收-HTTP-响应消息" class="headerlink" title="接收 HTTP 响应消息"></a>接收 HTTP 响应消息</h3><p>应用程序（如浏览器）在发出请求后，会紧接着调用 read 函数从缓冲区中读取数据，但由于数据没有那么快就回来，因此协议栈会先将该操作挂起，等待数据回来后（发触发事件），然后结束挂起，开始读取数据；</p>
<p>在收到数据后，发送方的协议栈所做的事情如下：</p>
<ul>
<li>收到包，开始解析包，检查数据是否完整；</li>
<li>如果完整，给发送方发 ACK 信号；如果不完整，丢弃该包；</li>
<li>将包中的数据暂存到缓冲区，回到第一步，解析下一个包，直到解析完已收到的所有包；</li>
<li>将已到达的多个数据包组装还原成连续的数据，写入应用程序指定的内存地址，清空缓冲区；</li>
<li>给发送方发送新的窗口（可用缓冲区）大小；</li>
</ul>
<h2 id="从服务器断开并删除套接字"><a href="#从服务器断开并删除套接字" class="headerlink" title="从服务器断开并删除套接字"></a>从服务器断开并删除套接字</h2><h3 id="数据发送完毕后断开连接"><a href="#数据发送完毕后断开连接" class="headerlink" title="数据发送完毕后断开连接"></a>数据发送完毕后断开连接</h3><p>断开连接的时机和操作由应用程序（接收和发送的任意一方都可以）来决定的，因为协议栈无法知道什么数据算是发送完了。一般来说，完成发送的一方会断开连接（Web 程序一般是由服务器来断开，因为它最清楚本次请求的数据是否已经发送完毕了，客户端反而不是第一时间知道）；</p>
<p>当服务端想要发起断开连接的操作时，只需调用 socket 库中 的 close 函数，它会生成一个只有头部没有主体的 TCP 数据包，包头部中的 FIN 字段值会设置为 1，表示 FINISH 为 True，然后将该包交给 IP 模块发送出去；</p>
<p>客户端在收到该 FIN 包后，会更新 Socket 对象中的状态字段，以标记为断开状态，然后发一个 ACK 包给服务端，表示自己收到 FIN 包了；</p>
<p>之后当应用程序调用 read 函数来读取数据时，如果缓冲区中有数据，就将数据交给应用程序，直至清空缓冲区 ；如果没有数据，则给应用程序返回信号，告知应用程序数据已经全部接收完毕了，没有更多的数据了。然后应用程序会调用 socket 库的 close 函数，关闭连接。此时客户端会发送一个 FIN 包给服务端；服务端收到该 FIN 包后，会返回一个 ACK 信号；</p>
<h3 id="删除套接字"><a href="#删除套接字" class="headerlink" title="删除套接字"></a>删除套接字</h3><p>当连接断开后，双方的套接字并不会立即删除，而是会保留一段时间后（一般是几分钟）再删除。之所以如此，是为了避免出现异外情况。例如客户端在收到服务端的 FIN 包后，会返回一个 ACK 信号给服务端，但有可能该 ACK 在网络中丢失了。因此过了一段时间服务端会重发一次 FIN 信号。如果客户端在发出 ACK 信号后，即将套接字删除，并将端口分配给一个新的应用程序，则有可能导致该应用程序收到服务端的 FIN 包，导致连接出错；</p>
<h3 id="数据收发操作小结"><a href="#数据收发操作小结" class="headerlink" title="数据收发操作小结"></a>数据收发操作小结</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211207201855.png"></p>
<h2 id="IP-与以太网的包收发操作"><a href="#IP-与以太网的包收发操作" class="headerlink" title="IP 与以太网的包收发操作"></a>IP 与以太网的包收发操作</h2><h3 id="包的基本知识"><a href="#包的基本知识" class="headerlink" title="包的基本知识"></a>包的基本知识</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211207210529.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211207210653.png"></p>
<p>MAC 头部也是由 IP 协议栈来写入的，IP 协议栈将下一个转发设备的 MAC 地址作为 MAC 头部的字段。之后以太网协议根据这个 MAC 头部，就可以知道应该将数据包发给哪台转发设备；因此，在整个传输过程中，MAC 头部的信息是不断变化的，由当前转发设备改写它，改写后的新内容是下一个转发设备的 MAC 地址；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211207211706.png"></p>
<p>转发设备在收到数据包后，会先去掉 MAC 头部，然后查看里面的目的地服务器的 IP 地址，然后基于该 IP 地址，从自己维护的映射表中，找到下一个转发设备的 MAC 地址，然后为数据包添加新的 MAC 头部；</p>
<blockquote>
<p>此处基于以太网来举例，所以用到了 MAC 头部。当数据包在某个非以太网的网络中进行传输时，转发设备就会按照不同的协议规定，为其添加相应的头部，例如无线网、ADSL等，以便该数据包在新的网络中，也可以进行传输。这就是分层的好处，某一层的改变，不会影响到其他层，从而在使用过程中可以非常的灵活，任意的组合，兼容各种使用场景；</p>
</blockquote>
<h3 id="包收发操作概览"><a href="#包收发操作概览" class="headerlink" title="包收发操作概览"></a>包收发操作概览</h3><p>当收到 TCP 数据包后，IP 模块需要为其添加两个头部，分别是 IP 头部（带 IP  地址）和 MAC 头部（带 MAC 地址）；IP 模块并不关心 TCP 包的类型（控制包、数据包）和内容，一视同仁，处理方式完全一样；</p>
<h3 id="生成包含接收方-IP-地址的-IP-头部"><a href="#生成包含接收方-IP-地址的-IP-头部" class="headerlink" title="生成包含接收方 IP 地址的 IP 头部"></a>生成包含接收方 IP 地址的 IP 头部</h3><p>IP 头部主要字段如下：</p>
<ul>
<li>版本号：4 bit，IP 协议版本号，例如 IPv4 还是 IPv6；</li>
<li>头部长度 IHL：4 bit，由于存在可选字段，头部长度是动态的，因此需要有字段来标注长度；</li>
<li>服务类型 ToS：8 bit，包传输的优先级；</li>
<li>总长度：16 bit，整条 IP 消息的总长度；</li>
<li>ID 号：16 bit，用来标识包的编号，类似于序列号；如果包被分片，则所有分片的 ID 号会相同，以便识别它们属于同一个包；</li>
<li>标志 Flag：3 bit，表示当前包是否允许分片，以及是否存在分片；</li>
<li>分片偏移量：13 bit，表示当前分片从整条 IP 消息的起始位置；</li>
<li>生存时间 TTL：8 bit，为了避免出现 网络回环时，包在网络中被无限制的传递下去；每经过一个中转设备，该值就会减 1，当减为 0 后，就不转发该包，而是直接丢弃（貌似该值可用来判断包被转发了多少次？）；</li>
<li>协议号：8 bit，用来表示 TCP、UDP、ICMP 等协议信息；</li>
<li>头部检验和：16 bit，用来数据完整性，据说现在已经弃用；</li>
<li>发送方 IP 地址：32 bit</li>
<li>接收方 IP  地址：32 bit</li>
<li>其他可选字段：很少使用；</li>
</ul>
<blockquote>
<p> IP 地址并非分配给计算机的，而是分配给网卡的，因此一台计算机有多个网卡时，就可以拥有多个 IP 地址；例如笔记本电脑既支持有线连接，也支持无线连接，因此其实它配备了两张网卡，如果两种连接都启用的话，会有两个 IP 地址；</p>
</blockquote>
<p>当计算机拥有多张网卡和多个 IP 时，如果判断数据包应该交给哪张网卡进行转发呢？答案是使用路由表（route table）；路由表中记载着转发规则，其中会有一条通用规则，当其他规则都无法匹配时，就使用该通用规则来转发。通用规则一般表示默认网关，它的目标地址和掩码都是 0.0.0.0；</p>
<p>路由表一般有下面几列：</p>
<ul>
<li>Destination：表示目标地址；</li>
<li>Netmask：表示掩码，用来和 TCP 告知的目标 IP 地址进行掩码计算，再根据计算结果匹配对应的 Destination；</li>
<li>Gateway：表示路由器的 IP 地址；</li>
<li>Interface：表示负责发送数据包的网络接口（即网卡），当匹配成功时，就会在 IP 头部中填写该 Interface 的 IP 地址作为发送方地址，然后将数据包交给该网卡进行发送；发送的目的地即是 Gateway（此处的目的地猜测不是去改写 TCP 包中的目标 IP 地址，而是在 MAC 头部中填写该 Gateway 对应的 MAC 地址）；</li>
<li>Metric：表示线路的传输成本，值越高，表示距离 越远；</li>
</ul>
<blockquote>
<p>IP 模块在给数据包添加 IP 头部和 MAC 头部前，需要先到路由表中查询对应的信息，之后才有办法生成头部；</p>
</blockquote>
<h3 id="生成以太网用的-MAC-头部"><a href="#生成以太网用的-MAC-头部" class="headerlink" title="生成以太网用的 MAC 头部"></a>生成以太网用的 MAC 头部</h3><p>MAC 头部主要有以下几个字段：</p>
<ul>
<li>接收方的 MAC 地址：48 bit，不像 IP 地址有层级结构，整个地址是一个整体，没有层级规律；</li>
<li>发送方的 MAC 地址：48bit，网卡自带的 MAC 地址；</li>
<li>以太类型：表示不同的协议，例如 ARP协议、IPv6 协议、IP 协议、IEEE802.3 协议等；</li>
</ul>
<h3 id="通过-ARP-查询目标路由器的-MAC-地址"><a href="#通过-ARP-查询目标路由器的-MAC-地址" class="headerlink" title="通过 ARP 查询目标路由器的 MAC 地址"></a>通过 ARP 查询目标路由器的 MAC 地址</h3><p>ARP：address resolution protocol，地址解析协议，基于 IP 地址查询相应的 MAC 地址；</p>
<p>ARP 有点类似广播机制，它会向同一子网中的所有设备广播一条查询消息；收到消息的设备，会检查自己的 IP 是否与查询信息匹配，如果匹配，就应答；如果不匹配，就保持沉默；（如果是连接到集线器的话，广播是可以理解的；但好奇如果网卡是连接到路由器而，路由器应该不会广播吧，而是直接返回结果？）</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211208194814.png"></p>
<p>为了避免重复查询，IP 模块使用了 ARP 缓存。每次查询一条新记录后，就将结果保存到缓存中。这样下次查询的时候，先查找一下缓存中的记录，如果能够找到，就不需要对外广播查询了，提高效率；</p>
<p>由于外部的 IP 地址可能是动态变化，同一个 IP 地址，一段时间后，可能绑定到了一台新的设备上面。因此 ARP 缓存中的数据是会失效的。为了规避失效问题，简单粗暴的办法就是每隔一段时间，让删除缓存记录，这样就可以定期更新了；尽管如此，在刷新之前，有可能缓存记录就已经是错的了，这个时候就只能手动删除缓存来解决了；</p>
<blockquote>
<p>添加 MAC 头部的动作理论上也可以交由网卡来完成，但这样会导致网卡（硬件）和网络类型耦合，降低了网卡的通用性，因此设计成由 IP 模块来完成添加 MAC 头部的动作会更加合理；</p>
</blockquote>
<h3 id="以太网的基本知识"><a href="#以太网的基本知识" class="headerlink" title="以太网的基本知识"></a>以太网的基本知识</h3><p>最早的以太网是设计成广播式的，以太网中的各个设备通过一条主干网线连接起来，然后任意一台设备发出的数据包，会传输给所有的设备。收到的数据包的设备检查包中的 MAC 地址是否与自己的相符，如果相符，就处理它；如果不符，就丢弃它；显然，这种方式效率有点低，后来进一步进化，衍生出了交换机。交换机作为中介接收数据包，再将数据包发给匹配的设备，不再广播给所有设备了，这样提高了处理效率；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211208200208.png"></p>
<p>简化来说，以太网可以视作基于 MAC 地址进行相互通讯的一个局域网络；</p>
<h3 id="将-IP-包转换成电或光信号发送出去"><a href="#将-IP-包转换成电或光信号发送出去" class="headerlink" title="将 IP 包转换成电或光信号发送出去"></a>将 IP 包转换成电或光信号发送出去</h3><p>IP 模块完成添加头部的动作后，接下来就需要将数据包交给网卡驱动进行处理了。网卡驱动负责将数据写入到网卡的缓冲区，然后通知网卡内部的 MAC 模块进行发送；MAC 模块收到指令后，从缓冲区读取数据后，交给 PHY 模块转成电信号发送出去；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211208203858.png"></p>
<blockquote>
<p>虽然每张网卡在出厂的时候的内置一个全球唯一的 MAC 地址，但是实际通信过程中不一定会使用它。该地址可由网卡驱动程序从网卡内置的 ROM 中读取，也可以由用户自己设置写入驱动程序，此时会忽略内置的 ROM；</p>
</blockquote>
<h3 id="给网络包再加-3-个控制数据"><a href="#给网络包再加-3-个控制数据" class="headerlink" title="给网络包再加 3 个控制数据"></a>给网络包再加 3 个控制数据</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211208205031.png"></p>
<p>网卡的 MAC 模块从缓冲区读取完数据后，会为它们再次添加三个数据，分别是：</p>
<ul>
<li>报头：56 bit，由 1 和 0 组成的比特序列；这些 1 和 0 序列转成电信号后，会出现特定形状的波形，接收方基于该波形判断什么时候开始读取数据（用来同步双方的时钟周期）；</li>
<li>起始桢分界符 SFD：8 bit， 也是一个特定 1 和 0 组成的序列，接收方在看到该序列时，就知道接下来的部分是主体数据了；</li>
<li>FCS：32 bit，校验和，方便接收方判断所接收到的数据是否完整和正确，用来排除传输过程中的信号干扰；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211208205052.png"></p>
<p>之所以会有波形的概念，然后在于 1 和 0 会被转化成特定的电压和电流，这样电压和电流就会出现变化，形成波；理论上，接收方在收到电信号波后，可以将其还原成 0 和 1。但这里面存在一个问题，当连续出现 1 或 0 的时候，波形没有变化，这个时候就抓瞎了，不知道该段波形中包含几个 1 或 0；</p>
<p>为了能够能够一段没有变化的波形中，包含几个 1 或 0，就需要引入时钟单位，每个时钟单位对应一个比特。这样就可以知道一段没有变化的波形包含几个比特的 1 或 0 了；最简单粗暴的办法，是增加一条线路，将时钟信号也发给接收方。这样接收方就可以根据时钟信号，对另外一条线路中的数据信号进行解读。</p>
<p>但是这又引入了一个新的问题，当有两条线路时，它们很难是一样长度的。随着距离超长，二者的长短误差就会变得越大。大到一定程度时，就会导致时钟偏移（偏左或偏右了），这样最终读取出来的数据就不准确了；</p>
<p>为了解决偏移问题，一个巧妙的办法是将两种信号叠加起来，然后额外告知对方时钟的变化周期，让双方的时钟周期实现同步。这就是报头的作用，报头本质上是一段让接收方获得发送方时钟周期的特殊信号；接收方在收到数据包后，解析报头，获得时钟信号。然后反算出数据信号；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211208205340.png"></p>
<h3 id="向集线器发送网络包"><a href="#向集线器发送网络包" class="headerlink" title="向集线器发送网络包"></a>向集线器发送网络包</h3><p>网卡的 MAC 模块为数据添加头部、分界符和校验值之后，就可以调用 PHY（MAU）模块将数据转成电信号发送出去。日常生活中经常听到的 10M 或 100M 带宽的意思即是每秒种可以将多少数字信号转成电信号；</p>
<blockquote>
<p>集线器的工作方式是半双工的，意思是同一个时刻，要么是发送状态，要么是接收状态，两种状态不能同时存在，有点像对讲机；因此，在给集线器发送信号之前，网卡需要先判断一下当前的线路状态，如果处于空闲就可以发送；如果正在发送上一组信号，或者正在接收信号，则需要等待；当多台设备同时发送信号时，就会出现信号碰撞，导致传输的信号无效。这时检测到碰撞的设备会广播碰撞信号，所有收到广播的设备都会终止发送。然后根据各自的 MAC 地址计算出各自的等待时间，之后再开始发送；</p>
<p>交换机的工作方式是全双工的，接收和发送可以同时发生，因此不会发生信号碰撞的问题，传输效率要高很多，也比较简单；</p>
</blockquote>
<p>MAC 模块转换成的电信号是通用格式，但实际是线路有很多规格，不同规格有不同的电信号模式。因此 PHY 模块需要负责将通用电信号转换成特定类型的电信号。例如 10BASE-T 类型的电信号以变化代表 1，没有变化代表 0，如下图：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211209071038.png"></p>
<h3 id="接收返回包"><a href="#接收返回包" class="headerlink" title="接收返回包"></a>接收返回包</h3><p>包的接收过程和发送过程刚好是反过来的，区别在于 MAC 模块将数据存入缓冲区后，需要发出中断信号，这样 CPU 才会宠幸一下，将控制权转移给中断处理程序，中断处理程序再通知网卡驱动程序，把缓冲区中的数据拿走处理；</p>
<p>网卡驱动程序取到数据后，从 MAC 头部解析出以太网类型（如 0800 表示 TCP&#x2F;IP），然后调用相应的栈议栈（如 TCP&#x2F;IP）对数据包进行处理。协议栈拿到数据后，对头部进行解析，判断消息应该交给哪个应用程序进行处理；</p>
<h3 id="将服务器的响应包从-IP-传递给-TCP"><a href="#将服务器的响应包从-IP-传递给-TCP" class="headerlink" title="将服务器的响应包从 IP 传递给 TCP"></a>将服务器的响应包从 IP 传递给 TCP</h3><p>IP 模块在收到网卡驱动程序的数据包后，会先检查一下这个包是否属于自己（通过比对接收方 IP 地址和当前网卡的 IP 地址是否一致）；如果一致，就接收；如果不一致，就报错；</p>
<p>IP 模块报错的方法是按照 ICMP 协议给发送方发一条 ICMP 消息（类型 3，Destination Unreachable），常见的消息如下：</p>
<ul>
<li>类型0：Echo reply，用来响应类型 8 的 Echo 消息；</li>
<li>类型3：Destination unreachable，告知对方包未送达目的地，中途被丢弃了；例如因为目标 IP 地址不在路由表中、目标端口号没有对应的套接字等；</li>
<li>类型4：Source quench，告知对方收到太多包了，超负荷了，要求对方降低发送速度；</li>
<li>类型5：Redirect，重定向，告知对方正确的发送地址；</li>
<li>类型8：Echo，ping 消息，用来检查一下对方是否存在。如果存在，对方会回个类型 0 的消息；如果没有回，表示不存在；</li>
<li>类型11：Time exceeded，告知对方收到当前数据包时， TTL 已经减为 0 因此包被丢弃了；</li>
<li>类型12： Parameter problem，告知对方头部存在字段错误；</li>
</ul>
<p>有时候 IP 模块还需要做一项“分片重组”的工作。出现这种情况是因为 TCP 数据包比较大，因此需要分成多个小包；这些小包在头部有标记相同的包 ID，同时还有偏移量。因此，IP 模块可以基于这些信息实现重组；</p>
<p>IP 模块完成工作后，会将数据包交给 TCP 模块。TCP 模块会根据接发双方的 IP 地址和端口号，从映射表里面找到对应的套接字，然后根据套接字中的状态，执行不同的操作：</p>
<ul>
<li>如果是数据包，则返回 ACK 消息，并将数据存入缓冲区，等待应用程序来取；</li>
<li>如果是控制包，则按规则执行相应的动作；</li>
</ul>
<blockquote>
<p>注意，由于 TCP 模块需要用到 IP 头部中的信息，因此 IP 模块在将数据包转给 TCP 模块处理时，并没有将 IP 头部去掉，不然 TCP 模块就得不到该数据了；</p>
</blockquote>
<h2 id="UDP-协议的收发操作"><a href="#UDP-协议的收发操作" class="headerlink" title="UDP 协议的收发操作"></a>UDP 协议的收发操作</h2><h3 id="不需要重发的数据用-UDP-发送更高效"><a href="#不需要重发的数据用-UDP-发送更高效" class="headerlink" title="不需要重发的数据用 UDP 发送更高效"></a>不需要重发的数据用 UDP 发送更高效</h3><p>TCP 协议为了保证数据完整到达，建立了一套 ACK 机制，因此整个传输过程相对比较复杂（交换控制信息、交换窗口大小、互发 ACK，互发断开信号等）；但有些场景并不需要确保数据完整到达，例如音频和视频数据，丢几个包也没什么大不了；又或者像 DNS 查询，数据很少，一个包就装得下了，不存在丢失其中一个包的情况；此时就可以使用更加简化的 UDP 协议来传输数据。由于不需要保证每个包都到达，一下子事情就变得简单多了；</p>
<blockquote>
<p>发现发送一段数据，UDP 协议只要一个来回就行了，TCP 要好几个来回，多搞不少事情；</p>
</blockquote>
<h3 id="控制用的短数据"><a href="#控制用的短数据" class="headerlink" title="控制用的短数据"></a>控制用的短数据</h3><p>类似 DNS 查询之类的短数据，就很适合使用 UDP 来通信；UDP 协议有多简单呢，简单到在收到应用程序的消息后，只需要加上 UDP 头部，之后就可以将数据包转给 IP 模块处理了，其他工作统统没有；如果丢包了，只要过一段时间发现没有返回响应，再重发一次就好了；</p>
<p>UDP 头部总共有 8 字节（64 bit），包含以下几个字段：</p>
<ul>
<li>发送方端口：16 bit</li>
<li>接收方端口：16 bit</li>
<li>数据长度：16 bit，头部之后的数据长度，注意这里头部的长度是固定的，但数据部分的长度不固定；</li>
<li>校验和：16 bit</li>
</ul>
<h3 id="音频和视频数据"><a href="#音频和视频数据" class="headerlink" title="音频和视频数据"></a>音频和视频数据</h3><p>由于音频和视频播放场景对丢包的容忍度比较高，但对播放流畅度有要求，因此也很适合使用 UDP 来传输数据；</p>
<blockquote>
<p>有时防火墙会阻止 UDP 协议，因此需要更改规则对 UDP 放行，要么就只能改用 TCP 协议来发送了；</p>
</blockquote>
<h1 id="从网线到网络设备"><a href="#从网线到网络设备" class="headerlink" title="从网线到网络设备"></a>从网线到网络设备</h1><h2 id="信号在网线和集线器中传输"><a href="#信号在网线和集线器中传输" class="headerlink" title="信号在网线和集线器中传输"></a>信号在网线和集线器中传输</h2><h3 id="每个包都是独立传输的"><a href="#每个包都是独立传输的" class="headerlink" title="每个包都是独立传输的"></a>每个包都是独立传输的</h3><p>包从网卡出来后，在网络中的传输过程是只涉及到 MAC 头部和 IP 头部，因此 TCP 头部和内容，都与传输过程无关，因为在传输过程中用不到里面的数据；</p>
<h3 id="防止网线中的信号衰减很重要"><a href="#防止网线中的信号衰减很重要" class="headerlink" title="防止网线中的信号衰减很重要"></a>防止网线中的信号衰减很重要</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211209213236.png"></p>
<p>信号传输的本质其实是在网线上施加正负变化的电压，但是在发送端很清晰准确的电压值，在传输过程中，随着距离加大，会出现衰减，并且也会受到干扰。因此，当信号到达接收端的时候，其波形以及电压值有可能失真。如果失真的程度很大，则会造成信号值解析错误；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211209214055.png"></p>
<h3 id="双绞是为了抑制噪声"><a href="#双绞是为了抑制噪声" class="headerlink" title="双绞是为了抑制噪声"></a>双绞是为了抑制噪声</h3><p>当网线周围存在电磁波时，由于信号线是金属，因此会在信号线上产生电流，叠加到原本的信号电流，导致电流受到干扰出现失真；双绞线的原理，就是让网线不是直的，而是呈螺旋型，这样网线一直在左右两个方向拐来拐去改变方向。而根据电磁波的原理，它会在不同方向的网线上产生方向相反的电流，因此这两部分电流刚好相互抵销；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211209220249.png"></p>
<p>其他降低噪声的措施：</p>
<ul>
<li>在信号线外部包裹金属屏蔽网；</li>
<li>在信号线之间增加隔板；</li>
</ul>
<h3 id="集线器将信号发往所有线路"><a href="#集线器将信号发往所有线路" class="headerlink" title="集线器将信号发往所有线路"></a>集线器将信号发往所有线路</h3><p>以太网最初的设计是广播机制，即信号被广播到所有连接到同一网络的设备，然后由各个设备自行判断当前数据包是否属于自己；是就接收，不是就丢弃；</p>
<p>网线支持全双工，这意味着发送信号和接收信号的线是分工单独运行的，因此当两个设备使用网线进行连接的时候，需要使用交叉接线，不然发送对发送，信号就碰撞了；网卡一般是直线接线（MDI），集线器默认是交叉接线（MDI-X），这样网卡可以用网线直接连接到集线器即可正常工作。但是如果是两台集线器之间，就需要做切换转换，集线器一般自带信号转换开关。开关的作用是将当前接口由默认的 MDI-X 模式转换为 MDI 模式；如果是两台计算机直连，则需要使用交叉网线；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211210070311.png"></p>
<p>集线器的功能非常简单，大部分是使用中断电路，将发送方的信号，原封不动的广播到所有其他设备上面（貌似非常吻合早期的原始场景）；</p>
<h2 id="交换机的包转发操作"><a href="#交换机的包转发操作" class="headerlink" title="交换机的包转发操作"></a>交换机的包转发操作</h2><h3 id="交换机根据地址表进行转发"><a href="#交换机根据地址表进行转发" class="headerlink" title="交换机根据地址表进行转发"></a>交换机根据地址表进行转发</h3><p>交换机比集线器智能一点，不再广播数据包，而是维护一张 MAC 地址和端口的映射表，然后收到数据包里面，从 MAC 头部解析出 MAC 地址，再从映射表中查询到相应的端口，之后将数据包转发给该端口上面的设备即可；</p>
<p>当然，为了得到数据包中的 MAC 地址，交换机也是需要会出不少代价的，它需要做一遍普通网卡需要做的数据包解析工作。因此，可以将每个交换机上面的端口近似看做一张网卡。唯一的不同是交换机端口会接收所有的包，不像网卡会丢弃不属于自己的包；</p>
<blockquote>
<p>网卡支持开启 MIX 模式，在该模式下，网卡会接收所有的包。如果在计算机中安装一个软件对包按 MAC 地址进行转发，那么计算机就可以扮演交换机的功能，相当于”软交换机“；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211210071109.png"></p>
<p>交换机通过交换电路来实现转发。交换电路的原理也非常简单，它通过一个二维的开关网格，来实现输入端和输出端之间的电路连接。通过操控网格中的电子开关，就可以将任意一路输入端和任意一路输出端连接起来；而且可以并发转不同的输入端信号；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211210074559.png"></p>
<h3 id="MAC-地址表的维护"><a href="#MAC-地址表的维护" class="headerlink" title="MAC 地址表的维护"></a>MAC 地址表的维护</h3><p>MAC 地址表的维护涉及两个动作，分别如下：</p>
<ul>
<li>添加：当收到一个数据包时，解析出其中的发送方 MAC 地址后，将其写入地址表，映射到相应的端口号上面；</li>
<li>删除：定期删除记录，以避免设备断开旧端口，切换到新接口；</li>
</ul>
<h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><ul>
<li>当交换机发现某个包的接收方 MAC 地址和发送方 MAC 地址相同时，就会丢弃该包，因为无法实现转发；</li>
<li>当交换机发现某个包的接收方 MAC 地址不在地址表中时，就会在网络中广播这个包；</li>
<li>当交换机发现某个包的接收方 MAC 地址是一个广播地址时，也会广播该包；广播地址有标准格式，即 6 个 FF，或者 IP 地址中的 4 个 255；</li>
</ul>
<h3 id="全双工模式可以同时进行发送和接收"><a href="#全双工模式可以同时进行发送和接收" class="headerlink" title="全双工模式可以同时进行发送和接收"></a>全双工模式可以同时进行发送和接收</h3><p>早期的以太网规范只规定了半双工模式，但显然这种传输方式由于要避免信号碰撞，导致传输效率低下。后来规范进行了更新，开始支持全双工模式；</p>
<blockquote>
<p>为了支持全双工模式，网卡中的 MAC 模块需要由分别负责发送和接收两个独立模块组成；</p>
</blockquote>
<h3 id="自动协商：确定最优的传输速率"><a href="#自动协商：确定最优的传输速率" class="headerlink" title="自动协商：确定最优的传输速率"></a>自动协商：确定最优的传输速率</h3><p>在以太网的连接中，当双方没有传输数据时，线路并不是空闲的，而是会持续发送脉冲信号，用来检测当前线路是否处于正常连接的状态；当连接正常时，网卡上的 LED 指示灯会显示绿色；</p>
<p>早期的脉冲信号很简单，仅用来探测连接正常即可。后来人们利用信号中的偶数位置，来传递有意义的信号，用于双方的工作模式和传输速率自动协商；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211210081736.png"></p>
<h3 id="交换机可同时执行多个转发操作"><a href="#交换机可同时执行多个转发操作" class="headerlink" title="交换机可同时执行多个转发操作"></a>交换机可同时执行多个转发操作</h3><p>由于交换机每次只将数据包转发给特定的端口，其他端口并不会接收到该数据包，因此其他端口也可以同时发送或接收自己的数据，即所有的端口都是可以同时工作的，不像集线器模式下，当某个端口广播数据时，其他端口只能停下来并接收数据；</p>
<h2 id="路由器的包转发操作"><a href="#路由器的包转发操作" class="headerlink" title="路由器的包转发操作"></a>路由器的包转发操作</h2><h3 id="路由器的基本知识"><a href="#路由器的基本知识" class="headerlink" title="路由器的基本知识"></a>路由器的基本知识</h3><p>路由器的核心功能也是包的转发，它与交换机的区别在于，交换机是面向以太网设计的，因此基于 MAC 地址进行转发判断；而路由器是基于互联网设计的，因此它是基于 IP 地址进行转发判断；</p>
<p>路由器主要由两个模块组成，一个是端口模块，一个是转发模块。转发模块负责判断数据包的目的地（类似 IP 模块，基于路由表的查询），端口模块则负责具体收发操作（类似网卡）；</p>
<p>不同的路由器拥有一种或多种端口，可以支持多种不同的网络，例如无线局域网、ADSL、FTTH（光纤）、以太网等；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211210082755.png"></p>
<p>路由器和交换机的一个最大区别在于，交换机只是通过交换电路，帮助收发双方的电路实现连接，它本身并不参与其中。但路由器则不同，它是以独立的中间人身份介入整个收发过程的。发送方和接收方并没有直接互联，而是对接路由器这个中间方；相当于接收方只知道路由器的存在，并没有和发送方直接打交道；为了扮演中间人的作用，路由器上的每个端口都有自己的 IP 地址，而交换机则没有（但也可以有，如果开启 DHCP 功能的话）；</p>
<blockquote>
<p>路由器有点像是一个透明代理</p>
</blockquote>
<h3 id="路由表中的信息"><a href="#路由表中的信息" class="headerlink" title="路由表中的信息"></a>路由表中的信息</h3><p>交换机维护的是 MAC 地址映射表，而路由器维护的则是 IP 地址映射表；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211210083821.png"></p>
<p>10.10.1.0 &#x2F; 255.255.255.0 所表达的含义和 10.10.1.0 &#x2F; 24，是完全相同的，都是用来表示匹配该地址的前 24 个位即可；子网掩码的功能是用来表示需要匹配目标地址多少个位；因此，会存在多种匹配级别，例如前8位、前16位、前24位，前32位等；当为前32位时，由于 IPv4 地址总共也才 32 位，因此已经是全部匹配了，此时一般对应某台具体的主机；</p>
<p>当匹配到某条路由记录后，就可以读取记录中的端口号，用来作为数据包的转发目标；</p>
<p>交换机的 MAC 地址表是由交换机自动维护的，而路由器上的路由表，则同时支持自动维护和手工维护两种模式；自动维护会涉及到路由协议，常见的路由协议有 RIP, OSPC, BGP 等；</p>
<h3 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h3><p>路由器的包接收操作跟普通网卡基本没有区别，如果它发现数据包中的 MAC 地址跟当前端口的 MAC 地址不同，它也会像网卡一样，直接丢弃该包，而不会像交换机那样将包收下来；</p>
<h3 id="查询路由表确定输出端口"><a href="#查询路由表确定输出端口" class="headerlink" title="查询路由表确定输出端口"></a>查询路由表确定输出端口</h3><p>当路由器在路由表中匹配到多条记录时，最长匹配长度的那条记录将胜出，做为转发目标；如果有多条记录匹配的长度相同，那么跃点数最少的那条记录胜出；如果在路由表中查询不到匹配记录，则丢弃该包，并给发送发送一条 ICMP 消息，告知目标 IP 地址有误；</p>
<blockquote>
<p>由于路由表中一般设置有默认匹配路由，所以丢弃包的情况貌似不太容易出现；</p>
</blockquote>
<h3 id="找不到匹配路由时选择默认路由"><a href="#找不到匹配路由时选择默认路由" class="headerlink" title="找不到匹配路由时选择默认路由"></a>找不到匹配路由时选择默认路由</h3><p>默认路由的子网掩码为 0.0.0.0，它表示需要匹配的比特位数量为 0 个，因此相当于匹配所有了；计算机的网卡 IPv4 属性设置中，也有一个默认网关，其实它就是在设置默认路由；</p>
<h3 id="包的有效期"><a href="#包的有效期" class="headerlink" title="包的有效期"></a>包的有效期</h3><p>路由器在转发包的时候，会更新其中数据包头部的 TTL 值，以避免回环；默认值一般为 64 或者 128；</p>
<h3 id="通过分片功能拆分大网络包"><a href="#通过分片功能拆分大网络包" class="headerlink" title="通过分片功能拆分大网络包"></a>通过分片功能拆分大网络包</h3><p>由于路由器支持多种端口，因此可能存在收到的数据包尺寸大于端口能够支持的最大尺寸，此时路由器就需要对包作分片的动作，以便能够将包转发出去；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211211065950.png"></p>
<p>有两种情况不允许分片：</p>
<ul>
<li>头部字段禁止分片；遇到情况会丢弃该包，并发送 ICMP 消息通知发送方；</li>
<li>数据包已经分过片了；</li>
</ul>
<h3 id="路由器的发送操作和计算机相同"><a href="#路由器的发送操作和计算机相同" class="headerlink" title="路由器的发送操作和计算机相同"></a>路由器的发送操作和计算机相同</h3><p>路由在转发数据包时与计算机网卡发送数据包的过程基本相同。唯一的不同点是在计算机上面，网关地址即是目标发送地址，根据该地址查询 MAC 地址并添加到 MAC 头部即可。但路由器的网关地址一般为空，此时需要根据最终目标 IP 地址来查询 MAC 地址并添加到 MAC 头部（注：查询回来的结果并不是绑定目标 IP 地址的设备 MAC 地址，而其实是下一个中转设备的 MAC 地址（如交换机或路由器）；</p>
<h3 id="路由器与交换机的关系"><a href="#路由器与交换机的关系" class="headerlink" title="路由器与交换机的关系"></a>路由器与交换机的关系</h3><p>IP 路由器工作在 IP 层面，它通过查询目标 IP 地址的 MAC 地址，然后将其写到 MAC 头部中；之后交换机通过该头中的 MAC 地址，将数据包转发到下一个路由器；</p>
<h2 id="路由器的附加功能"><a href="#路由器的附加功能" class="headerlink" title="路由器的附加功能"></a>路由器的附加功能</h2><h3 id="通过地址转换有效利用-IP-地址"><a href="#通过地址转换有效利用-IP-地址" class="headerlink" title="通过地址转换有效利用 IP 地址"></a>通过地址转换有效利用 IP 地址</h3><p>如果全世界每一个计算机都分配一个 IPv4 地址的话，按照 IPv4 地址的长度来计算，是完全不够分配的，因为计算机的数量增长得太快了。因此，人们制订了规则，将当时还未分配的三段 IPv4 地址，设置为仅限内部子网使用。这样每家公司都可以在其子网内自行分配 IP 地址，而不用担心和其他公司产生冲突。而为子网的出口设备分配一个公共 IP，这样子网内的计算机可以和子网外的计算机进行通信了；这个机制是很好的，但是在数据包从子网内到子网外时，需要增加一个动作，即对其做地址转换才行；</p>
<blockquote>
<p>私有地址分别有以下三段：</p>
<ul>
<li>10.0.0.0 至  10.255.255.255，约可容纳 1600 万台；</li>
<li>172.16.0.0 至 172.31.255.255，约可容纳 100 万台；</li>
<li>192.168.0.0 至  192.168.255.255，约可容纳 6 万台</li>
</ul>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211211080731.png"></p>
<h3 id="地址转换的基本原理"><a href="#地址转换的基本原理" class="headerlink" title="地址转换的基本原理"></a>地址转换的基本原理</h3><p>地址转换的原理非常简单，就是将数据包 IP 头部中的私有地址和端口，改成公有地址和新端口，并在内部建立映射表，然后发送出去。建立映射表的目的是当接收方返回数据时，可以根据映射表再次转换，将数据包转发给内网的设备；</p>
<h3 id="改写端口号的原因"><a href="#改写端口号的原因" class="headerlink" title="改写端口号的原因"></a>改写端口号的原因</h3><p>如果不改写端口号，那么只能通过 IP 地址来区分不同的内网设备，这时就需要分每台内网分配一个唯一的公共 IP 地址，并在连接结束后收回。这种方式虽然也可行，但无法最大化的节省公共 IP 地址。因为当内网设备很多的时候，并且有同时上网的需求，就会分配一大堆的公共 IP 地址；</p>
<h3 id="从互联网访问公司内网"><a href="#从互联网访问公司内网" class="headerlink" title="从互联网访问公司内网"></a>从互联网访问公司内网</h3><p>地址转换会带来一个有趣的副作用，即如果地址转换映射表中没有记录，从互联网进入内网的包就不知道应转发给哪个设备，此时路由器就会丢弃该包。该副作用是可以保护内网设备的安全性，防止非法入侵；</p>
<h3 id="路由器的包过滤功能"><a href="#路由器的包过滤功能" class="headerlink" title="路由器的包过滤功能"></a>路由器的包过滤功能</h3><p>所谓的包过滤，指根据 MAC 头部、IP 头部、TCP 头部中的内容，与提前预设的规则进行匹配，然后根据匹配结果，决定是否丢弃包，还是转发包；多数防火墙软件即是基于包过滤来实现；</p>
<blockquote>
<p>虽然包过滤的原理很简单，但是想要实现正确的配置，在实现正常访问的同时，还能够防止非常入侵，是非常困难的</p>
</blockquote>
<h1 id="通过接入网进入互联网内部"><a href="#通过接入网进入互联网内部" class="headerlink" title="通过接入网进入互联网内部"></a>通过接入网进入互联网内部</h1><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212092010.png"></p>
<h2 id="ADSL-接入网的结构和工作方式"><a href="#ADSL-接入网的结构和工作方式" class="headerlink" title="ADSL 接入网的结构和工作方式"></a>ADSL 接入网的结构和工作方式</h2><h3 id="互联网的基本结构和家庭、公司网络是相同的"><a href="#互联网的基本结构和家庭、公司网络是相同的" class="headerlink" title="互联网的基本结构和家庭、公司网络是相同的"></a>互联网的基本结构和家庭、公司网络是相同的</h3><p>互联网的基本结构和家庭或公司内部网络是相同的，主要不同点如下：</p>
<ul>
<li>由于物理距离变长和线路的信号衰减，因此需要在中间增加很多路由器作为中间转发设备；</li>
<li>路由器上面的路由表由于转发记录很大，其维护机制有所不同；</li>
</ul>
<h3 id="连接用户与互联网的接入网"><a href="#连接用户与互联网的接入网" class="headerlink" title="连接用户与互联网的接入网"></a>连接用户与互联网的接入网</h3><p>不管是互联网接入路由器，还是以太网路由器，它们的主要职责和原理都是一样的，即根据路由包负责包的转发。有多种方式可以将家庭或公司接入互联网，例如 ADSL（电话线）、FTTH（光纤）、CATV（有线电视）等，因此互联网接入路由器会基于入网规则来转发包；</p>
<blockquote>
<p>ADSL：asymmetric digital subscriber line，不对称数字用户线路。利用现有电话线进行通信的技术，它的特点是上行和下行不对称；</p>
</blockquote>
<h3 id="ADSL-Modem-将包拆分成信元"><a href="#ADSL-Modem-将包拆分成信元" class="headerlink" title="ADSL Modem 将包拆分成信元"></a>ADSL Modem 将包拆分成信元</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212095235.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212095612.png"></p>
<p>当使用 ADSL 来接入网络时，接入路由器通常使用 PPPoE 方式进行连接，因此路由器会按照 PPPoE 规则，给包加上PPP 头部、PPPoE 头部和 MAC 头部，然后再将包发送给 ADSL Modem；Modem 的职责是将收到的包拆成 ATML 信元，然后转成电信号发送给运营商的 Modem；</p>
<blockquote>
<p>ATM：Asynchronous Transfer Mode，异步传输。ATM 信元也是一种数据包，但是它很小，头部只有 5 个字节，数据主体只有 48 字节，使用 ATM 通信协议；</p>
<p>ADSL 之所以使用 ATM 将包拆分成更小的单位，其初衷是尽可能提高兼容性，降低设备的开始和投入成本；</p>
</blockquote>
<h3 id="ADSL-将信元“调制”成信号"><a href="#ADSL-将信元“调制”成信号" class="headerlink" title="ADSL 将信元“调制”成信号"></a>ADSL 将信元“调制”成信号</h3><p>网线在传输数字信号时，一般使用方波，它的优点是简单，但缺点是容易失真，随着距离变长，出错率会上升。ADSL 为了克服容易失真的缺点，使用了正弦波（圆滑波形）合成信号（调制）来表示 0 和 1；</p>
<p>调制信号有很多种方法，例如振幅调制、相位调制。它们的区别在于使用不同的方法来表示 0 和 1，甚至表示更多的位，例如用 4 种振幅分别表示 00、01、10、11 等（虽然振幅越多可以表示更多种情况，但也更容易误判出错）；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212115223.png"></p>
<p>相位调制也可以让波从不同位置开始来表示四种情况，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212120030.png"></p>
<p>正交振幅调制通过结合振幅调制和相位调制，就可以用表示四种情况；由于振幅和相位是不同维度的特征，因此这种维度结合方案，相对单维度的细分方案，更加健壮不容易出错；</p>
<h3 id="ADSL-通过使用多个波来提高速率"><a href="#ADSL-通过使用多个波来提高速率" class="headerlink" title="ADSL 通过使用多个波来提高速率"></a>ADSL 通过使用多个波来提高速率</h3><p>波是可以有多种频率的，而通过滤波器我们又可以将不同频率的波分离出来。因此，通过将多种频率的波合成在一起，我们就可以在单位时间内传递更多的信号，而单位时间可以传递的信号数量即是带宽。</p>
<p>ADSL 通过合成上百个不同频率的波，来实现更大的带宽。为了降低分离难度，每种波使用一定的频率范围，不同波之间的频率间隔为 4.312 KHz，并且都使用正交振幅进行调制；</p>
<p>另外不同频段的波，其受到的环境噪声不一样（一般来说，频段越高，衰减和噪声越大）。如果某个频段的环境噪声小，就可以分配更多的比特位；如果噪声大，就分配较少的比特位；</p>
<p>ADSL 之所以能够实现上下行不同的速率，其原因就在于它为上行和下行分配了不同的数量的频段。上行的频段数量少一些，下行的多一些。</p>
<p>噪声和衰减由环境的影响很大，因此每条线路都会存在不同的情况。在为频段分配比特位时，为了提高分配效率，ADSL 在线路通电初始化时，会先做一个测试。根据测试结果，为不同的频段分配最合理数量的比特数（该过程称为训练，一般需要消耗几秒到几十秒左右的时间）；</p>
<h3 id="分离器的作用"><a href="#分离器的作用" class="headerlink" title="分离器的作用"></a>分离器的作用</h3><p>由于 ADSL 借助电话线进行信号的传播，因此电话信号和网络信号会同时在电话线上存在。分离器的作用，就是根据信号的频率，将电话信号（低频信号）分离出来，并将电话信号转给电话机。不然电话机如果收到所有的信号，就会导致电话声音包含很多噪声，无法听清；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212122709.png"></p>
<p>电话机在接通和挂断信号的瞬间，会导致线路的信号出现突然的增加和减少，因此会改变噪声条件。正常情况下，当噪声条件改变时，Modem 之间就需要重新握手。显然这样很不合理，因为在接听或挂断电话时，就会导致网络中断。分离器的另外一个作用，就是避免这种情况的出现。</p>
<h3 id="从用户到电话局"><a href="#从用户到电话局" class="headerlink" title="从用户到电话局"></a>从用户到电话局</h3><p>电信号从 Modem 出来后，就是走的日常的电话线路了。一般一幢大楼有很多住户或公司，因此每家住户或公司的电话线会先到达本栋大楼的 IDF（中间配线盘） 或 MDF （主配线盘），然后到达保安器（用来防雷击），最后汇成一股，接到室外的电线杆，延伸到电信局附近，然后走到地下，通过电缆隧道，进入电信局大楼的地下室。之所以最后一段要走地下，是为了避免电信局附近竖起大量的电线杆，一来占地太多，二来有火灾隐患；</p>
<blockquote>
<p>配线盘的目的是将电信局出来的线路与各住户或公司进行一一对应；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212124002.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212123940.png"></p>
<h3 id="噪声的干扰"><a href="#噪声的干扰" class="headerlink" title="噪声的干扰"></a>噪声的干扰</h3><p>由于电话线也是使用金属来传递电信号，因此它不可避免也会出现噪声干扰的问题；由于电话线设计之初并未考虑到会用来传递 ADSL 高频信号，因此它比双绞网线更容易受到噪声的干扰；</p>
<p>由于电话线传递的是多频合成的信号，其中只有和噪声频率相近的频段会受到噪声的影响，其余频段不受影响，因此最终接收方收到的可用信号变少了。由于在通电初始化时会检测可用频段，因此当出现噪声时，它不会像网线一样出现信号丢失，而是可用频段变少，传输速度下降而已；</p>
<h3 id="通过-DSLAM-到达-BAS"><a href="#通过-DSLAM-到达-BAS" class="headerlink" title="通过 DSLAM 到达 BAS"></a>通过 DSLAM 到达 BAS</h3><p>DSLAM：DSL Access Multiplexer，数字用户线路接入复用设备；相当于多路 Modem 集成器，可以同时处理多个用户端 Modem 发过来的信号；理论上电话局也可以为每个用户配备一个 Modem，但显然这样需要大量的空间来放置 Modem；使用 DSLAM 就可以节省空间了；</p>
<p>家用 Modem 有一个以太网接口，用来连接用户家里的路由器，而电信局的 DSLAM 一般不使用以太网接口，因为它不跟电信局路由器直接连接，而是使用 ATM 接口，先跟 BAS 设备连接，之后 BAS 设备再跟路由器连接；</p>
<p>BAS 是一台包转发设备（一种特定类型的专用路由器），它的职责是将 ATM 信元还原成原始的包，然后去掉 MAC 头部和 PPPoE 头部，为余下的 PPP 头部及其主体数据添加隧道协议的专用头部（例如 L2TP 协议），发给后面的隧道专用路由器；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212175920.png"></p>
<h2 id="光纤接入网（FTTH）"><a href="#光纤接入网（FTTH）" class="headerlink" title="光纤接入网（FTTH）"></a>光纤接入网（FTTH）</h2><h3 id="光纤的基本知识"><a href="#光纤的基本知识" class="headerlink" title="光纤的基本知识"></a>光纤的基本知识</h3><blockquote>
<p>FTTH：Fiber To The Home，或许可以翻译为光纤入户；</p>
</blockquote>
<p>ADSL 在电话中上复合多个不同的频率的电信号来传输数据，光纤则简单得多，它使用明暗两种光线来表示 0 和 1；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212180206.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211212180317.png"></p>
<h3 id="单模与多模"><a href="#单模与多模" class="headerlink" title="单模与多模"></a>单模与多模</h3><p>光本质上也是一种电磁波，因此光之间也会相互干扰；从光源射入光纤的光线有很多束，光束在被反射后，会出现相位的改变，而相位不同的光线会相互抵销；因此，只有特定入射角的光束能够在光纤中顺利向前传播，其他光束则因彼此相互干扰而抵销了；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211213122505.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211213122610.png"></p>
<p>光纤分单模和多模，其区别在于单模光纤的直径较细，因此只有最小入射角的光线，才能够保持相位一致并在光纤中传播；多模光纤由于直径较粗，存在多个满足相位一致的入射角光束，可以有多条光线在光纤中传播，因此接收设备对光敏元件的要求比较低，可以降低成本；</p>
<p>但它带来了另外一个问题，随着反射角度的变大，光线在光纤中反射的次数就会增多，传输距离变长，传输用时变多，因此和反射角度小的光线有到达时间差。如果时间差足够大，就会造成信号失真，因此，多模光纤的传输距离上限较小一些；</p>
<h3 id="通过光纤分路来降低成本"><a href="#通过光纤分路来降低成本" class="headerlink" title="通过光纤分路来降低成本"></a>通过光纤分路来降低成本</h3><p>FTTH 架构和 ADSL 差不多，只是 ADSL 的 Modem 在 FTTH 中被换成了光纤收发器，它的职责就是将数据转在光信号发送出去。为了避免上行光信号和下行光信号产生互相干扰，上行和下行会使用不同波长的光线来传输数据，并使用棱镜分离原理获取所需的信号；</p>
<p>除了光纤收发器外，还有一种成本更低的做法，它的原理是上行的时候使用排队机制。用户端使用 ONU 设备，电信局端使用 OLT 使用；OLT 会给接入的多个用户信号进行排队，然后指示 ONU 设备按分配到队列序号发送光信号，这样多台客户端 ONU 设备发送的信号就不会出现冲突。当服务器返回响应时，OLT 会给数据包添加用户端编号，并广播到所有 ONU 设备上。ONU 检查收到的数据包，如果编号匹配，就接受；如果不匹配，就丢弃（有点像集线器和网卡的配合）；</p>
<blockquote>
<p>不管 FTTH 使用直连还是分路的方式，都可以使用 PPPoE 来传输数据包；</p>
</blockquote>
<h2 id="接入网中使用的-PPP-和隧道"><a href="#接入网中使用的-PPP-和隧道" class="headerlink" title="接入网中使用的 PPP 和隧道"></a>接入网中使用的 PPP 和隧道</h2><h3 id="用户认证和配置下发"><a href="#用户认证和配置下发" class="headerlink" title="用户认证和配置下发"></a>用户认证和配置下发</h3><p>多数 ADSL 使用 PPPoE 协议来完成认证和配置下发（例如分配公共 IP 地址）的工作。传统的 PPP 拨号流程如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211213170315.png"></p>
<blockquote>
<p>RADIUS：Remote Access Dial-In User Service，拨号用户远程登录服务；</p>
<p>LCP：Link Control Protocol，连接控制协议</p>
<p>PAP：PPP Authentication Protocol，PPP 认证协议；</p>
<p>IPCP：Internet Protocol Control Protocol；</p>
</blockquote>
<h3 id="在以太网上传输-PPP-消息"><a href="#在以太网上传输-PPP-消息" class="headerlink" title="在以太网上传输 PPP 消息"></a>在以太网上传输 PPP 消息</h3><p>由于 ADSL 或 FTTH 线路是由 ISP 提供并直接连接 BAS 端口，因此理论上并不需要用户+密码的登录动作。但为了方便管理用户，多数运营商会使用 PPPoE 协议进行用户认证，这样有两个好处：</p>
<ul>
<li>用户可以输入不同的用户名和密码，在不同的运营商之间进行切换；</li>
<li>运营商可以根据用户名，统计用户的流量；</li>
</ul>
<p>在拨号上网的时代，使用专线传输，因此 PPP 协议可以使用 HDLC 协议作为容器。但到了非专线的 ADSL 和 FFTH 的时代，PPP 协议无法和以太网兼容，因此需要做一些改进，新的协议标准即为 PPPoE，Point to Point Protocol over Ethernet.</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211213171049.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211213171110.png"></p>
<blockquote>
<p>ADSL Modem 在收到路由器发过来的以太网数据包后，需要先将其转成 ATM 信元，之后再转成电信号，然后传送出去，到达电信局的 DSLAM；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211213171132.png"></p>
<blockquote>
<p>FTTH 光纤收发器在收到路由器的以太网数据包后，无须转 ATM 信元，而是直接转成光信号，然后传送出去，到达电信局的多路光纤收发器；</p>
</blockquote>
<h3 id="通过隧道将网络包发送给运营商"><a href="#通过隧道将网络包发送给运营商" class="headerlink" title="通过隧道将网络包发送给运营商"></a>通过隧道将网络包发送给运营商</h3><p>BAS 在收到 PPPoE 数据包后，进行解析，去掉 MAC 头部和 PPPoE 头部，从中取出 PPP 消息体，进行认证；</p>
<blockquote>
<p>所谓的隧道，其实只是一种抽象。它表示通过建立某种形式的连接，将数据包从一头原封不动的传输到另一头。TCP&#x2F;IP 栈即是一种隧道方案，另外还可以其他封装方案；</p>
</blockquote>
<h3 id="接入网的整体工作过程"><a href="#接入网的整体工作过程" class="headerlink" title="接入网的整体工作过程"></a>接入网的整体工作过程</h3><ul>
<li>用户在接入互联网的路由器上面配置 ISP 运营商提供的用户名和密码；</li>
<li>路由器基于 PPPoE 协议，广播一条消息，查询 BAS 的 MAC 地址（有点像 ARP 的 MAC 寻址）；</li>
<li>BAS 返回消息，告知路由器自己的 MAC 地址；</li>
<li>路由器得到 BAS 的 MAC 地址，使用 CHAP 或 PAP ，将用户名和密码发送给 BAS；</li>
<li>BAS 收到用户名和密码，进行校验，如果密码正确，使用 IPCP 将配置信息（公有 IP 地址、DNS 服务器 IP 地址和默认网关的 IP 地址等）发送给路由器；</li>
<li>路由器收到配置信息，更新自身的配置参数；</li>
<li>客户端开始发送 TCP&#x2F;IP 数据包；</li>
<li>路由器为数据包添加 PPP  头部、PPPoE 头部、MAC 头部，由 Modem 转成电信号，发出给 DSLAM；</li>
<li>DSLAM 将电信号还原成 PPPoE 数据包，转给 BAS；</li>
<li>BAS 去掉数据包的 PPPoE 头部，得到 PPP 包，通过隧道发给运营商内部的路由器；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211213222041.png"></p>
<blockquote>
<p>好奇客户端在完成 PPPoE 拨号连接后，后续的包是否需要携带用户名密码？还是携带会话 ID 即可？理论上首次登录时，运营商的 BAS 路由器应该会与认证服务器（存储用户信息）通信，验证用户名和密码是否正确；如果正确，理论上 BAS 应该在本地生成会话，并将会话 ID 下发给客户端即可；这样后续每次收到客户端的数据包，只需检查其中的 PPPoE 头部是否包含有效的会话 ID 即可，无需再次连接认证服务器进行验证；</p>
</blockquote>
<h3 id="不分配-IP-地址的无编号端口"><a href="#不分配-IP-地址的无编号端口" class="headerlink" title="不分配 IP 地址的无编号端口"></a>不分配 IP 地址的无编号端口</h3><p>假设用户家里的接入路由器和运营商的 BAS 路由器是一对一连接的，那么包只有一条传输线路，肯定会到达 BAS 路由器，理论上完全没有必要为数据包添加 PPPoE 头部，而且也不需要为用户的接入路由器分配公有 IP 地址。这种不分配 IP 地址的方式称为无编号端口；</p>
<h3 id="互联网接入路由器将私有地址转换成公有地址"><a href="#互联网接入路由器将私有地址转换成公有地址" class="headerlink" title="互联网接入路由器将私有地址转换成公有地址"></a>互联网接入路由器将私有地址转换成公有地址</h3><p>当使用路由器接入互联网时，BAS 会将公有地址分配给路由器。而位于路由器背后的局域网中的计算机，则只拥有路由器分配的私有地址。因此，当路由器收到内部局域网中的计算机的数据包时，需要做地址转换的动作，即将数据包中的私有 IP 地址转换成公网 IP 地址；</p>
<p>如果没有使用路由器，而是让计算机直连到 ADSL Modem 或者光纤收发器上面，那么计算机就会直接拥有公网 IP 地址；</p>
<h3 id="除-PPPoE-以外的其他方式"><a href="#除-PPPoE-以外的其他方式" class="headerlink" title="除 PPPoE 以外的其他方式"></a>除 PPPoE 以外的其他方式</h3><p>除了 PPPoE 外，还有一些其他连接方式，例如 PPPoA；PPPoA 和 PPPoE 的区别在于不给 PPP 消息添加 MAC 和 PPPoE 头部，而是直接将 PPP 消息转换成 ATM 信元 直接发送出去。PPPoE 之所以要添加 MAC 头部，是因为这样可以遵守以太网协议，Modem 可以充当一条以太网直接，和路由器用网线连接。当 PPPoA 不使用 MAC 头部时，就意味着 Modem 和路由器之间不可以使用网线连接，而是需要集成在一起；</p>
<blockquote>
<p>最近几年国内运营商提供的 Modem 好像都是集成路由功能的，但里面的路由功能很弱鸡，所以大部分用户又不得不再自行购买一台更高性能的路由器；</p>
</blockquote>
<p>集成在一起会减少一些灵活性的损失，例如更换设备时，需要整套更换，而不能只更新其中的一部分。但好处是少了一些头部后，数据包可容纳的数据量变多了，MTU 比较大，间接提高了传输速度；</p>
<p>另外还可以不使用 PPP，而是使用 DHCP 的方式给用户的路由器下发配置信息，这样就无须用户填写用户名和密码并对其进行验证；由于免去了 PPP 头部，还可以间接增加 MTU；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211213230640.png"></p>
<p>虽然 DHCP 也使用 ADSL Modem，但这个 Modem 的作用有所不同，它无须将数据转成信元，而转成 ADSL 信号发直接送出去；</p>
<blockquote>
<p>DHCP：Dynamic Host Configuratin Protocol，动态主机配置协议；路由器可以借助该协议，将网络配置信息告知主机，这样主机就可以通过路由器接入互联网；</p>
</blockquote>
<h2 id="网络运营商的内部"><a href="#网络运营商的内部" class="headerlink" title="网络运营商的内部"></a>网络运营商的内部</h2><h3 id="POP-和-NOC"><a href="#POP-和-NOC" class="headerlink" title="POP 和 NOC"></a>POP 和 NOC</h3><p>互联网上面的内容，不管是内容访问方，还是内容提供方，他们都需要依赖运营商来实现对接；运营商跟使用者之间使用 POP 设备进行连接；从 ADSL、FTTH 发出的信号，最终会到达 POP 设备，然后进入互联网；</p>
<blockquote>
<p>POP：Point of Presense，互联网接入点，即运营商暴露给使用者的路由器；</p>
<p>NOC：Network Operation Center，网络运行中心，即运营商内部对接多个 POP 设备的中心设备。</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211214202614.png"></p>
<p>POP 设备有很多种类型，具体使用哪种类型，取决于运营商使用哪种线路和上下游进行对接；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211214203125.png"></p>
<p>POP 中连接用户端的路由器需要配备很多端口，以便可以和很多用户同时对接；由于 POP 到用户端的线路速率，因此相对于接骨干网的路由器，接入用户端的路由器的性能要求会低一些；而 NOC 设备由于要同时处理很多 POP 设备的数据，因此它的性能要求很高，其数据吞吐能力是普通 POP 设备的 3-4 个数量级；</p>
<h3 id="室外通信线路的网络包"><a href="#室外通信线路的网络包" class="headerlink" title="室外通信线路的网络包"></a>室外通信线路的网络包</h3><p>家庭或公司内部的网络连接，由于数据量较小，因此一般使用双绞线就足够了；但对于运营商来说，网线不够用，一般需要使用光纤来传输数据；</p>
<p>在室外铺设光纤的费用是很高的，只有拥有足够多客户的公司才能够承担。对于小运营商来说，更合理的方案是向大运营商租借线路的通信能力；</p>
<h2 id="跨越运营商的网络包"><a href="#跨越运营商的网络包" class="headerlink" title="跨越运营商的网络包"></a>跨越运营商的网络包</h2><h3 id="运营商之间的连接"><a href="#运营商之间的连接" class="headerlink" title="运营商之间的连接"></a>运营商之间的连接</h3><p>当用户的数据包到达 POP 路由器之后，如果目的地服务器刚好也是使用同一家运营商，那么就好办了。POP 只需查询自己的路由表，即可知道应该将数据包转发给哪台内部的 POP 路由器或者 NOC 路由器；</p>
<blockquote>
<p>路由器之间会相互交换路由信息，从而自动更新自身的路由表；</p>
</blockquote>
<p>如果目的地服务器属于另外一家运营商管理，那也没有问题。因为运营商之间也是用路由器相互连接的，因此彼此也拥有对方的路由信息，从而可以查询到转发目标；</p>
<h3 id="运营商之间的路由信息交换"><a href="#运营商之间的路由信息交换" class="headerlink" title="运营商之间的路由信息交换"></a>运营商之间的路由信息交换</h3><p>分配给运营商的 IP 地址不是单个，而是整段的。当运营商在自己的路由器中配置了该段 IP 地址后，该路由器就可以使用 BGP 协议，将该信息发给相连接的其他运营商路由器，同时对方路由器也会发过来它负责的 IP 段；</p>
<blockquote>
<p>BGP：Border Gateway Protocol，边界网关协议；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211215083832.png"></p>
<p>有两种路由交换方案：</p>
<ul>
<li>转接：A 不但发送自己的子网，还发送自己知道的互联网上所有的路由信息；这种方案的好处是被告知者 B 可以知道 A 背后还有谁，有些包可以通过 A 作为中介到达 A 背后的运营商；</li>
<li>对等：A 仅发送自己的子网；被告知者 B 只会将属于 A 子网的数据包发给 A，不属于 A 的就不会发了；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211215084240.png"></p>
<h3 id="与公司网络中自动更新路由表机制的区别"><a href="#与公司网络中自动更新路由表机制的区别" class="headerlink" title="与公司网络中自动更新路由表机制的区别"></a>与公司网络中自动更新路由表机制的区别</h3><p>运营商之间的路由器，跟普通公司内部的路由器在本质上并没有什么区别。但是由于运营商之间存在线路费用的关系，因此在制定和交换路由规则上面，需要有所考量，不能像普通路由那样使用最短路径；</p>
<p>假设某个运营商的线路对外是收费的，那么他就会在路由规则中设置只转发交过费用的运营商的数据包，同时拒收那些未交费的运营商的数据包；另外，由于不同运营商的收费标准不同，因此在选择路由路径时，会设置一定的优先级，以降低成本；</p>
<p>保证用户能够访问互联网中任意一台机器，是运营商的基本职责。虽然出于成本考量，不一定选择最短路径，但终究是可达的；</p>
<h3 id="IX-的必要性"><a href="#IX-的必要性" class="headerlink" title="IX 的必要性"></a>IX 的必要性</h3><p>运营商之间可以使用专线实现一对一的连接，但如果运营商很多，这种一对一的专线方案就显得成本太高了，更合适的方案是引入一个中心设备，各家运营商只需连接到该中心设备，数据包通过中心设备统一转发即可</p>
<blockquote>
<p>IX：Internet Exchange，互联网交换中心；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211215201312.png"></p>
<blockquote>
<p>由于 IX 同时对接多家运营商，因此其数据吞吐量非常大，有些甚至高达 200Gbit 每秒；</p>
</blockquote>
<h3 id="运营如何通过-IX-互相连接"><a href="#运营如何通过-IX-互相连接" class="headerlink" title="运营如何通过 IX 互相连接"></a>运营如何通过 IX 互相连接</h3><p>IX 本质上是一台交换机，与普通交换机的区别在于它的端口特别多，而且性能非常好（目前主流是使用 10Gbit&#x2F;s 的光纤端口）；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211215201657.png"></p>
<h1 id="服务器端的局域网中有什么玄机"><a href="#服务器端的局域网中有什么玄机" class="headerlink" title="服务器端的局域网中有什么玄机"></a>服务器端的局域网中有什么玄机</h1><h2 id="Web-服务器的部署地点"><a href="#Web-服务器的部署地点" class="headerlink" title="Web 服务器的部署地点"></a>Web 服务器的部署地点</h2><h3 id="在公司里部署-Web-服务器"><a href="#在公司里部署-Web-服务器" class="headerlink" title="在公司里部署 Web 服务器"></a>在公司里部署 Web 服务器</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211215202718.png"></p>
<p>Web 服务器上面通常会安装很多软件，如果某个软件存在安全漏洞，就会导致服务器受到攻击，但其实大部分服务器上的软件并不对外提供服务；因此，通过引入防火墙，只允许访问特定软件的数据包通过，这样就可以避免服务器受到某个软件漏洞的影响；</p>
<blockquote>
<p>目前仅靠防火墙已经不够用了，还需要配合反病毒软件、非法入侵检测软件、访问隔离机制等多套方案，才能有效提高安全性；</p>
</blockquote>
<h3 id="将-Web-服务器部署在数据中心"><a href="#将-Web-服务器部署在数据中心" class="headerlink" title="将 Web 服务器部署在数据中心"></a>将 Web 服务器部署在数据中心</h3><p>由于数据中心离 IX 很近，因此可以让服务器获得更快的访问速度。同时由于数据中心通常还提供各种增值服务，因此一般也更加安全；</p>
<h2 id="防火墙的结构和原理"><a href="#防火墙的结构和原理" class="headerlink" title="防火墙的结构和原理"></a>防火墙的结构和原理</h2><h3 id="主流的包过滤方式"><a href="#主流的包过滤方式" class="headerlink" title="主流的包过滤方式"></a>主流的包过滤方式</h3><p>防火墙的作用是只允许满足条件的流量通过，实现这个目标有很多种方案，但简单和低成本的方案是使用包过滤的方式；</p>
<h3 id="如何设置包过滤规则"><a href="#如何设置包过滤规则" class="headerlink" title="如何设置包过滤规则"></a>如何设置包过滤规则</h3><p>由于数据包的头部包含一些关键的信息，因此可以基于这些头部信息制作相应的规则来实现包过滤；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211215204746.png"></p>
<blockquote>
<p>上图的例子中，通过加入 TCP 包的控制位规则，实现 Web 服务器无法发起对互联网的访问，而只能响应客户端的请求；</p>
</blockquote>
<h3 id="通过端口号限定应用程序"><a href="#通过端口号限定应用程序" class="headerlink" title="通过端口号限定应用程序"></a>通过端口号限定应用程序</h3><p>通过在规则中增加端口号，就可以实现只允许特定应用程序被外部访问；因为端口号映射着绑定该端口号的应用程序；</p>
<h3 id="通过控制位判断连接方向"><a href="#通过控制位判断连接方向" class="headerlink" title="通过控制位判断连接方向"></a>通过控制位判断连接方向</h3><p>TCP 头部中的控制位可以用来判断包的方向，因为在建立 TCP 连接时，发起的第一个数据包中的控制位为 SYN&#x3D;1 和 ACK&#x3D;0，后续的其他包的控制位都不再是这个组合。因此通过限制该组合的出现，就可以阻止建立 TCP 连接；</p>
<p>控制位只能适用于 TCP 连接，而其他连接协议（如 UDP）则不适用，因为 UDP 头部都没有这些控制位；这个时候要么妥协，要么需要增加其他防火墙方案，而不能只使用包过滤机制；</p>
<h3 id="从公司内网访问公开区域的规则"><a href="#从公司内网访问公开区域的规则" class="headerlink" title="从公司内网访问公开区域的规则"></a>从公司内网访问公开区域的规则</h3><p>仅在发送方的 IP  地址为公司内网的 IP 地址时，才允许通过；</p>
<blockquote>
<p>想到了访问后台时，可以临时添加 IP 地址来实现访问；先在内网中设立一个专用的后台程序来暴露接口。由于该程序处于内网，因此可以访问主程序的敏感接口；然后只允许特定 IP 访问该后台程序；</p>
</blockquote>
<p>通常来说，内网的计算机分配的是私有 IP 地址，当访问外网时，路由器需要对其作地址转换。但内网之间的访问，则不需要地址转换，此时可以在路由器中配置相应的规则，让内网中的计算机对公开区域的访问，仍然使用私有地址；</p>
<h3 id="从外部无法访问公司内网"><a href="#从外部无法访问公司内网" class="headerlink" title="从外部无法访问公司内网"></a>从外部无法访问公司内网</h3><p>如果路由器没有地址转换的映射记录，当收到外网发进来的包时，由于不知道应该转发给哪台内网设备，路由器默认会丢弃该数据包；</p>
<h3 id="通过防火墙"><a href="#通过防火墙" class="headerlink" title="通过防火墙"></a>通过防火墙</h3><p>使用防火墙软件时，可考虑开启包丢弃日志，这样可以分析入侵者的攻击方法；路由器由于内置存储很小，一般不适合开启日志功能；</p>
<h3 id="防火墙无法抵御的攻击"><a href="#防火墙无法抵御的攻击" class="headerlink" title="防火墙无法抵御的攻击"></a>防火墙无法抵御的攻击</h3><p>服务器程序本身的 BUG 引发的安全漏洞，是无法使用包过滤来规避的。常规的方法是增加部署检查包内容的软件或硬件；但这种方法的效力也是有限，因为某个包是否安全，是由服务器程序本身是否存在 BUG 来决定的，而这种 BUG 在早期是未知的，因此包检查软件也难以判断该数据包是否安全；</p>
<h2 id="通过将请求平均分配给多台服务器来平均负载"><a href="#通过将请求平均分配给多台服务器来平均负载" class="headerlink" title="通过将请求平均分配给多台服务器来平均负载"></a>通过将请求平均分配给多台服务器来平均负载</h2><h3 id="性能不足时需要负载均衡"><a href="#性能不足时需要负载均衡" class="headerlink" title="性能不足时需要负载均衡"></a>性能不足时需要负载均衡</h3><p>负载均衡可以有多种方案，最简单的方案是使用 DNS；在设置 DNS 解析时，新增多条相同域名的解析记录，每一条对应一个不同的 IP 地址；这样每次查询 DNS 时，DNS 服务器都会返回所有地址，但不同的地址顺序；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211216081555.png"></p>
<p>虽然 DNS 机制最简单，但是它也有一些缺点，例如：</p>
<ul>
<li>当某台服务器宕机时，DNS 服务器无法知晓，仍然会给客户端返回宕机的服务器 IP 地址；除非客户端在发现第一个地址无效时，会自动访问第二个 IP 地址（多数浏览器已经实现该功能）；</li>
<li>当多台服务器时，如果用户的某个会话信息存储在其中一台服务器上面，之后用户访问另外一台服务器时，会导致会话丢失；</li>
</ul>
<h3 id="使用负载均衡器分配访问"><a href="#使用负载均衡器分配访问" class="headerlink" title="使用负载均衡器分配访问"></a>使用负载均衡器分配访问</h3><p>负载均衡的另外一种方案是使用专门的负载均衡器；DNS 解析指向该负载均衡器，当客户端访问负载均衡器时，会负载均衡器判断应该将包转发给哪台服务器；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211216082200.png"></p>
<p>负载均衡器会根据服务器当前的负载情况来转发包，有多种判断办法，例如：</p>
<ul>
<li>定期查询服务器的 CPU 和内存使用情况；</li>
<li>根据服务器的性能参数按比例转发；</li>
<li>会话亲和性；</li>
</ul>
<blockquote>
<p>如果需要让负载均衡器将某个客户端请求固定转发到特定的机器上面，一般会使用 HTTP 的 cookie 字段作为判断；其原理很简单，当某个客户端首次访问时，负载均衡器为其分配一个唯一的 cookie 值，并记录映射的服务器；之后客户端的请求都需要携带该 cookie 值，这样负载均衡器就可以通过查询映射表，将请求转发给固定的服务器；</p>
</blockquote>
<h2 id="使用缓存服务器分担负载"><a href="#使用缓存服务器分担负载" class="headerlink" title="使用缓存服务器分担负载"></a>使用缓存服务器分担负载</h2><h3 id="如何使用缓存服务器"><a href="#如何使用缓存服务器" class="headerlink" title="如何使用缓存服务器"></a>如何使用缓存服务器</h3><p>负载均衡可以有两种思路，这种思路可以单独使用，也可以组合使用：</p>
<ul>
<li>使用多台功能相同的服务器：每台服务器分担的请求变少；</li>
<li>使用多台功能不同的服务器：每台服务器分担的工作内容变少</li>
</ul>
<h3 id="缓存服务器通过更新时间管理内容"><a href="#缓存服务器通过更新时间管理内容" class="headerlink" title="缓存服务器通过更新时间管理内容"></a>缓存服务器通过更新时间管理内容</h3><p>缓存服务器需要前置在 Web 服务器之前先处理请求，如果没有负载均衡器，那么缓存服务器需要直接注册到 DNS 解析记录中；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211216085257.png"></p>
<p>当客户端首次访问某个资源时，缓存服务器没有命中缓存，会直接将请求转给 Web 服务器，之后缓存 Web 服务器返回的结果；当客户端下次再访问相同资源时，缓存服务器在转发请求时，会在头部增加 If-Modified-Since 字段，用来沟通该资源是否发生了变更；</p>
<h3 id="最原始的代理–正向代理"><a href="#最原始的代理–正向代理" class="headerlink" title="最原始的代理–正向代理"></a>最原始的代理–正向代理</h3><p>缓存服务器的方案最早其实是部署在客户端的（公司），而不像现在部署在服务端。当时客户端的缓存服务器是为了实现防火墙，然后在此过程中发现还可以顺便充当缓存服务器，因为当时的网速很慢，因此使用缓存服务器可以有效提高访问速度；另外公司还可以利用该机制，控制员工可访问的网站列表，避免访问危险的网站；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211217073608.png"></p>
<blockquote>
<p>后来由于出现了多种多样的代理方案，不同方案之间为了相互区分，因此才有了正向代理（forward proxy）、反向代理（reverse proxy）之类的名称；</p>
</blockquote>
<p>当在浏览器中开启代理功能时，浏览器发送出去的请求会有所不同，主要区别如下：</p>
<ul>
<li>没有代理<ul>
<li>请求发往目标网站所在的服务器；</li>
<li>HTTP 报文的 URI 只有路径，没有域名；</li>
</ul>
</li>
<li>有代理<ul>
<li>请求发往代理服务器；</li>
<li>HTTP 报文的 URI 包含完整的域名和路径；</li>
</ul>
</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211217074225.png"></p>
<h3 id="正向代理的改良版–反向代理"><a href="#正向代理的改良版–反向代理" class="headerlink" title="正向代理的改良版–反向代理"></a>正向代理的改良版–反向代理</h3><p>由于使用正向代理要求用户修改浏览器配置，比较麻烦而且容易出错导致浏览器无法正常工作。因此改进的办法是将缓存服务器部署到服务端，将 HTTP 报文中的 URI 和目标 Web 服务器进行关联（因为 HTTP 1.0 版本没有 Host 字段），这样就可以得到完整的网站，从而能够转发任意消息。为了跟传统的前端代理以示区别，这种方式称为反向代理（reverse proxy）；</p>
<h3 id="透明代理"><a href="#透明代理" class="headerlink" title="透明代理"></a>透明代理</h3><p>正向代理需要配置浏览器，反向代理需要配置服务器，二者才能正常工作；还有一种方案是根据数据包中 IP 头部来判断转发目标，这样就既不需要配置服务端，也无须配置浏览器，同时还获得了各自的优点；</p>
<p>由于透明代理作为中间人在工作，因此它必须知道最终访问的目标 IP 地址，而不能让自己像反向代理一样成为被访问目标，否则数据包中的最终目标 IP 地址就变成它自己了（貌似可以通过域名再次查询出来？）；为了实现透明代理的功能，透明代理需要放置于数据包发出方和接收方之间的传输线路上面；</p>
<h2 id="内容分发服务"><a href="#内容分发服务" class="headerlink" title="内容分发服务"></a>内容分发服务</h2><h3 id="利用内容分发服务分担负载"><a href="#利用内容分发服务分担负载" class="headerlink" title="利用内容分发服务分担负载"></a>利用内容分发服务分担负载</h3><p>如果将缓存服务器放在服务端，那么它可以减轻后端 Web 服务器的负担，提高后端这一段的访问速度，但由于所有的用户流量仍然会到达缓存服务器，因此它无法避免网络传输线路上存在的堵塞；</p>
<p>如果缓存服务器由用户自己部署在客户端，那么它可以很好的避免网络上的堵塞，但是 Web 服务器无法控制客户端缓存服务器中的内容；</p>
<p>第三种方案就是将缓存服务器放在互联网的边缘（即客户端所在的运营商机房），这样客户端在进入堵塞区域之前，能够先到达运营商机房内部的缓存服务器，既提高了客户端的访问速度，也减轻了服务端的负担，同时服务端也能够控制缓存服务器上面的内容；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211217082159.png"></p>
<p>单个 Web 服务器的运营者跟运营商签合同的话，费用成本很高，因此出现了专门的第三方，他们和主要的几家运营商签合同，之后再租借给单个的 Web 服务器运营者，实现三赢；这种模式称为内容分发服务；</p>
<h3 id="如何找到最近的缓存服务器"><a href="#如何找到最近的缓存服务器" class="headerlink" title="如何找到最近的缓存服务器"></a>如何找到最近的缓存服务器</h3><p> 寻找最近的缓存服务器有多种方案，其中一种是使用 DNS；大致原理如下：</p>
<ul>
<li>Web 服务器注册的 DNS 服务器先收集好各缓存服务器的路由信息；</li>
<li>当收到客户端发出的 DNS 解析请求时，基于上一步的路由信息，判断客户端到哪台缓存服务器的路径最短，并返回结果；</li>
</ul>
<h3 id="通过重定向服务器分配访问目标"><a href="#通过重定向服务器分配访问目标" class="headerlink" title="通过重定向服务器分配访问目标"></a>通过重定向服务器分配访问目标</h3><p>另外一种寻找最近缓存服务器的方法是添加重定向服务器，并将其添加到 DNS 解析记录中；这样当客户端发起请求时，数据包先到达重定向服务器，之后重定向服务器基于提前收集好的路由信息，判断最近的缓存缓存器，并存储在 HTTP 响应头部中的 Location 字段。客户端在收到该响应后，会向 Location 中的缓存服务器地址，发起一个新的连接；</p>
<h3 id="缓存的更新方法会影响性能"><a href="#缓存的更新方法会影响性能" class="headerlink" title="缓存的更新方法会影响性能"></a>缓存的更新方法会影响性能</h3><p>缓存机制最早是被动式的，首次收到请求后，发现缓存中没有数据，因此向 Web 服务器请求资源；后续的请求则每次询问 Web 服务器资源是否变更，若没有变更，则返回缓存中的内容；这种被动式的缓存有两个缺点，一是首次访问较慢，二是后续的每次查询仍然会给 Web 服务器带来一定的负担；</p>
<p>更好的办法是使用主动式的缓存，它的原理是当 Web 服务器上面的内容有变更时，就通知缓存服务器更新。这种方法可以避免后续 Web 服务器收到大量关于资源是否变更的询问；</p>
<h1 id="请求到达-Web-服务器，响应返回浏览器"><a href="#请求到达-Web-服务器，响应返回浏览器" class="headerlink" title="请求到达 Web 服务器，响应返回浏览器"></a>请求到达 Web 服务器，响应返回浏览器</h1><h2 id="服务器概览"><a href="#服务器概览" class="headerlink" title="服务器概览"></a>服务器概览</h2><h3 id="客户端与服务器的区别"><a href="#客户端与服务器的区别" class="headerlink" title="客户端与服务器的区别"></a>客户端与服务器的区别</h3><p>客户端与服务器并没有本质上的区别，都是计算机，唯一的区别是服务器要先做好开门候客的动作（在没有客户端请求到达之前，需要先创建好套接字并进入待连接状态；而客户端只需要发起连接前，再临时创建套接字即可）；因为在 TCP 协议的设计中，必须有一方处于待连接的状态，连接才有可能建立；</p>
<blockquote>
<p>虽然在本质上没有不同，但所使用的硬件型号一般有所区别，服务器的使用场景有两个关键特点，一个是并发量高，需要应付很多客户端的访问；二是需要长时期的稳定运行。为了满足这两种需求，一般服务器的 CPU 核数更多，但单核性能不高；内存更大，而且带校验机制，但内存性能较低；通常不配备显卡，网卡比较多，可拓展更多的硬盘，以满足存储需求；</p>
</blockquote>
<h3 id="服务器程序的结构"><a href="#服务器程序的结构" class="headerlink" title="服务器程序的结构"></a>服务器程序的结构</h3><p>服务端要应付多个客户端发起的连接请求，因此服务端会给每个请求创建一个单独的套接字；大概过程如下：</p>
<p>当服务端创建完第一个套接字后，先进入监听状态和等待连接的状态；之后如果有新的客户端连接请求到达，它就会复制一个套接字副本出来（使用新的文件描述符），并将客户端的控制信息填写到副本里面，而旧的套接字内容保持不变，并继续处于待连接状态，以便应付新的客户端请求；当有多个客户端同时连接服务端时，就会存在多个套接字副本，更有意思的是，它们都绑定到相同的端口号；</p>
<p>协议栈会维护一张套接字映射表，通过四项信息的组合，来识别接收到的数据包到底是属于哪个套接字，这四项信息分别是客户端IP+客户端端口+本机IP+本机端口；根据这四项信息，通过查找映射表，就知道当前的数据包是属于哪个套接字了；</p>
<p>而对于应用程序来说，是通过文件描述符来跟套接字打交道的；多个套接字副本，意味着有多个文件描述符；当某个文件描述符进入就绪状态后，它会发起一个中断，之后操作系统会通知应用程序，并将控制权转移给应用程序进行处理；</p>
<blockquote>
<p>特别注意：套接字跟端口可以是多对一的关系，协议栈会维护一张映射表，根据数据包中的头部信息判断，该数据包隶属于哪个套接字负责；每个套接字中存储着不同的连接信息；</p>
<p>以前在学 《深入》和 C 语言时，由于 socket 初始化后，总是有一个 bind 的动作，误以为套接字和端口是一对一的关系，现在才发现其实不是；以前没有留意到 accept 动作会返回新的套接字，回头看了一下笔记，才发现当时写的是描述符，因此没有意识到 accept 返回的新描述符背后，其实是一个新的套接字；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211218070827.png"></p>
<h3 id="服务器端的套接字和端口号"><a href="#服务器端的套接字和端口号" class="headerlink" title="服务器端的套接字和端口号"></a>服务器端的套接字和端口号</h3><p>服务端的应用程序大致可以划分为两个模块：</p>
<ul>
<li>负责建立连接的模块，即下图的连接模块；</li>
<li>负责生成响应的模块，即下图的通信模块；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211218074210.png"></p>
<p>调用 accept 并不会马上返回新的套接字，在客户端的请求没有到达之前，它其实是进入阻塞的状态，要一直等到客户端的请求进来后，才会返回新套接字；该新套接字其实不是从头新建的，而是复制旧套接字并进行补充客户端连接信息后而来的；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211218075418.png"></p>
<p>当出现多个套接字对应同一个端口号时，为避免混乱，协议栈必须维护一张映射表，以便知悉哪个客户端请求对应的是哪个套接字；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211218075756.png"></p>
<h2 id="服务器的接收操作"><a href="#服务器的接收操作" class="headerlink" title="服务器的接收操作"></a>服务器的接收操作</h2><h3 id="网卡将接收到的信号转换成数字信息"><a href="#网卡将接收到的信号转换成数字信息" class="headerlink" title="网卡将接收到的信号转换成数字信息"></a>网卡将接收到的信号转换成数字信息</h3><p>网卡收到电信号后：</p>
<ul>
<li>先根据规范约定的波形判断出头部的位置，</li>
<li>从头部中读取到时钟周期</li>
<li>基于该时钟周期，从原始被发送方叠加过时期周期的电信号中，分离出原始信号；</li>
<li>将原始信号转换成 0 和 1 表示的数字信号；</li>
<li>根据规范，从数字信号末尾读取校验值；</li>
<li>计算解析后的数字信号的校验值，看是否跟收到的校验值一致；</li>
<li>若不一致，丢弃该数据包；</li>
<li>若一致，检查头部中的 MAC 值是否跟当前网卡的 MAC 值一致；</li>
<li>若不一致，丢弃该数据包；</li>
<li>若一致，将数字信号放到缓存中，触发中断事件，以便 CPU 介入，并将控制权转移给网卡驱动程序；</li>
<li>网卡驱动程序读取缓存中的数据，根据 MAC 头部判断使用何种协议；然后触发中断事件，以便 CPU 介入，并将控制权转给相应的协议栈进行处理；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211218083942.png"></p>
<h3 id="IP-模块的接收操作"><a href="#IP-模块的接收操作" class="headerlink" title="IP 模块的接收操作"></a>IP 模块的接收操作</h3><p>IP 模块收到数据包后的动作：</p>
<ul>
<li>检查 IP 头部中的目标 IP 地址，判断该包是否发给自己；</li>
<li>若不是，则根据情况（是否开启转发功能）转发该数据包；</li>
<li>若是，检查是否分片；若有分，则等待所有分片到达后组装它们；</li>
<li>组装好后，检查头部中的协议号字段，看使用何种协议，并转交给相应的协议模块（如 TCP ）进行处理；</li>
</ul>
<h3 id="TCP-模块如何处理连接包"><a href="#TCP-模块如何处理连接包" class="headerlink" title="TCP 模块如何处理连接包"></a>TCP 模块如何处理连接包</h3><p>TCP 模块收到 IP 模块转交的数据后：</p>
<ul>
<li>检查头部中的端口号字段，看有无套接字在监听该端口号；</li>
<li>若没有，发送一条 ICMP 消息给客户端告知错误（黑客可基于该条规则对端口号进行扫描，了解有哪些端口号处于监听状态）；如果有，继续往下；</li>
<li>检头部中的控制位 SYN，如果值为 1，表示这个一个尝试建立连接的控制包；复制一份当前监听访端口的套接字，写入客户端相关信息（如客户端的 IP 地址、端口号、窗口大小、序列起始值等）；然后生成包含己方连接信息的控制包，转交给 IP 模块处理发出去；</li>
</ul>
<h3 id="TCP-模块如何处理数据包"><a href="#TCP-模块如何处理数据包" class="headerlink" title="TCP 模块如何处理数据包"></a>TCP 模块如何处理数据包</h3><p>如果 TCP 头部中的控制位没有值，则说明当前包是一个数据包，而不是连接控制包，动作如下：</p>
<ul>
<li>判断该数据包属于哪个套接字处理，判断办法基于接发双方的 IP 地址和端口号四项信息即可；</li>
<li>根据套接字中保存的信息，了解之前已收到第几个序列号的包，以及当前包的序号是否能够连上，以便后续可以将各个分包组装成完整的数据；若可连上，将数据放入缓冲区；</li>
<li>每隔一小段时间，发送 ACK 控制信息给客户端，告知某个序号以前的包已经收到了；</li>
<li>收到所有包后，触发中断事件，CPU 介入，通知应用程序来读取数据；</li>
</ul>
<h3 id="TCP-模块的断开操作"><a href="#TCP-模块的断开操作" class="headerlink" title="TCP 模块的断开操作"></a>TCP 模块的断开操作</h3><p>当收到完整的数据包之后，连接就可以断开了，断开动作可以由客户端发起，也可以由服务端发起；</p>
<ul>
<li>HTTP 1.0，规定由服务端发起；</li>
<li>HTTP 1.1，规定由客户端发起；</li>
</ul>
<h2 id="Web-服务器程序解释请求消息并作出响应"><a href="#Web-服务器程序解释请求消息并作出响应" class="headerlink" title="Web 服务器程序解释请求消息并作出响应"></a>Web 服务器程序解释请求消息并作出响应</h2><h3 id="将请求的-URI-转换为实现的文件名"><a href="#将请求的-URI-转换为实现的文件名" class="headerlink" title="将请求的 URI 转换为实现的文件名"></a>将请求的 URI 转换为实现的文件名</h3><p>对于静态资源的访问，请求中的 URI 通常会映射到服务器上面某个目录中的某个文件， 只需提前在服务器程序中进行配置好可；文件名可以一一对应，也可以不一样，然后通过配置好的改写规则进行映射即可；</p>
<h3 id="运行-CGI-程序"><a href="#运行-CGI-程序" class="headerlink" title="运行 CGI 程序"></a>运行 CGI 程序</h3><p>对于动态资源的访问，一般 URI 会被映射给某个符合 CGI 标准的程序文件；当访问该 URI 时，就会委托操作系统运行相应的 CGI 程序文件，此时会将 HTTP 请求报文的内容作为参数传递给该 CGI  程序；</p>
<p>传统的 CGI 程序在运行结束后，会生成 HTML 格式的内容作为响应消息，现在则衍生出了很多种格式，例如 XML，JSON 等格式；之后将响应内容交给服务器模块发送给客户端，服务器模块不会修改内容，但有时会添加一些头部字段；</p>
<h3 id="Web-服务器的访问控制"><a href="#Web-服务器的访问控制" class="headerlink" title="Web 服务器的访问控制"></a>Web 服务器的访问控制</h3><p>如果某些资源限制访问，当收到访问这些限制资源的请求时，需要验证用户的身份，以检查是否满足访问条件，常用的办法是使用用户名和密码，偶尔会使用客户端的 IP；</p>
<h3 id="返回响应消息"><a href="#返回响应消息" class="headerlink" title="返回响应消息"></a>返回响应消息</h3><p>返回响应消息的过程跟发出消息的过程差不多，只是反过来而已；</p>
<h2 id="浏览器接收响应消息并显示内容"><a href="#浏览器接收响应消息并显示内容" class="headerlink" title="浏览器接收响应消息并显示内容"></a>浏览器接收响应消息并显示内容</h2><h3 id="通过响应的数据类型判断其中的内容"><a href="#通过响应的数据类型判断其中的内容" class="headerlink" title="通过响应的数据类型判断其中的内容"></a>通过响应的数据类型判断其中的内容</h3><p>浏览器在收到服务器返回的消息后，需要先根据头部的 content-type 字段判断一下消息的类型，以便能够正常显示它们；常见的消息类型有 text、image、audio、video、application、multipart（复合类型）等；例如：</p>
<p>Content-Type: text&#x2F;html; charset&#x3D;utf-8，text 表示主类型为文本，斜杠右边的 html 表示子类型，charset 表示编码方式；</p>
<p>另外为了提高传输速度，数据有可能被压缩了，此时可以根据头部的 Content-Encoding 字段了解使用的压缩方式，然后进行解压；</p>
<h3 id="浏览器显示网页内容"><a href="#浏览器显示网页内容" class="headerlink" title="浏览器显示网页内容"></a>浏览器显示网页内容</h3><p>有些数据类型如 HTML、图片是浏览器能够直接显示的，有些浏览器显示不了的数据类型，就会调用相应的应用程序来处理数据；</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="TSL-连接过程"><a href="#TSL-连接过程" class="headerlink" title="TSL 连接过程"></a>TSL 连接过程</h2><h3 id="单向认证"><a href="#单向认证" class="headerlink" title="单向认证"></a>单向认证</h3><ul>
<li>客户端：发起问候，告知服务端自己所支持的协议和加密套件，以及客户端生成的随机数；</li>
<li>服务端：发起问候，告知客户端自己的 SSL 公钥以及相应的签发机构，所支持的协议和加密套件，以及服务端生成的随机数；</li>
<li>客户端：用证书机构的公钥，验证服务端的 SSL 公钥是否和所访问的域名一致；若不一致，结束；若一致，下一步；</li>
<li>客户端：生成第二个随机数（称为 premaster secret），使用服务端的公钥加密后，发给服务端；</li>
<li>服务端：用私钥解密收到的数据，得到 premaster secret，加上之前双方各自生成的两个随机数，共三个随机数，使用加密套件生成会话密钥；使用会话密钥，加密“已完成”的消息，发给客户端，告知对方自己就绪；</li>
<li>客户端：同样使用三个随机数生成会话密钥，加密“已完成”的消息，发给服务端，告知对方自己就绪；</li>
<li>双方完成握手；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20211227085902.png"></p>
<h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><p>双向认证与单向认证的唯一不同点在于第4步，客户端在发送 premaster 时，还会同时附上自己的公钥证书，以及将之前双方的随机字符串使用自己的私钥进行加密并发送，这样服务端收到该公钥证书，使用 CA 可以进行验证；如果有问题，中断通信，握手失败；如果没问题，后续跟单向认证相同，即开始用自己的私钥解密得到 premaster，然后使用加密套件计算出会话密钥；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211825009.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211826047.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211826196.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211827281.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211827217.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211828355.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211828468.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211829615.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211829705.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211830582.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211830669.png"></p>
<h2 id="非对称密钥"><a href="#非对称密钥" class="headerlink" title="非对称密钥"></a>非对称密钥</h2><ul>
<li>使用 openssl 等工具，可以生成非对称密钥，即一把公钥和一把私钥，其中一把加密后的内容，可以由另外一把解密；</li>
<li>所谓的证书，是指使用权威 CA 机构的私钥，对公钥拥有者（例如域名）和公钥本身进行加密后，生成的内容；由于 CA 机构的公钥是公开的，因此任何人都可以使用 CA 机构的公钥对证书进行解密，解密后就可以验证其中的内容（公钥+公钥所有者的身份信息），例如域名是否为预期想访问的网站域名；如果是，说明该证书是有效的；</li>
<li>权威机构在受理证书申请时，需要验证申请人的身份信息，例如申请网站的域名证书时，就需要验证该域名是否真的被申请人持有；Let’s Encrypt 的方法是生成两个随机字符串，一个做为域名的访问路径，然后发起对该路径的访问，看访问结果是否为另外一个随机字符串；如果是，说明域名确实由申请者所拥有，因为申请者能够将字符串添加到访问路径和访问结果中；</li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件/">软件</a><a href="/tags/网络/">网络</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/11/12/js 多重继承/"><span>js多重继承</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/11/12/js 多重继承/" rel="bookmark">
        <time class="entry-date published" datetime="2017-11-12T08:46:48.000Z">
          2017-11-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h4 id="方法一：克隆一个A对象，再将-B-对象的属性混入，适用于-A-B-的属性不冲突的场景；"><a href="#方法一：克隆一个A对象，再将-B-对象的属性混入，适用于-A-B-的属性不冲突的场景；" class="headerlink" title="方法一：克隆一个A对象，再将 B 对象的属性混入，适用于 A&#x2F;B 的属性不冲突的场景；"></a>方法一：克隆一个A对象，再将 B 对象的属性混入，适用于 A&#x2F;B 的属性不冲突的场景；</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mixInto</span>(<span class="params">object, mixIn</span>)&#123;</span><br><span class="line">    <span class="title function_">forEachIn</span>(mixIn, <span class="keyword">function</span>(<span class="params">name, value</span>)&#123;</span><br><span class="line">        object[name] = value;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">SmallDetailedItem</span> = <span class="title function_">clone</span>(<span class="title class_">DetailedItem</span>);</span><br><span class="line"><span class="title function_">mixInto</span>(<span class="title class_">SmallDetailedItem</span>, <span class="title class_">SmallItem</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deadMouse = <span class="title class_">SmallDetailedItem</span>.<span class="title function_">create</span>(<span class="string">&quot;Fred the mouse&quot;</span>, <span class="string">&quot;he is dead&quot;</span>);</span><br></pre></td></tr></table></figure>


<h4 id="方法二：用-A-对象扩展一个子对象，再用-B-对象-扩展并覆盖子对象中的冲突属性；"><a href="#方法二：用-A-对象扩展一个子对象，再用-B-对象-扩展并覆盖子对象中的冲突属性；" class="headerlink" title="方法二：用  A 对象扩展一个子对象，再用 B 对象 扩展并覆盖子对象中的冲突属性；"></a>方法二：用  A 对象扩展一个子对象，再用 B 对象 扩展并覆盖子对象中的冲突属性；</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Monster</span> = <span class="title class_">Item</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">	<span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">name, dangerous</span>)&#123;</span><br><span class="line">		<span class="title class_">Item</span>.<span class="property">construct</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">dangerous</span> = dangerous;</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">kick</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dangerous</span>)&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; bites your head off&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; squeaks and runs away&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">DetailedMonster</span> = <span class="title class_">DetailedItem</span>.<span class="title function_">extend</span>(&#123;</span><br><span class="line">	<span class="attr">construct</span>: <span class="keyword">function</span>(<span class="params">name, description, dangerous</span>)&#123;</span><br><span class="line">		<span class="title class_">DetailedItem</span>.<span class="property">construct</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, dangerous);</span><br><span class="line">		<span class="title class_">Monster</span>.<span class="property">construct</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, dangerous);</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">kick</span>: <span class="title class_">Monster</span>.<span class="property">kick</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> giantSloth = <span class="title class_">DetailedMonster</span>.<span class="title function_">create</span>(</span><br><span class="line">	<span class="string">&quot;the giant sloth&quot;</span>,</span><br><span class="line">	<span class="string">&quot;it is quietly hanging from a tree, munching leaves&quot;</span>,</span><br><span class="line">	<span class="literal">false</span>);</span><br><span class="line">	</span><br><span class="line">giantSloth.<span class="title function_">kick</span>();</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件/">软件</a><a href="/tags/javascript/">javascript</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/07/25/流畅的Python/"><span>流畅的Python</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/07/25/流畅的Python/" rel="bookmark">
        <time class="entry-date published" datetime="2017-07-25T10:34:00.000Z">
          2017-07-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="第1章-Python-数据结构"><a href="#第1章-Python-数据结构" class="headerlink" title="第1章  Python 数据结构"></a>第1章  Python 数据结构</h1><h2 id="一摞-Python-风格的纸牌"><a href="#一摞-Python-风格的纸牌" class="headerlink" title="一摞 Python 风格的纸牌"></a>一摞 Python 风格的纸牌</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FrenchDeck</span>:</span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>)] + <span class="built_in">list</span>(<span class="string">&#x27;JQKA&#x27;</span>)</span><br><span class="line">    suits = <span class="string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="variable language_">self</span>._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> <span class="variable language_">self</span>.suits</span><br><span class="line">    					<span class="keyword">for</span> rank <span class="keyword">in</span> <span class="variable language_">self</span>.ranks]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">len</span>(<span class="variable language_">self</span>._cards)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, position</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">self</span>._cards[position]</span><br></pre></td></tr></table></figure>

<p>上面这个代码示例惊艳到我了，让我对 Python 的类刮目相看；此刻我才开始开始意识到内置方法的存在；</p>
<p>例如它仅仅因为实现了 _<em>len_</em> 和 _<em>getitem_</em> 两个特殊方法，便使得这个类能够自动使用 Python 的内置函数，例如</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 len 函数获得数量</span></span><br><span class="line"> deck = FrenchDeck()</span><br><span class="line"> <span class="built_in">len</span>(deck)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用索引访问列表中的元素</span></span><br><span class="line">deck[<span class="number">0</span>]</span><br><span class="line">deck[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用内置的标准库，例如 random，从列表中随机读取元素</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line">choice(deck)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动支持切片操作</span></span><br><span class="line">deck[:<span class="number">3</span>]</span><br><span class="line">deck[<span class="number">12</span>::<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动可迭代</span></span><br><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> deck:</span><br><span class="line">    <span class="built_in">print</span>(card)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 自动支持 in 运算符</span></span><br><span class="line">Card(<span class="string">&quot;Q&quot;</span>, <span class="string">&quot;hearts&quot;</span>) <span class="keyword">in</span> deck</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只需定义排序规则，即可自动支持内置的 sorted 排序函数</span></span><br><span class="line">suit_values = <span class="built_in">dict</span>(spades=<span class="number">3</span>, hearts=<span class="number">2</span>, diamonds=<span class="number">1</span>, clubs=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">spades_high</span>(<span class="params">card</span>):</span><br><span class="line">    rank_value = FrenchDeck.rands.index(card.rand)</span><br><span class="line">    <span class="keyword">return</span> rank_value * <span class="built_in">len</span>(suit_values) + suite_values[card.suit]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> <span class="built_in">sorted</span>(deck, key = spades_high):</span><br><span class="line">    <span class="built_in">print</span>(card)</span><br></pre></td></tr></table></figure>



<h2 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h2><p>特殊方法是为了给解释器调用，从而实现一些内置的功能，而不是为了自己调用；如果是自己调用，那么只需写普通方法即可，无须写特殊方法；</p>
<p>另外，也尽量避免随意添加特殊方法，因为有可能出解释器内置的方法出现命名冲突，导致发生不可预知的情况；</p>
<p>特殊方法还可以用来重载运算符，例如转成字符串，加号，乘号，取绝对值等，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line">    </span><br><span class="line">     <span class="comment"># repr 用来定义对象用字符串如何显示，另外还有一个 str 用来给 str() 或者 print 函数调用</span></span><br><span class="line">     <span class="comment"># 通常定义 repr 即可，它更加通用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(%r, %r)&#x27;</span> % (<span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__abs__</span>(<span class="params">self</span>):  <span class="comment"># 重载了 abs 函数</span></span><br><span class="line">        <span class="keyword">return</span> hypot(<span class="variable language_">self</span>.x, <span class="variable language_">self</span>.y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__bool__</span>(<span class="params">self</span>): <span class="comment"># 当调用 bool 函数时，如何判断对象是否为真</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="variable language_">self</span>.x <span class="keyword">or</span> <span class="variable language_">self</span>.y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>): <span class="comment"># 重载了加号</span></span><br><span class="line">        x = <span class="variable language_">self</span>.x + other.x</span><br><span class="line">        y = <span class="variable language_">self</span>.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, scalar</span>):  <span class="comment"># 重载了乘号</span></span><br><span class="line">        <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x * scalar, <span class="variable language_">self</span>.y * scalar)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h2 id="特殊方法一览"><a href="#特殊方法一览" class="headerlink" title="特殊方法一览"></a>特殊方法一览</h2><p>特殊方法挺多的，有80 多个，其中有 40 个多用于实现算术运算、位运算和比较操作；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261657707.png"></p>
<h2 id="为什么-len-不是普通-方法"><a href="#为什么-len-不是普通-方法" class="headerlink" title="为什么 len 不是普通 方法"></a>为什么 len 不是普通 方法</h2><p>len 的目的是为了读取对象的长度，对于内置类型的对象，它们是用 C 语言的 struct 表示的，struct 里面有个属性存储着长度值，因此在这种情况下，len  会直接去读取 struct 的长度值，而不是调用 _<em>len</em>_ 来计算长度；主要是出于性能考量</p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>通过实现特殊方法，能够让自定义类型表现跟内置类型一样，从而能够直接使用 Python 的很多内置函数，让代码更容易阅读；</p>
<h1 id="第2章-序列构成的数组"><a href="#第2章-序列构成的数组" class="headerlink" title="第2章 序列构成的数组"></a>第2章 序列构成的数组</h1><h2 id="内置序列类型"><a href="#内置序列类型" class="headerlink" title="内置序列类型"></a>内置序列类型</h2><p>Python 有两种序列类型，一种存放的是对象的引用，因此它可以容纳任何类型，称为容器序列；一种存放值，而不是引用，因此只能放相同类型的值，称为扁平序列；</p>
<p>序列按照能否修改，可分为可变序列和不可变序列</p>
<ul>
<li>可变序列（Mutable Sequence）：list, bytearray, array.array, collections.deque, memoryview</li>
<li>不可变序列（Sequence）：tuple, str, bytes</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261807612.png"></p>
<h2 id="列表推导和生成器表达式"><a href="#列表推导和生成器表达式" class="headerlink" title="列表推导和生成器表达式"></a>列表推导和生成器表达式</h2><p>列表推导式（list comprehension）非常适合用来创建新的列表，这种写法更容易读懂；如果列表推导太长，则可以改用传统的 for 循环；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts</span><br><span class="line">[(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;L&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;S&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>生成器表达式用来其他类型的序列；生成器表达式使用圆括号，而不是方括号；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols) <span class="comment"># 由于生成器表达式是函数的唯一参数，所以无需用括号括起来</span></span><br><span class="line">(<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array.array(<span class="string">&#x27;I&#x27;</span>, (<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)) <span class="comment"># 非唯一参数，所以多加了一层括号</span></span><br><span class="line">array(<span class="string">&#x27;I&#x27;</span>, [<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>])</span><br></pre></td></tr></table></figure>

<p>生成器表达式每次产生一个运算结果，而不是一下生成整个列表，这样可以节省内存，尤其是元素多的时候，非常明显</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">&#x27;%s %s&#x27;</span> % (c, s) <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes): <span class="comment"># 一次只生成一个计算结果，而非整个列表</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(tshirt)</span><br><span class="line">...</span><br><span class="line">black S</span><br><span class="line">black M</span><br><span class="line">black L</span><br><span class="line">white S</span><br><span class="line">white M</span><br><span class="line">white L</span><br></pre></td></tr></table></figure>

<h2 id="元组不仅仅是不可变的列表"><a href="#元组不仅仅是不可变的列表" class="headerlink" title="元组不仅仅是不可变的列表"></a>元组不仅仅是不可变的列表</h2><p>元组是不可变列表，但其实它存放的数据，也可以基于顺序来表达不同的含义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traveler_ids = [(<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;31195855&#x27;</span>), (<span class="string">&#x27;BRA&#x27;</span>, <span class="string">&#x27;CE342567&#x27;</span>), (<span class="string">&#x27;ESP&#x27;</span>, <span class="string">&#x27;XDA205856&#x27;</span>)]</span><br><span class="line"><span class="comment"># 位置1是国家，位置2是代号</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lax_coordinates = (<span class="number">33.9425</span>, -<span class="number">118.408056</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>latitude, longitude = lax_coordinates <span class="comment"># 元组拆包</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b, a = a, b</span><br><span class="line"><span class="comment"># 使用拆包，实现变量的值交换</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">divmod</span>(*t) <span class="comment"># 星号 * 可用来将元组拆包成函数的函数</span></span><br></pre></td></tr></table></figure>

<p>星号* 可用来存放拆包的余下元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">5</span>)  <span class="comment"># 星号 * 用来存放剩余元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="built_in">range</span>(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放在中间的位置也可以</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *body, c, d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, body, c, d</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 放在开头的位置也可以</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*head, b, c, d = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>head, b, c, d</span><br><span class="line">([<span class="number">0</span>, <span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="嵌套元组拆包"><a href="#嵌套元组拆包" class="headerlink" title="嵌套元组拆包"></a>嵌套元组拆包</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">    (<span class="string">&#x27;Tokyo&#x27;</span>,<span class="string">&#x27;JP&#x27;</span>,<span class="number">36.933</span>,(<span class="number">35.689722</span>,<span class="number">139.691667</span>)), <span class="comment"># 嵌套的元组</span></span><br><span class="line">    (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">    (<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line">    (<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line">    (<span class="string">&#x27;Sao Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas: <span class="comment"># 嵌套拆包</span></span><br><span class="line">    <span class="keyword">if</span> longitude &lt;= <span class="number">0</span>: </span><br><span class="line">    	<span class="built_in">print</span>(fmt.<span class="built_in">format</span>(name, latitude, longitude))</span><br></pre></td></tr></table></figure>

<h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>City = namedtuple(<span class="string">&#x27;City&#x27;</span>, <span class="string">&#x27;name country population coordinates&#x27;</span>) <span class="comment"># 定义元组结构</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo = City(<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)) <span class="comment"># 赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo</span><br><span class="line">City(name=<span class="string">&#x27;Tokyo&#x27;</span>, country=<span class="string">&#x27;JP&#x27;</span>, population=<span class="number">36.933</span>, coordinates=(<span class="number">35.689722</span>,</span><br><span class="line"><span class="number">139.691667</span>)) <span class="comment"># 各个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo.population ➌</span><br><span class="line"><span class="number">36.933</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo.coordinates</span><br><span class="line">(<span class="number">35.689722</span>, <span class="number">139.691667</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;JP&#x27;</span></span><br></pre></td></tr></table></figure>

<p>具名元组有一些内置的属性和方法，包括：</p>
<ul>
<li>_fields 属性，用来查看所有字段的名称</li>
<li>_make() 方法，用来创建实例</li>
<li>_asdict() 方法，用来返回 OrderDict</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>City._fields </span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;country&#x27;</span>, <span class="string">&#x27;population&#x27;</span>, <span class="string">&#x27;coordinates&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LatLong = namedtuple(<span class="string">&#x27;LatLong&#x27;</span>, <span class="string">&#x27;lat long&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi_data = (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, LatLong(<span class="number">28.613889</span>, <span class="number">77.208889</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi = City._make(delhi_data) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi._asdict() </span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Delhi NCR&#x27;</span>), (<span class="string">&#x27;country&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>), (<span class="string">&#x27;population&#x27;</span>, <span class="number">21.935</span>), (<span class="string">&#x27;coordinates&#x27;</span>, LatLong(lat=<span class="number">28.613889</span>, long=<span class="number">77.208889</span>))])</span><br></pre></td></tr></table></figure>

<p>相对列表，元组没有添加和删除元素的方法，其他方法则都差不多；</p>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片有个特殊的用法，即 s[a : b : c]，它表示在 a ~ b 的区间内，以 c 为间隔取值；即  s[start : stop : step]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;bicycle&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">3</span>] <span class="comment"># 正序，间隔 3 取值</span></span><br><span class="line"><span class="string">&#x27;bye&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">1</span>] <span class="comment"># 倒序，间隔 1 取值</span></span><br><span class="line"><span class="string">&#x27;elcycib&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::-<span class="number">2</span>]  <span class="comment"># 倒序，间隔 2 取值</span></span><br><span class="line"><span class="string">&#x27;eccb&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">12</span>::<span class="number">13</span>] <span class="comment"># 正序，从 12 开始，间隔 13 取值，</span></span><br></pre></td></tr></table></figure>

<p>切片有个很有意思的用法，它可以让代码更易读</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>SKU = <span class="built_in">slice</span>(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>DESCRIPTION = <span class="built_in">slice</span>(<span class="number">6</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>UNIT_PRICE = <span class="built_in">slice</span>(<span class="number">40</span>, <span class="number">52</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>QUANTITY = <span class="built_in">slice</span>(<span class="number">52</span>, <span class="number">55</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ITEM_TOTAL = <span class="built_in">slice</span>(<span class="number">55</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> line_items:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(item[UNIT_PRICE], item[DESCRIPTION]) <span class="comment"># 此处的 UNIT_PRICE 也可硬编码，但这样写更优雅</span></span><br><span class="line">...</span><br><span class="line">$<span class="number">17.50</span> Pimoroni PiBrella</span><br><span class="line">$<span class="number">4.95</span> 6mm Tactile Switch x20</span><br><span class="line">$<span class="number">28.00</span> Panavise Jr. - PV-<span class="number">201</span></span><br><span class="line">$<span class="number">34.95</span> PiTFT Mini Kit 320x240</span><br></pre></td></tr></table></figure>

<p>切片也可用来赋值，或者删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>] <span class="comment"># 赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>] <span class="comment"># 删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>::<span class="number">2</span>] = [<span class="number">11</span>, <span class="number">22</span>] <span class="comment"># 赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = <span class="number">100</span> <span class="comment"># 不可行，右侧需要是可迭代对象，不能是数值</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">100</span>] <span class="comment"># 可行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<h2 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用 + 和 *"></a>对序列使用 + 和 *</h2><p>加号 + 用来表示将两个序列拼接起来，并返回一个新的序列；</p>
<p>乘号 * 表示重复多份序列并拼接起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l * <span class="number">5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> * <span class="string">&#x27;abcd&#x27;</span></span><br><span class="line"><span class="string">&#x27;abcdabcdabcdabcdabcd&#x27;</span></span><br></pre></td></tr></table></figure>

<p>特别注意，在 [a] * n 这个表达式中，如果 a 是一个引用，那么复制出来的是 n 个引用，并且这 n 个引用实际上指向同一个对象；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正确用法，使用列表推导式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;X&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;X&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误用法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board = [[<span class="string">&#x27;_&#x27;</span>] * <span class="number">3</span>] * <span class="number">3</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;O&#x27;</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weird_board</span><br><span class="line">[[<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>], [<span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;O&#x27;</span>]] <span class="comment"># 虽然有三个列表，但指向同一个对象</span></span><br></pre></td></tr></table></figure>

<h2 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h2><p>自增 +&#x3D; 或者自乘 *&#x3D; 实际上调用的是 _<em>iadd</em>_  和  _<em>imul</em>_ 方法，如果一个类没有实际  iadd 方法，那么解释器就会调用 add 方法来计算，此时相当于 a &#x3D; a + b，因此，如果 a + b 返回的是一个新的对象，那么 a 将指向该新的对象，而不是改变旧对象的值；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4311953800</span> ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l *= <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(l)</span><br><span class="line"><span class="number">4311953800</span> ➋</span><br></pre></td></tr></table></figure>

<p>元组是不可变的，当在元组里面放入一个可变序列时，会出现异常情况，即该可变序列可被改变，但是无法将改变后的新序列，赋值给元组的引用；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>] += [<span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;tuple&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment <span class="comment"># 赋值给 t[2] 的时候报错了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]) <span class="comment"># 成功改变了序列</span></span><br></pre></td></tr></table></figure>

<h2 id="list-sort-方法和内置函数-sorted"><a href="#list-sort-方法和内置函数-sorted" class="headerlink" title="list.sort 方法和内置函数 sorted"></a>list.sort 方法和内置函数 sorted</h2><p>list.sort 会就地修改列表，返回 None</p>
<p>sorted 则不会修改原列表，而是会返回一个新的列表；</p>
<h2 id="用-bisect-来管理已排序的序列"><a href="#用-bisect-来管理已排序的序列" class="headerlink" title="用 bisect 来管理已排序的序列"></a>用 bisect 来管理已排序的序列</h2><p>bisect 用来从有序列表中查找某个值的插入位置，满足插入后原序列的顺序不变；</p>
<p>insort 用来将元素插入到有序列表中，插入后顺序保持不变；</p>
<h2 id="当列表不是首选时"><a href="#当列表不是首选时" class="headerlink" title="当列表不是首选时"></a>当列表不是首选时</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>array.array：数组里面存储的不是对象，而是字面值（例如数字，在内存中直接用字节表示即可）；因此它的读定性能要高很多；但因此它能够存储的类型也比较有限，只有少数几种；</p>
<p>创建数组时，需要通过参数指定类型，以便解释器能够决定如何分配内存空间；</p>
<h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><blockquote>
<p>memory view</p>
</blockquote>
<p>在不复制内容的情况下，操作数组的切片，例如 Numpy；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers = array.array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv = <span class="built_in">memoryview</span>(numbers) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(memv)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv[<span class="number">0</span>] </span><br><span class="line">-<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct = memv.cast(<span class="string">&#x27;B&#x27;</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct.tolist() </span><br><span class="line">[<span class="number">254</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>memv_oct[<span class="number">5</span>] = <span class="number">4</span> <span class="comment"># 此处的赋值，改变的是高位字节部分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numbers</span><br><span class="line">array(<span class="string">&#x27;h&#x27;</span>, [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1024</span>, <span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># 原本的 0，因为高位字节改变，变成了 1024</span></span><br></pre></td></tr></table></figure>

<h3 id="Numpy-和-SciPy"><a href="#Numpy-和-SciPy" class="headerlink" title="Numpy 和 SciPy"></a>Numpy 和 SciPy</h3><p>操作高阶数组和矩阵的利器；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = numpy.arange(<span class="number">12</span>) ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape ➌</span><br><span class="line">(<span class="number">12</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape = <span class="number">3</span>, <span class="number">4</span> ➍</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">[ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">[ <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="双向队列和其他形式的队列"><a href="#双向队列和其他形式的队列" class="headerlink" title="双向队列和其他形式的队列"></a>双向队列和其他形式的队列</h3><p>虽然可以用列表在模拟队列，但是性能并不好，尤其是在头部插入新元素时；双向队列更方便，而且可以指定长度，在超出长度时，会自动删除较早的内容；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq = deque(<span class="built_in">range</span>(<span class="number">10</span>), maxlen=<span class="number">10</span>) ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(<span class="number">3</span>) <span class="comment"># 旋转，将最后3个元素，放到前面来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(-<span class="number">4</span>) <span class="comment"># 将头部 4 个元素，放到后面去</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.appendleft(-<span class="number">1</span>) <span class="comment"># 添加到头部，会自动删除尾部溢出的部分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([-<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extend([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]) <span class="comment"># 添加到尾部，会删除头部溢出的部分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extendleft([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]) <span class="comment"># 逐一添加到头部，因此顺序会反过来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], maxlen=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>注：append 和 popleft 是原子操作，因此是线程安全的；</p>
<p>除了双向队列，还有以下几种队列，分别是：</p>
<ul>
<li>queue：如果队列满了，不会自动删除旧元素，而是会被锁住；因此可用来控制活跃线程的数量； </li>
<li>multiprocessing：用于进程间的通信</li>
<li>asyncio：用于异步编程</li>
<li>heapq：堆队列</li>
</ul>
<h1 id="第3章-字典和集合"><a href="#第3章-字典和集合" class="headerlink" title="第3章 字典和集合"></a>第3章 字典和集合</h1><h2 id="字典构造方法"><a href="#字典构造方法" class="headerlink" title="字典构造方法"></a>字典构造方法</h2><blockquote>
<p>如果一个对象是可散列的，那么它的散列值需要不可变，而且这个对象需要实现 hash 和 eq 方法，以便可以计算散列值并和其他对象做比较；</p>
</blockquote>
<p>字典有很多种构造方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">dict</span>(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = <span class="built_in">dict</span>([(<span class="string">&#x27;two&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;one&#x27;</span>, <span class="number">1</span>), (<span class="string">&#x27;three&#x27;</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = <span class="built_in">dict</span>(&#123;<span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b == c == d == e</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>



<h2 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h2><p>字典可以从任何以键值对作为元素的可迭代对象中构造出来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>DIAL_CODES = [ ➊</span><br><span class="line"><span class="meta">... </span>(<span class="number">86</span>, <span class="string">&#x27;China&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">91</span>, <span class="string">&#x27;India&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">1</span>, <span class="string">&#x27;United States&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">62</span>, <span class="string">&#x27;Indonesia&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">55</span>, <span class="string">&#x27;Brazil&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">92</span>, <span class="string">&#x27;Pakistan&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">880</span>, <span class="string">&#x27;Bangladesh&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">234</span>, <span class="string">&#x27;Nigeria&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">7</span>, <span class="string">&#x27;Russia&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>(<span class="number">81</span>, <span class="string">&#x27;Japan&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_code = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> DIAL_CODES&#125; <span class="comment"># 构造1 country : code</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>country_code</span><br><span class="line">&#123;<span class="string">&#x27;China&#x27;</span>: <span class="number">86</span>, <span class="string">&#x27;India&#x27;</span>: <span class="number">91</span>, <span class="string">&#x27;Bangladesh&#x27;</span>: <span class="number">880</span>, <span class="string">&#x27;United States&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"><span class="string">&#x27;Pakistan&#x27;</span>: <span class="number">92</span>, <span class="string">&#x27;Japan&#x27;</span>: <span class="number">81</span>, <span class="string">&#x27;Russia&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Brazil&#x27;</span>: <span class="number">55</span>, <span class="string">&#x27;Nigeria&#x27;</span>:</span><br><span class="line"><span class="number">234</span>, <span class="string">&#x27;Indonesia&#x27;</span>: <span class="number">62</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;code: country.upper() <span class="keyword">for</span> country, code <span class="keyword">in</span> country_code.items() <span class="comment"># 构造2 code : country </span></span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> code &lt; <span class="number">66</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">&#x27;UNITED STATES&#x27;</span>, <span class="number">55</span>: <span class="string">&#x27;BRAZIL&#x27;</span>, <span class="number">62</span>: <span class="string">&#x27;INDONESIA&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;RUSSIA&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常见的映射方法"><a href="#常见的映射方法" class="headerlink" title="常见的映射方法"></a>常见的映射方法</h2><p>有个 setdefault 方法不常用，但其实很不错。它的用法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">&quot;abc&quot;</span>: <span class="number">123</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.setdefault(<span class="string">&quot;abc&quot;</span>, <span class="number">456</span>) <span class="comment"># 如果 abc 没值，则赋值456；如果有值，则返回值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>



<h2 id="映射的弹性键查询"><a href="#映射的弹性键查询" class="headerlink" title="映射的弹性键查询"></a>映射的弹性键查询</h2><p>通常情况下，当我们使用 dict[key] 的方式访问时，如果该 key 不存在，会出现报错；而 collencts.defaultdict 可以处理这种情况；它会将该键为一个预先设定好的默认值，并返回该值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">WORD_RE = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\w+&#x27;</span>)</span><br><span class="line">index = collections.defaultdict(<span class="built_in">list</span>) <span class="comment"># list 代表默认的构造方法，如键不存在，则会调用该构造方法，构造默认值</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(sys.argv[<span class="number">1</span>], encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = <span class="keyword">match</span>.group()</span><br><span class="line">            column_no = <span class="keyword">match</span>.start()+<span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line">            index[word].append(location)</span><br></pre></td></tr></table></figure>

<p>defaultdict 仅在  dict[key] 下有效，在 dict.get(key) 是无效的，后者不会调用预设的工作方法；defaultdict  背后的工作原理是因为实现了  _<em>missing</em>_ 方法；当 _<em>getitem</em>_ 找不到键名时，默认会调用 missing 方法；因此，只要有实现该方法，即可以实现默认值的初始化和返回；</p>
<p>考虑到 missing 会被调用，那么就可以在这里设置手脚；例如将键名由数值转换字符串，以支持不管传入哪种类型，都可以找到对应的键；</p>
<h2 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h2><h3 id="collections-OrderDict"><a href="#collections-OrderDict" class="headerlink" title="collections.OrderDict"></a>collections.OrderDict</h3><p>会记录每个键的添加顺序，然后可以删除最晚或者晚早添加的键；</p>
<h3 id="collections-ChainMap"><a href="#collections-ChainMap" class="headerlink" title="collections.ChainMap"></a>collections.ChainMap</h3><p>ChainMap 会将多个 dict 组合成一个 chain，让它表现起来，像是一个 dict</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>baseline = &#123;<span class="string">&#x27;music&#x27;</span>: <span class="string">&#x27;bach&#x27;</span>, <span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;rembrandt&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adjustments = &#123;<span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;van gogh&#x27;</span>, <span class="string">&#x27;opera&#x27;</span>: <span class="string">&#x27;carmen&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm = ChainMap(baseline, adjustments)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm</span><br><span class="line">ChainMap(&#123;<span class="string">&#x27;music&#x27;</span>: <span class="string">&#x27;bach&#x27;</span>, <span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;rembrandt&#x27;</span>&#125;, &#123;<span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;van gogh&#x27;</span>, <span class="string">&#x27;opera&#x27;</span>: <span class="string">&#x27;carmen&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(cm)</span><br><span class="line">[<span class="string">&#x27;art&#x27;</span>, <span class="string">&#x27;opera&#x27;</span>, <span class="string">&#x27;music&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm[<span class="string">&#x27;music&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;bach&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm[<span class="string">&#x27;art&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;rembrandt&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cm.values()</span><br><span class="line">ValuesView(ChainMap(&#123;<span class="string">&#x27;music&#x27;</span>: <span class="string">&#x27;bach&#x27;</span>, <span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;rembrandt&#x27;</span>&#125;, &#123;<span class="string">&#x27;art&#x27;</span>: <span class="string">&#x27;van gogh&#x27;</span>, <span class="string">&#x27;opera&#x27;</span>: <span class="string">&#x27;carmen&#x27;</span>&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="collections-Counter"><a href="#collections-Counter" class="headerlink" title="collections.Counter"></a>collections.Counter</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = collections.Counter(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)  <span class="comment"># 计算每个键的出现次数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.update(<span class="string">&#x27;aaaaazzz&#x27;</span>) <span class="comment"># update 会递增键的出现次数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;z&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;r&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.most_common(<span class="number">2</span>) <span class="comment"># 可以返回最常见的 n 个键，此处是最常见的 2 个键</span></span><br><span class="line">[(<span class="string">&#x27;a&#x27;</span>, <span class="number">10</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cnt = Counter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> word <span class="keyword">in</span> [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    cnt[word] += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cnt</span><br><span class="line">Counter(&#123;<span class="string">&#x27;blue&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;green&#x27;</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="collections-UserDict"><a href="#collections-UserDict" class="headerlink" title="collections.UserDict"></a>collections.UserDict</h3><p>用于让用户继承来编写子类，与 dict 的不同之处在于它是纯 Python 实现；而 dict 为了性能，某些功能的实现并不完全按照规范；</p>
<h2 id="子类化-UserDict"><a href="#子类化-UserDict" class="headerlink" title="子类化 UserDict"></a>子类化 UserDict</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现 dict[key] 不管 key 是字符串还是数字，都可以正常访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrKeyDict</span>(collections.UserDict):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__missing__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>[<span class="built_in">str</span>(key)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__contains__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(key) <span class="keyword">in</span> <span class="variable language_">self</span>.data</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, key, item</span>):</span><br><span class="line">        <span class="variable language_">self</span>.data[<span class="built_in">str</span>(key)] = item</span><br></pre></td></tr></table></figure>

<p>一些好用的方法</p>
<p>update</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>td1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">7</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>td2 = &#123;<span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>td1.update(td2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>td1</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;female&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



<h2 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h2><p>Python 的标准库并不支持不可变映射类型，但是有个变通的办法来实现相同的效果，即通过 MappingProxyType，从名字可以看得出来它是一个代理，这个代理是只读的；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>:<span class="string">&#x27;A&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy = MappingProxyType(d) <span class="comment"># 创建一个代理</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy</span><br><span class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">&#x27;A&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">1</span>] <span class="comment"># 代理是可以访问的</span></span><br><span class="line"><span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment"># 但是不可以修改，会报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;mappingproxy&#x27;</span> <span class="built_in">object</span> does <span class="keyword">not</span> support item assignment</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">2</span>] = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy <span class="comment"># 代理可以实时的看到 d 更新后的效果</span></span><br><span class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">&#x27;A&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;B&#x27;</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>]</span><br><span class="line"><span class="string">&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h2><p>集合 set 是一些对象的集合，它可以用来去重；集合中的元素必须是可散列的；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>, <span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">set</span>(l)</span><br><span class="line">&#123;<span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">set</span>(l))</span><br><span class="line">[<span class="string">&#x27;eggs&#x27;</span>, <span class="string">&#x27;spam&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>集合有一些自己的运算符，以便计算合集、交集、差集等；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用 &amp; 符号求交集</span></span><br><span class="line">found = <span class="built_in">len</span>(needles &amp; haystack)</span><br></pre></td></tr></table></figure>

<h3 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h3><p>创建空集需要使用 set()， 而不是 { }，不然就变成了字典了；</p>
<p>s1 &#x3D; {1, 2, 3}  的性能比 s2 &#x3D; set([1, 2, ,3])，因为后者涉及先构造列表的动作；</p>
<h3 id="集合推导"><a href="#集合推导" class="headerlink" title="集合推导"></a>集合推导</h3><p>集合推导和列表推导的唯一差别在于方括号 [ ] 还是花括号 { }</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> unicodedata <span class="keyword">import</span> name ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">256</span>) <span class="keyword">if</span> <span class="string">&#x27;SIGN&#x27;</span> <span class="keyword">in</span> name(<span class="built_in">chr</span>(i),<span class="string">&#x27;&#x27;</span>)&#125; ➋</span><br><span class="line">&#123;<span class="string">&#x27;§&#x27;</span>, <span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;¢&#x27;</span>, <span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;¤&#x27;</span>, <span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;¥&#x27;</span>, <span class="string">&#x27;μ&#x27;</span>, <span class="string">&#x27;×&#x27;</span>, <span class="string">&#x27;$&#x27;</span>, <span class="string">&#x27;¶&#x27;</span>, <span class="string">&#x27;£&#x27;</span>, <span class="string">&#x27;©&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;°&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;÷&#x27;</span>, <span class="string">&#x27;±&#x27;</span>, <span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;¬&#x27;</span>, <span class="string">&#x27;®&#x27;</span>, <span class="string">&#x27;%&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h3><p>集合有不少专属的操作，这些操作很多是通过对运算符的重载来实现的；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281058984.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281059641.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281059545.png"></p>
<h2 id="dict-和-set-背后"><a href="#dict-和-set-背后" class="headerlink" title="dict 和 set 背后"></a>dict 和 set 背后</h2><p>dict 和 set 背后的实现原理是散列，这样性能就不会因为元素数量的增长出现大多波动；散列本质上是以空间换时间；列表则是以时间换空间；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407281109644.png"></p>
<h3 id="dict-的实现及其结果"><a href="#dict-的实现及其结果" class="headerlink" title="dict 的实现及其结果"></a>dict 的实现及其结果</h3><blockquote>
<p>注：所有由用户自定义的对象，都是可散列的；因为它的散列值是由 id() 来生成的，跟对象本身的值没有关系。因此所有这些自定义对象，即使值相同，由于 id 不同，它们也是不相等的；</p>
</blockquote>
<p>相比列表，元组会比较节省空间；一方面是因为它无须重复存储键名，另一方面是它不需要用到散列；</p>
<p>应避免在迭代的过程中，对字典进行修改，它会给迭代带来扰乱，有可能导致出错，或者结果错乱；</p>
<p>字典 dict 是不可散列的，所以无法直接将 dict 添加到 set 中；</p>
<p>字典 dict 的键名顺序是有可能会变化的，例如当出现散列冲突时或者扩容时；</p>
<h1 id="第4章-文本和字节序列"><a href="#第4章-文本和字节序列" class="headerlink" title="第4章 文本和字节序列"></a>第4章 文本和字节序列</h1><h2 id="字符问题"><a href="#字符问题" class="headerlink" title="字符问题"></a>字符问题</h2><p>在 Python3，字符统一使用 Unicode 进行表示（称为码位），这样能够涵盖所有的已知字符，而且这个字符的 Unicode 也是固定的；但是在存储的时候，可以有多种编码方法（将码位转成字节序列），例如 UTF8, UTF16 等；使用不同的编码方法存储，就需要使用相应的解码方法读取，这样出来的结果才是正确的；</p>
<h2 id="字节概要"><a href="#字节概要" class="headerlink" title="字节概要"></a>字节概要</h2><p>在 Python3，有 bytes 和 bytearray 两种字节序列类型，其内部的元素是 0~255 的整数；</p>
<ul>
<li>bytes[0]，返回一个元素；</li>
<li>bytes[:1]，返回一个切片，即一段新的序列</li>
</ul>
<p>虽然二进制序列在底层是整数序列，但是显示的字面量有多种可能，包括：</p>
<ul>
<li>ASCII 字符</li>
<li>制表符、换行符、回车符、斜杠等特殊符号；</li>
<li>十六进制转义表示</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;caf\xc3\xa9&#x27;</span>  <span class="comment"># caf 刚好可以用 Ascii  表示，后来两个只能用十六进制表示</span></span><br></pre></td></tr></table></figure>





<h2 id="基本的编解码器"><a href="#基本的编解码器" class="headerlink" title="基本的编解码器"></a>基本的编解码器</h2><h2 id="了解编解码问题"><a href="#了解编解码问题" class="headerlink" title="了解编解码问题"></a>了解编解码问题</h2><h2 id="处理文本文件"><a href="#处理文本文件" class="headerlink" title="处理文本文件"></a>处理文本文件</h2><h2 id="为了正确比较而规范化-Unicode-字符串"><a href="#为了正确比较而规范化-Unicode-字符串" class="headerlink" title="为了正确比较而规范化 Unicode 字符串"></a>为了正确比较而规范化 Unicode 字符串</h2><h2 id="Unicode-文本排序"><a href="#Unicode-文本排序" class="headerlink" title="Unicode 文本排序"></a>Unicode 文本排序</h2><h2 id="Unicode-数据库"><a href="#Unicode-数据库" class="headerlink" title="Unicode 数据库"></a>Unicode 数据库</h2><h2 id="支持字符串和字节序列的双模式-API"><a href="#支持字符串和字节序列的双模式-API" class="headerlink" title="支持字符串和字节序列的双模式 API"></a>支持字符串和字节序列的双模式 API</h2><h1 id="第5章-一等函数"><a href="#第5章-一等函数" class="headerlink" title="第5章 一等函数"></a>第5章 一等函数</h1><h2 id="把函数视为对象"><a href="#把函数视为对象" class="headerlink" title="把函数视为对象"></a>把函数视为对象</h2><p>first class 函数满足以下条件：</p>
<ul>
<li>能够在运行时创建</li>
<li>能够赋值给变量或者数据结构中的元素；</li>
<li>能够做为参数传递给函数；</li>
<li>能够做为结果从函数调用中返回；</li>
</ul>
<p>简而言之，函数就像一个对象一样（事实上在底层实现也是如此，函数即对象）；</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>高阶函数：higher-order function，接受函数做为参数，或者返回结果为参数；</p>
<p>常用的 map 和 filter，可以用列表推导式和生成器表达式进行替代，看起来更容易理解，示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(func, <span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line">[func(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">filter</span>(<span class="keyword">lambda</span> n : n % <span class="number">2</span>, <span class="built_in">range</span>(<span class="number">6</span>))</span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>) <span class="keyword">if</span> i % <span class="number">2</span>]</span><br></pre></td></tr></table></figure>



<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>由于 python 的 lambda 函名函数只能写单行的表达式，因此表达能力非常有限，导致使用场景非常少；常用于高阶函数的函数参数；类似下面这个样子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(<span class="keyword">lambda</span> n : n % <span class="number">2</span>, <span class="built_in">range</span>(<span class="number">6</span>))</span><br></pre></td></tr></table></figure>



<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>调用运算符，即一对括号，不仅可以运用在函数上，其实也可以运用在普通对象上；</p>
<p>可用 callable 函数来判断某个对象是否可以调用</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261020586.png"></p>
<h2 id="用户定义的可调用类型"><a href="#用户定义的可调用类型" class="headerlink" title="用户定义的可调用类型"></a>用户定义的可调用类型</h2><p>事实上所有对象都是可以调用的，只要对象有实现  call 方法即可；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261039412.png"></p>
<h2 id="函数内省"><a href="#函数内省" class="headerlink" title="函数内省"></a>函数内省</h2><blockquote>
<p>函数内省，function introspection，这个翻译名称有点奇怪；</p>
</blockquote>
<p>由于函数是一个对象，因此其实这个对象内部存储着很多与函数有关的信息，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261045205.png"></p>
<h2 id="从定位参数到仅限关键字参数"><a href="#从定位参数到仅限关键字参数" class="headerlink" title="从定位参数到仅限关键字参数"></a>从定位参数到仅限关键字参数</h2><p>python 的函数参数处理机制非常灵活强大，既支持固定位置的参数形式，也支持按关键字进行匹配的参数形式。同时还支持使用 * 单星号或者 ** 双星号，将不固定数量的任意个参数，打包成一个可迭代对象，以便在函数体内部进行访问；其中单个星号打包成 tuple 元组的形式；两个星号打包成字典 dict 的形式；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261110944.png"></p>
<h2 id="获取关于参数的信息"><a href="#获取关于参数的信息" class="headerlink" title="获取关于参数的信息"></a>获取关于参数的信息</h2><p>函数内部的属性，可用来做一起有用的事情，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407261114146.png"></p>
<p>此处使用了装饰器，装饰器会检查 hello 函数内部属性中存储的与参数有关的信息。检查后，它会发现 hello 函数需要一个 person 函数；因此，它可以用 query 对象中，获取相应的 person 值，然后作为参数，传递给 hello 函数；</p>
<p>_<em>default_</em>  存储函数参数的默认值；</p>
<p>_<em>code_</em>  是一个对象，它也存储着函数的相关信息，例如：</p>
<ul>
<li>co_varnames 存储着参数名称 + 局部变量名称</li>
<li>co_argcount 存储着函数的参数个数；</li>
</ul>
<p>直接访问 code 对象或者 default 不是很方便，不过有个 inspect 库提供了方便的查看方式；</p>
<h2 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h2><p>函数注解可用来给参数和返回值备注类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clip</span>(<span class="params">text:<span class="built_in">str</span>, max_len:<span class="string">&#x27;int &gt; 0&#x27;</span>=<span class="number">80</span></span>) -&gt; <span class="built_in">str</span>: <span class="comment"># 备注参数和返回值的类型</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;省略&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>注解会存储在函数的 _<em>annotations</em>_ 属性中；</p>
<p>注解本身不会做任何事情，有注解跟没有注解是一样的；但是注解可以给第三方工具（例如框架、装饰器等）提供有用的信息，例如 IDE 或者 Lint 工具可以利用注解来检查；</p>
<h2 id="支持函数式编程的包"><a href="#支持函数式编程的包" class="headerlink" title="支持函数式编程的包"></a>支持函数式编程的包</h2><h3 id="operator-模块"><a href="#operator-模块" class="headerlink" title="operator 模块"></a>operator 模块</h3><p>operator 模块提供了一些算术运算符函数，它让代码更加简单易懂；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">   <span class="keyword">return</span> reduce(mul, <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)) <span class="comment"># mul 函数可用来计算两个数值的乘积</span></span><br></pre></td></tr></table></figure>

<p>itemgetter 可用来读取元组中的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>metro_data = [</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)),</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, -<span class="number">99.133333</span>)),</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, -<span class="number">74.020386</span>)),</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;Sao Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (-<span class="number">23.547778</span>, -<span class="number">46.635833</span>)),</span><br><span class="line"><span class="meta">... </span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> city <span class="keyword">in</span> <span class="built_in">sorted</span>(metro_data, key=itemgetter(<span class="number">1</span>)): <span class="comment"># itemgetter(1) 等同于 lamba fields : fields[1]</span></span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(city)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处的 itemgetter 的两个参数，表示读取两个位置的值，组成元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cc_name = itemgetter(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> city <span class="keyword">in</span> metro_data:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(cc_name(city))</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;JP&#x27;</span>, <span class="string">&#x27;Tokyo&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;IN&#x27;</span>, <span class="string">&#x27;Delhi NCR&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;MX&#x27;</span>, <span class="string">&#x27;Mexico City&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;US&#x27;</span>, <span class="string">&#x27;New York-Newark&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;BR&#x27;</span>, <span class="string">&#x27;Sao Paulo&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>attrgetter 与 itemgetter 的不同之处在于它使用名称来提取对象的属性；</p>
<p>methodcaller 接受一个参数，表示要调用的函数名称，然后它可以在之后传入的对象中调用相应的方法；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> methodcaller</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;The time has come&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase = methodcaller(<span class="string">&#x27;upper&#x27;</span>) <span class="comment"># 表示调用 upper 方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>upcase(s)  <span class="comment"># 在 s 身上调用 upper 方法</span></span><br><span class="line"><span class="string">&#x27;THE TIME HAS COME&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hiphenate = methodcaller(<span class="string">&#x27;replace&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;-&#x27;</span>) <span class="comment"># 调用 replace 方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hiphenate(s)  <span class="comment"># 在 s 身上调用</span></span><br><span class="line"><span class="string">&#x27;The-time-has-come&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-functools-partial-冻结参数"><a href="#使用-functools-partial-冻结参数" class="headerlink" title="使用 functools.partial 冻结参数"></a>使用 functools.partial 冻结参数</h3><p>partial 可用来将某个函数的参数设置为固定值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = partial(mul, <span class="number">3</span>) <span class="comment"># mul 原本接受两个参数，此处将 mul 的第一个参数固定 3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">7</span>) <span class="comment"># 调用时，只需传入第二个参数即可计算出结果</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">map</span>(triple, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)))  </span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>, <span class="number">24</span>, <span class="number">27</span>]</span><br></pre></td></tr></table></figure>



<h1 id="第6章-使用一等函数实现设计模式"><a href="#第6章-使用一等函数实现设计模式" class="headerlink" title="第6章 使用一等函数实现设计模式"></a>第6章 使用一等函数实现设计模式</h1><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>在函数作为一等公民时，很多设计模式就有了更简单的实现方法了；例如策略模式中，每个策略对应一个类；实际上它们都可以简单替换成函数即可，完全没有必要单独为了调用它而去实例化一个对象；</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式的本意是想在命令的调用者（操作对象）和接收者（实现对象）之间进行解耦，这样调用者无须了解各个接收者具体是什么接口，而让它们对接口进行统一命名；但其实有更简单的做法，即直接将各个实现绑定到调用者身上就可以了，有点像回调那样；</p>
<p>面向对象之所以要搞成那么复杂，完全是因为它们不能接受函数作为参数，而是只能接受对象做为参数，然后再去调用对象的方法，这样就不得不对所调用的方法有个规范命名，不然就不知道如何调用；但如果能够接受函数作为参数，那就完全不一样了，直接将形参当作函数调用即可，非常简单直观，容易理解；</p>
<h1 id="第7章-函数装饰器和闭包"><a href="#第7章-函数装饰器和闭包" class="headerlink" title="第7章 函数装饰器和闭包"></a>第7章 函数装饰器和闭包</h1><h2 id="装饰器基础知识"><a href="#装饰器基础知识" class="headerlink" title="装饰器基础知识"></a>装饰器基础知识</h2><p>装饰器是一个可调用的对象，类似函数，它的参数是另外一个函数，它的目的是对该函数进行打包封装，干些额外的工作；它的执行结果有可能会返回参数函数，也有可能是返回另外一个新的函数或可调用对象，并赋值给原本作为参数的函数名称，这样调用者并不知道这个函数可能已经被替换了；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;running target()&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 上面的写法跟下面的写法是一个意思</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">target</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;running target()&quot;</span>)</span><br><span class="line">    </span><br><span class="line">target = decorate(target);</span><br></pre></td></tr></table></figure>



<h2 id="Python-何时执行装饰器"><a href="#Python-何时执行装饰器" class="headerlink" title="Python 何时执行装饰器"></a>Python 何时执行装饰器</h2><p>注意，在定义装饰器的代码文件被加载时，装饰器会被立即执行，此时被装饰的函数还没有被调用；</p>
<h2 id="使用装饰器改进策略模式"><a href="#使用装饰器改进策略模式" class="headerlink" title="使用装饰器改进策略模式"></a>使用装饰器改进策略模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">promos = [] </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">promotion</span>(<span class="params">promo_func</span>): </span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion </span><span class="comment"># 使用装饰器，在添加新的折扣策略时，不容易遗漏</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fidelity</span>(<span class="params">order</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;为积分为1000或以上的顾客提供5%折扣&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"><span class="meta">    @promotion</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@promotion </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bulk_item</span>(<span class="params">order</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;单个商品为20个或以上时提供10%折扣&quot;&quot;&quot;</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">        	discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br></pre></td></tr></table></figure>



<h2 id="变量作用域规则"><a href="#变量作用域规则" class="headerlink" title="变量作用域规则"></a>变量作用域规则</h2><p>python 在编译函数定义时，它会先检查函数中声明的局部变量；</p>
<ul>
<li>如果变量存在，那么之后使用变量时，解释器只会在本地作用域中寻找；</li>
<li>如果不存在，那么就会到函数的定义环境中寻找全局变量；</li>
</ul>
<p>global 关键字可用来告知某个变量为全局的，以引导解释器到正确的位置查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f3</span>(<span class="params">a</span>):</span><br><span class="line"><span class="meta">... </span><span class="keyword">global</span> b</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(a)</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(b)</span><br><span class="line"><span class="meta">... </span>b = <span class="number">9</span></span><br></pre></td></tr></table></figure>



<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>如果函数引用了某个变量，该不在其定义内部定义，而是在函数外部定义的，那么解释器会在函数对象中，保留一个指向该外部变量的引用，以便在使用该变量时，能够取到相应的值；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    series = [] </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">new_value</span>):</span><br><span class="line">         <span class="comment"># 此处引用的 series 变量在 averager 外部定义，averager 对象属性中会保存它的引用</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = <span class="built_in">sum</span>(series)</span><br><span class="line">        <span class="keyword">return</span> total/<span class="built_in">len</span>(series)</span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>

<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407282027810.png"></p>
<h2 id="nonlocal-声明"><a href="#nonlocal-声明" class="headerlink" title="nonlocal 声明"></a>nonlocal 声明</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">new_value</span>):</span><br><span class="line">        count += <span class="number">1</span> </span><br><span class="line">        <span class="comment"># 此处的表达式等同于 count = count + 1，因此解释器会将 count 当作局部变量</span></span><br><span class="line">        <span class="comment"># 因此在执行 count + 1 会出现报错</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了解决以上问题，需要用 nonlocal 关键字将 count 和 total 声明为非局部变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_averager</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averager</span>(<span class="params">new_value</span>):</span><br><span class="line">    	<span class="keyword">nonlocal</span> count, total <span class="comment"># 声明 nonlocal</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>



<h2 id="实现一个简单的装饰器"><a href="#实现一个简单的装饰器" class="headerlink" title="实现一个简单的装饰器"></a>实现一个简单的装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clock</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clocked</span>(<span class="params">*args</span>): <span class="comment"># 不支持关键字参数</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_str = <span class="string">&quot;, &quot;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[%0.8fs] %s(%s) -&gt; %r&#x27;</span> % (elapsed, name, arg_str, result))</span><br><span class="line">     <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>

<p>支持关键字参数的版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clock</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>) </span><span class="comment"># 用于将函数属性从 func 复制到 clocked 函数中，例如函数名称等</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clocked</span>(<span class="params">*args, **kwargs</span>):  <span class="comment"># 支持关键字参数</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">&quot;, &quot;</span>.join(<span class="built_in">repr</span>(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">&#x27;%s=%r&#x27;</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> <span class="built_in">sorted</span>(kwargs.items())]</span><br><span class="line">            arg_lst.append(<span class="string">&quot;, &quot;</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">&quot;, &quot;</span>.join(arg_lst)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[%0.8fs] %s(%s) -&gt; %r &#x27;</span> % (elapsed, name, arg_str, result))</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>



<h2 id="标准库中的装饰器"><a href="#标准库中的装饰器" class="headerlink" title="标准库中的装饰器"></a>标准库中的装饰器</h2><h3 id="使用-lru-cache-缓存"><a href="#使用-lru-cache-缓存" class="headerlink" title="使用  lru_cache  缓存"></a>使用  lru_cache  缓存</h3><p>lru_cache  可以帮助缓存函数的计算结果，如果下次再传入相同的参数，则直接从缓存中返回计算结果，不再重复计算，这会极大的提高性能，尤其是存在大量重复计算的场景，例如计算斐波契那数列；</p>
<blockquote>
<p>lru 的全称 least recently used</p>
</blockquote>
<h3 id="单分派泛函数"><a href="#单分派泛函数" class="headerlink" title="单分派泛函数"></a>单分派泛函数</h3><blockquote>
<p>所谓的分泛函数是指这个函数的功能用于分别派分任务，它根据参数值，使用一串 if elif else 来分别调用相应的函数；在 OO 的语言中一般叫重载，但 Python 不支持重载；</p>
</blockquote>
<p>singledispatch 装饰器，可以将多个函数组合成一个泛函数；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch  </span><span class="comment"># 将 htmlize 包装成了泛函数，之后它可以注册不同的参数 </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">htmlize</span>(<span class="params">obj</span>):</span><br><span class="line">    content = html.escape(<span class="built_in">repr</span>(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;pre&gt;&#123;&#125;&lt;/pre&gt;&#x27;</span>.<span class="built_in">format</span>(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(<span class="params"><span class="built_in">str</span></span>)  </span><span class="comment"># 注册重载 str 类型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">text</span>):</span><br><span class="line">    content = html.escape(text).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&lt;br&gt;\n&#x27;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;&lt;p&gt;&#123;0&#125;&lt;/p&gt;&#x27;</span>.<span class="built_in">format</span>(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(<span class="params">numbers.Integral</span>) </span><span class="comment"># 注册重载 int 类型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">n</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;&#x27;</span>.<span class="built_in">format</span>(n)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(<span class="params"><span class="built_in">tuple</span></span>) </span><span class="comment"># 注册 tuple 类型</span></span><br><span class="line"><span class="meta">@htmlize.register(<span class="params">abc.MutableSequence</span>)  </span><span class="comment"># 可多个类型叠加</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">seq</span>):</span><br><span class="line">    inner = <span class="string">&#x27;&lt;/li&gt;\n&lt;li&gt;&#x27;</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;&lt;ul&gt;\n&lt;li&gt;&#x27;</span> + inner + <span class="string">&#x27;&lt;/li&gt;\n&lt;/ul&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>singledispatch 可以用来装饰自己编写的函数，也可以用来装饰他人编写的函数；</p>
<h2 id="叠放装饰器"><a href="#叠放装饰器" class="headerlink" title="叠放装饰器"></a>叠放装饰器</h2><p>装饰器支持叠放</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@d1</span></span><br><span class="line"><span class="meta">@d2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;f&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#等同于</span></span><br><span class="line">f = d1(d2(f))</span><br></pre></td></tr></table></figure>



<h2 id="参数化装饰器"><a href="#参数化装饰器" class="headerlink" title="参数化装饰器"></a>参数化装饰器</h2><p>通过创建一个装饰器工厂函数，便可使装饰器支持传入参数；调用该装饰器工厂函数时，返回的是真正的装饰器；</p>
<h1 id="第8章-对象引用、可变性和垃圾回收"><a href="#第8章-对象引用、可变性和垃圾回收" class="headerlink" title="第8章 对象引用、可变性和垃圾回收"></a>第8章 对象引用、可变性和垃圾回收</h1><h2 id="变量不是盒子"><a href="#变量不是盒子" class="headerlink" title="变量不是盒子"></a>变量不是盒子</h2><p>变量本身是一个独立的东西，我们借助它，让它指向某个对象，以方便实现引用该对象；</p>
<h2 id="标识、相等性和别名"><a href="#标识、相等性和别名" class="headerlink" title="标识、相等性和别名"></a>标识、相等性和别名</h2><p>在 Python 中，判断两个对象是否相同，有两种方法，一种是 &#x3D;&#x3D; 两个等号，一种是使用关键字 is，它们的意思是不一样的；&#x3D;&#x3D; 会调用对象的 __eq __ 方法进行判断，它比的是值相等即可，is 等是判断对象的 id，相当于内存的地址；</p>
<p>由于 is 比较的是地址，因为使用 is 进行判断它的性能很好；因为使用 &#x3D;&#x3D; 进行判断的话，需要遍历对象的属性值；</p>
<p>object 类型的 eq 方法比较的是 id，但是其他大多数内置类型的 eq 方法比较的是值；</p>
<p>当元组用于保存对象时，它保存的是对象的引用。虽然元组本身不可变，但这个引用背后的对象自身是可以变的；</p>
<h2 id="默认做浅复制"><a href="#默认做浅复制" class="headerlink" title="默认做浅复制"></a>默认做浅复制</h2><p>如果要做深复制，需要使用 deepcopy 方法；浅复制则使用 copy 方法；</p>
<h2 id="函数的参数作为引用时"><a href="#函数的参数作为引用时" class="headerlink" title="函数的参数作为引用时"></a>函数的参数作为引用时</h2><p>千万不要将函数参数的默认值设置为可变对象，而应该设置为 None；因为如果是可变对象，那么在函数载入时，会自动创建出来；这样导致多次不传参数的调用该函数时，多个函数都会指向该默认值，造成相互影响；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HauntedBus</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, passengers=[]</span>): <span class="comment"># 这里默认值 [] 是大忌，千万要避免</span></span><br><span class="line">        <span class="variable language_">self</span>.passengers = passengers</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pick</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.passengers.append(name)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drop</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.passengers.remove(name)</span><br></pre></td></tr></table></figure>

<p>如果函数的参数是一个可变对象，那么让函数对该对象进行修改，会直接作用到外部的实参对象上。有时候，这是想要的结果，有时候则不是非预期的结果。如果是非预期的结果，那么函数内部应对该实参进行复制；</p>
<h2 id="del-和垃圾回收"><a href="#del-和垃圾回收" class="headerlink" title="del 和垃圾回收"></a>del 和垃圾回收</h2><p>del 关键字并不是用来销毁对象的，而仅仅是切割变量和对象之间的引用关系；当对象的引用数量为零时，销毁的工作会垃圾回收器处理；</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用不会增加对象的引用计数，这样不会对对象的垃圾回收带来干扰；一般用于有生命周期限制的缓存管理中；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref = weakref.ref(a_set) ➊</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref</span><br><span class="line">&lt;weakref at <span class="number">0x100637598</span>; to <span class="string">&#x27;set&#x27;</span> at <span class="number">0x100636748</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() ➋</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125; ➌</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() ➍</span><br><span class="line">&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span> ➎</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wref() <span class="keyword">is</span> <span class="literal">None</span> ➏</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>WeakValueDictionary 是一种可变映射（字典也是一种可变映射），映射指向的值是对象的弱引用；当对象被回收时，对应的键会自动从 WeakValueDictionary 中被删除；因此，它很适合用来做缓存；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cheese</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, kind</span>):</span><br><span class="line">    	<span class="variable language_">self</span>.kind = kind</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;Cheese(%r)&#x27;</span> % <span class="variable language_">self</span>.kind</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> weakref</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>stock = weakref.WeakValueDictionary() <span class="comment"># 实例化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>catalog = [Cheese(<span class="string">&#x27;Red Leicester&#x27;</span>), Cheese(<span class="string">&#x27;Tilsit&#x27;</span>),</span><br><span class="line"><span class="meta">... </span>Cheese(<span class="string">&#x27;Brie&#x27;</span>), Cheese(<span class="string">&#x27;Parmesan&#x27;</span>)]</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> cheese <span class="keyword">in</span> catalog:</span><br><span class="line"><span class="meta">... </span>stock[cheese.kind] = cheese <span class="comment"># 将 stock 的键映射到 cheese 实例上</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(stock.keys())</span><br><span class="line">[<span class="string">&#x27;Brie&#x27;</span>, <span class="string">&#x27;Parmesan&#x27;</span>, <span class="string">&#x27;Red Leicester&#x27;</span>, <span class="string">&#x27;Tilsit&#x27;</span>] ➌</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> catalog</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(stock.keys())</span><br><span class="line">[<span class="string">&#x27;Parmesan&#x27;</span>] <span class="comment"># 为什么删除 catalog 后，没有全部删除，而是还剩下一个？</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> cheese <span class="comment"># for 循环中的 cheese 是全局变量，因此需要显式删除，不然仍然有一个引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>(stock.keys())</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>不是每个 python 对象都可以被弱引用，例如常用的 list 和 dict 实例无法被弱引用，但是它们的子类可以；set 实例也可以</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">list</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;list的子类，实例可以作为弱引用的目标&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">a_list = MyList(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># a_list可以作为弱引用的目标</span></span><br><span class="line">wref_to_a_list = weakref.ref(a_list)</span><br></pre></td></tr></table></figure>



<h2 id="Python-对不可变类型施加的把戏"><a href="#Python-对不可变类型施加的把戏" class="headerlink" title="Python 对不可变类型施加的把戏"></a>Python 对不可变类型施加的把戏</h2><p>使用一个元组构建另外一个元组，结果得到的是同一个元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = <span class="built_in">tuple</span>(t1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 <span class="keyword">is</span> t1</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>在 CPython 中，当对象的引用数量为零，会立即触发垃圾回收。但其他 Python 实现则不一定如此；这里涉及到性能的权衡；</p>
<h1 id="第9章-符合-Python-风格的对象"><a href="#第9章-符合-Python-风格的对象" class="headerlink" title="第9章 符合 Python 风格的对象"></a>第9章 符合 Python 风格的对象</h1><h2 id="对象表示形式"><a href="#对象表示形式" class="headerlink" title="对象表示形式"></a>对象表示形式</h2><p>Python 默认使用两个函数来表示对象的字符串形式，它们分别是 repr() 和 str() 函数。它们实际上调用的是对象的 _<em>repr</em>_ 和 _<em>str</em>_ </p>
<p>另外还有一个 bytes() 函数会调用 _<em>bytes</em>_ 方法来返回字节序列；</p>
<h2 id="再谈向量类"><a href="#再谈向量类" class="headerlink" title="再谈向量类"></a>再谈向量类</h2><p>以下是自定义向量类的待实现功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(v1.x, v1.y) <span class="comment"># 能够通过点运算符，直接访问属性</span></span><br><span class="line"><span class="number">3.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = v1 <span class="comment"># 支持元组拆包</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 <span class="comment"># repr 的显示格式</span></span><br><span class="line">Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_clone = <span class="built_in">eval</span>(<span class="built_in">repr</span>(v1)) <span class="comment"># 基于 repr 结果生成对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v1_clone <span class="comment"># 支持 == 运算符</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(v1) <span class="comment"># str 的实现</span></span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = <span class="built_in">bytes</span>(v1)  <span class="comment"># 生成实例的二进制表示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets</span><br><span class="line"><span class="string">b&#x27;d\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(v1) <span class="comment"># 支持 abs 方法，返回实例的模</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(v1), <span class="built_in">bool</span>(Vector2d(<span class="number">0</span>, <span class="number">0</span>)) <span class="comment"># 支持 bool 方法，模为零时，返回 False</span></span><br><span class="line">(<span class="literal">True</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>



<h2 id="备选构造方法"><a href="#备选构造方法" class="headerlink" title="备选构造方法"></a>备选构造方法</h2><h2 id="classmethod-与-staticmethod"><a href="#classmethod-与-staticmethod" class="headerlink" title="classmethod 与 staticmethod"></a>classmethod 与 staticmethod</h2><p>classmethod 修饰的函数，调用时，不需要实例化对象；该函数的第一个参数是类本身，从而可以借助该函数，访问类的相关成员；</p>
<p>classmethod 的一个常见用途时定义额外的构造方法，一般该构造方法会对传入的数据进行清洗，之后再构造对象；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">frombytes</span>(<span class="params">cls, octets</span>): <span class="comment"># 第一个参数不是 self, 而是类本身</span></span><br><span class="line">    typecode = <span class="built_in">chr</span>(octets[<span class="number">0</span>]) </span><br><span class="line">    memv = <span class="built_in">memoryview</span>(octets[<span class="number">1</span>:]).cast(typecode) </span><br><span class="line">    <span class="keyword">return</span> cls(*memv) </span><br></pre></td></tr></table></figure>



<h2 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;1 BRL = &#123;rate:0.2f&#125; USD&#x27;</span>.<span class="built_in">format</span>(rate=brl) <span class="comment"># rate 表示具名变量</span></span><br><span class="line"><span class="string">&#x27;1 BRL = 0.41 USD&#x27;</span></span><br></pre></td></tr></table></figure>

<p>关于如何格式化，python 有一套自己的语法规则，可称之为微语言；这套微语言是可扩展的，可以自定义如何解释 forma_spec 参数</p>
<h2 id="可散列的-Vector2d"><a href="#可散列的-Vector2d" class="headerlink" title="可散列的 Vector2d"></a>可散列的 Vector2d</h2><p>通过实现 _<em>hash</em>_ 和 _<em>eq</em>_ 方法，可将一个不可散列的自定义类的对象，变成可散列的；</p>
<h2 id="Python-的私有属性和受保护的属性"><a href="#Python-的私有属性和受保护的属性" class="headerlink" title="Python 的私有属性和受保护的属性"></a>Python 的私有属性和受保护的属性</h2><p>python 没有类似 Java 中的 private 关键字，而是通过给类成员的名称添加两个下划线前缀，将该成员标记为私有成员，类似这样：__x，但也有一些人喜欢使用一个下划线来表示；</p>
<p>对于私有属性，解释器在实例化对象时，会给这些属性加上类名作为前缀，这样一来，直接用双下划线访问私有属性时，会提示该属性并不存在，从而实现访问控制；但实际上是可以访问的，只是曲折一点，需要加上类名前缀来访问；</p>
<h2 id="使用-slots-类属性节省空间"><a href="#使用-slots-类属性节省空间" class="headerlink" title="使用 slots 类属性节省空间"></a>使用 slots 类属性节省空间</h2><p>默认情况下，类的实例在 _<em>dict_</em> 字段中使用字典来存储属性成员，如果成员比较多的，会占据较大的内存，此时可考虑使用 _<em>slot_</em> 属性来存储以节省内存；它的原理是使用元组来存储，所以节省内存；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector2d</span>:</span><br><span class="line">    __slots__ = (<span class="string">&#x27;__x&#x27;</span>, <span class="string">&#x27;__y&#x27;</span>)</span><br><span class="line">    typecode = <span class="string">&#x27;d&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="覆盖类属性"><a href="#覆盖类属性" class="headerlink" title="覆盖类属性"></a>覆盖类属性</h2><p>Python 的类属性可以为实例属性提供默认值，这个默认值在实例中可以被重新赋值；</p>
<p>如果要批量处理，则可以考虑定义一个子类，该子类的属性重写，之后使用子类来实例化对象；</p>
<h1 id="第10章-序列的修改、散列和切片"><a href="#第10章-序列的修改、散列和切片" class="headerlink" title="第10章 序列的修改、散列和切片"></a>第10章 序列的修改、散列和切片</h1><p>鸭子类型：只要实现一些约定的接口，即可当作拥有目标类型的特征，并可以像目标类型一样被处理；例如一个类只需要实现 getitem 和  len 两个接口，那么它就可以被当作序列类型一样处理，至于它是谁的子类，并不重要；</p>
<blockquote>
<p>zip 函数可用于并行迭代多个序列，它会将多个序列的对象打包成元组，然后可以拆包赋值给各个变量； </p>
</blockquote>
<h1 id="第11章-接口：从协议到抽象基类"><a href="#第11章-接口：从协议到抽象基类" class="headerlink" title="第11章 接口：从协议到抽象基类"></a>第11章 接口：从协议到抽象基类</h1><h2 id="接口与协议"><a href="#接口与协议" class="headerlink" title="接口与协议"></a>接口与协议</h2><p>一个类只需要实现了某些特定的接口，它就可以被当作特定的类型进行操作（即鸭子类型）；</p>
<p>当一个类实现了 getitem 接口时，即使它没有实现 contains 和 iter 接口，它也是可迭代，并且支持 in 运算符的；因为解释器会调用 getitem 接口来实现以上两项功能；</p>
<blockquote>
<p>Python 类中的方法，第一个参数叫 self 纯粹是一种惯例，其实叫个其他名字也无妨；</p>
</blockquote>
<h2 id="猴子补丁"><a href="#猴子补丁" class="headerlink" title="猴子补丁"></a>猴子补丁</h2><p>猴子补丁：如果一个类在定义时，没有定义某个方法；之后在运行时，可以在外部单独定义一个函数，然后把这个函数绑定到类的某个属性上，这样就让类动态获得了某个方法；</p>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>抽象基类一般用于编写框架的场景，如果是业务场景，几乎不太可能需要自己编写抽象基类，而是使用现成的就可以了；</p>
<p>当继承抽象基类，就需要手工实现抽象基类中规定的所有方法，不管该方法是否用得到；</p>
<h2 id="标准库中的-ABC"><a href="#标准库中的-ABC" class="headerlink" title="标准库中的 ABC"></a>标准库中的 ABC</h2><blockquote>
<p>ABC：抽象基类，abstract base class</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407301247891.png"></p>
<p>不可变集合：Sequence, Mapping, Set</p>
<p>可变集合：MutableSequence, MutableMapping, MutableSet</p>
<h3 id="数字塔"><a href="#数字塔" class="headerlink" title="数字塔"></a>数字塔</h3><p>numbers 包定义了数字抽象基类的线性层次结构：Number &lt; Complex &lt; Real &lt; Rational &lt; Integral；</p>
<h1 id="第12章-继承的优缺点"><a href="#第12章-继承的优缺点" class="headerlink" title="第12章 继承的优缺点"></a>第12章 继承的优缺点</h1><h2 id="子类化内置类型很麻烦"><a href="#子类化内置类型很麻烦" class="headerlink" title="子类化内置类型很麻烦"></a>子类化内置类型很麻烦</h2><p>内置类型的方法不会调用子类覆盖后的方法，它只会调用内置类型原本的方法；因此，不会子类化内置类型，Python 有专门给用户子类化的类型，以 User 开头，例如 UserDict、UserList、UserString 等；</p>
<blockquote>
<p>猜测原因在于内置类型的很多方法，出于性能考虑，是用 C  语言专门优化过的，因此不严格遵行继承的定义；</p>
</blockquote>
<h2 id="多重继承和方法解析顺序"><a href="#多重继承和方法解析顺序" class="headerlink" title="多重继承和方法解析顺序"></a>多重继承和方法解析顺序</h2><p>多重继承会面临菱形问题，即子类继承多个父类中，存在同名的方法，导致子类无法确定应该执行哪个父类的同名方法；</p>
<h2 id="多重继承的真实应用"><a href="#多重继承的真实应用" class="headerlink" title="多重继承的真实应用"></a>多重继承的真实应用</h2><h2 id="处理多重继承"><a href="#处理多重继承" class="headerlink" title="处理多重继承"></a>处理多重继承</h2><h2 id="Django-示例"><a href="#Django-示例" class="headerlink" title="Django 示例"></a>Django 示例</h2><h1 id="第13章-正确重载运算符"><a href="#第13章-正确重载运算符" class="headerlink" title="第13章 正确重载运算符"></a>第13章 正确重载运算符</h1><h1 id="第14章-可迭代对象、迭代器和生成器"><a href="#第14章-可迭代对象、迭代器和生成器" class="headerlink" title="第14章 可迭代对象、迭代器和生成器"></a>第14章 可迭代对象、迭代器和生成器</h1><blockquote>
<p>迭代器模式：惰性加载数据，处理时加载，这样可以用较小的内存，处理很大的数据集；</p>
</blockquote>
<p>Python 中使用生成器来实现迭代器模式；生成器也是为了迭代数据，因此可将它当作迭代器来使用，唯一的区别在于它的惰性；</p>
<p>在 Python3 中，生成器是很普遍的，只是使用的时候没有觉察，例如 range(10) 返回的是一个类似生成器的对象；如果想要获得完整的列表，需要写成 list(range(10))；</p>
<h2 id="可迭代对象和迭代器对比"><a href="#可迭代对象和迭代器对比" class="headerlink" title="可迭代对象和迭代器对比"></a>可迭代对象和迭代器对比</h2><p>区别：从可迭代对象中，获取迭代器；迭代器如果迭代完毕，则不再可用，需要重新构建；</p>
<p>所谓的迭代器，可以理解为一个对象，每次调用它的 next 方法，可返回一个元素；如果空了，会报错；</p>
<blockquote>
<p>通常迭代器还有一个 iter 方法，调用这个方法，可返回迭代器本身；理论上不实现它，也不会影响迭代功能。但如果实现了它，issubclass 方法可将其判断为 Iterator 的子类；</p>
<p>可迭代对象也有一个 iter 方法，调用它，会返回一个新的迭代器；</p>
</blockquote>
<h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, text</span>):</span><br><span class="line">        <span class="variable language_">self</span>.text = text</span><br><span class="line">        <span class="variable language_">self</span>.words = RE_WORD.findall(text)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(<span class="variable language_">self</span>.text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># iter 使用了 yield 关键字，调用 iter 会返回生成器对象，此时 iter 是个生成器函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> <span class="variable language_">self</span>.words:</span><br><span class="line">        	<span class="keyword">yield</span> word </span><br></pre></td></tr></table></figure>



<h3 id="生成器函数的工作原理"><a href="#生成器函数的工作原理" class="headerlink" title="生成器函数的工作原理"></a>生成器函数的工作原理</h3><p>yield 关键字有点像 await，每次执行到 yield 所在的语句时，会暂停等待；</p>
<blockquote>
<p>for 循环语句会自动捕获并处理迭代器抛出的异常；</p>
</blockquote>
<h2 id="惰性实现"><a href="#惰性实现" class="headerlink" title="惰性实现"></a>惰性实现</h2><p>re 模块除了 findall 函数，还有一个生成器版本的 finditer 函数；它每次只返回一个匹配项；当数据量很大时，可以节省很多内存；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, text</span>):</span><br><span class="line">    	<span class="variable language_">self</span>.text = text </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(<span class="variable language_">self</span>.text)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> RE_WORD.finditer(<span class="variable language_">self</span>.text): <span class="comment"># finditer 返回生成器</span></span><br><span class="line">        	<span class="keyword">yield</span> <span class="keyword">match</span>.group()</span><br></pre></td></tr></table></figure>

<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器表达式有点像是列表推导的惰性版本；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">gen_AB</span>(): <span class="comment"># ➊</span></span><br><span class="line"><span class="meta">... </span>	<span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">yield</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="meta">... </span>	<span class="built_in">print</span>(<span class="string">&#x27;continue&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">yield</span> <span class="string">&#x27;B&#x27;</span></span><br><span class="line">...	 <span class="built_in">print</span>(<span class="string">&#x27;end.&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res1 = [x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()] <span class="comment"># res1 是一个列表，由生成器 gen_Ab 的返回值组成</span></span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res1: <span class="comment"># ➌</span></span><br><span class="line"><span class="meta">... </span>	<span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, i)</span><br><span class="line">...</span><br><span class="line">--&gt; AAA</span><br><span class="line">--&gt; BBB</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 = (x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()) <span class="comment"># res2 是一个生成器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res2 </span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x10063c240</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> res2: <span class="comment"># 遍历 res2，此时 gen_AB 函数才真正的执行</span></span><br><span class="line">...		<span class="built_in">print</span>(<span class="string">&#x27;--&gt;&#x27;</span>, i)</span><br><span class="line">...</span><br><span class="line">start</span><br><span class="line">--&gt; AAA</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; BBB</span><br><span class="line">end.</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"></span><br><span class="line">RE_WORD = re.<span class="built_in">compile</span>(<span class="string">&#x27;\w+&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sentence</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, text</span>):</span><br><span class="line">    	<span class="variable language_">self</span>.text = text</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="built_in">repr</span>(<span class="variable language_">self</span>.text)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用表达式构建一个生成器，而不是用 yield 来生成</span></span><br><span class="line">    <span class="comment"># 生成器表达式是一个语法糖，本质上跟使用 yield 的生成器函数没有区别</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    	<span class="keyword">return</span> (<span class="keyword">match</span>.group() <span class="keyword">for</span> <span class="keyword">match</span> <span class="keyword">in</span> RE_WORD.finditer(<span class="variable language_">self</span>.text))</span><br></pre></td></tr></table></figure>

<h2 id="何时用生成器表达式"><a href="#何时用生成器表达式" class="headerlink" title="何时用生成器表达式"></a>何时用生成器表达式</h2><p>生成器表达式是构建生成器的简捷方式，无需通过 def 定义函数来实现；但限于一些简单场景，一行可以搞定的那种；如果业务逻辑比较复杂，一行代码搞不定的话，则仍然需要使用函数来定义；</p>
<p>标准库  itertools 模块中有很多现成的生成器；</p>
<p>itertools.count(start, step)：创建一个数字生成器</p>
<p>itertools.takewhile 给生成器添加条件限制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = itertools.takewhile(<span class="keyword">lambda</span> n: n &lt; <span class="number">3</span>, itertools.count(<span class="number">1</span>, <span class="number">.5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(gen)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">2.0</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure>

<h2 id="标准库中的生成器"><a href="#标准库中的生成器" class="headerlink" title="标准库中的生成器"></a>标准库中的生成器</h2><p>在创建任何生成器前，很有必要先查一下标准库中有哪些生成器可用，以避免重复造轮子；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311445182.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311446562.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311447657.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311447765.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311454347.png"></p>
<h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><p>yield from 可用来作为可迭代对象的生成器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">chain</span>(<span class="params">*iterables</span>):</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">for</span> it <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>		<span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"><span class="meta">... </span>			<span class="keyword">yield</span> i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="built_in">tuple</span>(<span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(chain(s, t))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的写法，用 yield from 重写如下，可减少一层 for 循环</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">chain</span>(<span class="params">*iterables</span>):</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">for</span> i <span class="keyword">in</span> iterables:</span><br><span class="line"><span class="meta">... </span>		<span class="keyword">yield</span> <span class="keyword">from</span> i</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(chain(s, t))</span><br><span class="line">[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h2 id="可迭代的归约函数"><a href="#可迭代的归约函数" class="headerlink" title="可迭代的归约函数"></a>可迭代的归约函数</h2><p>归约函数：接受一个可迭代的对象，返回一个值，例如 reduce 函数；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311501287.png"></p>
<h2 id="深入分析-iter-函数"><a href="#深入分析-iter-函数" class="headerlink" title="深入分析 iter 函数"></a>深入分析 iter 函数</h2><p>iter 函数用于生成迭代器，一般接收一个可迭代对象作为参数；但是它还有个用法是接收两个参数，第一个参数是个可迭代对象，第二个参数是个 predicate，当可迭代对象产生的值满足 predicate 时，就停止产出；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">d6</span>():</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">return</span> randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter = <span class="built_in">iter</span>(d6, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d6_iter</span><br><span class="line">&lt;callable_iterator <span class="built_in">object</span> at <span class="number">0x00000000029BE6A0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> roll <span class="keyword">in</span> d6_iter:</span><br><span class="line"><span class="meta">... </span><span class="built_in">print</span>(roll)</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>生成器很适合用来处理大数据集，这样可以利用有限的内存，处理无限大的数据，例如大型数据库；</p>
<h2 id="生成器当作协程"><a href="#生成器当作协程" class="headerlink" title="生成器当作协程"></a>生成器当作协程</h2><p>生成器对象有个 send 方法，该方法允许给生成器对象发送消息；</p>
<h1 id="第15章-上下文管理器和-else-块"><a href="#第15章-上下文管理器和-else-块" class="headerlink" title="第15章 上下文管理器和 else 块"></a>第15章 上下文管理器和 else 块</h1><h2 id="else"><a href="#else" class="headerlink" title="else"></a>else</h2><p>else 不仅可以跟 if 搭配使用，还可以跟 for, while, try 搭配使用；在这些场景中，else 实际上是 then 的意思，表示某个动作如果顺利完成了，那么就执行 else 里面的语句；如果没有顺利完成，就不执行；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> my_list:</span><br><span class="line">	<span class="keyword">if</span> item.flavor == <span class="string">&#x27;banana&#x27;</span>:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 如果 for 循环结束，没有触发 break，那么就执行 else；如果触发，就退出循环，不执行else</span></span><br><span class="line">	<span class="keyword">raise</span> ValueError(<span class="string">&#x27;No banana flavor found!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	dangerous_call()</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">    log(<span class="string">&#x27;OSError...&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 如果 dangerous_call 顺利执行，没有报异常，则执行 else；如果报异常，就不执行 else</span></span><br><span class="line">	after_call()</span><br></pre></td></tr></table></figure>

<h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p>with 的目标是安全的实现 try…finally；with 之后的表达式（例如 open 函数）会创建一个上下文管理器对象。该对象有两个方法，分别是 enter 和 exit；with 语句开始执行时，会调用 enter 方法；执行结束后，会调用 exit 方法，类似 finally 的作用；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># with...as... 是一个表达式，该表达式的前半段子句，会创建上下文管理器对象，并执行 enter 方法</span></span><br><span class="line"><span class="comment"># enter 方法执行完成后，会将结果返回到 fp 变量上，但 as 并不是必须的，有些场景并不需要返回什么东西</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;mirror.py&#x27;</span>) <span class="keyword">as</span> fp: </span><br><span class="line"><span class="meta">... </span>src = fp.read(<span class="number">60</span>) <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当解释器执行完整个 with 块的语句后，会调用 exit 方法，清理现场</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下是一个上下文管理器类的示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LookingGlass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>): <span class="comment"># 做准备工作</span></span><br><span class="line">        <span class="keyword">import</span> sys</span><br><span class="line">        <span class="variable language_">self</span>.original_write = sys.stdout.write </span><br><span class="line">        sys.stdout.write = <span class="variable language_">self</span>.reverse_write </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;JABBERWOCKY&#x27;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_write</span>(<span class="params">self, text</span>): <span class="comment"># 实际干活的方法</span></span><br><span class="line">    	<span class="variable language_">self</span>.original_write(text[::-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_value, traceback</span>): <span class="comment"># 做清理工作</span></span><br><span class="line">        <span class="keyword">import</span> sys </span><br><span class="line">        sys.stdout.write = <span class="variable language_">self</span>.original_write </span><br><span class="line">        <span class="keyword">if</span> exc_type <span class="keyword">is</span> ZeroDivisionError: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Please DO NOT divide by zero!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br></pre></td></tr></table></figure>

<p>contextlib 模块中有一些现成的工作，可用来创建自定义的 context 类（上下文管理器）；</p>
<h2 id="contextmanager"><a href="#contextmanager" class="headerlink" title="@contextmanager"></a>@contextmanager</h2><p>contextmanager 装饰器可以简化上下文管理器的定义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager </span><span class="comment"># 该装饰器会将 looking_glass 函数包装成带有 enter 和 exit 方法的类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">looking_glass</span>():</span><br><span class="line">	<span class="keyword">import</span> sys</span><br><span class="line">    original_write = sys.stdout.write </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_write</span>(<span class="params">text</span>): </span><br><span class="line">    	original_write(text[::-<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">    sys.stdout.write = reverse_write </span><br><span class="line">    msg = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">    	<span class="keyword">yield</span> <span class="string">&#x27;JABBERWOCKY&#x27;</span> <span class="comment"># 这里 yield 起到了类似分隔的作用，enter 执行到这里，后面由 exit 执行</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        msg = <span class="string">&quot;Please DO NOT divide by zero&quot;</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        sys.stdout.write = original_write</span><br><span class="line">        <span class="keyword">if</span> msg:</span><br><span class="line">            <span class="built_in">print</span>(msg)</span><br></pre></td></tr></table></figure>

<p>个人感觉所谓的上下文管理器，本质上也像是一个实现了约定协议的鸭子类型，只要按照协议实现 enter 和 exit 方法即可；</p>
<h1 id="第16章-协程"><a href="#第16章-协程" class="headerlink" title="第16章 协程"></a>第16章 协程</h1><p>yield 有两个兽性，一个是生成，一个是退让；这两个意思刚好是协程的描述；</p>
<p>当 yield 放在表达式的左边时，它做为生成器使用；</p>
<p>当 yield 放在表达式的右边时，它做为协程使用，等待传入值；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">simple_coroutine</span>(): <span class="comment"># ➊</span></span><br><span class="line"><span class="meta">... </span>	<span class="built_in">print</span>(<span class="string">&#x27;-&gt; coroutine started&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>	x = <span class="keyword">yield</span> <span class="comment"># yield 右边没有值，意味着它生成 None</span></span><br><span class="line"><span class="meta">... </span>	<span class="built_in">print</span>(<span class="string">&#x27;-&gt; coroutine received:&#x27;</span>, x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro <span class="comment"># 生成器已经创建，但是还没有启动，需要通过 next 让它启动</span></span><br><span class="line">&lt;generator <span class="built_in">object</span> simple_coroutine at <span class="number">0x100c2be10</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(my_coro) <span class="comment"># 通过 next 来启动生成器</span></span><br><span class="line">-&gt; coroutine started</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_coro.send(<span class="number">42</span>) <span class="comment"># 给 yield 传值，仅当协程处于暂停状态时，才能够给它传值</span></span><br><span class="line">-&gt; coroutine received: <span class="number">42</span></span><br><span class="line">Traceback (most recent call last): <span class="comment"># ➏</span></span><br><span class="line">...</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>协和在 yield 关键字所在的位置暂停执行</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202407311816737.png"></p>
<p>使用协程重新设计平均值计算器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">averager</span>():</span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 永远不会停止，可以无限计算平均值</span></span><br><span class="line">        term = <span class="keyword">yield</span> average <span class="comment"># 等待外部传入值，外部每传一次，就计算一次总体平均值</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 以下是使用示例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg = averager() <span class="comment"># 创建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(coro_avg) <span class="comment"># 激活</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">10</span>) <span class="comment"># 传值</span></span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">30</span>)</span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>coro_avg.send(<span class="number">5</span>)</span><br><span class="line"><span class="number">15.0</span></span><br></pre></td></tr></table></figure>

<p>使用协程时，经常容易忘记要先激活它。为了避免这种错误，可考虑定义一个帮忙激活的装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coroutine</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;定义一个装饰器：帮忙预激`func`&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">primer</span>(<span class="params">*args,**kwargs</span>): ➊</span><br><span class="line">        gen = func(*args,**kwargs) ➋</span><br><span class="line">        <span class="built_in">next</span>(gen) <span class="comment"># 激活</span></span><br><span class="line">        <span class="keyword">return</span> gen ➍</span><br><span class="line">    <span class="keyword">return</span> primer</span><br></pre></td></tr></table></figure>

<p>在调用生成器的 send 函数时，如果给它传递的参数类型有误，会导致它抛出异常，从而终止协程；</p>
<p>生成器有一个 throw 方法可用于触发异常；如果生成器内部有处理异常的代码，则执行；如果没有，则冒泡；</p>
<p>生成器还有一个 close 方法可用于抛出 exit 异常</p>
<h2 id="yield-from-1"><a href="#yield-from-1" class="headerlink" title="yield from"></a>yield from</h2><p>yield from 带来了双向通讯机制，貌似可用来实现异步编程；先定义生成器，然后激活它；之后向它发送数据；当数据处理完成后，会触发异常，获得处理结果；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Result = namedtuple(<span class="string">&#x27;Result&#x27;</span>, <span class="string">&#x27;count average&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">averager</span>(): </span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> <span class="comment"># 感觉此处有点像是一个点位符，等待外部传值进来，或许应该叫 await</span></span><br><span class="line">        <span class="keyword">if</span> term <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 当外部传 None 进来时，就中断退出循环</span></span><br><span class="line">        	<span class="keyword">break</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line">    <span class="keyword">return</span> Result(count, average) <span class="comment"># 中断循环后，返回计算结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 委托生成器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grouper</span>(<span class="params">results, key</span>):</span><br><span class="line">    <span class="comment"># 这里为什么要循环？</span></span><br><span class="line">    <span class="comment"># 答：为了不断接收外面传进来的值</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">        <span class="comment"># 关键字 yield from 默认会让当前函数返回一个生成器，可惜这个关键字很不直观</span></span><br><span class="line">        <span class="comment"># send 传进来的值，会通过传入 averager，yield from 有点像管道的作用</span></span><br><span class="line">        results[key] = <span class="keyword">yield</span> <span class="keyword">from</span> averager()  <span class="comment"># 这里的 yield from 很像 await</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 客户端（调用方）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">data</span>):</span><br><span class="line">    results = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> data.items():</span><br><span class="line">        group = grouper(results, key) <span class="comment"># grouper 返回生成器</span></span><br><span class="line">        <span class="built_in">next</span>(group) <span class="comment"># 预激活 # 激活后，开始进入 while 循环，在 yield from 处暂停</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            group.send(value) <span class="comment"># send 将值传给 averager，开始与内部的子生成器通讯</span></span><br><span class="line">        group.send(<span class="literal">None</span>) <span class="comment"># 传入None，中断子生成器，让委托生成器获得结果</span></span><br><span class="line">    <span class="built_in">print</span>(results)</span><br></pre></td></tr></table></figure>

<p>yield from 跟 await 有一个很大的不同，即 yield from 在将工作做到一半后，将控制权还给调用者，由调用者做剩下的工作；</p>
<blockquote>
<p>据说  python 后来引入了 await</p>
</blockquote>
<h1 id="第19章-并发模型"><a href="#第19章-并发模型" class="headerlink" title="第19章 并发模型"></a>第19章 并发模型</h1><p>协程: coroutine，一个可以暂停并重新运行自己的函数；</p>
<p>协程的特点在于可以通过关键字，标识出异步的位置，然后交出控制权，让主程序的其他部分获得控制权；自己则进入队列，等待异步的代码执行完毕；改变自己状态，等待被唤醒，继续运行自己余下部分的代码；</p>
<blockquote>
<p>没想到 Python 有一个全局锁（GIL），每次只允许一个线程占有，那这就意味着 python 无法同时利用多核的优势好像，除非起多个进程，就像 js 的 cluster 一样；</p>
<p>Python 解释器每隔一定的时间（貌似是 5ms），会释放 GIL，以便其他线程能够获取锁；另外，任意一个函数在调用 syscall 时，它都会释放 GIL；</p>
</blockquote>
<blockquote>
<p>书里面的 spinner 案例，看起来很奇怪，因为协程的结束，竟然是由调用者的代码发起的，跟 js 好像不太一样；但是 await 貌似是一样的；</p>
<p>后来发现，协程也可以自己结束，不需要外部让它结束；书上的案例只是示范说可以主动干预。但其实正常使用场景是不干预，让它自行运行结束，返回结果；</p>
<p>问：好奇有无可能用装饰器，将非协程的代码，包装成协程代码？答：想了一下，虽然可能，但是由于非协程代码里面，在遇到 I&#x2F;O 任务时，没有使用 await 交出控制权，该协程貌似可能会卡在那里等待；</p>
<p>协程能够起作用，貌似重点在于每次遇到 I&#x2F;O 任务时，要主动交出控制权；在 js 里，很多库都是默认异步编写的，因此不容易忘记这个事情。但是在 python 里面，很多库并非天生异步，例如常用的 requests，此时很有必要提高警惕；</p>
<p>当协程获得控制权，处于运行中的状态时，它是无法被取消的。因为只有一个线程，当它在运行时，意味着想要取消它的代码并没有在运行；仅当协程位于队列中，处于等待状态时，才有可能被取消；此时取消它的代码有可能获得了控制权；</p>
</blockquote>
<p>asyncio.run() 函数，做为所有协程运行代码的入口；</p>
<p>asyncio.create_task()，在当前协程中，创建一个新的协程；可基于返回的 task 对象，对新建的协程进行控制；</p>
<p>await coro()，调用 coro，并同步等待它返回结果；</p>
<p>调用 coro() 时，并不意味着 coro 的代码会马上执行，而只是表示将它加入了队列，实际的执行时间取决于事件循环的高度器；</p>
<p>跟 js 一样，await 关键字必须用在 async 定义的函数中；当函数用 async 定义时，它是一个协程；每次对该函数的调用，都是都它加入事件循环的队列中；而 await 表示交给当前协程对 CPU 的使用，即停止运行，让调度器去运行其他协程；等 await 的事件结束时，调度器会重新安排它运行；</p>
<h2 id="GIL-的真实影响"><a href="#GIL-的真实影响" class="headerlink" title="GIL 的真实影响"></a>GIL 的真实影响</h2><p>各种处理网络请示的库，如 requests，在发起请示后，会释放当前线程的 GIL，以便其他线程可以抢占；但如果只有一个线程，那么抢占并没有意义。仅在多线程时，抢占才有意义；而且即使抢占成功，后续 requests 仍然会再次被分配 GIL，但此时它有可能仍然还没有取得响应，因此会浪费掉一些性能；但总的来说，多线程有助于提高 I&#x2F;O 的并发处理能力；但不适用于 CPU 密集型的任务，性能反而变差，因为 CPU 不断在多个线程之间切换，但每次只运行一个线程，最终的性能还不如顺序执行来得快；</p>
<p>另外还有一些库的设计是异步的，但如果当前的代码不是 async 的话，貌似也无法使用 await 来交出控制权？</p>
<blockquote>
<p>当处理计算密集型任务，因为 GIL 的存在，多线程是没有意义的，因为每次只有一个线程在工作；反而不如使用单线程来得简单和高效；如果有多核，则可以考虑使用多进程模式来提高效率；</p>
</blockquote>
<h1 id="第20章-Concurrent-Executors"><a href="#第20章-Concurrent-Executors" class="headerlink" title="第20章 Concurrent Executors"></a>第20章 Concurrent Executors</h1><p>concurrent.futures 库里面，有两个类，分别是 ThreadPoolExecutor 和 ProcessPoolExecutor，它们可以很方便的使用线程或者进程来实现并发；</p>
<p>对使用者来说，背后的线程或进程是透明的，它会自动开启多线程或进程，同时创建任务队列，收集各线程的处理结果；</p>
<p>Python 里面的 futures 有点像 js 里面的 promise；但 futures 一般不直接创建，而是交由框架来创建；开发者可以在更高的抽象维度来使用它，这样可以避免错误使用；</p>
<p>future.done() 方法可用来查询是否计算完成了，但更常见的做法是不查询，而是等待通知，即完成后，调用回调函数即可；</p>
<p>future 有个 add_done_callback 方法，它接受一个回调函数做为参数；注意：该回调函数，将在运行该 future 的线程或进程中直接运行；</p>
<p>future.result() 方法可用于获取计算结果；但 concurrency 和 asyncio 两个库对方法的实现有所不同；concurrency 调用 result 方法时，会造成堵塞，等待结果的返回；同时支持 timeout 参数，超时未返回时，会抛出异常；asyncio 则不支持 timeout 方法，但支持 await 关键字，这样不会造成堵塞；</p>
<p>concurrency 还有一个 as_completed 方法，专门用来读取 result，以避免堵塞，</p>
<p>executor.map() 主要用于一个函数，并发处理多个不同的参数</p>
<p>executor.submit() 则更灵活一些，多个不同的函数，并处理各自不同的参数；最后通过 as_completed 方法收集计算结果；</p>
<h1 id="第21章-异步编程"><a href="#第21章-异步编程" class="headerlink" title="第21章 异步编程"></a>第21章 异步编程</h1><blockquote>
<p>虽然可以通过 async def 来定义异步函数，但是如果函数体中包含一些非异步的操作，比如将文件写入本地，貌似该同步操作有可能会造成堵塞，占用整个线程，直到写入成功？经查证，发现确实如此，在异步函数中，只要有任意一个</p>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>海象符 :&#x3D;，为了省写一行代码，先检查，确认有值后，再赋值；没值的话，就不赋值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有海象符的时候</span></span><br><span class="line">name = abc.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> name:</span><br><span class="line">    <span class="comment"># doA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># doB</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 有海象符后</span></span><br><span class="line"><span class="keyword">if</span> name := abc.get(<span class="string">&quot;name&quot;</span>):</span><br><span class="line">    <span class="comment"># doA</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># doB</span></span><br></pre></td></tr></table></figure>










      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件/">软件</a><a href="/tags/python/">python</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/04/高效团队开发/"><span>高效团队开发</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/04/高效团队开发/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-04T07:10:00.000Z">
          2016-11-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="1-什么是团队开发"><a href="#1-什么是团队开发" class="headerlink" title="1. 什么是团队开发"></a>1. 什么是团队开发</h2><h3 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h3><ul>
<li>“谁”“到何时为止”做了“什么事情”，“怎样”算做“完成”等；</li>
<li>在团队内部共享代码等各类工作成果；</li>
<li>保证各成员能够利用工作成果并行作业，同时防止工作成果遭到破坏；</li>
<li>在团队中共享从项目中学到的知识；</li>
<li>证明开发出的软件，在任何时间都是可以正常运行的；</li>
<li>构建自动化的工作流程，确保任何人都可以正确的开发、测试和发布；</li>
</ul>
<h3 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h3><ul>
<li>版本管理</li>
<li>缺陷管理</li>
<li>持续集成</li>
<li>持续交付</li>
<li>回归测试</li>
</ul>
<h2 id="2-团队开发中的问题"><a href="#2-团队开发中的问题" class="headerlink" title="2. 团队开发中的问题"></a>2. 团队开发中的问题</h2><h3 id="重要的邮件太多，无法确定处理的优先顺序"><a href="#重要的邮件太多，无法确定处理的优先顺序" class="headerlink" title="重要的邮件太多，无法确定处理的优先顺序"></a>重要的邮件太多，无法确定处理的优先顺序</h3><p>使用邮件交流问题并不是一个好的方法，因为邮件算不上一种格式化的数据，很难归类整理；</p>
<p>解决方法：使用版本缺陷系统进行问题的管理；</p>
<h3 id="没有能用于验证的环境"><a href="#没有能用于验证的环境" class="headerlink" title="没有能用于验证的环境"></a>没有能用于验证的环境</h3><p>如果没有用于验证的环境，将导致每次复现 BUG 需要花费很长的时间，导致效率很低；</p>
<p>解决方法：搭建多个环境，分别用于开发、验证、测试、发布等；</p>
<h3 id="用别名目录管理分支"><a href="#用别名目录管理分支" class="headerlink" title="用别名目录管理分支"></a>用别名目录管理分支</h3><p>用于实现谁、何时、做了什么样的修改；</p>
<h3 id="重新制作数据库比较困难"><a href="#重新制作数据库比较困难" class="headerlink" title="重新制作数据库比较困难"></a>重新制作数据库比较困难</h3><p>数据库的变更操作也应纳入版本系统进行管理，确保每次的操作内容、顺序在各个环境都是一致的，而不是各个开发环境执行自己的；</p>
<h3 id="不运行系统就无法察觉的问题"><a href="#不运行系统就无法察觉的问题" class="headerlink" title="不运行系统就无法察觉的问题"></a>不运行系统就无法察觉的问题</h3><p>测试时，需要确保将全员的代码集中到一起运行，以免发生退化；</p>
<p>解决方案：持续集成，每次提交新代码，就合并代码并自动化测试，在第一时间暴露问题；</p>
<h3 id="覆盖了其他组员修正的代码"><a href="#覆盖了其他组员修正的代码" class="headerlink" title="覆盖了其他组员修正的代码"></a>覆盖了其他组员修正的代码</h3><p>当合并其他成员的代码时，如果出现冲突，有些开发人员可能直接将其他成员的代码进行覆盖，导致出现问题；</p>
<p>解决方案：持续集成；</p>
<h3 id="无法自信的地进行代码重构"><a href="#无法自信的地进行代码重构" class="headerlink" title="无法自信的地进行代码重构"></a>无法自信的地进行代码重构</h3><p>缺少措施避免出现退化；</p>
<p>解决方案：自动化测试；</p>
<h3 id="不知道-BUG-的修正日期，也不能追踪退化"><a href="#不知道-BUG-的修正日期，也不能追踪退化" class="headerlink" title="不知道 BUG 的修正日期，也不能追踪退化"></a>不知道 BUG 的修正日期，也不能追踪退化</h3><p>缺少缺陷跟踪系统，导致需要从一堆邮件中查询当时的情况；</p>
<p>解决方案：CI、缺陷跟踪、版本管理三个工具是确保项目高效开发的神器；甚至还应该考虑使用自动化部署；</p>
<h3 id="没有灵活使用分支和标签"><a href="#没有灵活使用分支和标签" class="headerlink" title="没有灵活使用分支和标签"></a>没有灵活使用分支和标签</h3><p>导致合并的时候容易出现混乱；有时在切换分支修复某些 BUG，切换回新功能分支时，忘了合并刚才的 BUG 分支；</p>
<h3 id="在测试环境、正式环境上无法运行"><a href="#在测试环境、正式环境上无法运行" class="headerlink" title="在测试环境、正式环境上无法运行"></a>在测试环境、正式环境上无法运行</h3><p>缺少统一管理第三方模块，确保在各个环境的依赖实现一致性的办法；</p>
<p>解决方案： docker；</p>
<h3 id="发布太复杂，以至于需要发布手册"><a href="#发布太复杂，以至于需要发布手册" class="headerlink" title="发布太复杂，以至于需要发布手册"></a>发布太复杂，以至于需要发布手册</h3><p>涉及如何更新DDL、依赖的库以及配置文件；</p>
<p>解决方案：持续交付；</p>
<h2 id="3-版本管理系统"><a href="#3-版本管理系统" class="headerlink" title="3. 版本管理系统"></a>3. 版本管理系统</h2><p>Git 等分布式版本管理系统</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>能将代码完整地复制到本地</li>
<li>运行速度快</li>
<li>临时作业的提交易于管理</li>
<li>分支、合并简单方便</li>
<li>可以不受地点的限制进行协作开发</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>系统中没有真正意义上的最新版本</li>
<li>没有真正意义上的版本号</li>
<li>工作流程的配置过于灵活，容易产生混乱</li>
<li>有一定的学习成本</li>
</ul>
<h3 id="需纳入版本管理的内容"><a href="#需纳入版本管理的内容" class="headerlink" title="需纳入版本管理的内容"></a>需纳入版本管理的内容</h3><ul>
<li>代码</li>
<li>需求定义和设计等文档</li>
<li>库的依赖</li>
<li>数据库初始化命令</li>
<li>环境配置文件</li>
</ul>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>Git 的每次提交有一个唯一识别码，但是它比较难记，为了让它更具备可识别性，可以为该提交添加标签，通过标签来识别；</p>
<blockquote>
<p>虽然分支也可以使用标签，但我发现好像并不是很有必要，貌似直接用分支名就够了；</p>
</blockquote>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><h4 id="中央集权型工作流"><a href="#中央集权型工作流" class="headerlink" title="中央集权型工作流"></a>中央集权型工作流</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151311.png"></p>
<h4 id="Github-型工作流"><a href="#Github-型工作流" class="headerlink" title="Github 型工作流"></a>Github 型工作流</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151415.png"></p>
<h3 id="分支策略模式"><a href="#分支策略模式" class="headerlink" title="分支策略模式"></a>分支策略模式</h3><h4 id="Git-flow"><a href="#Git-flow" class="headerlink" title="Git-flow"></a>Git-flow</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151453.png"></p>
<h5 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h5><ul>
<li>master：为发布而建的分支，每次发布时都打上标签</li>
<li>develop：开发用的分支，发布前的最新版本</li>
</ul>
<h5 id="临时分支"><a href="#临时分支" class="headerlink" title="临时分支"></a>临时分支</h5><ul>
<li>feature：分离自 develop，开发特定功能的分支</li>
<li>release：分离自 develop，为发布做准备的分支，避免混入多余的 feature；</li>
<li>hotfix：分离自 master，修复 master 分支的故障；修复后，需要被合并到 master\develop\release 三个分支；</li>
</ul>
<blockquote>
<p>有专门的 git-flow 脚本实现以上的管理模式；<br>git-flow 的缺点是有些复杂，需要学习适应一下；同时不支持 GUI 可视化工具；</p>
</blockquote>
<h4 id="Github-flow"><a href="#Github-flow" class="headerlink" title="Github-flow"></a>Github-flow</h4><p>git-flow 的优点是非常清晰可靠，缺点是看上去有点复杂不易理解，因此产生了 github-flow 模式来降低学习成本；</p>
<h5 id="Github-flow-流程"><a href="#Github-flow-流程" class="headerlink" title="Github-flow 流程"></a>Github-flow 流程</h5><ul>
<li>master 分支的内容都可以进行发布；</li>
<li>添加内容时，直接从 master 分支新建分支</li>
<li>建立的分支在本地环境上提交，并以同名的分支定期向远程代码库进行 push</li>
<li>开发结束后向 master 分支发送 pull request</li>
<li>pull request 在被审核通过后，合并到 master，并从 master 向正式环境发布；</li>
</ul>
<blockquote>
<p>Jenkins 可以监控仓库中中的所有分支，这样每个分支 push 到仓库后，都会触发自动构建和测试，确保代码没有问题；</p>
</blockquote>
<h3 id="数据库模式和数据的管理"><a href="#数据库模式和数据的管理" class="headerlink" title="数据库模式和数据的管理"></a>数据库模式和数据的管理</h3><p>问题发生的原因在于如果不同的开发人员，在设置数据库初始化的命令顺序上面，可能存在冲突，导致一些功能无法正常运行；</p>
<p>数据库版本管理的必要条件</p>
<ul>
<li>在任意环境中，都能使用相同的步骤来构建数据库</li>
<li>能够反复执行多次</li>
<li>格式为文件</li>
</ul>
<h4 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h4><p>基本原理：将数据库初始化需要用的 SQL 命令写入文件，这些文件按数字进行顺序命令，每次启动程序时，按照这些文件进行数据库初始化；</p>
<p>由于是分布式开发，每个开发人员新添加的 SQL 文件可能存在命名冲突，当合并分支时，Git 会报错，此时需要解决冲突，并再次提效修改后的版本；由于修改后的版本是最新版本，因此其他人在合并该版本时，会自动覆盖其本地的版本，因此，仍然能够实现正确的初始化；</p>
<p>SQL 文件中的初始化命令是成对出现的，它提供了回滚机制，当出现冲突时，先回滚当前的数据库，再按照最新的版本，重新初始化；</p>
<p>由于冲突是通过手工合并 SQL 命令来解决的，因此不可避免存在错误的可能性，此时就需要通过增加测试代码，来确保万无一失；</p>
<h3 id="配置文件的管理"><a href="#配置文件的管理" class="headerlink" title="配置文件的管理"></a>配置文件的管理</h3><p>配置文件包括环境变量、密码等信息，这些信息不适合纳入版本管理，因此需要单独上传部署的服务器，此时可以通过编写一个部署脚本，来实现自动上传；而上传的信息，同样可以写在配置文件中，而脚本本身可以纳入版本管理；</p>
<p>常用部署的工具：Chef, Puppet, Capistrano, Fabric, ServerSepc；</p>
<h3 id="依赖关系的管理"><a href="#依赖关系的管理" class="headerlink" title="依赖关系的管理"></a>依赖关系的管理</h3><p>大多数语言都有自己的依赖管理工具和公共仓库，例如 Java 的 Maven，Node 的 npm，Python 的 Pypi 等；</p>
<p>这些现成的工具的原理：</p>
<ul>
<li>设置一个中央仓库；</li>
<li>使用一个文件来定义对库的依赖；</li>
<li>执行上述依赖文件的脚本；</li>
</ul>
<h2 id="4-任务管理"><a href="#4-任务管理" class="headerlink" title="4. 任务管理"></a>4. 任务管理</h2><h4 id="任务管理系统的优点"><a href="#任务管理系统的优点" class="headerlink" title="任务管理系统的优点"></a>任务管理系统的优点</h4><ul>
<li>“有须做什么”的任务定义</li>
<li>“谁来做”的职责分配</li>
<li>“什么时候完成”的期限管理</li>
<li>“作业中或已完成”的状态管理</li>
</ul>
<h4 id="其他优点"><a href="#其他优点" class="headerlink" title="其他优点"></a>其他优点</h4><ul>
<li>直观性</li>
<li>方便检索</li>
<li>对信息统一管理及共享</li>
<li>能够生成各类报表</li>
<li>能够与其他系统进行关联，具备可扩展性；</li>
</ul>
<h4 id="任务驱动开发"><a href="#任务驱动开发" class="headerlink" title="任务驱动开发"></a>任务驱动开发</h4><p>将新功能或者 BUG 任务登记在缺陷管理系统中，每次代码的提交，都与某一个具体的任务单相对应，禁止没有任务单号的提交；</p>
<p>通过设置 Github 的 Webhook，可以实现将 commit 和相应的任务单进行关联；</p>
<h3 id="开发新功能、修改BUG的工作流程"><a href="#开发新功能、修改BUG的工作流程" class="headerlink" title="开发新功能、修改BUG的工作流程"></a>开发新功能、修改BUG的工作流程</h3><ul>
<li>建立任务单</li>
<li>指定责任人</li>
<li>开发</li>
<li>提交：提交的时候，记得标注对应哪个问题单号；这样可以通过问题单，查询到代码修改了哪些内容、什么时候修改的；也可以反向查询，即找到当前代码的修改，对应到哪些问题单，从而知道当时什么要做如此的修改；</li>
<li>Push 到代码库</li>
</ul>
<h3 id="管理对象"><a href="#管理对象" class="headerlink" title="管理对象"></a>管理对象</h3><ul>
<li>epic</li>
<li>story</li>
<li>task</li>
<li>bug</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Redmine-安装"><a href="#Redmine-安装" class="headerlink" title="Redmine 安装"></a>Redmine 安装</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redmine:</span><br><span class="line">    image: redmine</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">8080</span>:<span class="number">3000</span></span><br><span class="line">    environment:</span><br><span class="line">      REDMINE_DB_POSTGRES: db</span><br><span class="line">      REDMINE_DB_PASSWORD: secret</span><br><span class="line">      REDMINE_DB_USERNAME: redmine</span><br><span class="line">    networks:</span><br><span class="line">      redmine-network:</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_PASSWORD: secret</span><br><span class="line">      POSTGRES_USER: redmine</span><br><span class="line">    networks:</span><br><span class="line">      redmine-network:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  redmine-network:</span><br></pre></td></tr></table></figure>

<h4 id="Redmine-访问"><a href="#Redmine-访问" class="headerlink" title="Redmine 访问"></a>Redmine 访问</h4><p>localhost:8080</p>
<h2 id="5-CI-持续集成"><a href="#5-CI-持续集成" class="headerlink" title="5. CI 持续集成"></a>5. CI 持续集成</h2><h3 id="主要的-CI-工具"><a href="#主要的-CI-工具" class="headerlink" title="主要的 CI 工具"></a>主要的 CI 工具</h3><ul>
<li>Jenkins：插件众多，可配置性强；缺点是上手成本高；</li>
<li>Travis：需要配合 Github 使用，优点是上手简单；</li>
</ul>
<h3 id="build-工具"><a href="#build-工具" class="headerlink" title="build 工具"></a>build 工具</h3><p>以 Java 为例，常用的构建工具有：</p>
<ul>
<li>Maven：适用于新项目；</li>
<li>Ant：适用于已开发一半的项目；</li>
</ul>
<h3 id="测试代码的写法"><a href="#测试代码的写法" class="headerlink" title="测试代码的写法"></a>测试代码的写法</h3><p>常见的测试类型：</p>
<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>用户验收测试</li>
<li>回归测试</li>
</ul>
<blockquote>
<p>编写测试代码是要付出时间成本的，理想的情况下当然是覆盖以上所有的测试场景；如果不允许，则应至少包括单元测试和集成测试；</p>
</blockquote>
<h3 id="棘手的测试"><a href="#棘手的测试" class="headerlink" title="棘手的测试"></a>棘手的测试</h3><ul>
<li>和外部系统有交互的测试</li>
<li>使用 mock 框架进行测试</li>
<li>使用内存数据进行测试：可避免跟数据库中的数据产生耦合；常用工具如 H2 数据库；</li>
<li>UI 相关的测试</li>
</ul>
<h3 id="Jenkins-使用流程"><a href="#Jenkins-使用流程" class="headerlink" title="Jenkins 使用流程"></a>Jenkins 使用流程</h3><ul>
<li>新建任务：一个任务对应一个项目；</li>
<li>下载代码：将 Github 代码地址与项目进行关联，并设置 Github 的 Webhook，在收到 push 请求后，调用 Jenkins 接口拉取最新的代码；</li>
<li>自动执行 Build 和测试：制作一个构建的脚本，并由 Jenkins 进行调用即可；脚本中需设置退出值，以便 Jenkins 判断任务的执行是失败还是成功；</li>
<li>统计结果并生成报表：使用 JUnitXML 形式输出报表有更好的通用性和直观性，虽然它是 JUnit 设定的格式，但其他语言也有相应的库可以生成该格式的报表；</li>
<li>统计覆盖率：常用的覆盖率统计工具有 Cobertura, Jacoco, Scct, simpleCov, Rcov 等（Cobertura 已于 2011 年停止了开发）；</li>
<li>静态分析：常用工具 Checkstyle, PMD, Findbugs等；</li>
<li>配置通知：对构建结果进行通知，选择常用插件即可，支持邮件、Twitter、IRC、XFD等；</li>
</ul>
<h3 id="构建失败的惩罚"><a href="#构建失败的惩罚" class="headerlink" title="构建失败的惩罚"></a>构建失败的惩罚</h3><p>设计一个搞笑的仪式，例如警报灯闪烁、弹射球、戴礼帽等；</p>
<p>当构建发生失败时，基于该构建的分支之后编写的代码，将需要禁止提交，直到构建修复成功为止；为了避免出现这种等待的情况，可考虑使用 Github flow 中的 pull request 流程；当收到 pull request 后会自动进行构建，如果成功，则合并到主分支；如果失败，则不合并；</p>
<p>以上功能在 Jenkins 中需要使用 Github pull request builder 插件实现；</p>
<h3 id="确保可追溯性"><a href="#确保可追溯性" class="headerlink" title="确保可追溯性"></a>确保可追溯性</h3><p>通过相应的插件，可实现 Jenkins 和 缺陷管理系统的任务单相关，并可以方便的查看每次代码提交的差异；</p>
<h2 id="6-自动化部署–持续交付"><a href="#6-自动化部署–持续交付" class="headerlink" title="6. 自动化部署–持续交付"></a>6. 自动化部署–持续交付</h2><h3 id="由谁负责"><a href="#由谁负责" class="headerlink" title="由谁负责"></a>由谁负责</h3><p>由想实施部署自动化的人着手去做即可，因此一般来说是运维人员牵头；</p>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li>全部团队成员都采用版本管理；</li>
<li>所有的环境使用相同的方式构建；</li>
<li>实现发布工作的自动化，并事先进行验证</li>
<li>要反复多次进行测试</li>
</ul>
<h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><ul>
<li>引导：服务器 OS 的配置自动化；</li>
<li>配置：服务器及中间件的配置自动化；</li>
<li>业务流程：代码部署及发布的自动化；</li>
</ul>
<h4 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h4><h5 id="Kickstart"><a href="#Kickstart" class="headerlink" title="Kickstart"></a>Kickstart</h5><p>原理：安装 Linux 时，给内核参数加上 ks&#x3D;&lt;…&gt; 选项，即可开启从外部设备加载配置文件，实现安装自动化；背后的本质是将安装过程中的选项，以配置文件的形式提前写好；</p>
<blockquote>
<p>仅适用于 RHEL 系统的 Linux 系统，不适用于 Debian 系列；</p>
</blockquote>
<h5 id="Vagrant"><a href="#Vagrant" class="headerlink" title="Vagrant"></a>Vagrant</h5><p>用途：用来创建和配置虚拟环境，可以最大化的利用单台机器的性能；</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>应用程序总是运行在一定的进程环境中，复杂的应用程序，可能涉及非常多的环境配置选项，从而带来很大的工作量；</p>
<h5 id="Chef"><a href="#Chef" class="headerlink" title="Chef"></a>Chef</h5><p>根据提前写好的配置规则（cookbooks），让服务器安装软件包和配置中间件，实现自动化；</p>
<blockquote>
<p>可以为应用服务器和数据库服务器分别编写 cookbook，这样就能够复制搭建服务器的步骤，实现批量化；</p>
</blockquote>
<h5 id="Serverspec"><a href="#Serverspec" class="headerlink" title="Serverspec"></a>Serverspec</h5><p>用途：一个测试框架，可对服务器的配置进行单元测试，确保服务器如预期的正常运行；</p>
<h4 id="最佳实践1：使用虚拟环境"><a href="#最佳实践1：使用虚拟环境" class="headerlink" title="最佳实践1：使用虚拟环境"></a>最佳实践1：使用虚拟环境</h4><ul>
<li>使用 Vagrant 创建干净的虚拟环境；（怀疑之处可考虑结合 docker 来创建虚拟环境）；</li>
<li>拉取 Chef 的 cookbook 和 Serverspec 的测试用例；</li>
<li>执行 Chef，完成服务器的配置；</li>
<li>执行 Serverspec，完成对服务器的状态测试，确保配置成功；</li>
<li>将结果反馈给 jenkins；</li>
</ul>
<blockquote>
<p>以上各个工具都有相应的替代器，因此无须局限于以上工具的使用，重点在于选择最适合团队使用的工具；</p>
</blockquote>
<h4 id="最佳实践2：使用物理机"><a href="#最佳实践2：使用物理机" class="headerlink" title="最佳实践2：使用物理机"></a>最佳实践2：使用物理机</h4><p>Kickstart + Chef + Serverspec 的组合；</p>
<blockquote>
<p>与实践1的差别在于将 Vagrant 替换为 Kickstart；</p>
</blockquote>
<h3 id="发布自动化"><a href="#发布自动化" class="headerlink" title="发布自动化"></a>发布自动化</h3><h4 id="Capistrano"><a href="#Capistrano" class="headerlink" title="Capistrano"></a>Capistrano</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151546.png"></p>
<p>Capistrano 使用 Push 的方式，无须在应用程序和数据库服务上面安装，只需执行服务器能够通过 SSH 登录前两种服务器即可；</p>
<h4 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h4><p>功能同 Capistrano，差别在于使用 Python，而非 Ruby；另外 Fabric 任务可以顺序执行，也可以并行，甚至还可以分组顺序执行，组内则是并行；相当灵活；</p>
<h4 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h4><p>Jenkins 同样可以用来实现发布的自动化，不过需要在从节点上安装 Jenkins 才行，还好只需能够 SSH 登录从节点，即可在主节点上远程进行安装；</p>
<p>相对于前面两个工具，Jenkins 的优点在于：</p>
<ul>
<li>可视化的控制台；</li>
<li>可实现发布任务的权限管理</li>
<li>可查询发布的详细历史记录；</li>
</ul>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>组合使用 Jenkins + Fabric，这样既可以利用 Jenkins 的日志功能，又可以获得 Fabric 灵活易用的功能；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151632.png"></p>
<h4 id="手动部署的工具"><a href="#手动部署的工具" class="headerlink" title="手动部署的工具"></a>手动部署的工具</h4><p>如果可能，尽量所有部署工作设置为自动化；如果出现少数需要手动部署的特例，例如某台机器磁盘空间不足，则有以下工具可以使用：</p>
<ul>
<li>RLogin</li>
<li>Tera Term</li>
</ul>
<p>以上两个工具可以实现一个终端输入，在多台机器上实施相同操作的效果；</p>
<p>当机器数据很多时，有时可能存在少数几台机器的命令执行不成功，此时在执行下一条指令前，应先就上一条指令的结果进行验证，确保无误后，再执行下一条指令；</p>
<h3 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h3><h4 id="不中断服务的部署方法"><a href="#不中断服务的部署方法" class="headerlink" title="不中断服务的部署方法"></a>不中断服务的部署方法</h4><h5 id="蓝绿部署"><a href="#蓝绿部署" class="headerlink" title="蓝绿部署"></a>蓝绿部署</h5><p>原理：将机器分成两组，先部署其他的一组，成功后，再部署剩下的一组；</p>
<p>缺点：部署过程中会暂停一半的机器资源，会给系统带来比较大的压力，除非增加备用机器，但那样做的成功过高；</p>
<h5 id="云蓝绿部署"><a href="#云蓝绿部署" class="headerlink" title="云蓝绿部署"></a>云蓝绿部署</h5><p>原理：机器不分组，部署前增加一批新机器进行部署，部署成功后，删除旧机器；</p>
<blockquote>
<p>该方法克服了传统蓝绿部署的缺点，但会增加复杂性和出错概率，因为务必要先实现部署的自动化和自动测试；</p>
</blockquote>
<h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p>部署失败不可避免，因此应随时有回滚的机制，包括代码回滚、数据库回滚两种；</p>
<blockquote>
<p>回滚时，除了回滚源代码外，还应以服务器的环境进行验证，确保可用；同时还需考虑数据库的迁移；</p>
</blockquote>
<p>数据库的回滚分为两种情况，一种是允许新数据的丢弃，一种是不允许；后一种情况比较麻烦，因此，在发布新代码前，应分成两步进行测试，先确保只更新数据库的情况下，旧代码能够顺利进行；之后再进行新代码的发布；此时如果出现问题，也只需回滚代码部分，无须回滚数据库部分；</p>
<h4 id="PasS"><a href="#PasS" class="headerlink" title="PasS"></a>PasS</h4><p>自动化部署需要花费一定的学习和时间成本，因此也有一个选项是考虑使用 PasS 服务；只需 push 代码到相应的平台，即可实现自动化部署；</p>
<h5 id="PasS-适用场景"><a href="#PasS-适用场景" class="headerlink" title="PasS 适用场景"></a>PasS 适用场景</h5><ul>
<li>没有足够资源，但希望快速推出产品，收集反馈的项目；（创新项目）</li>
<li>无法预测峰值负荷的服务；（新上线的手机游戏）</li>
<li>生命周期短的服务（例如展会）；</li>
<li>与现有产品进行配合的小项目；</li>
</ul>
<h5 id="PasS-缺点"><a href="#PasS-缺点" class="headerlink" title="PasS 缺点"></a>PasS 缺点</h5><ul>
<li>当流量很大时，费用成本出现不成比例的上升；</li>
<li>有时难以获得想要的日志进行问题分析；</li>
<li>获得的服务等级和合同约定可能不相符；</li>
</ul>
<h2 id="7-回归测试"><a href="#7-回归测试" class="headerlink" title="7. 回归测试"></a>7. 回归测试</h2><h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151658.png"></p>
<h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p>Selenium 并不是单个软件，而是一套工具集；</p>
<h4 id="几个常用的-Selenium-工具"><a href="#几个常用的-Selenium-工具" class="headerlink" title="几个常用的 Selenium 工具"></a>几个常用的 Selenium 工具</h4><h5 id="Selenium-IDE"><a href="#Selenium-IDE" class="headerlink" title="Selenium IDE"></a>Selenium IDE</h5><p>以 Firefox 的插件形式出现，可以录制键盘和鼠标动作，因此对于非技术人员依然非常友好；</p>
<h5 id="Selenium-Remote-Control"><a href="#Selenium-Remote-Control" class="headerlink" title="Selenium Remote Control"></a>Selenium Remote Control</h5><p>在测试脚本和浏览器之间，增加了一个服务器作为中间层；由于这个抽象层后，可以使用各种语言编写测试脚本，使得测试更加灵活，例如可以实现循环和分支等；</p>
<h5 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium WebDriver"></a>Selenium WebDriver</h5><p>出于安全考虑，主流的浏览器都会对 Javascript 的调用进行限制，WebDriver 的目标即是绕开这些限制，实现调用  OS 的原生接口；在结合 Selenium 后，推出了 Selenium2；</p>
<h4 id="制作测试用例"><a href="#制作测试用例" class="headerlink" title="制作测试用例"></a>制作测试用例</h4><p>测试由测试用例组成，多个测试用例可以组合一个测试组；测试组内部的用例是顺序执行的；而测试组之间则是并发执行的；好的测试应该能够尽量缩短测试时间，因此，应考虑将测试用例设计成可以并行测试的模式；好的测试组之间不应相互依赖；</p>
<blockquote>
<p>由于测试用例的执行是代码级别的速度，而网页的加载则跟网速有关，因此 Selenium<br>的自动化测试会容易出现失败；解决办法在于执行下一条指令前，应对上一条指令的结果进行确认；如果确认失败，应该重复上一条指令；如果确认成功，再开始执行下一条指令；</p>
</blockquote>
<h3 id="Jenkins-和-Selenium-的协作"><a href="#Jenkins-和-Selenium-的协作" class="headerlink" title="Jenkins 和 Selenium 的协作"></a>Jenkins 和 Selenium 的协作</h3><p>安装相应的插件，然后配置好相应的参数即可；</p>
<h3 id="Selenium-测试的高速化"><a href="#Selenium-测试的高速化" class="headerlink" title="Selenium 测试的高速化"></a>Selenium 测试的高速化</h3><ul>
<li>利用 Jenkins 的分布式机制，设置主从节点，通过启动多个浏览器，实现并发测试；</li>
<li>为每个浏览器客户端匹配相应的应用程序服务器，实现服务端测试的负载均衡（不太理解为什么不使用 nginx 之类的工具来实现，而是改动 hosts 文件）</li>
</ul>
<h3 id="多个应用程序版本的测试"><a href="#多个应用程序版本的测试" class="headerlink" title="多个应用程序版本的测试"></a>多个应用程序版本的测试</h3><p>通过 Jenkins 的 Parameterized Trigger plugin”插件，可实现对指定版本进行测试；</p>
<p>使用 Git 拉取相应版本的测试用例时，需要配置插件选项，为每个版本生成相应的目录，避免不同版本的测试用例混在一起；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151733.png"></p>
<h2 id="8-实践"><a href="#8-实践" class="headerlink" title="8. 实践"></a>8. 实践</h2><p>在 Github 上面新建一个项目<br>拉取该项目的代码到本地<br>初始化 package.json<br>npm install 安装依赖<br>简单写一些代码，实现 hello world<br>运行代码，确保顺利<br>写一些单元测试代码<br>写测试脚本<br>设置测试脚本的文件为可执行<br>推送代码到 Github<br>登录生产服务器，新增用户，安装git，拉取代码，安装依赖，运行应用<br>登录 Jenkins 服务器，新增用户，安装 Jenkins，启动 Jenkins<br>配置 jenkins，安装插件，更改密码，新建任务，配置构建脚本；<br>配置 Github 的 Webhooks，以便 push 后触发 Jenkins 的构建；<br>生成 SSH-KEY，将公钥存放到应用程序服务器，开放存放文件夹的访问权限；<br>创建部署文件夹，创建部署的自动化脚本，设置脚本为可执行</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/软件/">软件</a><a href="/tags/项目管理/">项目管理</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/6/" class="pagination-prev">Prev</a>
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2024 ccw
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>